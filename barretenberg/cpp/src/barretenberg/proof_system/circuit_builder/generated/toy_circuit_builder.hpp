

// AUTOGENERATED FILE
#pragma once

#include "barretenberg/common/constexpr_utils.hpp"
#include "barretenberg/common/throw_or_abort.hpp"
#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include "barretenberg/honk/proof_system/logderivative_library.hpp"
#include "barretenberg/proof_system/circuit_builder/circuit_builder_base.hpp"
#include "barretenberg/relations/generic_lookup/generic_lookup_relation.hpp"
#include "barretenberg/relations/generic_permutation/generic_permutation_relation.hpp"

#include "barretenberg/flavor/generated/toy_flavor.hpp"
#include "barretenberg/relations/generated/toy/lookup_err.hpp"
#include "barretenberg/relations/generated/toy/lookup_xor.hpp"
#include "barretenberg/relations/generated/toy/toy_avm.hpp"
#include "barretenberg/relations/generated/toy/two_column_perm.hpp"
#include "barretenberg/relations/generated/toy/two_column_sparse_perm.hpp"

namespace bb {

template <typename FF> struct ToyFullRow {
    FF toy_first{};
    FF toy_q_tuple_set{};
    FF toy_set_1_column_1{};
    FF toy_set_1_column_2{};
    FF toy_set_2_column_1{};
    FF toy_set_2_column_2{};
    FF toy_sparse_column_1{};
    FF toy_sparse_column_2{};
    FF toy_sparse_lhs{};
    FF toy_sparse_rhs{};
    FF toy_xor_a{};
    FF toy_xor_b{};
    FF toy_xor_c{};
    FF toy_table_xor_a{};
    FF toy_table_xor_b{};
    FF toy_table_xor_c{};
    FF toy_q_xor{};
    FF toy_q_xor_table{};
    FF toy_q_err{};
    FF toy_q_err_check{};
    FF toy_clk{};
    FF toy_m_clk{};
    FF two_column_perm{};
    FF two_column_sparse_perm{};
    FF lookup_xor{};
    FF lookup_err{};
    FF lookup_xor_counts{};
    FF lookup_err_counts{};
};

class ToyCircuitBuilder {
  public:
    using Flavor = bb::ToyFlavor;
    using FF = Flavor::FF;
    using Row = ToyFullRow<FF>;

    // TODO: template
    using Polynomial = Flavor::Polynomial;
    using ProverPolynomials = Flavor::ProverPolynomials;

    static constexpr size_t num_fixed_columns = 28;
    static constexpr size_t num_polys = 28;
    std::vector<Row> rows;

    void set_trace(std::vector<Row>&& trace) { rows = std::move(trace); }

    ProverPolynomials compute_polynomials()
    {
        const auto num_rows = get_circuit_subgroup_size();
        ProverPolynomials polys;

        // Allocate mem for each column
        for (auto& poly : polys.get_all()) {
            poly = Polynomial(num_rows);
        }

        for (size_t i = 0; i < rows.size(); i++) {
            polys.toy_first[i] = rows[i].toy_first;
            polys.toy_q_tuple_set[i] = rows[i].toy_q_tuple_set;
            polys.toy_set_1_column_1[i] = rows[i].toy_set_1_column_1;
            polys.toy_set_1_column_2[i] = rows[i].toy_set_1_column_2;
            polys.toy_set_2_column_1[i] = rows[i].toy_set_2_column_1;
            polys.toy_set_2_column_2[i] = rows[i].toy_set_2_column_2;
            polys.toy_sparse_column_1[i] = rows[i].toy_sparse_column_1;
            polys.toy_sparse_column_2[i] = rows[i].toy_sparse_column_2;
            polys.toy_sparse_lhs[i] = rows[i].toy_sparse_lhs;
            polys.toy_sparse_rhs[i] = rows[i].toy_sparse_rhs;
            polys.toy_xor_a[i] = rows[i].toy_xor_a;
            polys.toy_xor_b[i] = rows[i].toy_xor_b;
            polys.toy_xor_c[i] = rows[i].toy_xor_c;
            polys.toy_table_xor_a[i] = rows[i].toy_table_xor_a;
            polys.toy_table_xor_b[i] = rows[i].toy_table_xor_b;
            polys.toy_table_xor_c[i] = rows[i].toy_table_xor_c;
            polys.toy_q_xor[i] = rows[i].toy_q_xor;
            polys.toy_q_xor_table[i] = rows[i].toy_q_xor_table;
            polys.toy_q_err[i] = rows[i].toy_q_err;
            polys.toy_q_err_check[i] = rows[i].toy_q_err_check;
            polys.toy_clk[i] = rows[i].toy_clk;
            polys.toy_m_clk[i] = rows[i].toy_m_clk;
            polys.two_column_perm[i] = rows[i].two_column_perm;
            polys.two_column_sparse_perm[i] = rows[i].two_column_sparse_perm;
            polys.lookup_xor[i] = rows[i].lookup_xor;
            polys.lookup_err[i] = rows[i].lookup_err;
            polys.lookup_xor_counts[i] = rows[i].lookup_xor_counts;
            polys.lookup_err_counts[i] = rows[i].lookup_err_counts;
        }

        return polys;
    }

    [[maybe_unused]] bool check_circuit()
    {

        const FF gamma = FF::random_element();
        const FF beta = FF::random_element();
        bb::RelationParameters<typename Flavor::FF> params{
            .eta = 0,
            .beta = beta,
            .gamma = gamma,
            .public_input_delta = 0,
            .lookup_grand_product_delta = 0,
            .beta_sqr = 0,
            .beta_cube = 0,
            .eccvm_set_permutation_delta = 0,
        };

        auto polys = compute_polynomials();
        const size_t num_rows = polys.get_polynomial_size();

        const auto evaluate_relation = [&]<typename Relation>(const std::string& relation_name,
                                                              std::string (*debug_label)(int)) {
            typename Relation::SumcheckArrayOfValuesOverSubrelations result;
            for (auto& r : result) {
                r = 0;
            }
            constexpr size_t NUM_SUBRELATIONS = result.size();

            for (size_t i = 0; i < num_rows; ++i) {
                Relation::accumulate(result, polys.get_row(i), {}, 1);

                bool x = true;
                for (size_t j = 0; j < NUM_SUBRELATIONS; ++j) {
                    if (result[j] != 0) {
                        std::string row_name = debug_label(static_cast<int>(j));
                        throw_or_abort(
                            format("Relation ", relation_name, ", subrelation index ", row_name, " failed at row ", i));
                        x = false;
                    }
                }
                if (!x) {
                    return false;
                }
            }
            return true;
        };

        const auto evaluate_logderivative = [&]<typename LogDerivativeSettings>(const std::string& lookup_name) {
            // Check the logderivative relation
            bb::compute_logderivative_inverse<Flavor, LogDerivativeSettings>(polys, params, num_rows);

            typename LogDerivativeSettings::SumcheckArrayOfValuesOverSubrelations lookup_result;

            for (auto& r : lookup_result) {
                r = 0;
            }
            for (size_t i = 0; i < num_rows; ++i) {
                LogDerivativeSettings::accumulate(lookup_result, polys.get_row(i), params, 1);
            }
            for (auto r : lookup_result) {
                if (r != 0) {
                    info("Lookup ", lookup_name, " failed.");
                    return false;
                }
            }
            return true;
        };

        if (!evaluate_relation.template operator()<Toy_vm::toy_avm<FF>>("toy_avm",
                                                                        Toy_vm::get_relation_label_toy_avm)) {
            return false;
        }

        if (!evaluate_logderivative.template operator()<two_column_perm_relation<FF>>("two_column_perm")) {
            return false;
        }
        if (!evaluate_logderivative.template operator()<two_column_sparse_perm_relation<FF>>(
                "two_column_sparse_perm")) {
            return false;
        }
        if (!evaluate_logderivative.template operator()<lookup_xor_relation<FF>>("lookup_xor")) {
            return false;
        }
        if (!evaluate_logderivative.template operator()<lookup_err_relation<FF>>("lookup_err")) {
            return false;
        }

        return true;
    }

    [[nodiscard]] size_t get_num_gates() const { return rows.size(); }

    [[nodiscard]] size_t get_circuit_subgroup_size() const
    {
        const size_t num_rows = get_num_gates();
        const auto num_rows_log2 = static_cast<size_t>(numeric::get_msb64(num_rows));
        size_t num_rows_pow2 = 1UL << (num_rows_log2 + (1UL << num_rows_log2 == num_rows ? 0 : 1));
        return num_rows_pow2;
    }
};
} // namespace bb
