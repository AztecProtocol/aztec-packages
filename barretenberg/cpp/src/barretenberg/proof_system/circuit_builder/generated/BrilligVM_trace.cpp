
// AUTOGENERATED FILE

#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include "barretenberg/proof_system/arithmetization/arithmetization.hpp"
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <sys/types.h>
#include <vector>

#include "barretenberg/proof_system/arithmetization/generated/BrilligVM_arith.hpp"
#include "barretenberg/proof_system/relations/generated/BrilligVM.hpp"

using namespace barretenberg;

namespace proof_system {

using Row = BrilligVM_vm::Row<barretenberg::fr>;
inline fr read_field(std::ifstream& file)
{
    uint8_t buffer[32];
    file.read(reinterpret_cast<char*>(buffer), 32);

    // swap it to big endian ???? TODO: create utility
    for (int n = 0, m = 31; n < m; ++n, --m) {
        std::swap(buffer[n], buffer[m]);
    }

    return fr::serialize_from_buffer(buffer);
}

inline std::vector<Row> read_both_file_into_cols(std::string const& commited_filename,
                                                 std::string const& constants_filename)
{
    std::vector<Row> rows;

    // open both files
    std::ifstream commited_file(commited_filename, std::ios::binary);
    if (!commited_file) {
        std::cout << "Error opening commited file" << std::endl;
        return {};
    }

    std::ifstream constant_file(constants_filename, std::ios::binary);
    if (!constant_file) {
        std::cout << "Error opening constant file" << std::endl;
        return {};
    }

    // TODO: temp hack: required for shifts
    Row check_row = { .main_FIRST = 1, .main__block_enforcer_last_step = 1, .main_XIsZero = 1 };
    rows.push_back(check_row);

    // We are assuming that the two files are the same length
    while (commited_file) {
        Row current_row = {};

        current_row.main_POSITIVE = read_field(constant_file);
        current_row.main_FIRST = read_field(constant_file);
        current_row.main_LAST = read_field(constant_file);
        current_row.main_STEP = read_field(constant_file);
        current_row.main__romgen_first_step = read_field(constant_file);
        current_row.main_first_step = read_field(constant_file);
        current_row.main_p_line = read_field(constant_file);
        current_row.main_p_X_const = read_field(constant_file);
        current_row.main_p_instr__jump_to_operation = read_field(constant_file);
        current_row.main_p_instr__loop = read_field(constant_file);
        current_row.main_p_instr__reset = read_field(constant_file);
        current_row.main_p_instr_call = read_field(constant_file);
        current_row.main_p_instr_call_param_l = read_field(constant_file);
        current_row.main_p_instr_ret = read_field(constant_file);
        current_row.main_p_instr_return = read_field(constant_file);
        current_row.main_p_reg_write_X_r0 = read_field(constant_file);
        current_row.main_p_reg_write_X_r1 = read_field(constant_file);
        current_row.main_p_reg_write_X_r3 = read_field(constant_file);
        current_row.main__block_enforcer_last_step = read_field(constant_file);
        current_row.main__linker_first_step = read_field(constant_file);

        current_row.main_XInv = read_field(commited_file);

        current_row.main_XIsZero = read_field(commited_file);

        current_row.main_m_addr = read_field(commited_file);

        current_row.main_m_step = read_field(commited_file);

        current_row.main_m_change = read_field(commited_file);

        current_row.main_m_value = read_field(commited_file);

        current_row.main_m_op = read_field(commited_file);

        current_row.main_m_is_write = read_field(commited_file);

        current_row.main_m_is_read = read_field(commited_file);

        current_row.main__operation_id = read_field(commited_file);

        current_row.main__sigma = read_field(commited_file);

        current_row.main_pc = read_field(commited_file);

        current_row.main_X = read_field(commited_file);

        current_row.main_Y = read_field(commited_file);

        current_row.main_Z = read_field(commited_file);

        current_row.main_jump_ptr = read_field(commited_file);

        current_row.main_addr = read_field(commited_file);

        current_row.main_tmp = read_field(commited_file);

        current_row.main_reg_write_X_r0 = read_field(commited_file);

        current_row.main_r0 = read_field(commited_file);

        current_row.main_reg_write_X_r1 = read_field(commited_file);

        current_row.main_r1 = read_field(commited_file);

        current_row.main_r2 = read_field(commited_file);

        current_row.main_reg_write_X_r3 = read_field(commited_file);

        current_row.main_r3 = read_field(commited_file);

        current_row.main_r4 = read_field(commited_file);

        current_row.main_r5 = read_field(commited_file);

        current_row.main_r6 = read_field(commited_file);

        current_row.main_r7 = read_field(commited_file);

        current_row.main_r8 = read_field(commited_file);

        current_row.main_r9 = read_field(commited_file);

        current_row.main_r10 = read_field(commited_file);

        current_row.main_r11 = read_field(commited_file);

        current_row.main_instr_call = read_field(commited_file);

        current_row.main_instr_call_param_l = read_field(commited_file);

        current_row.main_instr_ret = read_field(commited_file);

        current_row.main_instr__jump_to_operation = read_field(commited_file);

        current_row.main_instr__reset = read_field(commited_file);

        current_row.main_instr__loop = read_field(commited_file);

        current_row.main_instr_return = read_field(commited_file);

        current_row.main_X_const = read_field(commited_file);

        current_row.main_X_free_value = read_field(commited_file);

        current_row.main_Y_free_value = read_field(commited_file);

        current_row.main_Z_free_value = read_field(commited_file);

        current_row.main__operation_id_no_change = read_field(commited_file);

        rows.push_back(current_row);
    }

    // remove the last row - TODO: BUG!
    rows.pop_back();

    // Build out shifts from collected rows

    for (size_t i = 1; i < rows.size(); ++i) {
        Row& row = rows[i - 1];
        row.main_r7_shift = rows[(i) % rows.size()].main_r7;
        row.main__romgen_first_step_shift = rows[(i) % rows.size()].main__romgen_first_step;
        row.main_r0_shift = rows[(i) % rows.size()].main_r0;
        row.main_r8_shift = rows[(i) % rows.size()].main_r8;
        row.main_r1_shift = rows[(i) % rows.size()].main_r1;
        row.main_r9_shift = rows[(i) % rows.size()].main_r9;
        row.main_r10_shift = rows[(i) % rows.size()].main_r10;
        row.main_m_is_write_shift = rows[(i) % rows.size()].main_m_is_write;
        row.main_pc_shift = rows[(i) % rows.size()].main_pc;
        row.main_tmp_shift = rows[(i) % rows.size()].main_tmp;
        row.main_addr_shift = rows[(i) % rows.size()].main_addr;
        row.main_jump_ptr_shift = rows[(i) % rows.size()].main_jump_ptr;
        row.main_r11_shift = rows[(i) % rows.size()].main_r11;
        row.main_r2_shift = rows[(i) % rows.size()].main_r2;
        row.main_r3_shift = rows[(i) % rows.size()].main_r3;
        row.main_m_value_shift = rows[(i) % rows.size()].main_m_value;
        row.main_r5_shift = rows[(i) % rows.size()].main_r5;
        row.main__operation_id_shift = rows[(i) % rows.size()].main__operation_id;
        row.main__sigma_shift = rows[(i) % rows.size()].main__sigma;
        row.main_r4_shift = rows[(i) % rows.size()].main_r4;
        row.main_m_addr_shift = rows[(i) % rows.size()].main_m_addr;
        row.main_r6_shift = rows[(i) % rows.size()].main_r6;
        row.main_first_step_shift = rows[(i) % rows.size()].main_first_step;
    }

    return rows;
}

} // namespace proof_system
