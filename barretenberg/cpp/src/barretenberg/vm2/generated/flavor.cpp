// AUTOGENERATED FILE
#include "flavor.hpp"

namespace bb::avm2 {

AvmFlavor::ProverPolynomials::ProverPolynomials(ProvingKey& proving_key)
{
    for (auto [prover_poly, key_poly] : zip_view(this->get_unshifted(), proving_key.get_all())) {
        ASSERT(flavor_get_label(*this, prover_poly) == flavor_get_label(proving_key, key_poly));
        prover_poly = key_poly.share();
    }
    for (auto [prover_poly, key_poly] : zip_view(this->get_shifted(), proving_key.get_to_be_shifted())) {
        ASSERT(flavor_get_label(*this, prover_poly) == (flavor_get_label(proving_key, key_poly) + "_shift"));
        prover_poly = key_poly.shifted();
    }
}

<<<<<<< HEAD
=======
AvmFlavor::CommitmentLabels::CommitmentLabels()
{
    Base::precomputed_bitwise_input_a = "PRECOMPUTED_BITWISE_INPUT_A";
    Base::precomputed_bitwise_input_b = "PRECOMPUTED_BITWISE_INPUT_B";
    Base::precomputed_bitwise_op_id = "PRECOMPUTED_BITWISE_OP_ID";
    Base::precomputed_bitwise_output = "PRECOMPUTED_BITWISE_OUTPUT";
    Base::precomputed_clk = "PRECOMPUTED_CLK";
    Base::precomputed_first_row = "PRECOMPUTED_FIRST_ROW";
    Base::precomputed_power_of_2 = "PRECOMPUTED_POWER_OF_2";
    Base::precomputed_sel_bitwise = "PRECOMPUTED_SEL_BITWISE";
    Base::precomputed_sel_range_16 = "PRECOMPUTED_SEL_RANGE_16";
    Base::precomputed_sel_range_8 = "PRECOMPUTED_SEL_RANGE_8";
    Base::precomputed_sel_sha256_compression = "PRECOMPUTED_SEL_SHA256_COMPRESSION";
    Base::precomputed_sha256_compression_round_constant = "PRECOMPUTED_SHA256_COMPRESSION_ROUND_CONSTANT";
    Base::execution_input = "EXECUTION_INPUT";
    Base::alu_dst_addr = "ALU_DST_ADDR";
    Base::alu_ia = "ALU_IA";
    Base::alu_ia_addr = "ALU_IA_ADDR";
    Base::alu_ib = "ALU_IB";
    Base::alu_ib_addr = "ALU_IB_ADDR";
    Base::alu_ic = "ALU_IC";
    Base::alu_op = "ALU_OP";
    Base::alu_sel_op_add = "ALU_SEL_OP_ADD";
    Base::execution_addressing_error_idx = "EXECUTION_ADDRESSING_ERROR_IDX";
    Base::execution_addressing_error_kind = "EXECUTION_ADDRESSING_ERROR_KIND";
    Base::execution_base_address_tag = "EXECUTION_BASE_ADDRESS_TAG";
    Base::execution_base_address_val = "EXECUTION_BASE_ADDRESS_VAL";
    Base::execution_bytecode_id = "EXECUTION_BYTECODE_ID";
    Base::execution_clk = "EXECUTION_CLK";
    Base::execution_ex_opcode = "EXECUTION_EX_OPCODE";
    Base::execution_indirect = "EXECUTION_INDIRECT";
    Base::execution_last = "EXECUTION_LAST";
    Base::execution_op1 = "EXECUTION_OP1";
    Base::execution_op1_after_relative = "EXECUTION_OP1_AFTER_RELATIVE";
    Base::execution_op2 = "EXECUTION_OP2";
    Base::execution_op2_after_relative = "EXECUTION_OP2_AFTER_RELATIVE";
    Base::execution_op3 = "EXECUTION_OP3";
    Base::execution_op3_after_relative = "EXECUTION_OP3_AFTER_RELATIVE";
    Base::execution_op4 = "EXECUTION_OP4";
    Base::execution_op4_after_relative = "EXECUTION_OP4_AFTER_RELATIVE";
    Base::execution_pc = "EXECUTION_PC";
    Base::execution_rop1 = "EXECUTION_ROP1";
    Base::execution_rop2 = "EXECUTION_ROP2";
    Base::execution_rop3 = "EXECUTION_ROP3";
    Base::execution_rop4 = "EXECUTION_ROP4";
    Base::execution_sel = "EXECUTION_SEL";
    Base::execution_sel_addressing_error = "EXECUTION_SEL_ADDRESSING_ERROR";
    Base::execution_sel_op1_is_address = "EXECUTION_SEL_OP1_IS_ADDRESS";
    Base::execution_sel_op2_is_address = "EXECUTION_SEL_OP2_IS_ADDRESS";
    Base::execution_sel_op3_is_address = "EXECUTION_SEL_OP3_IS_ADDRESS";
    Base::execution_sel_op4_is_address = "EXECUTION_SEL_OP4_IS_ADDRESS";
    Base::range_check_dyn_diff = "RANGE_CHECK_DYN_DIFF";
    Base::range_check_dyn_rng_chk_bits = "RANGE_CHECK_DYN_RNG_CHK_BITS";
    Base::range_check_dyn_rng_chk_pow_2 = "RANGE_CHECK_DYN_RNG_CHK_POW_2";
    Base::range_check_is_lte_u112 = "RANGE_CHECK_IS_LTE_U112";
    Base::range_check_is_lte_u128 = "RANGE_CHECK_IS_LTE_U128";
    Base::range_check_is_lte_u16 = "RANGE_CHECK_IS_LTE_U16";
    Base::range_check_is_lte_u32 = "RANGE_CHECK_IS_LTE_U32";
    Base::range_check_is_lte_u48 = "RANGE_CHECK_IS_LTE_U48";
    Base::range_check_is_lte_u64 = "RANGE_CHECK_IS_LTE_U64";
    Base::range_check_is_lte_u80 = "RANGE_CHECK_IS_LTE_U80";
    Base::range_check_is_lte_u96 = "RANGE_CHECK_IS_LTE_U96";
    Base::range_check_rng_chk_bits = "RANGE_CHECK_RNG_CHK_BITS";
    Base::range_check_sel = "RANGE_CHECK_SEL";
    Base::range_check_sel_r0_16_bit_rng_lookup = "RANGE_CHECK_SEL_R0_16_BIT_RNG_LOOKUP";
    Base::range_check_sel_r1_16_bit_rng_lookup = "RANGE_CHECK_SEL_R1_16_BIT_RNG_LOOKUP";
    Base::range_check_sel_r2_16_bit_rng_lookup = "RANGE_CHECK_SEL_R2_16_BIT_RNG_LOOKUP";
    Base::range_check_sel_r3_16_bit_rng_lookup = "RANGE_CHECK_SEL_R3_16_BIT_RNG_LOOKUP";
    Base::range_check_sel_r4_16_bit_rng_lookup = "RANGE_CHECK_SEL_R4_16_BIT_RNG_LOOKUP";
    Base::range_check_sel_r5_16_bit_rng_lookup = "RANGE_CHECK_SEL_R5_16_BIT_RNG_LOOKUP";
    Base::range_check_sel_r6_16_bit_rng_lookup = "RANGE_CHECK_SEL_R6_16_BIT_RNG_LOOKUP";
    Base::range_check_u16_r0 = "RANGE_CHECK_U16_R0";
    Base::range_check_u16_r1 = "RANGE_CHECK_U16_R1";
    Base::range_check_u16_r2 = "RANGE_CHECK_U16_R2";
    Base::range_check_u16_r3 = "RANGE_CHECK_U16_R3";
    Base::range_check_u16_r4 = "RANGE_CHECK_U16_R4";
    Base::range_check_u16_r5 = "RANGE_CHECK_U16_R5";
    Base::range_check_u16_r6 = "RANGE_CHECK_U16_R6";
    Base::range_check_u16_r7 = "RANGE_CHECK_U16_R7";
    Base::range_check_value = "RANGE_CHECK_VALUE";
    Base::sha256_a = "SHA256_A";
    Base::sha256_a_and_b = "SHA256_A_AND_B";
    Base::sha256_a_and_b_xor_a_and_c = "SHA256_A_AND_B_XOR_A_AND_C";
    Base::sha256_a_and_c = "SHA256_A_AND_C";
    Base::sha256_a_rotr_13 = "SHA256_A_ROTR_13";
    Base::sha256_a_rotr_2 = "SHA256_A_ROTR_2";
    Base::sha256_a_rotr_22 = "SHA256_A_ROTR_22";
    Base::sha256_a_rotr_2_xor_a_rotr_13 = "SHA256_A_ROTR_2_XOR_A_ROTR_13";
    Base::sha256_and_sel = "SHA256_AND_SEL";
    Base::sha256_b = "SHA256_B";
    Base::sha256_b_and_c = "SHA256_B_AND_C";
    Base::sha256_c = "SHA256_C";
    Base::sha256_ch = "SHA256_CH";
    Base::sha256_clk = "SHA256_CLK";
    Base::sha256_computed_w_lhs = "SHA256_COMPUTED_W_LHS";
    Base::sha256_computed_w_rhs = "SHA256_COMPUTED_W_RHS";
    Base::sha256_d = "SHA256_D";
    Base::sha256_dummy_zero = "SHA256_DUMMY_ZERO";
    Base::sha256_e = "SHA256_E";
    Base::sha256_e_and_f = "SHA256_E_AND_F";
    Base::sha256_e_rotr_11 = "SHA256_E_ROTR_11";
    Base::sha256_e_rotr_25 = "SHA256_E_ROTR_25";
    Base::sha256_e_rotr_6 = "SHA256_E_ROTR_6";
    Base::sha256_e_rotr_6_xor_e_rotr_11 = "SHA256_E_ROTR_6_XOR_E_ROTR_11";
    Base::sha256_f = "SHA256_F";
    Base::sha256_g = "SHA256_G";
    Base::sha256_h = "SHA256_H";
    Base::sha256_helper_w0 = "SHA256_HELPER_W0";
    Base::sha256_helper_w1 = "SHA256_HELPER_W1";
    Base::sha256_helper_w10 = "SHA256_HELPER_W10";
    Base::sha256_helper_w11 = "SHA256_HELPER_W11";
    Base::sha256_helper_w12 = "SHA256_HELPER_W12";
    Base::sha256_helper_w13 = "SHA256_HELPER_W13";
    Base::sha256_helper_w14 = "SHA256_HELPER_W14";
    Base::sha256_helper_w15 = "SHA256_HELPER_W15";
    Base::sha256_helper_w2 = "SHA256_HELPER_W2";
    Base::sha256_helper_w3 = "SHA256_HELPER_W3";
    Base::sha256_helper_w4 = "SHA256_HELPER_W4";
    Base::sha256_helper_w5 = "SHA256_HELPER_W5";
    Base::sha256_helper_w6 = "SHA256_HELPER_W6";
    Base::sha256_helper_w7 = "SHA256_HELPER_W7";
    Base::sha256_helper_w8 = "SHA256_HELPER_W8";
    Base::sha256_helper_w9 = "SHA256_HELPER_W9";
    Base::sha256_init_a = "SHA256_INIT_A";
    Base::sha256_init_b = "SHA256_INIT_B";
    Base::sha256_init_c = "SHA256_INIT_C";
    Base::sha256_init_d = "SHA256_INIT_D";
    Base::sha256_init_e = "SHA256_INIT_E";
    Base::sha256_init_f = "SHA256_INIT_F";
    Base::sha256_init_g = "SHA256_INIT_G";
    Base::sha256_init_h = "SHA256_INIT_H";
    Base::sha256_input_offset = "SHA256_INPUT_OFFSET";
    Base::sha256_is_input_round = "SHA256_IS_INPUT_ROUND";
    Base::sha256_latch = "SHA256_LATCH";
    Base::sha256_lhs_a_13 = "SHA256_LHS_A_13";
    Base::sha256_lhs_a_2 = "SHA256_LHS_A_2";
    Base::sha256_lhs_a_22 = "SHA256_LHS_A_22";
    Base::sha256_lhs_e_11 = "SHA256_LHS_E_11";
    Base::sha256_lhs_e_25 = "SHA256_LHS_E_25";
    Base::sha256_lhs_e_6 = "SHA256_LHS_E_6";
    Base::sha256_lhs_w_10 = "SHA256_LHS_W_10";
    Base::sha256_lhs_w_17 = "SHA256_LHS_W_17";
    Base::sha256_lhs_w_18 = "SHA256_LHS_W_18";
    Base::sha256_lhs_w_19 = "SHA256_LHS_W_19";
    Base::sha256_lhs_w_3 = "SHA256_LHS_W_3";
    Base::sha256_lhs_w_7 = "SHA256_LHS_W_7";
    Base::sha256_maj = "SHA256_MAJ";
    Base::sha256_next_a_lhs = "SHA256_NEXT_A_LHS";
    Base::sha256_next_a_rhs = "SHA256_NEXT_A_RHS";
    Base::sha256_next_e_lhs = "SHA256_NEXT_E_LHS";
    Base::sha256_next_e_rhs = "SHA256_NEXT_E_RHS";
    Base::sha256_not_e = "SHA256_NOT_E";
    Base::sha256_not_e_and_g = "SHA256_NOT_E_AND_G";
    Base::sha256_output_a_lhs = "SHA256_OUTPUT_A_LHS";
    Base::sha256_output_a_rhs = "SHA256_OUTPUT_A_RHS";
    Base::sha256_output_b_lhs = "SHA256_OUTPUT_B_LHS";
    Base::sha256_output_b_rhs = "SHA256_OUTPUT_B_RHS";
    Base::sha256_output_c_lhs = "SHA256_OUTPUT_C_LHS";
    Base::sha256_output_c_rhs = "SHA256_OUTPUT_C_RHS";
    Base::sha256_output_d_lhs = "SHA256_OUTPUT_D_LHS";
    Base::sha256_output_d_rhs = "SHA256_OUTPUT_D_RHS";
    Base::sha256_output_e_lhs = "SHA256_OUTPUT_E_LHS";
    Base::sha256_output_e_rhs = "SHA256_OUTPUT_E_RHS";
    Base::sha256_output_f_lhs = "SHA256_OUTPUT_F_LHS";
    Base::sha256_output_f_rhs = "SHA256_OUTPUT_F_RHS";
    Base::sha256_output_g_lhs = "SHA256_OUTPUT_G_LHS";
    Base::sha256_output_g_rhs = "SHA256_OUTPUT_G_RHS";
    Base::sha256_output_h_lhs = "SHA256_OUTPUT_H_LHS";
    Base::sha256_output_h_rhs = "SHA256_OUTPUT_H_RHS";
    Base::sha256_output_offset = "SHA256_OUTPUT_OFFSET";
    Base::sha256_perform_round = "SHA256_PERFORM_ROUND";
    Base::sha256_rhs_a_13 = "SHA256_RHS_A_13";
    Base::sha256_rhs_a_2 = "SHA256_RHS_A_2";
    Base::sha256_rhs_a_22 = "SHA256_RHS_A_22";
    Base::sha256_rhs_e_11 = "SHA256_RHS_E_11";
    Base::sha256_rhs_e_25 = "SHA256_RHS_E_25";
    Base::sha256_rhs_e_6 = "SHA256_RHS_E_6";
    Base::sha256_rhs_w_10 = "SHA256_RHS_W_10";
    Base::sha256_rhs_w_17 = "SHA256_RHS_W_17";
    Base::sha256_rhs_w_18 = "SHA256_RHS_W_18";
    Base::sha256_rhs_w_19 = "SHA256_RHS_W_19";
    Base::sha256_rhs_w_3 = "SHA256_RHS_W_3";
    Base::sha256_rhs_w_7 = "SHA256_RHS_W_7";
    Base::sha256_round_constant = "SHA256_ROUND_CONSTANT";
    Base::sha256_round_count = "SHA256_ROUND_COUNT";
    Base::sha256_rounds_remaining = "SHA256_ROUNDS_REMAINING";
    Base::sha256_rounds_remaining_inv = "SHA256_ROUNDS_REMAINING_INV";
    Base::sha256_s_0 = "SHA256_S_0";
    Base::sha256_s_1 = "SHA256_S_1";
    Base::sha256_sel = "SHA256_SEL";
    Base::sha256_start = "SHA256_START";
    Base::sha256_state_offset = "SHA256_STATE_OFFSET";
    Base::sha256_w = "SHA256_W";
    Base::sha256_w_15_rotr_18 = "SHA256_W_15_ROTR_18";
    Base::sha256_w_15_rotr_7 = "SHA256_W_15_ROTR_7";
    Base::sha256_w_15_rotr_7_xor_w_15_rotr_18 = "SHA256_W_15_ROTR_7_XOR_W_15_ROTR_18";
    Base::sha256_w_15_rshift_3 = "SHA256_W_15_RSHIFT_3";
    Base::sha256_w_2_rotr_17 = "SHA256_W_2_ROTR_17";
    Base::sha256_w_2_rotr_17_xor_w_2_rotr_19 = "SHA256_W_2_ROTR_17_XOR_W_2_ROTR_19";
    Base::sha256_w_2_rotr_19 = "SHA256_W_2_ROTR_19";
    Base::sha256_w_2_rshift_10 = "SHA256_W_2_RSHIFT_10";
    Base::sha256_w_s_0 = "SHA256_W_S_0";
    Base::sha256_w_s_1 = "SHA256_W_S_1";
    Base::sha256_xor_sel = "SHA256_XOR_SEL";
    Base::perm_dummy_dynamic_inv = "PERM_DUMMY_DYNAMIC_INV";
    Base::lookup_rng_chk_pow_2_inv = "LOOKUP_RNG_CHK_POW_2_INV";
    Base::lookup_rng_chk_diff_inv = "LOOKUP_RNG_CHK_DIFF_INV";
    Base::lookup_rng_chk_is_r0_16_bit_inv = "LOOKUP_RNG_CHK_IS_R0_16_BIT_INV";
    Base::lookup_rng_chk_is_r1_16_bit_inv = "LOOKUP_RNG_CHK_IS_R1_16_BIT_INV";
    Base::lookup_rng_chk_is_r2_16_bit_inv = "LOOKUP_RNG_CHK_IS_R2_16_BIT_INV";
    Base::lookup_rng_chk_is_r3_16_bit_inv = "LOOKUP_RNG_CHK_IS_R3_16_BIT_INV";
    Base::lookup_rng_chk_is_r4_16_bit_inv = "LOOKUP_RNG_CHK_IS_R4_16_BIT_INV";
    Base::lookup_rng_chk_is_r5_16_bit_inv = "LOOKUP_RNG_CHK_IS_R5_16_BIT_INV";
    Base::lookup_rng_chk_is_r6_16_bit_inv = "LOOKUP_RNG_CHK_IS_R6_16_BIT_INV";
    Base::lookup_rng_chk_is_r7_16_bit_inv = "LOOKUP_RNG_CHK_IS_R7_16_BIT_INV";
    Base::lookup_sha256_round_constant_inv = "LOOKUP_SHA256_ROUND_CONSTANT_INV";
    Base::lookup_dummy_precomputed_inv = "LOOKUP_DUMMY_PRECOMPUTED_INV";
    Base::lookup_dummy_dynamic_inv = "LOOKUP_DUMMY_DYNAMIC_INV";
    Base::lookup_rng_chk_pow_2_counts = "LOOKUP_RNG_CHK_POW_2_COUNTS";
    Base::lookup_rng_chk_diff_counts = "LOOKUP_RNG_CHK_DIFF_COUNTS";
    Base::lookup_rng_chk_is_r0_16_bit_counts = "LOOKUP_RNG_CHK_IS_R0_16_BIT_COUNTS";
    Base::lookup_rng_chk_is_r1_16_bit_counts = "LOOKUP_RNG_CHK_IS_R1_16_BIT_COUNTS";
    Base::lookup_rng_chk_is_r2_16_bit_counts = "LOOKUP_RNG_CHK_IS_R2_16_BIT_COUNTS";
    Base::lookup_rng_chk_is_r3_16_bit_counts = "LOOKUP_RNG_CHK_IS_R3_16_BIT_COUNTS";
    Base::lookup_rng_chk_is_r4_16_bit_counts = "LOOKUP_RNG_CHK_IS_R4_16_BIT_COUNTS";
    Base::lookup_rng_chk_is_r5_16_bit_counts = "LOOKUP_RNG_CHK_IS_R5_16_BIT_COUNTS";
    Base::lookup_rng_chk_is_r6_16_bit_counts = "LOOKUP_RNG_CHK_IS_R6_16_BIT_COUNTS";
    Base::lookup_rng_chk_is_r7_16_bit_counts = "LOOKUP_RNG_CHK_IS_R7_16_BIT_COUNTS";
    Base::lookup_sha256_round_constant_counts = "LOOKUP_SHA256_ROUND_CONSTANT_COUNTS";
    Base::lookup_dummy_precomputed_counts = "LOOKUP_DUMMY_PRECOMPUTED_COUNTS";
    Base::lookup_dummy_dynamic_counts = "LOOKUP_DUMMY_DYNAMIC_COUNTS";
};

>>>>>>> 70e31a6f6d (fix: address comments)
void AvmFlavor::Transcript::deserialize_full_transcript()
{
    size_t num_frs_read = 0;
    circuit_size = deserialize_from_buffer<uint32_t>(proof_data, num_frs_read);

    for (auto& commitment : commitments) {
        commitment = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);
    }

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N; ++i) {
        sumcheck_univariates.emplace_back(deserialize_from_buffer<bb::Univariate<FF, BATCHED_RELATION_PARTIAL_LENGTH>>(
            Transcript::proof_data, num_frs_read));
    }

    sumcheck_evaluations =
        deserialize_from_buffer<std::array<FF, NUM_ALL_ENTITIES>>(Transcript::proof_data, num_frs_read);

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {
        gemini_fold_comms.push_back(deserialize_from_buffer<Commitment>(proof_data, num_frs_read));
    }

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N; ++i) {
        gemini_fold_evals.push_back(deserialize_from_buffer<FF>(proof_data, num_frs_read));
    }

    shplonk_q_comm = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);

    kzg_w_comm = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);
}

void AvmFlavor::Transcript::serialize_full_transcript()
{
    size_t old_proof_length = proof_data.size();
    Transcript::proof_data.clear();

    serialize_to_buffer(circuit_size, Transcript::proof_data);

    for (const auto& commitment : commitments) {
        serialize_to_buffer(commitment, Transcript::proof_data);
    }

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N; ++i) {
        serialize_to_buffer(sumcheck_univariates[i], Transcript::proof_data);
    }

    serialize_to_buffer(sumcheck_evaluations, Transcript::proof_data);

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {
        serialize_to_buffer(gemini_fold_comms[i], proof_data);
    }

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N; ++i) {
        serialize_to_buffer(gemini_fold_evals[i], proof_data);
    }

    serialize_to_buffer(shplonk_q_comm, proof_data);
    serialize_to_buffer(kzg_w_comm, proof_data);

    // sanity check to make sure we generate the same length of proof as before.
    ASSERT(proof_data.size() == old_proof_length);
}

AvmFlavor::PartiallyEvaluatedMultivariates::PartiallyEvaluatedMultivariates(const size_t circuit_size)
{
    // Storage is only needed after the first partial evaluation, hence polynomials of size (n / 2)
    for (auto& poly : get_all()) {
        poly = Polynomial(circuit_size / 2);
    }
}

AvmFlavor::ProvingKey::ProvingKey(const size_t circuit_size, const size_t num_public_inputs)
    : circuit_size(circuit_size)
    , evaluation_domain(bb::EvaluationDomain<FF>(circuit_size, circuit_size))
    , commitment_key(std::make_shared<CommitmentKey>(circuit_size + 1))
{
    // TODO: These come from PrecomputedEntitiesBase, ideal we'd just call that class's constructor.
    this->log_circuit_size = numeric::get_msb(circuit_size);
    this->num_public_inputs = num_public_inputs;

    // The proving key's polynomials are not allocated here because they are later overwritten
    // AvmComposer::compute_witness(). We should probably refactor this flow.
};

/**
 * @brief Serialize verification key to field elements
 *
 * @return std::vector<FF>
 */
std::vector<AvmFlavor::VerificationKey::FF> AvmFlavor::VerificationKey::to_field_elements() const
{
    std::vector<FF> elements = { FF(circuit_size), FF(num_public_inputs) };

    for (auto const& comm : get_all()) {
        std::vector<FF> comm_as_fields = field_conversion::convert_to_bn254_frs(comm);
        elements.insert(elements.end(), comm_as_fields.begin(), comm_as_fields.end());
    }
    return elements;
}

} // namespace bb::avm2