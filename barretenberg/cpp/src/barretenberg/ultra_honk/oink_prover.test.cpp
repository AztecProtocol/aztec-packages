#include "barretenberg/ultra_honk/oink_prover.hpp"
#include "barretenberg/goblin/mock_circuits.hpp"
#include "barretenberg/stdlib_circuit_builders/mock_circuits.hpp"
#include "barretenberg/ultra_honk/decider_proving_key.hpp"

#include <gtest/gtest.h>

using namespace bb;

class OinkTests : public ::testing::Test {
  public:
    using Flavor = MegaFlavor;
    using OinkProver = OinkProver<Flavor>;
    using Builder = Flavor::CircuitBuilder;
    using DeciderProvingKey = DeciderProvingKey_<Flavor>;
    using VerificationKey = Flavor::VerificationKey;

    static void SetUpTestSuite() { bb::srs::init_file_crs_factory(bb::srs::bb_crs_path()); };
};

/**
 * @brief Test that the OinkProver produces the same result when run multiple times on the same key
 *
 */
TEST_F(OinkTests, OinkProverIsDeterministic)
{
    Builder circuit;
    circuit.add_ultra_and_mega_gates_to_ensure_all_polys_are_non_zero(); // Ensure all polys are non-zero
    auto proving_key = std::make_shared<DeciderProvingKey>(circuit);
    auto verification_key = std::make_shared<VerificationKey>(proving_key->get_precomputed());

    {
        // Run OinkProver for the first time
        OinkProver prover(proving_key, verification_key);
        prover.prove();
    }

    // Store data generated by Oink prover
    auto alphas = proving_key->alphas;
    auto relation_parameters = proving_key->relation_parameters;
    auto gate_challenges = proving_key->gate_challenges;
    auto w4 = proving_key->polynomials.w_4;
    auto lookup_read_counts = proving_key->polynomials.lookup_read_counts;
    auto lookup_read_tag = proving_key->polynomials.lookup_read_tags;
    auto lookup_inverse = proving_key->polynomials.lookup_inverses;
    auto z_perm = proving_key->polynomials.z_perm;
    auto databus_inverses = proving_key->polynomials.get_databus_inverses().get_copy();

    {
        // Run OinkProver for the second time
        OinkProver prover(proving_key, verification_key);
        prover.prove();
    }

    // Check that the data hasn't changed
    for (auto [new_alpha, old_alpha] : zip_view(proving_key->alphas, alphas)) {
        BB_ASSERT_EQ(new_alpha, old_alpha);
    };
    for (auto [new_parameter, old_parameter] :
         zip_view(proving_key->relation_parameters.get_to_fold(), relation_parameters.get_to_fold())) {
        BB_ASSERT_EQ(new_parameter, old_parameter);
    };
    for (auto [new_challenge, old_challenge] : zip_view(proving_key->gate_challenges, gate_challenges)) {
        BB_ASSERT_EQ(new_challenge, old_challenge);
    };
    BB_ASSERT_EQ(proving_key->polynomials.w_4, w4);
    BB_ASSERT_EQ(proving_key->polynomials.lookup_read_counts, lookup_read_counts);
    BB_ASSERT_EQ(proving_key->polynomials.lookup_read_tags, lookup_read_tag);
    BB_ASSERT_EQ(proving_key->polynomials.lookup_inverses, lookup_inverse);
    BB_ASSERT_EQ(proving_key->polynomials.z_perm, z_perm);
    for (auto [new_databus, old_databus] :
         zip_view(proving_key->polynomials.get_databus_inverses().get_copy(), databus_inverses)) {
        BB_ASSERT_EQ(new_databus, old_databus);
    };
}
