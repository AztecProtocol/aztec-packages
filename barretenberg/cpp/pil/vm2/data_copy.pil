include "memory.pil";
include "calldata.pil";
include "precomputed.pil";
include "constants_gen.pil";
include "range_check.pil";
include "context.pil";

/** This trace handles CALLDATACOPY and RETURNDATACOPY
 * The data_copy gadget handles CALLDATACOPY and RETURNDATACOPY (both enqueued and nested)
 *
 * Opcode operands (relevant in EXECUTION when interacting with this gadget):
 * - register[0]: copy_size
 * - register[1]: copy_offset
 * - rop[2]: dst_addr
 *
 * Memory I/O, this subtrace can potentially read and write across two different memory space ids (indicated by the context_ids)
 * All reads are performed in the src context (using the src_context_id) and writes are performed in the current executing
 * context (using dst_context_id).
 * - M[src_addr]: aka value[0] (the first value read from the src context)
 *     - the memory tag is ignored for these reads
 * - M[src_addr + max_read_index]: aka value[max_read_index] (the last value read from the src context)
 *     - max_read_index is derived from the copy_size, see pil relations for an explanation
 *     - the memory tag is ignored for these reads
 * - M[dst_addr]: aka output[0] (the first value written to the dst context)
 *     - guaranteed by this gadget to be FF
 * - M[dst_addr + copy_size]: aka output[copy_size] (the last value written to the dst context)
 *     - guaranteed by this gadget to be FF
 *
 * ERROR HANDLING:
 * There is one potential errors that is checked: memory out of range accesses
 * If there are no errors, we read and write the calldata/returndata from the parent/child context to the current context
 * COMPUTING AMOUNT OF DATA TO READ
 * We need to ensure that we do not read outside the bounds designated by the parent/child context for their respective data.
 * this max_read_index is computed via min(data_size, copy_size + copy_offset).
 *
 * READING / WRITING DATA
 * At each row, the i-th data is simultaneously read from the parent/child and written into the current context
 * For top level calldatacopy, the data is retrieved from the calldata column.
 * the number of reads that are performed is (max_read_index - copy_offset), while the number of writes is copy_size
 * If the max_read_index < copy_offset, the number of reads is constrained to be 0.
 * If num_reads < copy_size, the remaining (copy_size - num_reads) rows are designated as padding rows.
 * padding rows are constrained to have the value = 0.
 *
 * It is memory aware and so is expected to call the memory subtrace directly
 *
 * Note that there are two ways that this subtrace is invoked from the execution trace: CD_COPY or RD_COPY
 * This requires two permutations because they operate on different execution trace cols (parent vs child)
 * CD COPY
 * execution.sel_calldata_copy {
 *     clk,
 *     parent_id, context_id,
 *     reg[0], reg[1], rop[2],
 *     parent_calldata_addr, parent_calldata_size,
 *     sel_calldata_copy, sel_opcode_error
 * }
 * in
 * sel_start {
 *     clk,
 *     src_context_id, dst_context_id,
 *     copy_size, offset, dst_addr,
 *     src_addr, src_data_size,
 *     sel_cd_copy, err
 * }
 *
 * RD COPY
 * execution.sel_returndata_copy {
 *     clk,
 *     last_child_id, context_id,
 *     reg[0], reg[1], rop[2],
 *     last_child_returndata_addr, last_child_returndata_size,
 *     sel_returndata_copy, sel_opcode_error
 * }
 * is
 * sel_rd_copy_start {
 *     clk,
 *     src_context_id, dst_context_id,
 *     copy_size, offset, dst_addr,
 *     src_addr, src_data_size,
 *     sel_rd_copy, err
 * };
 *
 * Reading from calldata column
 * Calldata Trace
 * +-----+-------+-------+------------+
 * | sel | value | index | context_id |
 * +-----+-------+-------+------------+
 * |   1 |   100 |     1 |          1 |
 * |   1 |   200 |     2 |          1 |
 * |   1 |   300 |     3 |          1 |
 * +-----+-------+-------+------------+
 * Execution Trace                         (dst_addr)      (cd_size)   (cd_offset)
 * +-----+-----+------------+-----------+---------------+------------+------------+
 * | clk | sel | context_id | parent_id | resolved_op_2 | register_0 | register_1 |
 * +-----+-----+------------+-----------+---------------+------------+------------+
 * |   1 |   1 |          1 |         0 |       0       |     3      |     0      |
 * +-----+-----+------------+-----------+---------------+------------+------------+
 * DataCopy Trace
 * +-------------+------------+------------+-----------+------------------+----------+-------+------------+
 * | sel_cd_copy | src_ctx_id | dst_ctx_id | copy_size | cd_copy_col_read | cd_index | value |  dst_addr  |
 * +-------------+------------+------------+-----------+------------------+----------+-------+------------+
 * |           1 |          0 |          1 |         3 |                1 |        1 |   100 |          5 |
 * |           1 |          0 |          1 |         2 |                1 |        2 |   200 |          6 |
 * |           1 |          0 |          1 |         1 |                1 |        3 |   300 |          7 |
 * +-------------+------------+------------+-----------+------------------+----------+-------+------------+
 */

namespace data_copy;

    pol SEL = sel_rd_copy + sel_cd_copy;
    pol MAX_MEM_ADDR = constants.AVM_HIGHEST_MEM_ADDRESS;

    #[skippable_if]
    SEL = 0;

    // Selectors for calldata_copy and returndata_copy, mutually exclusive given a constrained gadget id
    pol commit sel_cd_copy;
    sel_cd_copy * (1 - sel_cd_copy) = 0;
    pol commit sel_rd_copy;
    sel_rd_copy * (1 - sel_rd_copy) = 0;

    pol commit clk;

    // Things are range checked to 32 bits
    pol commit thirty_two; // todo: while we do not support constants in lookups
    SEL * (thirty_two - 32) = 0;

    ///////////////////////////////
    // Inputs from execution trace
    ///////////////////////////////
    pol commit src_context_id; // The context that is read from
    pol commit dst_context_id; // The context that is written to

    pol commit copy_size; // This is also the number of writes
    pol commit offset; // This is the offset within the data to start copying
    pol commit src_addr; // This is the address of the start of the data in parent/child, should be 0 for top level
    pol commit src_data_size; // This is the size of the data in parent/child, for top level needs to be retrieved from calldata col

    pol commit dst_addr;

    //////////////////////////////
    // Unconditional Operations
    //////////////////////////////
    // These relations occur independent of if we error (mainly because they help in finding out if there is an error)
    // Start and end constrained in "Control Flow Management" section
    pol commit sel_start; // sel_start = 1 <==> SEL = 1
    sel_start * (1 - SEL) = 0;

    // End controls most of the row propagation, so if we error we also set end to turn off row propagation
    pol commit sel_end; // sel_end = 1 <==> SEL = 1
    sel_end * (1 - SEL) = 0;

    // is_top_level if this is an enqueued call
    pol commit is_top_level; // == 1 iff parent_id == 0
    is_top_level * (1 - is_top_level) = 0;
    pol commit parent_id_inv; // For zero-check of has_parent_ctx
    #[TOP_LEVEL_COND]
    sel_cd_copy * (src_context_id * (is_top_level * (1 - parent_id_inv) + parent_id_inv) - 1 + is_top_level) = 0;

    ////////////////////////////////////////////////
    // Computing the max src index that can be read
    ////////////////////////////////////////////////
    // Computing the read count, i.e. the number of elements that will be read from the src data.
    // We compute the max read index using min(offset + copy_size, src_data_size)
    // This ensures that we cannot read pass the designated data address assigned by the parent/child
    // The min operation is essentially checking the comparison of the following
    // 1) (offset + copy_size) > src_data_size or
    // 2) (offset + copy_size) <= src_data_size
    // if (1) then max_read_index = src_data_size, otherwise max_read_index = (offset + copy_size)
    pol commit offset_plus_size;
    offset_plus_size = sel_start * (offset + copy_size);
    pol commit offset_plus_size_is_gt;

    #[MAX_READ_INDEX_GT]
    sel_start { offset_plus_size, src_data_size, offset_plus_size_is_gt }
    in
    gt.sel { gt.input_a, gt.input_b, gt.res };

    // Set max_read_index based on the conditions (1) or (2) from above
    pol commit max_read_index;
    max_read_index = sel_start * ((src_data_size - offset_plus_size) * offset_plus_size_is_gt + offset_plus_size);

    //////////////////////////////
    // Error Handling
    //////////////////////////////
    pol commit src_out_of_range_err; // Read slices should be in MEM range
    src_out_of_range_err * (1 - src_out_of_range_err) = 0;
    pol commit dst_out_of_range_err; // Write slices should be in MEM range
    dst_out_of_range_err * (1 - dst_out_of_range_err) = 0;

    pol commit max_mem_addr; // todo: While we do not support constants
    sel_start * (max_mem_addr - constants.AVM_HIGHEST_MEM_ADDRESS) = 0;

    // MAX_READ_ADDR = 0 if this is a top level call since there aren't any memory reads at the top level
    // conceptually cd copy and rd copy don't perform reads at the top level.
    pol MAX_READ_ADDR = src_addr + max_read_index;
    pol commit max_read_addr;
    max_read_addr = sel_start * MAX_READ_ADDR;
    #[CHECK_SRC_ADDR_IN_RANGE]
    sel_start { max_read_addr, max_mem_addr, src_out_of_range_err }
    in
    gt.sel { gt.input_a, gt.input_b, gt.res };

    pol MAX_WRITE_ADDR = dst_addr + copy_size;
    pol commit max_write_addr;
    max_write_addr = sel_start * MAX_WRITE_ADDR;
    #[CHECK_DST_ADDR_IN_RANGE]
    sel_start { max_write_addr, max_mem_addr, dst_out_of_range_err }
    in
    gt.sel { gt.input_a, gt.input_b, gt.res };

    // Consolidate the errors
    pol commit err;
    err = 1 - (1 - dst_out_of_range_err) * (1 - src_out_of_range_err);

    //////////////////////////////
    // Control flow management
    //////////////////////////////
    pol commit sel_start_no_err;
    sel_start_no_err * (1 - sel_start_no_err) = 0;
    sel_start_no_err = sel_start * (1 - err);

    // An active row succeeding sel_end has to be a sel_start
    #[START_AFTER_END]
    (sel_cd_copy' + sel_rd_copy') * sel_end * (sel_start' - 1) = 0;

    pol commit sel_write_count_is_zero;
    pol commit write_count_zero_inv; // Could optimise by using the existing write_count_minus_on_inv
    // sel_write_count_is_zero = 1 IFF copy_size = 0 && sel_start = 1 (and there are no errors)
    #[ZERO_SIZED_WRITE]
    sel_start_no_err * (copy_size * (sel_write_count_is_zero * (1 - write_count_zero_inv) + write_count_zero_inv) - 1 + sel_write_count_is_zero) = 0;
    #[END_IF_WRITE_IS_ZERO]
    sel_start_no_err * sel_write_count_is_zero * (sel_end - 1) = 0;

    pol SEL_PERFORM_COPY = SEL * (1 - err) * (1 - sel_write_count_is_zero);

    pol WRITE_COUNT_MINUS_ONE = copy_size - 1;
    pol commit write_count_minus_one_inv;
    // sel_end = 1 IFF copy_size - 1 = 0;
    #[END_WRITE_CONDITION]
    SEL_PERFORM_COPY * (WRITE_COUNT_MINUS_ONE * (sel_end * (1 - write_count_minus_one_inv) + write_count_minus_one_inv) - 1 + sel_end) = 0;

    #[END_ON_ERR] // sel_end = 1 if error
    err * (sel_end - 1) = 0;

    pol commit reads_left; // Number of reads of the src data, if reads_left = 0 but copy_size != 0 then it is a padding row
    // src data elements are read from indicies [offset, max_read_index], therefore reads_left = max_read_index - offset
    // We need to be careful that max_read_index - offset does not underflow (i.e. when offset > max_read_index, reads_left = 0)
    // We test that condition here
    pol commit offset_gt_max_read_index;
    #[OFFSET_GT_MAX_READ_INDEX]
    sel_start_no_err { offset, max_read_index, offset_gt_max_read_index }
    in
    gt.sel { gt.input_a, gt.input_b, gt.res };

    // If sel_offset_gt_max_read = 1 (i.e. when offset > MAX_READ_INDEX, reads_left = 0)
    // otherwise, reads_left = MAX_READ_INDEX - offset
    #[INIT_READS_LEFT]
    sel_start_no_err * (1 - sel_write_count_is_zero) * (reads_left - (max_read_index - offset) * (1 - offset_gt_max_read_index)) = 0;

    //////////////////////////////
    // Execute Data Copy
    //////////////////////////////
    // Most of these relations are either gated explicitly by an err or by sel_end (which is 1 when err = 1)
    // ===== Writing to dst_context_id =====
    pol commit sel_mem_write;
    sel_mem_write = SEL_PERFORM_COPY; // We write if there is no error and copy_size != 0
    // Data copy size decrements for each row until we end
    #[DECR_COPY_SIZE]
    SEL * (1 - sel_end) * (copy_size' - copy_size + 1) = 0;

    #[INCR_WRITE_ADDR]
    (1 - precomputed.first_row) * SEL * (1 - sel_end) * (dst_addr' - dst_addr - 1) = 0;

    #[MEM_WRITE]
    sel_mem_write { clk, dst_addr, value, /*mem_tag=*/precomputed.zero/*(FF)*/, /*rw=*/sel_mem_write/*(write)*/, dst_context_id }
    in
    memory.sel { memory.clk, memory.address, memory.value, memory.tag, memory.rw, memory.space_id };

    // ===== Reading for nested call =====
    pol commit read_addr;  // The addr to start reading the data from: src_addr + offset;
    #[INIT_READ_ADDR] // Only occurs at the start if we have not errored
    sel_start_no_err * (1 - sel_write_count_is_zero) * (read_addr - src_addr - offset) = 0;
    // Subsequent read addrs are incremented by 1 unless this is a padding row
    #[INCR_READ_ADDR]
    SEL * (1 - padding) * (1 - sel_end) * (read_addr' - read_addr - 1) = 0;

    // Read count decrements
    #[DECR_READ_COUNT]
    SEL * (1 - padding) * (1 - sel_end) * (reads_left' - reads_left + 1) = 0;
    pol commit padding; // Padding = 1 if reads_left = 0
    pol commit reads_left_inv;
    #[PADDING_CONDITION]
    SEL_PERFORM_COPY * (reads_left * (padding * (1 - reads_left_inv) + reads_left_inv) - 1 + padding) = 0;

    // Read from memory if we are not the top level call and not a padding row
    pol commit sel_mem_read; // If the current row is a memory op read
    sel_mem_read = SEL_PERFORM_COPY * (1 - is_top_level) * (1 - padding);

    // === Value Padding ===
    pol commit value;
    #[PAD_VALUE]
    SEL_PERFORM_COPY * padding * value = 0;

    #[MEM_READ]
    sel_mem_read { clk, read_addr, value, /*mem_tag=*/precomputed.zero/*FF*/, /*rw=*/precomputed.zero/*(read)*/, src_context_id }
    in
    memory.sel { memory.clk, memory.address, memory.value, memory.tag, memory.rw, memory.space_id };

    // ===== Reading cd column for top level cd copy =====
    // Reading from column
    // TODO: data size for top level column reads need to be constrained
    // After calldata hashing
    pol commit cd_copy_col_read;
    #[CD_COPY_COLUMN]
    cd_copy_col_read = SEL_PERFORM_COPY * (1 - padding) * is_top_level * sel_cd_copy;

    #[COL_READ]
    cd_copy_col_read { value, dst_context_id, read_addr }
    in
    calldata.sel { calldata.value, calldata.context_id, calldata.index };

    ////////////////////////////////////////////////
    // Dispatch Permutation
    ////////////////////////////////////////////////
    // Since these are permutations, we need to distinguish between the start
    // of a cd_copy and rd_copy.
    // Note that the value of sel_cd_copy and sel_rd_copy are constrained by their
    // inclusion inside the permutation.

    pol commit sel_cd_copy_start;
    sel_cd_copy_start = sel_start * sel_cd_copy;
    #[DISPATCH_CD_COPY]
    execution.sel_execute_calldata_copy {
        precomputed.clk,
        execution.parent_id, execution.context_id,
        execution.register[0], execution.register[1], execution.rop[2],
        execution.parent_calldata_addr, execution.parent_calldata_size,
        execution.sel_execute_calldata_copy/*=1*/, execution.sel_opcode_error
    }
    is
    sel_cd_copy_start {
        clk,
        src_context_id, dst_context_id,
        copy_size, offset, dst_addr,
        src_addr, src_data_size,
        sel_cd_copy, err
    };

    pol commit sel_rd_copy_start;
    sel_rd_copy_start = sel_start * sel_rd_copy;
    #[DISPATCH_RD_COPY]
    execution.sel_execute_returndata_copy {
        precomputed.clk,
        execution.last_child_id, execution.context_id,
        execution.register[0], execution.register[1], execution.rop[2],
        execution.last_child_returndata_addr, execution.last_child_returndata_size,
        execution.sel_execute_returndata_copy/*=1*/, execution.sel_opcode_error
    }
    is
    sel_rd_copy_start {
        clk,
        src_context_id, dst_context_id,
        copy_size, offset, dst_addr,
        src_addr, src_data_size,
        sel_rd_copy, err
    };

