include "contract_instance_retrieval.pil";
include "bc_hashing.pil";

include "../constants_gen.pil";

// Bytecode retrieval.
//
// This subtrace constrains everything related to "retrieving" a bytecode given an address.
// In practice this means:
// - Silo the address.
// - Check if the nullifier exists.
// - Derive the class id.
// - Derive the address.
// - Check updatability.
//
// The lookups into this subtrace are expected to be on the columns
// { bytecode_id, address, error }
// This trace is the owner of the bytecode_id (incrementing).
//
// Note that this trace will prove both success or failure of retrieval.

namespace bc_retrieval;

pol commit sel;
sel * (1 - sel) = 0;

// No relations will be checked if this identity is satisfied.
#[skippable_if]
sel = 0;

// If sel = 0, and it's not the first row, then all following rows should have sel = 0.
#[TRACE_CONTINUITY]
(1 - sel) * (1 - precomputed.first_row) * sel' = 0;

// This id is the bytecode commitment itself
// The bytecode_id should equal the public_bytecode_commitment.
pol commit bytecode_id;
pol commit error;  // some error occurred.
pol commit address;  // contract address.

// contract instance members.
//
// Note that bytecode retrieval doesn't care about the other instance members
// (salt, deployer_addr, init_hash). It is sufficient that after validating
// contract address nullifier membership, contract instance retrieval and its
// call to address derivation will enforce that the correct instance members
// are used. If a prover tries to use the wrong instance members, address derivation
// will have unsatisfiable constraints. So, here we only need the current_class_id
// to then validate with class id derivation.
//
// See full contract instance struct at barretenberg/cpp/src/barretenberg/vm2/common/aztec_types.hpp
pol commit current_class_id;

// contract class members.
// See barretenberg/cpp/src/barretenberg/vm2/common/aztec_types.hpp
pol commit artifact_hash;
pol commit private_function_root;
// Note that bytecode_id is used as public_bytecode_commitment!

// current state
// These should be looked up and constrained by the caller.
pol commit public_data_tree_root;
pol commit nullifier_tree_root;
pol commit prev_retrieved_bytecodes_tree_root;
pol commit prev_retrieved_bytecodes_tree_size;

// next state
pol commit next_retrieved_bytecodes_tree_root;
pol commit next_retrieved_bytecodes_tree_size;

pol commit instance_exists;
instance_exists * (1 - instance_exists) = 0;

#[CONTRACT_INSTANCE_RETRIEVAL]
sel {
    address,
    current_class_id,
    instance_exists,
    public_data_tree_root,
    nullifier_tree_root
} in contract_instance_retrieval.sel {
    contract_instance_retrieval.address,
    contract_instance_retrieval.current_class_id,
    contract_instance_retrieval.exists,
    contract_instance_retrieval.public_data_tree_root,
    contract_instance_retrieval.nullifier_tree_root
};

pol commit no_remaining_bytecodes;
no_remaining_bytecodes * (1 - no_remaining_bytecodes) = 0;

// The tree size is 1 (prefill) + retrieved_bytecodes_count
pol REMAINING_BYTECODES = constants.MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS + constants.AVM_RETRIEVED_BYTECODES_TREE_INITIAL_SIZE - next_retrieved_bytecodes_tree_size;

pol commit remaining_bytecodes_inv;

#[NO_REMAINING_BYTECODES]
sel * (REMAINING_BYTECODES * (no_remaining_bytecodes * (1 - remaining_bytecodes_inv) + remaining_bytecodes_inv) - 1 + no_remaining_bytecodes) = 0;

pol commit new_bytecode;

#[NEW_BYTECODE_CHECK]
instance_exists {
    current_class_id,
    new_bytecode,
    prev_retrieved_bytecodes_tree_root
} in retrieved_bytecodes_tree_check.sel {
    retrieved_bytecodes_tree_check.class_id,
    retrieved_bytecodes_tree_check.leaf_not_exists,
    retrieved_bytecodes_tree_check.root
};

pol TOO_MANY_BYTECODES = no_remaining_bytecodes * new_bytecode;

// We error if instance doesn't exist or if we have too many bytecodes.
sel * (instance_exists * (1 - TOO_MANY_BYTECODES) - (1 - error)) = 0;

pol commit should_retrieve;
should_retrieve = sel * (1 - error);

// Observe the following also connects the current_class_id of the instance to the class members.
// Note: only need to derive the class id if the instance exists.
// TODO: Probably some latch is also needed.
#[CLASS_ID_DERIVATION]
should_retrieve {
  current_class_id,
  artifact_hash,
  private_function_root,
  /*public_bytecode_commitment=*/ bytecode_id
} in class_id_derivation.sel {
  class_id_derivation.class_id,
  class_id_derivation.artifact_hash,
  class_id_derivation.private_function_root,
  class_id_derivation.public_bytecode_commitment
};

#[RETRIEVED_BYTECODES_INSERTION]
should_retrieve {
    current_class_id,
    should_retrieve, // 1
    prev_retrieved_bytecodes_tree_root,
    prev_retrieved_bytecodes_tree_size,
    next_retrieved_bytecodes_tree_root,
    next_retrieved_bytecodes_tree_size
} in retrieved_bytecodes_tree_check.sel {
    retrieved_bytecodes_tree_check.class_id,
    retrieved_bytecodes_tree_check.write,
    retrieved_bytecodes_tree_check.root,
    retrieved_bytecodes_tree_check.tree_size_before_write,
    retrieved_bytecodes_tree_check.write_root,
    retrieved_bytecodes_tree_check.tree_size_after_write
};

// TODO(dbanks12): re-enable once C++ and PIL use standard poseidon2 hashing for bytecode commitments.
// Note: only need to hash the bytecode if there is no error. Otherwise there is nothing to hash!
//#[BYTECODE_HASH_IS_CORRECT]
//should_retrieve { bytecode_id, /*public_bytecode_commitment=*/ bytecode_id } in bc_hashing.latch { bc_hashing.bytecode_id, bc_hashing.output_hash };

// If class ID derivation is disabled (error), force all members to 0.
#[CURRENT_CLASS_ID_IS_ZERO_IF_ERROR]
error * (current_class_id - 0) = 0;
#[ARTIFACT_HASH_IS_ZERO_IF_ERROR]
error * (artifact_hash - 0) = 0;
#[PRIVATE_FUNCTION_ROOT_IS_ZERO_IF_ERROR]
error * (private_function_root - 0) = 0;
#[BYTECODE_ID_IS_ZERO_IF_ERROR]
error * (bytecode_id - 0) = 0;

// On error, constrain next root and size to be the same as the previous ones.
error * (next_retrieved_bytecodes_tree_root - prev_retrieved_bytecodes_tree_root) = 0;
error * (next_retrieved_bytecodes_tree_size - prev_retrieved_bytecodes_tree_size) = 0;

// Note: we don't need to silo and check the class id because the deployer contract guarrantees
// that if a contract instance exists, the class has been registered.

// TODO: To ensure bytecode_id unicity inside of bc_decomposition.pil, we will have to introduce
// a permutation of the form: sel_XXX {bytecode_id} is bc_decomposition.last_of_contract {bc_decomposition.id}
// sel_XXX will have to be picked so that it selects a bytecode_id iff it has an entry in bc_decomposition
