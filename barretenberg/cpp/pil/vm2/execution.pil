include "alu.pil";
include "addressing.pil";
include "address_derivation.pil";
include "bc_decomposition.pil";
include "bc_hashing.pil";
include "bc_retrieval.pil";
include "call_opcode.pil";
include "instr_fetching.pil";
include "class_id_derivation.pil";
include "range_check.pil";
include "bitwise.pil";
include "merkle_check.pil";
include "memory.pil";
include "keccakf1600.pil";
include "precomputed.pil";
include "sha256.pil";
include "ecc.pil";
include "poseidon2_hash.pil";
include "poseidon2_perm.pil";
include "scalar_mul.pil";
include "to_radix.pil";
include "ff_gt.pil";
include "context.pil";
include "context_stack.pil";
include "execution_discard.pil";
include "public_data_check.pil";
include "update_check.pil";
include "nullifier_check.pil";
include "public_inputs.pil";
include "gas.pil";
include "data_copy.pil";

namespace execution;

pol commit sel; // subtrace selector
pol commit last; // last row selector
sel * (1 - sel) = 0;
last * (1 - last) = 0;

// This is a set of selectors for the tx trace, they are here for now
pol commit enqueued_call_start;
pol commit enqueued_call_end;

// If `sel` is 0, then the Execution relation should pass.
#[skippable_if]
sel = 0;

/**************************************************************************************************
 *  Setup (some general constraints)
 **************************************************************************************************/

// If the current row is an execution row, then either
// the next row is an execution row, or the current row is marked as the last row.
// sel => (sel' v last) = 1              iff
// ¬sel v (sel' v last) = 1              iff
// ¬(¬sel v (sel' v last)) = 0           iff
// sel ^ (¬sel' ^ ¬last) = 0             iff
// sel * (1 - sel') * (1 - last) = 0
#[TRACE_CONTINUITY_1]
sel * (1 - sel') * (1 - last) = 0;
// If the current row is not an execution row, then there are no more execution rows after that.
// (not enforced for the first row)
#[TRACE_CONTINUITY_2]
(1 - precomputed.first_row) * (1 - sel) * sel' = 0;
// If the current row is the last row, then the next row is not an execution row.
#[LAST_IS_LAST]
last * sel' = 0;

/**************************************************************************************************
 *  Temporality group 1: Instruction fetching (unconditional)
 **************************************************************************************************/

pol commit bytecode_id;
pol commit instr_length; // Need this for shift col on next_pc
pol commit sel_instruction_fetching_failure;

pol commit ex_opcode;
pol commit indirect;
pol commit op[7];  // operands

// We now proceed to fetch the instruction.
// The handling is slightly subtle: suppose fetching fails, then in simulation/tracegen
// we will NOT have the partial information of the instruction, and to be honest we
// ideally want to leave it unconstrained. This is why we do 2 lookups instead of 1.
// TODO: We can consider optimizing this later, but it is probably the cleanest right now.

#[INSTRUCTION_FETCHING_RESULT]
sel {
    pc, bytecode_id, sel_instruction_fetching_failure
} in instr_fetching.sel {
    instr_fetching.pc, instr_fetching.bytecode_id, instr_fetching.sel_parsing_err
};

pol commit sel_instruction_fetching_success;
sel * (sel_instruction_fetching_success - (1 - sel_instruction_fetching_failure)) = 0;

#[INSTRUCTION_FETCHING_BODY]
sel_instruction_fetching_success {
    pc, bytecode_id, ex_opcode, instr_length,
    indirect, op[0], op[1], op[2], op[3], op[4], op[5], op[6]
} in instr_fetching.sel {
    instr_fetching.pc,
    instr_fetching.bytecode_id,
    instr_fetching.exec_opcode,
    instr_fetching.instr_size,
    instr_fetching.indirect,
    instr_fetching.op1,
    instr_fetching.op2,
    instr_fetching.op3,
    instr_fetching.op4,
    instr_fetching.op5,
    instr_fetching.op6,
    instr_fetching.op7
};

/**************************************************************************************************
 *  Temporality group 2
 *  - Mapping from wire instruction to execution instruction
 *  - Gas
 **************************************************************************************************/

// TODO(fcarreiro): Ideally we would use this one as selector for readability, but it's not supported yet.
// pol SEL_SHOULD_READ_EXEC_SPEC = sel_instruction_fetching_success;
#[EXEC_SPEC_READ]
sel_instruction_fetching_success {
    ex_opcode,
    // in gas.pil.
    opcode_gas,
    base_da_gas,
    dynamic_l2_gas,
    dynamic_da_gas,
    // addressing
    sel_op_is_address[0], sel_op_is_address[1], sel_op_is_address[2],  sel_op_is_address[3],
    sel_op_is_address[4], sel_op_is_address[5], sel_op_is_address[6],
    // subtraces, mem ops, etc (defined later in this file)
    subtrace_operation_id, sel_alu, sel_bitwise, sel_to_radix, sel_ecc_add, sel_poseidon2_perm,
    mem_op[0], mem_op[1], mem_op[2], mem_op[3], mem_op[4], mem_op[5], mem_op[6],
    rw[0], rw[1], rw[2], rw[3], rw[4], rw[5], rw[6]
} in
precomputed.sel_exec_spec {
    // execution opcode
    precomputed.clk,
    // gas
    precomputed.exec_opcode_opcode_gas,
    precomputed.exec_opcode_base_da_gas,
    precomputed.exec_opcode_dynamic_l2_gas,
    precomputed.exec_opcode_dynamic_da_gas,
    // addressing
    precomputed.sel_op_is_address[0],
    precomputed.sel_op_is_address[1],
    precomputed.sel_op_is_address[2],
    precomputed.sel_op_is_address[3],
    precomputed.sel_op_is_address[4],
    precomputed.sel_op_is_address[5],
    precomputed.sel_op_is_address[6],
    // subtraces
    precomputed.subtrace_operation_id,
    precomputed.sel_dispatch_alu,
    precomputed.sel_dispatch_bitwise,
    precomputed.sel_dispatch_poseidon_perm,
    precomputed.sel_dispatch_to_radix,
    precomputed.sel_dispatch_ecc,
    // memory operations per register
    precomputed.mem_op_reg[0],
    precomputed.mem_op_reg[1],
    precomputed.mem_op_reg[2],
    precomputed.mem_op_reg[3],
    precomputed.mem_op_reg[4],
    precomputed.mem_op_reg[5],
    precomputed.mem_op_reg[6],
    // read / write per register
    precomputed.rw[0],
    precomputed.rw[1],
    precomputed.rw[2],
    precomputed.rw[3],
    precomputed.rw[4],
    precomputed.rw[5],
    precomputed.rw[6]
};

//////// BASE GAS ////////

// Ideally this could be an alias, but I'm adding a column for readability.
pol commit sel_should_check_gas;
sel * (sel_should_check_gas - sel_instruction_fetching_success) = 0;

// NOTE: Gas is constrained in gas.pil.
// The "output we want is" out_of_gas_base from gas.pil.

/**************************************************************************************************
 *  Temporality group 3: Address resolution
 **************************************************************************************************/

pol commit sel_should_resolve_address;
// This assumes mutual exclusivity of the failure selectors.
sel * (sel_should_resolve_address - (1 - out_of_gas_base - sel_instruction_fetching_failure)) = 0;

// resolved operands
pol commit rop[7];

// NOTE: Constraints on the resolved operands are in addressing.pil.
// The "output we want is" sel_addressing_error from addressing.pil.

/**************************************************************************************************
 *  Temporality group N: Registers + Dispatch opcode
 **************************************************************************************************/

// TODO: gate this group.

// Registers
pol commit register[7];
// Memory Acccesses
pol commit mem_op[7];
// Memory Tag
pol commit mem_tag[7];
// Read / Write selectors
pol commit rw[7];

/**************************************************************************************************
 *  Temporality group N: Dispatch opcode
 **************************************************************************************************/

// TODO: gate this group with some error flag from the previous group.

// Subtrace operation id
pol commit subtrace_operation_id;

// Subtrace Dispatch selectors
// These boolean selectors are constrained via the precomputed Execution Instruction Spec Table
pol commit sel_alu;
pol commit sel_bitwise;
pol commit sel_to_radix;
pol commit sel_ecc_add;
pol commit sel_poseidon2_perm;

/**************************************************************************************************
 *  Temporality group N: Dynamic gas
 **************************************************************************************************/

// TODO: gate this group. This is actually interleaved with the previous group.

/**************************************************************************************************
 *  Error collection
 **************************************************************************************************/

// sel_error is 1 iff any kind of error happens at the execution level.
pol commit sel_error;
sel_error * (1 - sel_error) = 0;

// TODO: complete.
// This implies mutual exclusivity of the failure selectors.
// sel_error = sel_gas_failure + sel_instruction_fetching_failure;
