include "alu.pil";
include "addressing.pil";
include "address_derivation.pil";
include "bc_decomposition.pil";
include "bc_hashing.pil";
include "bc_retrieval.pil";
include "instr_fetching.pil";
include "class_id_derivation.pil";
include "range_check.pil";
include "bitwise.pil";
include "merkle_check.pil";
include "memory.pil";
include "keccakf1600.pil";
include "precomputed.pil";
include "sha256.pil";
include "ecc.pil";
include "poseidon2_hash.pil";
include "poseidon2_perm.pil";
include "scalar_mul.pil";
include "to_radix.pil";
include "ff_gt.pil";
include "context.pil";
include "context_stack.pil";
include "public_data_check.pil";
include "update_check.pil";
include "nullifier_check.pil";
include "public_inputs.pil";
include "gas.pil";

namespace execution;

pol commit sel; // subtrace selector

#[skippable_if]
sel = 0;

// Subtrace operation id
pol commit subtrace_operation_id;

// Subtrace Dispatch selectors
// These boolean selectors are constrained via the precomputed Execution Instruction Spec Table
pol commit sel_alu;
pol commit sel_bitwise;
pol commit sel_to_radix;
pol commit sel_ecc_add;
pol commit sel_poseidon2_perm;

pol commit ex_opcode;
pol commit indirect;
// operands
pol commit op1, op2, op3, op4;
pol commit op5, op6, op7;
// resolved operands
pol commit rop1, rop2, rop3, rop4;
pol commit rop5, rop6, rop7;
// Registers
pol commit reg1, reg2, reg3, reg4;
pol commit reg5, reg6, reg7;
// Memory Acccesses
pol commit mem_op1, mem_op2, mem_op3, mem_op4;
pol commit mem_op5, mem_op6, mem_op7;
// Memory Tag
pol commit mem_tag1, mem_tag2, mem_tag3, mem_tag4;
pol commit mem_tag5, mem_tag6, mem_tag7;
// Read / Write selectors
pol commit rw1, rw2, rw3, rw4;
pol commit rw5, rw6, rw7;

pol commit bytecode_id;
pol commit instr_length; // Need this for shift col on next_pc, will be part of lookup to instr_fetch
pol commit last;

// Selector constraints
sel * (1 - sel) = 0;
last * (1 - last) = 0;

// If the current row is an execution row, then either
// the next row is an execution row, or the current row is marked as the last row.
// sel => (sel' v last) = 1              iff
// ¬sel v (sel' v last) = 1              iff
// ¬(¬sel v (sel' v last)) = 0           iff
// sel ^ (¬sel' ^ ¬last) = 0             iff
// sel * (1 - sel') * (1 - last) = 0
#[TRACE_CONTINUITY_1]
sel * (1 - sel') * (1 - last) = 0;
// If the current row is not an execution row, then there are no more execution rows after that.
// (not enforced for the first row)
#[TRACE_CONTINUITY_2]
(1 - precomputed.first_row) * (1 - sel) * sel' = 0;
// If the current row is the last row, then the next row is not an execution row.
#[LAST_IS_LAST]
last * sel' = 0;

// These are needed to have a non-empty set of columns for each type.
pol public input;

#[EXEC_SPEC_READ]
sel {
    ex_opcode,
    opcode_gas,
    base_da_gas,
    dynamic_l2_gas,
    dynamic_da_gas
    // Mem ops, subtrace selectors, etc
} in
precomputed.sel_exec_spec {
    precomputed.clk,
    precomputed.exec_opcode_opcode_gas,
    precomputed.exec_opcode_base_da_gas,
    precomputed.exec_opcode_dynamic_l2_gas,
    precomputed.exec_opcode_dynamic_da_gas
};

// ========== CALL/STATICCALL SPECIFIC LOGIC ==========

// Register 1 contains allocated l2 gas
// Register 2 contains allocated da gas
// Register 3 contains the address of the contract to call

pol commit constant_32;
sel_enter_call * (32 - constant_32) = 0;

// ==== GAS CLAMPING ====
// Guaranteed not to wrap since we never put a gas used > gas limit
pol L2_GAS_LEFT = l2_gas_limit - l2_gas_used;
pol DA_GAS_LEFT = da_gas_limit - da_gas_used;

// L2 gas clamping

// Hint of whether the allocated gas is less than the left gas
pol commit call_is_l2_gas_allocated_lt_left;
call_is_l2_gas_allocated_lt_left * (1 - call_is_l2_gas_allocated_lt_left) = 0;


pol ALLOCATED_GTE_LEFT_L2 = reg1 - L2_GAS_LEFT;
pol ALLOCATED_LT_LEFT_L2 = L2_GAS_LEFT - reg1 - 1;
pol commit call_allocated_left_l2_cmp_diff;
sel_enter_call * ((ALLOCATED_LT_LEFT_L2 - ALLOCATED_GTE_LEFT_L2) * call_is_l2_gas_allocated_lt_left + ALLOCATED_GTE_LEFT_L2 - call_allocated_left_l2_cmp_diff) = 0;

#[CALL_ALLOCATED_LEFT_L2_RANGE]
sel_enter_call { call_allocated_left_l2_cmp_diff, constant_32 }
in
range_check.sel
    { range_check.value, range_check.rng_chk_bits };

// next row's l2_gas_limit = if call_is_l2_gas_allocated_lt_left { reg1 } else { L2_GAS_LEFT }
sel_enter_call * ((reg1 - L2_GAS_LEFT) * call_is_l2_gas_allocated_lt_left + L2_GAS_LEFT - l2_gas_limit') = 0;

// DA gas clamping

// Hint of whether the allocated gas is less than the left gas
pol commit call_is_da_gas_allocated_lt_left;
call_is_da_gas_allocated_lt_left * (1 - call_is_da_gas_allocated_lt_left) = 0;

pol ALLOCATED_GTE_LEFT_DA = reg2 - DA_GAS_LEFT;
pol ALLOCATED_LT_LEFT_DA = DA_GAS_LEFT - reg2 - 1;
pol commit call_allocated_left_da_cmp_diff;
sel_enter_call * ((ALLOCATED_LT_LEFT_DA - ALLOCATED_GTE_LEFT_DA) * call_is_da_gas_allocated_lt_left + ALLOCATED_GTE_LEFT_DA - call_allocated_left_da_cmp_diff) = 0;

#[CALL_ALLOCATED_LEFT_DA_RANGE]
sel_enter_call { call_allocated_left_da_cmp_diff, constant_32 }
in
range_check.sel
    { range_check.value, range_check.rng_chk_bits };

// next row's da_gas_limit = if call_is_da_gas_allocated_lt_left { reg2 } else { DA_GAS_LEFT }
sel_enter_call * ((reg2 - DA_GAS_LEFT) * call_is_da_gas_allocated_lt_left + DA_GAS_LEFT - da_gas_limit') = 0;

