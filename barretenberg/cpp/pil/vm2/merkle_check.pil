include "./poseidon2_hash.pil";

/**
 * A merkle membership check to compute a root given a sibling path.
 * One sibling pair per row.
 *
 * @param current_node_value The value of the current node being processed alongside its sibling.
 * @param current_index_in_layer The index of the current node in the current layer.
 * @param remaining_path_len The remaining path length to process, not including this one. When 0, `output_hash` is the root.
 * @param expected_tree_root The expected root of the tree. Checked against `output_hash` when `remaining_path_len == 0`.
 *
 * @hint sibling_value The value of the sibling node to be hashed with `current_node_value`.
 *
 * @lookup to `poseidon2_hash` to constrain that `hash(current_node_value, sibling_value) == output_hash` for the current layer
 *
 * @constrains that each layer's `output_hash` is the input (`current_node_value`) to the next layer except when `remaining_path_len == 0`
 * @constrains that `remaining_path_len` is decremented by 1 each layer except when `remaining_path_len == 0`
 * @constrains that `current_index_in_layer` is halved each layer until `remaining_path_len == 0`
 * @constrains that progression of `remaining_path_len`, `current_index_in_layer`, and `output_hash`->`current_node_value` stops when `remaining_path_len == 0` (when `root_latch` goes high)
 */
namespace merkle_check(256);
    pol commit sel;
    sel * (1 - sel) = 0;
    // No relations will be checked if this identity is satisfied.
    #[skippable_if]
    sel = 0;

    // Inputs to the gadget
    pol commit current_node_value;
    pol commit current_index_in_layer;
    // Hinted
    pol commit sibling_value;

    pol commit remaining_path_len;
    // TODO(dbanks12): do we need root here. It is not used in vm1?
    //pol commit expected_tree_root;
    // These are all hinted

    pol commit root_latch;
    root_latch * (1 - root_latch) = 0;

    // If we are not done, the remaining_path_len decrements by 1
    #[PATH_LEN_DECREMENTS]
    sel * (1 - root_latch) * (remaining_path_len' - remaining_path_len + 1) = 0;

    pol commit remaining_path_len_inv;
    // root_latch == 1 when the remaining_path_len == 0
    #[ROOT_LATCH_HIGH_WHEN_PATH_EMPTY]
    sel * (remaining_path_len * (root_latch * (1 - remaining_path_len_inv) + remaining_path_len_inv) - 1 + root_latch) = 0;

    // Note this might be covered by the halving of the current index if the original index is constrained.
    // TODO(dbanks12): May need a range check on current_index_in_layer to enforce that this is indeed even.
    // https://aztecprotocol.slack.com/archives/C04DL2L1UP2/p1738189301548169
    pol commit index_is_even;
    index_is_even * (1 - index_is_even) = 0;
    pol INDEX_IS_ODD = (1 - index_is_even);
    // If we are not done, the index into the next layer is half the current index;
    // We don't need to worry about underflowing the field since (current_index_in_layer - INDEX_IS_ODD)
    // will be even (over the integers) and as the field is not of characteristic 2, current_index_in_layer' == current_index_in_layer / 2 over the integers
    #[NEXT_INDEX_IS_HALVED]
    sel * (1 - root_latch) * (current_index_in_layer' * 2 + INDEX_IS_ODD - current_index_in_layer) = 0;
    // TODO(dbanks12): should there be some assertion that if root_latch is 1, current_index_in_layer should be 0 or 1?

    // These are what are sent to poseidon2
    // These arrange the current_node_value and sibling_value in the correct order
    pol commit left_hash;
    pol commit right_hash;
    // This is accomplished by using index_is_even to toggle the (left_hash - right_hash) term.
    // If current_index_in_layer is even, left_hash (to send to poseidon2) is current_node_value and right_hash is sibling_value.
    // And vice-versa.
    #[ASSIGN_CURRENT_NODE_LEFT_OR_RIGHT]
    sel * index_is_even * (left_hash - right_hash) + right_hash - current_node_value = 0;
    #[ASSIGN_SIBLING_VALUE_LEFT_OR_RIGHT]
    sel * index_is_even * (right_hash - left_hash) + left_hash - sibling_value = 0;
    // NOTE: don't think these can be safely combined

    // output_hash = hash(current_node_value, sibling_value)
    pol commit output_hash;
    // If we are not done, this row's output_hash is the next row's current_node_value input
    #[OUTPUT_HASH_IS_NEXT_ROWS_CURRENT_NODE_VALUE]
    sel * (1 - root_latch) * (current_node_value' - output_hash) = 0;

    pol LAST_COMPUTE = sel * root_latch;
    // LAST_COMPUTE will be used in permutations to other traces

    // Permutation to the full poseidon2 gadget
    #[MERKLE_POSEIDON2]
    sel { left_hash, right_hash, output_hash }
    in poseidon2_hash.end {poseidon2_hash.input_0, poseidon2_hash.input_1, poseidon2_hash.output };
