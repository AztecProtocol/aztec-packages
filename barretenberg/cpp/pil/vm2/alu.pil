include "constants_gen.pil";
include "execution.pil";
include "ff_gt.pil";
include "gt.pil";
include "precomputed.pil";
namespace alu;

pol commit sel;

pol commit sel_op_add;
pol commit sel_op_eq;
pol commit sel_op_lt;
pol commit sel_op_lte;
pol commit sel_op_not;
pol commit sel_op_shl;
pol commit sel_op_shr;
pol commit op_id;

pol commit ia;
pol commit ib;
pol commit ic;

pol commit ia_tag;
pol commit ib_tag;
pol commit ic_tag;

#[skippable_if]
sel = 0;

// carry flag
pol commit cf;

// Generic helper column
// Current use: EQ (inverse of a-b)
pol commit helper1;

// maximum bits the number can hold (i.e. 8 for a u8):
// TODO(MW): Now unused since we redirect the LT/LTE range checks to GT gadget - remove?
pol commit max_bits;
// maximum value the number can hold (i.e. 255 for a u8), we 'mod' by max_value + 1
pol commit max_value;
// we need a selector to conditionally lookup ff_gt when inputs a, b are fields:
pol commit sel_is_ff;

pol IS_NOT_FF = 1 - sel_is_ff;

sel * (1 - sel) = 0;
cf * (1 - cf) = 0;
sel_is_ff * (1 - sel_is_ff) = 0;

// TODO: Consider to gate with (1 - sel_tag_err) for op_id. This might help us remove the (1 - sel_tag_err)
// in various operation relations below.
// Note that the op_ids below represent a binary decomposition (see constants_gen.pil):
#[OP_ID_CHECK]
op_id = sel_op_add * constants.AVM_EXEC_OP_ID_ALU_ADD
      + sel_op_eq * constants.AVM_EXEC_OP_ID_ALU_EQ
      + sel_op_lt * constants.AVM_EXEC_OP_ID_ALU_LT
      + sel_op_lte * constants.AVM_EXEC_OP_ID_ALU_LTE
      + sel_op_not * constants.AVM_EXEC_OP_ID_ALU_NOT
      + sel_op_shl * constants.AVM_EXEC_OP_ID_ALU_SHL
      + sel_op_shr * constants.AVM_EXEC_OP_ID_ALU_SHR;

#[REGISTER_TAG_VALUE]
execution.sel_execute_alu {
    execution.register[0], execution.mem_tag_reg[0], execution.register[1],
    execution.mem_tag_reg[1], execution.register[2], execution.mem_tag_reg[2], execution.subtrace_operation_id, execution.sel_opcode_error
} in sel {
    ia, ia_tag, ib, ib_tag, ic, ic_tag, op_id, sel_tag_err
};

// MW Note: No need to range check values fit in their tag's max bits. Inputs a and b are reads (already checked), and c is checked in memory.
// Though in this circuit we could incorrectly set cf = false when we would overflow, the memory range check would catch that c is too large.

// IS_FF CHECKING

// TODO(MW): remove this and check for all (i.e. replace with sel), just being lazy for now. For add, we don't care, for lt we need to differentiate.
pol CHECK_TAG_FF = sel_op_lt + sel_op_lte + sel_op_not;
// We prove that sel_is_ff == 1 <==> ia_tag == MEM_TAG_FF
pol TAG_FF_DIFF = ia_tag - constants.MEM_TAG_FF;
pol commit tag_ff_diff_inv;
#[TAG_IS_FF]
CHECK_TAG_FF * (TAG_FF_DIFF * (sel_is_ff * (1 - tag_ff_diff_inv) + tag_ff_diff_inv) + sel_is_ff - 1) = 0;

// TAG CHECKING

// Will become e.g. sel_op_add * ia_tag + (comparison ops) * MEM_TAG_U1 + ....
pol EXPECTED_C_TAG = sel_op_add * ia_tag + (sel_op_eq + sel_op_lt + sel_op_lte) * constants.MEM_TAG_U1;

// The tag of c is generated by the opcode and is never wrong.
// Gating with (1 - sel_tag_err) is necessary because when an error occurs, we have to set the tag to 0,
// which might not be equal to EXPECTED_C_TAG.
#[C_TAG_CHECK]
(1 - sel_tag_err) * (EXPECTED_C_TAG - ic_tag) = 0;

pol commit sel_tag_err;
pol commit ab_tags_diff_inv;
pol AB_TAGS_EQ = 1 - sel_tag_err;

// For NOT opcode, an error occurs if the tag of a is FF. In this case, tracegen will set
// b as FF(0) which would not satisfy the relation #[AB_TAGS_CHECK] if it were not gated
// by CHECK_AB_TAGS (namely ia_tag == ib_tag == MEM_TAG_FF which would force sel_tag_err == 0, but
// sel_tag_err must be 1 for sel_op_not whenever ia_tag == MEM_TAG_FF.).
pol CHECK_AB_TAGS = 1 - sel_op_not * sel_is_ff;

// TODO(MW): Add sel/flag to turn off check when we expect a/b tags to not be equal (e.g. SHR?)
// Prove that sel_tag_err = 1 <==> we have a disallowed inequality between the tags:
#[AB_TAGS_CHECK]
CHECK_AB_TAGS * ( (ia_tag - ib_tag) * ( AB_TAGS_EQ * (1 - ab_tags_diff_inv) + ab_tags_diff_inv) - 1 + AB_TAGS_EQ ) = 0;

#[TAG_MAX_BITS_VALUE]
sel { ia_tag, max_bits, max_value } in precomputed.sel_tag_parameters { precomputed.clk, precomputed.tag_max_bits, precomputed.tag_max_value };


// ADD

sel_op_add * (1 - sel_op_add) = 0;

#[ALU_ADD]
sel_op_add * (1 - sel_tag_err) * (ia + ib - ic - cf * (max_value + 1)) = 0;

// EQ

sel_op_eq * (1 - sel_op_eq) = 0;
pol DIFF = ia - ib;

// Use helper1 to invert DIFF.
// ic is a boolean output and ic == 1 <==> a == b.
// Important: ic boolean constraint is enforced as part of write to memory due to ic_tag == U1 as enforced by #[C_TAG_CHECK].

// sel_op_eq == 1 => [ic == 1 <==> DIFF == 0]
#[EQ_OP_MAIN]
sel_op_eq * (1 - sel_tag_err) * (DIFF * (ic * (1 - helper1) + helper1) - 1 + ic) = 0;

// LT

sel_op_lt * (1 - sel_op_lt) = 0;

// LTE

sel_op_lte * (1 - sel_op_lte) = 0;

// LT & LTE - Shared relations:

pol commit sel_lt_ops;
sel_lt_ops = (1 - sel_tag_err) * (sel_op_lt + sel_op_lte);

pol commit sel_ff_lt_ops;
// sel_is_ff & sel_lt_ops:
sel_ff_lt_ops - sel_is_ff * sel_lt_ops = 0;

pol commit sel_int_lt_ops;
// !sel_is_ff & sel_lt_ops:
sel_int_lt_ops - IS_NOT_FF * sel_lt_ops = 0;

// To perform LT or LTE ops, we redirect to the GT gadget where we check lt_ops_input_a > lt_ops_input_b ? lt_ops_result_c:
//  For LT, we want to show that: a < b ? c, so we use GT with swapped inputs and check: b > a ? c
//      LT: lt_ops_input_a = ib, lt_ops_input_b = ia, lt_ops_result_c = ic
//  For LTE, we want to show that: a <= b ? c, so we use GT with values as they are input and negate the result: a > b ? !c
//      LTE: lt_ops_input_a = ia, lt_ops_input_b = ib, lt_ops_result_c = !ic
pol commit lt_ops_input_a, lt_ops_input_b, lt_ops_result_c;

#[LT_OPS_SWAP_INPUTS_A]
sel_op_lt * (lt_ops_input_a - ib) + sel_op_lte * (lt_ops_input_a - ia) = 0;

#[LT_OPS_SWAP_INPUTS_B]
sel_op_lt * (lt_ops_input_b - ia) + sel_op_lte * (lt_ops_input_b - ib) = 0;

#[LT_OPS_NEGATE_RESULT_C]
sel_op_lt * (lt_ops_result_c - ic) + sel_op_lte * (1 - sel_tag_err) * ((1 - lt_ops_result_c) - ic) = 0;

#[FF_GT]
sel_ff_lt_ops { lt_ops_input_a, lt_ops_input_b, lt_ops_result_c }
in ff_gt.sel_gt { ff_gt.a, ff_gt.b, ff_gt.result };

#[INT_GT]
sel_int_lt_ops { lt_ops_input_a, lt_ops_input_b, lt_ops_result_c }
in gt.sel { gt.input_a, gt.input_b, gt.res };

// NOT

sel_op_not * (1 - sel_op_not) = 0;

// Relation is: a + ~a = 2^k - 1, where k is the number of bits in a.
#[NOT_OP_MAIN]
sel_op_not * (1 - sel_tag_err) * (ia + ib - max_value) = 0;

#[NOT_OP_TAG_ERROR]
sel_op_not * sel_is_ff * (1 - sel_tag_err) = 0;
