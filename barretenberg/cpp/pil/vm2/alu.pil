
include "execution.pil";
include "precomputed.pil";
namespace alu;

pol commit sel;

pol commit sel_op_add;
pol commit op_id;

pol commit ia;
pol commit ib;
pol commit ic;

pol commit ia_tag;
pol commit ib_tag;
pol commit ic_tag;

#[skippable_if]
sel = 0;

// carry flag
pol commit cf;

// TODO(MW): Not required for add, reinstate when needed:
// pol commit max_bits;
// maximum value the number can hold (i.e. 255 for a u8), we 'mod' by max_value + 1
pol commit max_value;

sel * (1 - sel) = 0;
cf * (1 - cf) = 0;

#[REGISTER_TAG_VALUE]
execution.sel_alu {
    execution.register[0], execution.mem_tag[0], execution.register[1],
    execution.mem_tag[1], execution.register[2], execution.mem_tag[2], execution.subtrace_operation_id, execution.opcode_error
} in sel {
    ia, ia_tag, ib, ib_tag, ic, ic_tag, op_id, sel_tag_err
};

// MW Note: No need to range check values fit in their tag's max bits. Inputs a and b are reads (already checked), and c is checked in memory.
// Though in this circuit we could incorrectly set cf = false when we would overflow, the memory range check would catch that c is too large.

// For add, we should throw a tag error when ANY of the tags are not equal, so I'm batching here (taken from addressing.pil -> BATCHED_TAGS_DIFF).
// For this op (and SUB, DIV, ... (TODO(MW))), we do care that c_tag = a_tag = b_tag, so toggle on the check:
pol CHECK_C_TAG_EQUAL = sel_op_add; // Will become e.g. 1 - (1 - sel_op_add) * (1 - sel_op_sub) * ...
pol BATCHED_TAGS_DIFF = 2**0 * (ia_tag - ib_tag) + CHECK_C_TAG_EQUAL * 2**3 * (ia_tag - ic_tag);
pol commit sel_tag_err;
pol commit batched_tags_diff_inv;
pol BATCHED_TAGS_DIFF_IS_ZERO = 1 - sel_tag_err;

// Now, tag_err = 1 <==> we have a disallowed inequality between the tags:
#[BATCHED_TAGS_DIFF_CHECK]
BATCHED_TAGS_DIFF * ( BATCHED_TAGS_DIFF_IS_ZERO * (1 - batched_tags_diff_inv) + batched_tags_diff_inv) - 1 + BATCHED_TAGS_DIFF_IS_ZERO = 0;

// TODO(MW): Add max_bits -> precomputed.max_bits when required by other ops:
#[TAG_MAX_VALUE]
sel { ia_tag, max_value } in precomputed.sel_tag_parameters { precomputed.clk, precomputed.tag_max_value };


// ADD

// TODO(MW): Add other ops like: sel_op_add * 2**0 + sel_op_sub * 2**1 + sel_op_mul * 2**2 - op_id = 0;
#[OP_ID_CHECK]
sel_op_add - op_id = 0;

sel_op_add * (1 - sel_op_add) = 0;

#[ALU_ADD]
sel_op_add * (ia + ib - ic - cf * (max_value + 1)) = 0;
