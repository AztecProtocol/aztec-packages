include "bc_decomposition.pil";

namespace instr_fetching;

pol commit sel;
// No relations will be checked if this identity is satisfied.
#[skippable_if]
sel = 0;

sel * (1 - sel) = 0;

pol commit pc;
pol commit bytecode_id;

// pc out-of-range error boolean
pol commit pc_out_of_range;
pc_out_of_range * (1 - pc_out_of_range) = 0;

// Instruction out-of-range error boolean (happens iff instr_size > bytes_to_read)
pol commit instr_out_of_range;
instr_out_of_range * (1 - instr_out_of_range) = 0;

// opcode is out-of-range error boolean
pol commit opcode_out_of_range; // copied from precomputed.pil

// If any error occurs, we toggle the following boolean:
pol commit parsing_err;
parsing_err = 1 - (1 - pc_out_of_range) * (1 - instr_out_of_range) * (1 - opcode_out_of_range);
// parsing_err is a boolean by definition (followed from above formula)

// If the current row is not active, then there are no more active rows after that.
// (not enforced for the first row)
// Gives guarantee that the active trace must start just after the first row (clk == 0)
// and from there it is contiguous.
#[TRACE_CONTINUITY]
(1 - precomputed.first_row) * (1 - sel) * sel' = 0;

// Last row of a given bytecode portion (i.e., pertaining to a given bytecode_id)
pol commit last_of_bytecode;
last_of_bytecode * (1 - last_of_bytecode) = 0;

// last_of_bytecode is toggled iff BC_ID_DIFF != 0
// Standard non-zero inequality involving helper inverse column
pol BC_ID_DIFF = bytecode_id' - bytecode_id;
pol commit bc_id_diff_inv;
#[LAST_OF_BYTECODE_TOGGLE]
sel * (BC_ID_DIFF * ((1 - last_of_bytecode) * (1 - bc_id_diff_inv) + bc_id_diff_inv) - last_of_bytecode) = 0;

// If last_of_bytecode OR precomputed.first_row then next row has pc == 0
#[PC_IS_ZERO_IN_BYTECODE_FIRST_ROW]
(last_of_bytecode + precomputed.first_row) * pc' = 0;

// Retrieved from bc_decomposition.pil
pol commit bytes_remaining;
pol commit bytes_to_read;

pol commit bytecode_size;
#[BYTECODE_SIZE_INIT]
(last_of_bytecode + precomputed.first_row) * (bytecode_size' - bytes_remaining') = 0;

#[SAME_BYTECODE_SIZE]
sel * sel' * (1 - last_of_bytecode) * (bytecode_size - bytecode_size') = 0;
// Note that last_of_bytecode might not be toggled at the last active row.
// For this reason, we need the factor sel' in the above relation.

// Absolute difference variant where we compute:
// bytes_to_read - instr_size      if instr_size <= bytes_to_read
// instr_size - bytes_to_read - 1  if instr_size > bytes_to_read
pol commit instr_abs_diff;

// From the following relation, we have: instr_abs_diff >= 0 ==> [instr_size > bytes_to_read <==> instr_out_of_range == 1]
#[INSTR_OUT_OF_RANGE_TOGGLE]
instr_abs_diff = (2 * instr_out_of_range - 1) * (instr_size - bytes_to_read) - instr_out_of_range;

#[INSTR_ABS_DIFF_POSITIVE]
sel {instr_abs_diff} in precomputed.sel_range_8 {precomputed.clk};

// We have to enforce that: pc < bytecode_size <==> pc_out_of_range == 0
// We use same trick as above by using an absolute difference value.

// pc - bytecode_size       if bytecode_size <= pc
// bytecode_size - pc - 1   if bytecode_size > pc
pol commit pc_abs_diff;
#[PC_OUT_OF_RANGE_TOGGLE]
pc_abs_diff = sel * ((2 * pc_out_of_range - 1) * (pc - bytecode_size) - 1 + pc_out_of_range);

// pc_abs_diff might take 32 bits and we decompose into 2 16-bit limbs
pol commit pc_abs_diff_lo;
pol commit pc_abs_diff_hi;

#[PC_ABS_DIFF_LIMBS]
pc_abs_diff = pc_abs_diff_lo + 2**16 * pc_abs_diff_hi;

#[PC_ABS_DIFF_POSITIVE_LO]
sel {pc_abs_diff_lo} in precomputed.sel_range_16 {precomputed.clk};

#[PC_ABS_DIFF_POSITIVE_HI]
sel {pc_abs_diff_hi} in precomputed.sel_range_16 {precomputed.clk};

// bytecode[pc] to bytecode[pc + 36]
pol commit bd0, bd1, bd2, bd3, bd4,
           bd5, bd6, bd7, bd8, bd9, bd10,
           bd11, bd12, bd13, bd14, bd15,
           bd16, bd17, bd18, bd19, bd20,
           bd21, bd22, bd23, bd24, bd25,
           bd26, bd27, bd28, bd29, bd30,
           bd31, bd32, bd33, bd34, bd35,
           bd36;

// Source selector for lookups to bc_decomposition.pil and instruction specifications in precomputed.pil.
pol commit sel_opcode_defined;
// Toggled except when pc is out of range.
sel_opcode_defined = sel * (1 - pc_out_of_range);

// Bring in the bytes from the bytecode columns.
#[BYTES_FROM_BC_DEC]
sel_opcode_defined {
     pc,
     bytecode_id,
     bytes_remaining,
     bytes_to_read,
     bd0,  bd1,  bd2,  bd3,  bd4,
     bd5,  bd6,  bd7,  bd8,  bd9,
     bd10, bd11, bd12, bd13, bd14,
     bd15, bd16, bd17, bd18, bd19,
     bd20, bd21, bd22, bd23, bd24,
     bd25, bd26, bd27, bd28, bd29,
     bd30, bd31, bd32, bd33, bd34,
     bd35, bd36
} in
bc_decomposition.sel {
     bc_decomposition.pc,
     bc_decomposition.id,
     bc_decomposition.bytes_remaining,
     bc_decomposition.bytes_to_read,
     bc_decomposition.bytes,            bc_decomposition.bytes_pc_plus_1, bc_decomposition.bytes_pc_plus_2, bc_decomposition.bytes_pc_plus_3, bc_decomposition.bytes_pc_plus_4,
     bc_decomposition.bytes_pc_plus_5,  bc_decomposition.bytes_pc_plus_6, bc_decomposition.bytes_pc_plus_7, bc_decomposition.bytes_pc_plus_8, bc_decomposition.bytes_pc_plus_9,
     bc_decomposition.bytes_pc_plus_10, bc_decomposition.bytes_pc_plus_11, bc_decomposition.bytes_pc_plus_12, bc_decomposition.bytes_pc_plus_13, bc_decomposition.bytes_pc_plus_14,
     bc_decomposition.bytes_pc_plus_15, bc_decomposition.bytes_pc_plus_16, bc_decomposition.bytes_pc_plus_17, bc_decomposition.bytes_pc_plus_18, bc_decomposition.bytes_pc_plus_19,
     bc_decomposition.bytes_pc_plus_20, bc_decomposition.bytes_pc_plus_21, bc_decomposition.bytes_pc_plus_22, bc_decomposition.bytes_pc_plus_23, bc_decomposition.bytes_pc_plus_24,
     bc_decomposition.bytes_pc_plus_25, bc_decomposition.bytes_pc_plus_26, bc_decomposition.bytes_pc_plus_27, bc_decomposition.bytes_pc_plus_28, bc_decomposition.bytes_pc_plus_29,
     bc_decomposition.bytes_pc_plus_30, bc_decomposition.bytes_pc_plus_31, bc_decomposition.bytes_pc_plus_32, bc_decomposition.bytes_pc_plus_33, bc_decomposition.bytes_pc_plus_34,
     bc_decomposition.bytes_pc_plus_35, bc_decomposition.bytes_pc_plus_36
};

// Wire to execution opcodes translation.
pol commit exec_opcode;

// Instruction size in bytes
pol commit instr_size;

// Selectors for operands decomposition into bytes (copied from precomputed.pil)
// This table is populated by a map generated by a cpp test in op_decomposition.test.cpp.
pol commit sel_op_dc_0;
pol commit sel_op_dc_1;
pol commit sel_op_dc_2;
pol commit sel_op_dc_3;
pol commit sel_op_dc_4;
pol commit sel_op_dc_5;
pol commit sel_op_dc_6;
pol commit sel_op_dc_7;
pol commit sel_op_dc_8;
pol commit sel_op_dc_9;
pol commit sel_op_dc_10;
pol commit sel_op_dc_11;
pol commit sel_op_dc_12;
pol commit sel_op_dc_13;
pol commit sel_op_dc_14;
pol commit sel_op_dc_15;
pol commit sel_op_dc_16;
pol commit sel_op_dc_17;

#[WIRE_INSTRUCTION_INFO]
sel_opcode_defined {
     bd0,
     opcode_out_of_range,
     exec_opcode,
     instr_size,
     sel_op_dc_0,  sel_op_dc_1,  sel_op_dc_2,  sel_op_dc_3,
     sel_op_dc_4,  sel_op_dc_5,  sel_op_dc_6,  sel_op_dc_7,
     sel_op_dc_8,  sel_op_dc_9,  sel_op_dc_10, sel_op_dc_11,
     sel_op_dc_12, sel_op_dc_13, sel_op_dc_14, sel_op_dc_15,
     sel_op_dc_16, sel_op_dc_17
} in
precomputed.sel_range_8 {
    precomputed.clk,
    precomputed.opcode_out_of_range,
    precomputed.exec_opcode,
    precomputed.instr_size,
    precomputed.sel_op_dc_0,  precomputed.sel_op_dc_1,  precomputed.sel_op_dc_2,  precomputed.sel_op_dc_3,
    precomputed.sel_op_dc_4,  precomputed.sel_op_dc_5,  precomputed.sel_op_dc_6,  precomputed.sel_op_dc_7,
    precomputed.sel_op_dc_8,  precomputed.sel_op_dc_9,  precomputed.sel_op_dc_10, precomputed.sel_op_dc_11,
    precomputed.sel_op_dc_12, precomputed.sel_op_dc_13, precomputed.sel_op_dc_14, precomputed.sel_op_dc_15,
    precomputed.sel_op_dc_16, precomputed.sel_op_dc_17
};

pol commit indirect;

// Operands.
pol commit op1, op2, op3, op4, op5, op6, op7;

// The following relations decomposing operands (indirect, op1, ...) into bytes were code-generated by
// a cpp test in op_decomposition.test.cpp.
// Remark: Upper-casing the alias needs to be edited manually (not code-generated)!
pol SEL_OP_DC_18 = sel_op_dc_2 + sel_op_dc_6;

#[INDIRECT_BYTES_DECOMPOSITION]
indirect = sel_op_dc_0 * (bd1 * 2**8 + bd2 * 2**0) + SEL_OP_DC_18 * (bd1 * 2**0);
#[OP1_BYTES_DECOMPOSITION]
op1 = sel_op_dc_0 * (bd3 * 2**8 + bd4 * 2**0) + sel_op_dc_2 * (bd2 * 2**8 + bd3 * 2**0) + sel_op_dc_6 * (bd2 * 2**0) + sel_op_dc_15 * (bd1 * 2**24 + bd2 * 2**16 + bd3 * 2**8 + bd4 * 2**0);
#[OP2_BYTES_DECOMPOSITION]
op2 = sel_op_dc_0 * (bd5 * 2**8 + bd6 * 2**0) + sel_op_dc_3 * (bd4 * 2**8 + bd5 * 2**0) + sel_op_dc_6 * (bd3 * 2**0) + sel_op_dc_8 * (bd4 * 2**0) + sel_op_dc_16 * (bd4 * 2**24 + bd5 * 2**16 + bd6 * 2**8 + bd7 * 2**0);
#[OP3_BYTES_DECOMPOSITION]
op3 = sel_op_dc_0 * (bd7 * 2**8 + bd8 * 2**0) + sel_op_dc_4 * (bd6 * 2**8 + bd7 * 2**0) + sel_op_dc_9 * (bd5 * 2**248 + bd6 * 2**240 + bd7 * 2**232 + bd8 * 2**224 + bd9 * 2**216 + bd10 * 2**208 + bd11 * 2**200 + bd12 * 2**192 + bd13 * 2**184 + bd14 * 2**176 + bd15 * 2**168 + bd16 * 2**160 + bd17 * 2**152 + bd18 * 2**144 + bd19 * 2**136 + bd20 * 2**128 + bd21 * 2**120 + bd22 * 2**112 + bd23 * 2**104 + bd24 * 2**96 + bd25 * 2**88 + bd26 * 2**80 + bd27 * 2**72 + bd28 * 2**64 + bd29 * 2**56 + bd30 * 2**48 + bd31 * 2**40 + bd32 * 2**32 + bd33 * 2**24 + bd34 * 2**16 + bd35 * 2**8 + bd36 * 2**0) + sel_op_dc_10 * (bd5 * 2**120 + bd6 * 2**112 + bd7 * 2**104 + bd8 * 2**96 + bd9 * 2**88 + bd10 * 2**80 + bd11 * 2**72 + bd12 * 2**64 + bd13 * 2**56 + bd14 * 2**48 + bd15 * 2**40 + bd16 * 2**32 + bd17 * 2**24 + bd18 * 2**16 + bd19 * 2**8 + bd20 * 2**0) + sel_op_dc_11 * (bd5 * 2**56 + bd6 * 2**48 + bd7 * 2**40 + bd8 * 2**32 + bd9 * 2**24 + bd10 * 2**16 + bd11 * 2**8 + bd12 * 2**0) + sel_op_dc_12 * (bd5 * 2**24 + bd6 * 2**16 + bd7 * 2**8 + bd8 * 2**0) + sel_op_dc_13 * (bd5 * 2**8 + bd6 * 2**0) + sel_op_dc_14 * (bd4 * 2**0) + sel_op_dc_17 * (bd6 * 2**0);
#[OP4_BYTES_DECOMPOSITION]
op4 = sel_op_dc_0 * (bd9 * 2**8 + bd10 * 2**0) + sel_op_dc_5 * (bd8 * 2**8 + bd9 * 2**0) + sel_op_dc_7 * (bd8 * 2**0);
#[OP5_BYTES_DECOMPOSITION]
op5 = sel_op_dc_0 * (bd11 * 2**8 + bd12 * 2**0);
#[OP6_BYTES_DECOMPOSITION]
op6 = sel_op_dc_1 * (bd13 * 2**8 + bd14 * 2**0);
#[OP7_BYTES_DECOMPOSITION]
op7 = sel_op_dc_1 * (bd15 * 2**8 + bd16 * 2**0);
