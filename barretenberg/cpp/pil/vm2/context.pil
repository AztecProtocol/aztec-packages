include "context_stack.pil";

// This is a virtual gadget, which is part of the execution trace.
// This subtrace is focused on managing the changes to the context.
// By default (i.e. when not executing a context-changing opcode),
// the context object is propagated downwards
namespace execution;

    // This the same sel as in execution
    #[skippable_if]
    sel = 0;

    // Useful to define some opcodes within this pil file
    // Constrained to be boolean by execution instruction spec table
    pol commit sel_revert;
    pol commit sel_return;
    pol commit sel_call;
    pol commit sel_static_call;
    // Guaranteed to be boolean becuase sel_call & sel_static_call are mutually exclusive
    pol commit sel_enter_call;
    // Handle error separately since it takes priority and may occur during an sel_x_call
    sel_enter_call = (sel_call + sel_static_call) * (1 - sel_error);
    // CALL & precomputed.first_row are mutually exclusive
    sel_enter_call * precomputed.first_row = 0;

    // sel_exit_call is used to flag if we are returning or reverting or we error
    // sel_revert & sel_return are mutually exclusive
    pol commit sel_exit_call;
    sel_exit_call = 1 - (1 - sel_revert - sel_return) * (1 - sel_error);

    // Context columns
    pol commit context_id;
    pol commit parent_id;
    pol commit pc;
    pol commit next_pc;
    pol commit msg_sender;
    pol commit contract_address;
    // Constrained boolean by tx trace (for enqueued call) and #[NEXT_IS_STATIC] for nested
    pol commit is_static;

    pol commit parent_calldata_offset_addr;
    pol commit parent_calldata_size_addr;

    pol commit last_child_returndata_offset_addr;
    pol commit last_child_returndata_size;
    pol commit last_child_success; // Careful with this for now...

    // ==== Gas ====
    pol commit l2_gas_limit;
    pol commit da_gas_limit;
    pol commit l2_gas_used;
    pol commit da_gas_used;

    pol commit parent_l2_gas_limit;
    pol commit parent_da_gas_limit;
    pol commit parent_l2_gas_used;
    pol commit parent_da_gas_used;

    // ==== Tree State ===
    pol commit prev_note_hash_tree_root;
    pol commit prev_note_hash_tree_size;
    pol commit prev_num_note_hashes_emitted;

    pol commit prev_nullifier_tree_root;
    pol commit prev_nullifier_tree_size;
    pol commit prev_num_nullifiers_emitted;

    pol commit prev_public_data_tree_root;
    pol commit prev_public_data_tree_size;
    pol commit prev_num_pub_data_writes_emitted;

    pol commit prev_l1_l2_tree_root;
    pol commit prev_l1_l2_tree_size;

    // Next Tree State
    pol commit note_hash_tree_root;
    pol commit note_hash_tree_size;
    pol commit num_note_hashes_emitted;

    pol commit nullifier_tree_root;
    pol commit nullifier_tree_size;
    pol commit num_nullifiers_emitted;

    pol commit public_data_tree_root;
    pol commit public_data_tree_size;
    pol commit num_pub_data_writes_emitted;

    pol commit l1_l2_tree_root;
    pol commit l1_l2_tree_size;

    // ==== Helper columns ====
    // TODO: These context modifiers also need to factor in when a new enqueued call occurs
    pol NOT_LAST_EXEC = sel * sel';
    pol SWITCH_CTX = sel_enter_call + sel_exit_call; // Mutually Exclusive
    // We default propagate the context rows if we have more execution steps and we are not exiting or entering a call
    pol DEFAULT_CTX_ROW = (1 - SWITCH_CTX);

    pol commit has_parent_ctx; // == 1 if parent_id != 0;
    has_parent_ctx * (1 - has_parent_ctx) = 0;
    pol commit is_parent_id_inv; // For zero-check of has_parent_ctx
    parent_id * ((1 - has_parent_ctx) * (1 - is_parent_id_inv) + is_parent_id_inv) - has_parent_ctx = 0;

    // We need a flag to indicate when we are exiting a nested context
    pol commit nested_exit_call;
    // If we are exiting and we have a parent ctx
    nested_exit_call = has_parent_ctx * sel_exit_call;

    // next_context_id increments with each invocation of an external call or new enqueued call
    pol commit next_context_id; // Can be replaced by clk
    // The initial next_context_id = 2, in row = 1
    #[INCR_NEXT_CONTEXT_ID]
    NOT_LAST_EXEC * (next_context_id' - (next_context_id + sel_enter_call)) = 0;

    // nested_exit_call = 1 <==> context_id' = parent_id
    // sel_enter_call   = 1 <==> context_id' = next_context_id
    // otherwise        = 0 <==> context_id' = context_id
    #[CONTEXT_ID_CALL_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (context_id' - context_id) = 0;
    NOT_LAST_EXEC * sel_enter_call  * (context_id' - next_context_id) = 0;
    NOT_LAST_EXEC * nested_exit_call   * (context_id' - parent_id) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> parent_id' = context_id
    // otherwise        = 0 <==> parent_id' = parent_id
    #[PARENT_ID_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (parent_id' - parent_id) = 0;
    NOT_LAST_EXEC * sel_enter_call  * (parent_id' - context_id) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> pc' = 0
    // otherwise        = 0 <==> pc' = next_pc
    #[PC_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (pc' - next_pc) = 0;
    NOT_LAST_EXEC * sel_enter_call  * pc' = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> msg_sender' = contract_address
    // otherwise        = 0 <==> msg_sender' = msg_sender
    #[MSG_SENDER_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (msg_sender' - msg_sender) = 0;
    NOT_LAST_EXEC * sel_enter_call  * (msg_sender' - contract_address) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> contract_address' = register[2] (intermediate register 3 from execution trace)
    // otherwise        = 0 <==> contract_address' = contract_address
    #[CONTRACT_ADDR_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (contract_address' - contract_address) = 0;
    NOT_LAST_EXEC * sel_enter_call  * (contract_address' - register[2]) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 && static_call = 1 <==> is_static' = 1
    // sel_enter_call   = 1 && static_call = 0 <==> is_static' = 0
    // otherwise        = 0 <==> is_static' = is_static
    #[IS_STATIC_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (is_static' - is_static) = 0;
    NOT_LAST_EXEC * sel_enter_call  * (is_static' - sel_static_call) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> parent_calldata_offset_addr' = rop[3] (resolved operand 4 from execution trace)
    // otherwise        = 0 <==> parent_calldata_offset_addr' = parent_calldata_offset_addr
    #[CD_OFFSET_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (parent_calldata_offset_addr' - parent_calldata_offset_addr) = 0;
    NOT_LAST_EXEC * sel_enter_call  * (parent_calldata_offset_addr' - rop[3]) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> parent_calldata_size_addr' = rop[4] (resolved operand 5 from execution trace)
    // otherwise        = 0 <==> parent_calldata_size_addr' = parent_calldata_size_addr
    #[CD_SIZE_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (parent_calldata_size_addr' - parent_calldata_size_addr) = 0;
    NOT_LAST_EXEC * sel_enter_call  * (parent_calldata_size_addr' - rop[4]) = 0;

    pol NESTED_RET_REV_ONLY = nested_exit_call * (1 - sel_error);
    // NESTED_RET_REV_ONLY = 1 <==> rop[1] (resolved operand 2 from execution trace)
    // sel_error           = 1 <==> last_child_returndata_size' = 0;
    // sel_enter_call      = 1 <==> last_child_returndata_offset_addr' = 0;
    // otherwise           = 0 <==> last_child_returndata_offset_addr' = last_child_returndata_offset_addr
    #[RD_OFFSET_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (last_child_returndata_offset_addr' - last_child_returndata_offset_addr) = 0;
    NOT_LAST_EXEC * NESTED_RET_REV_ONLY * (last_child_returndata_offset_addr' - rop[1]) = 0;
    NOT_LAST_EXEC * (sel_enter_call + sel_error) * last_child_returndata_offset_addr' = 0;

    // NESTED_RET_REV_ONLY = 1 <==> register[0] (intermediate register 1 from execution trace)
    // sel_error               = 1 <==> last_child_returndata_size' = 0;
    // sel_enter_call          = 1 <==> last_child_returndata_size' = 0;
    // otherwise               = 0 <==> last_child_returndata_size' = last_child_returndata_size
    #[RD_SIZE_OFFSET_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (last_child_returndata_size' - last_child_returndata_size) = 0;
    NOT_LAST_EXEC * NESTED_RET_REV_ONLY  * (last_child_returndata_size' - register[0]) = 0;
    NOT_LAST_EXEC * (sel_enter_call + sel_error) * last_child_returndata_size' = 0;

    // nested_exit_call = 1 <==> l2_gas_limit' = parent_l2_gas_limit
    // sel_enter_call   = 1 <==> constraints come from call logic
    // otherwise        = 0 <==> l2_gas_limit' = l2_gas_limit
    #[L2_GAS_LIMIT_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (l2_gas_limit' - l2_gas_limit) = 0;
    #[L2_GAS_LIMIT_RESTORE_ON_EXIT]
    NOT_LAST_EXEC * nested_exit_call * (l2_gas_limit' - parent_l2_gas_limit) = 0;

    // nested_exit_call = 1 <==> da_gas_limit' = parent_da_gas_limit
    // sel_enter_call   = 1 <==> constraints come from call logic
    // otherwise        = 0 <==> da_gas_limit' = da_gas_limit
    #[DA_GAS_LIMIT_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (da_gas_limit' - da_gas_limit) = 0;
    #[DA_GAS_LIMIT_RESTORE_ON_EXIT]
    NOT_LAST_EXEC * nested_exit_call * (da_gas_limit' - parent_da_gas_limit) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> parent_l2_gas_limit' = l2_gas_limit
    // otherwise        = 0 <==> parent_l2_gas_limit' = parent_l2_gas_limit
    #[PARENT_L2_GAS_LIMIT_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (parent_l2_gas_limit' - parent_l2_gas_limit) = 0;
    #[PARENT_L2_GAS_LIMIT_STORE_ON_ENTER]
    NOT_LAST_EXEC * sel_enter_call * (parent_l2_gas_limit' - l2_gas_limit) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> parent_da_gas_limit' = da_gas_limit
    // otherwise        = 0 <==> parent_da_gas_limit' = parent_da_gas_limit
    #[PARENT_DA_GAS_LIMIT_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (parent_da_gas_limit' - parent_da_gas_limit) = 0;
    #[PARENT_DA_GAS_LIMIT_STORE_ON_ENTER]
    NOT_LAST_EXEC * sel_enter_call * (parent_da_gas_limit' - da_gas_limit) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> parent_l2_gas_used' = l2_gas_used
    // otherwise        = 0 <==> parent_l2_gas_used' = parent_l2_gas_used
    #[PARENT_L2_GAS_USED_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (parent_l2_gas_used' - parent_l2_gas_used) = 0;
    #[PARENT_L2_GAS_USED_STORE_ON_ENTER]
    NOT_LAST_EXEC * sel_enter_call * (parent_l2_gas_used' - l2_gas_used) = 0;

    // nested_exit_call = 1 <==> constraints come from lookup
    // sel_enter_call   = 1 <==> parent_da_gas_used' = da_gas_used
    // otherwise        = 0 <==> parent_da_gas_used' = parent_da_gas_used
    #[PARENT_DA_GAS_USED_NEXT_ROW]
    NOT_LAST_EXEC * DEFAULT_CTX_ROW * (parent_da_gas_used' - parent_da_gas_used) = 0;
    #[PARENT_DA_GAS_USED_STORE_ON_ENTER]
    NOT_LAST_EXEC * sel_enter_call * (parent_da_gas_used' - da_gas_used) = 0;

    #[CTX_STACK_CALL]
    sel_enter_call {
        next_context_id,
        context_id,
        parent_id,
        next_pc,
        msg_sender,
        contract_address,
        is_static,
        parent_calldata_offset_addr,
        parent_calldata_size_addr,
        parent_l2_gas_limit,
        parent_da_gas_limit,
        parent_l2_gas_used,
        parent_da_gas_used
    } in
    context_stack.sel {
        context_stack.entered_context_id,
        context_stack.context_id,
        context_stack.parent_id,
        context_stack.next_pc,
        context_stack.msg_sender,
        context_stack.contract_address,
        context_stack.is_static,
        context_stack.parent_calldata_offset_addr,
        context_stack.parent_calldata_size_addr,
        context_stack.parent_l2_gas_limit,
        context_stack.parent_da_gas_limit,
        context_stack.parent_l2_gas_used,
        context_stack.parent_da_gas_used
    };

    // If we are reverting or erroring a nested call, we restore the entire ctx from the stack
    pol commit rollback_context;
    rollback_context * (1 - rollback_context) = 0;
    // Constrained to be boolean based on previous relations
    rollback_context = nested_exit_call * (1 - sel_return);

    #[CTX_STACK_ROLLBACK]
    rollback_context {
        context_id,
        context_id', // constrained to be parent_id
        parent_id',
        pc',
        msg_sender',
        contract_address',
        is_static',
        parent_calldata_offset_addr',
        parent_calldata_size_addr',
        parent_l2_gas_limit',
        parent_da_gas_limit',
        parent_l2_gas_used',
        parent_da_gas_used'
        // Tree Snapshots
        // Counters
    } in
    context_stack.sel {
        context_stack.entered_context_id,
        context_stack.context_id,
        context_stack.parent_id,
        context_stack.next_pc,
        context_stack.msg_sender,
        context_stack.contract_address,
        context_stack.is_static,
        context_stack.parent_calldata_offset_addr,
        context_stack.parent_calldata_size_addr,
        context_stack.parent_l2_gas_limit,
        context_stack.parent_da_gas_limit,
        context_stack.parent_l2_gas_used,
        context_stack.parent_da_gas_used
        // Tree Snapshots
        // Counters
    };

    pol commit nested_return;
    nested_return = nested_exit_call * sel_return;
    #[CTX_STACK_RETURN]
    nested_return {
        context_id', // constrained to be parent_id
        parent_id',
        pc',
        msg_sender',
        contract_address',
        is_static',
        parent_calldata_offset_addr',
        parent_calldata_size_addr',
        parent_l2_gas_limit',
        parent_da_gas_limit',
        parent_l2_gas_used',
        parent_da_gas_used'
    } in
    context_stack.sel {
        context_stack.context_id,
        context_stack.parent_id,
        context_stack.next_pc,
        context_stack.msg_sender,
        context_stack.contract_address,
        context_stack.is_static,
        context_stack.parent_calldata_offset_addr,
        context_stack.parent_calldata_size_addr,
        context_stack.parent_l2_gas_limit,
        context_stack.parent_da_gas_limit,
        context_stack.parent_l2_gas_used,
        context_stack.parent_da_gas_used
    };

