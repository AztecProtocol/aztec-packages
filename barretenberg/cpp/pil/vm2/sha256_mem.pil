include "gt.pil";
include "constants_gen.pil";
include "sha256.pil";

/**
 * This handles the memory accesses for the SHA256Compression opcode and is virtual to the sha256_compression subtrace
 * The sha256 compression is computed across 65 rows (64 rounds + 1 final output row). Each row represents
 * a round of sh256 compression, where the input[i] is used for the i-th round. The 65th row contains the output
 * that will be written to memory
 *
 * This trace reads and writes the following:
 * (1) Read State: From { state_addr, state_addr + 1, ..., state_addr + 7 } 
 * (2) Read Input: From { input_addr, input_addr + 1, ..., input_addr + 15 }
 * (3) Write Output: From { output_addr, output_addr + 1, ..., output_addr + 7 }
 * All values operated on in this subtrace is validated to be U32.
 * This subtrace has a mix of a vertical and horizontal memory accesses.
 * The State and Outputs are written horizontally (i.e. there are 8 columns), this means that 
 * they are loaded in "parallel" and therefore they form their own temporality groups (for the purpos of errors)
 * The Input is "mixed" into the hash at each round, this means the inputs are loaded in a single column and the i-th input
 * is loaded in the i-th row  of computation. Therefore, a single load is a temporality group (for the purpose of errors)
 *
 * Opcode operands (relevant in EXECUTION when interacting with this gadget):
 * - rop[0]: state_addr
 * - rop[1]: input_addr
 * - rop[2]: dst_addr
 *
 * Memory I/O:
 * - M[rop[0]]: M[state_addr] aka state_0 (the first value of the hash state array)
 *     - guaranteed by this gadget to be U32
 * - M[rop[1]]: M[input_addr] aka input_0 (the first value of the hash input array)
 *     - guaranteed by this gadget to be U32.
 * - M[rop[2]]: M[dst_addr] aka output_0 (the first value of the hash output array)
 *     - guaranteed by this gadget to be U32.
*
 * ERROR HANDLING:
 * Two errors needs to be handled as part of this trace,
 * (1) DST_OUT_OF_BOUNDS_ACCESS: If the reads or writes would access a memory address outside
 *     of the max AVM memory address (AVM_HIGHEST_MEM_ADDRESS).
 * (2) INVALID_READ_TAG: If any of the state or input values retrieved from memory are NOT U32
 *
 * +----------------------------------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------+--------------------------------+
 * |       Opearands and helper columns           |  State Memory Columnss : Reads inital state from state_addr, and writes output state to dst_addr  | Input Loader: Loads 16 elements vertically | SHA256 COMPRESSION COMPUTATION |
 * +----------------------------------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------+--------------------------------+
 * | row | clk | space id | state addr | dst addr | mem addr[0] | ... | mem_addr[7]    | mem tags[8] | register[0]         | ... |     register[7]    |    input addr   | input tag | input value  |                                |
 * +-----+-----+----------+------------+----------+-------------+-----+----------------+-------------+---------------------+-----+--------------------+-----------------+-----------+--------------+--------------------------------+
 * |  1  |  2  |     1    | 0xdeadbeef | 0xc0ffee | 0xdeadbeef  | ... | 0xdeadbeef + 7 |    U32      | sha256_in_state[0]  | ... | sha256_in_state[7] | 0xdecafbad      |   U32     |     456      |                                |
 * |  2  |  2  |     1    | 0xdeadbeef | 0xc0ffee |     0       | ... |     0          |     0       |         0           | ... |         0          | 0xdecafbad + 1  |   U32     |     789      |                                |
 * | ... | ... |    ...   |    ...     |   ...    |    ...      | ... |    ...         |    ...      |        ...          | ... |        ...         |      ...        |   ...     |     ...      |       See sha256.pil           |
 * | 16  |  2  |     1    | 0xdeadbeef | 0xc0ffee |     0       | ... |    ...         |    ...      |        ...          | ... |        ...         | 0xdecafbad + 15 |   U32     |     123      |                                |
 * | ... | ... |    ...   |    ...     |   ...    |    ...      | ... |    ...         |    ...      |        ...          | ... |        ...         |       0         |   ...     |     ...      |                                |
 * | 65  |  2  |     1    | 0xdeadbeef | 0xc0ffee |  0xc0ffee   | ... |  0xc0ffee + 7  |    U32      | sha256_out_state[0] | ... | sha256_out_state[7]|       0         |    0      |      0       |                                |
 * +-----+-----+----------+------------+----------+-------------+-----+----------------+-------------+---------------------+-----+--------------------+-----------------+-----------+--------------+--------------------------------+
 *
 */

// virtual to the sha256 compression, written here for clarity
namespace sha256;
    
    // Selector for Sha256Compression Operation
    pol commit sel;
    sel * (1 - sel) = 0;

    #[skippable_if]
    sel = 0;

    // Inputs
    pol commit execution_clk;
    pol commit space_id;
    pol commit state_addr;
    pol commit input_addr;
    pol commit dst_addr;

    ////////////////////////////////////////////////
    // Error Handling - Out of Range Memory Access
    ////////////////////////////////////////////////
    pol commit sel_state_out_of_range_err;
    pol commit sel_input_out_of_range_err;
    pol commit sel_dst_out_of_range_err;

    // Use the comparison gadget to check that the max addresses are within range
    // The comparison gadget provides the ability to test GreaterThan so we check
    // (1) state_addr + 7 > max_mem_addr
    // (2) input_addr + 15 > max_mem_addr
    // (3) dst_addr + 7 > max_mem_addr
    pol commit max_mem_addr; // While we do not support constants
    sel * (max_mem_addr - constants.AVM_HIGHEST_MEM_ADDRESS) = 0;

    pol commit max_state_addr;
    max_state_addr = sel * (state_addr + 7); // We read 8 elements for the state
    #[CHECK_STATE_ADDR_IN_RANGE]
    sel { max_state_addr, max_mem_addr, sel_state_out_of_range_err }
    in
    gt.sel { gt.input_a, gt.input_b, gt.res };

    pol commit max_input_addr;
    max_input_addr = sel * (input_addr + 15); // We read 16 elements for inputs
    #[CHECK_INPUT_ADDR_IN_RANGE]
    sel { max_input_addr, max_mem_addr, sel_input_out_of_range_err }
    in
    gt.sel { gt.input_a, gt.input_b, gt.res };

    pol commit max_dst_addr;
    max_dst_addr = sel * (dst_addr + 7); // We write 8 elements for the output
    #[CHECK_DST_ADDR_IN_RANGE]
    sel { max_dst_addr, max_mem_addr, sel_dst_out_of_range_err }
    in
    gt.sel { gt.input_a, gt.input_b, gt.res };

    pol MEM_OUT_OF_RANGE_ERR = 1 - (1 - sel_state_out_of_range_err) * (1 - sel_input_out_of_range_err) * (1 - sel_dst_out_of_range_err);

    ////////////////////////////////////////////////////////
    // Memory Operations: State and Output
    ////////////////////////////////////////////////////////
    // We re-use the memory_addresses and memory registers when reading state and
    // writing outputs. This saves us having another 8 permutations

    // Read if we did not have an out of range error
    pol commit sel_should_read_mem;
    sel_should_read_mem = sel * (1 - MEM_OUT_OF_RANGE_ERR);

    // At the start/end of the sha256 computation, we activate read/write of the state memory columns
    // Start and last mutually exclusive
    pol commit sel_mem_start_and_last;
    sel_mem_start_and_last = sel_should_read_mem * (start + latch);
 
    pol commit u32_tag;
    u32_tag = sel_should_read_mem * constants.MEM_TAG_U32;

    pol commit memory_address[8]; // These will be use by state & dst addresses
    pol MEM_ADDR = start * state_addr + latch * dst_addr;
    sel_mem_start_and_last * (memory_address[0] - (MEM_ADDR + 0)) = 0;
    sel_mem_start_and_last * (memory_address[1] - (MEM_ADDR + 1)) = 0;
    sel_mem_start_and_last * (memory_address[2] - (MEM_ADDR + 2)) = 0;
    sel_mem_start_and_last * (memory_address[3] - (MEM_ADDR + 3)) = 0;
    sel_mem_start_and_last * (memory_address[4] - (MEM_ADDR + 4)) = 0;
    sel_mem_start_and_last * (memory_address[5] - (MEM_ADDR + 5)) = 0;
    sel_mem_start_and_last * (memory_address[6] - (MEM_ADDR + 6)) = 0;
    sel_mem_start_and_last * (memory_address[7] - (MEM_ADDR + 7)) = 0;

    // If we are at the start, the init_x values of the sha256 compression trace is populated by these registers
    // If we are at the end, the output_x_rhs values of the sha256 compression trace populate these registers
    pol commit memory_register[8]; // These will be used by state and dst values
    sel_mem_start_and_last * (start * (memory_register[0] - init_a) + latch * (memory_register[0] - output_a_rhs)) = 0;
    sel_mem_start_and_last * (start * (memory_register[1] - init_b) + latch * (memory_register[1] - output_b_rhs)) = 0;
    sel_mem_start_and_last * (start * (memory_register[2] - init_c) + latch * (memory_register[2] - output_c_rhs)) = 0;
    sel_mem_start_and_last * (start * (memory_register[3] - init_d) + latch * (memory_register[3] - output_d_rhs)) = 0;
    sel_mem_start_and_last * (start * (memory_register[4] - init_e) + latch * (memory_register[4] - output_e_rhs)) = 0;
    sel_mem_start_and_last * (start * (memory_register[5] - init_f) + latch * (memory_register[5] - output_f_rhs)) = 0;
    sel_mem_start_and_last * (start * (memory_register[6] - init_g) + latch * (memory_register[6] - output_g_rhs)) = 0;
    sel_mem_start_and_last * (start * (memory_register[7] - init_h) + latch * (memory_register[7] - output_h_rhs)) = 0;

    pol commit memory_tag[8]; // Memory Tag loaded from memory

    // TODO: These need to be changed to permutations once we have the custom permutation selectors impl
    #[MEM_OP_0]
    sel_mem_start_and_last { 
        execution_clk,       memory_address[0],
        memory_register[0], memory_tag[0],
        space_id,            /*rw=*/ latch
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };

    #[MEM_OP_1]
    sel_mem_start_and_last { 
        execution_clk,       memory_address[1],
        memory_register[1], memory_tag[1],
        space_id,            /*rw=*/ latch
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };

    #[MEM_OP_2]
    sel_mem_start_and_last { 
        execution_clk,       memory_address[2],
        memory_register[2], memory_tag[2],
        space_id,            /*rw=*/ latch
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };

    #[MEM_OP_3]
    sel_mem_start_and_last { 
        execution_clk,       memory_address[3],
        memory_register[3], memory_tag[3],
        space_id,            /*rw=*/ latch
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };

    #[MEM_OP_4]
    sel_mem_start_and_last { 
        execution_clk,       memory_address[4],
        memory_register[4], memory_tag[4],
        space_id,            /*rw=*/ latch
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };

    #[MEM_OP_5]
    sel_mem_start_and_last { 
        execution_clk,       memory_address[5],
        memory_register[5], memory_tag[5],
        space_id,            /*rw=*/ latch
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };

    #[MEM_OP_6]
    sel_mem_start_and_last { 
        execution_clk,       memory_address[6],
        memory_register[6], memory_tag[6],
        space_id,            /*rw=*/ latch
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };

    #[MEM_OP_7]
    sel_mem_start_and_last { 
        execution_clk,       memory_address[7],
        memory_register[7], memory_tag[7],
        space_id,            /*rw=*/ latch
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };


    ////////////////////////////////////////////////////////
    // Memory Operation: Loading (16) Round Input
    ////////////////////////////////////////////////////////
    // The 16 hash inputs are mixed into the first 16 rounds of the sha256 compression
    pol commit sel_is_input_round; // Selector to indicate this if this is an input round
    sel_is_input_round * (1 - sel_is_input_round) = 0;
    
    // Input Round Counter, starting value is 16
    pol commit input_rounds_rem;
    #[INPUT_ROUND_CTR_START_COND]
    start * (input_rounds_rem - 16) = 0;
    // Decrement the counter if we are in an input round row
    #[INPUT_ROUND_CTR_DECR_COND]
    (1 - start') * (input_rounds_rem' - (input_rounds_rem - sel_is_input_round)) = 0;

    // Constraining sel_is_input_round
    // (1) At start, sel_is_input_round = 1
    #[SEL_IS_INPUT_ROUND_START_COND]
    start * (sel_is_input_round - 1) = 0;

    // (2) If round_counter = 1, then we are at last round of the inputs and sel_is_input_round' = 0;
    pol commit input_rounds_rem_minus_one_inv;
    pol READ_INPUT_ROUNDS_MINUS_ONE = input_rounds_rem - 1;
    #[SEL_IS_INPUT_END]
    sel_is_input_round * (READ_INPUT_ROUNDS_MINUS_ONE * (sel_is_input_round' * (1 - input_rounds_rem_minus_one_inv) + input_rounds_rem_minus_one_inv) - 1 + sel_is_input_round') = 0;

    // (3) Otherwise propagate sel_is_input_round value to the next row. Note that if sel_is_input_round = 0
    // then sel_is_input_round' = 0 based on this relation
    #[SEL_IS_INPUT_PROPAGATE]
    (1 - start') * (1 - sel_is_input_round) * sel_is_input_round' = 0;

    pol commit sel_read_input_from_memory; 
    sel_read_input_from_memory = sel_should_read_mem * sel_is_input_round;

    // Put the result of the input loads
    pol commit input;
    pol commit input_tag;

    #[MEM_INPUT_READ]
    sel_read_input_from_memory { 
        execution_clk,       input_addr,
        input,               input_tag,
        space_id,            /*rw=*/ precomputed.zero
    } in
    memory.sel { 
        memory.clk,      memory.address,
        memory.value,    memory.tag,
        memory.space_id, memory.rw
    };

    ////////////////////////////////////////////////
    // Error Handling - Invalid Input Tag (not FF)
    ////////////////////////////////////////////////
    pol commit sel_invalid_tag_err;
    pol STATE_TAG_DIFF_0 = sel_mem_start_and_last * (memory_tag[0] - constants.MEM_TAG_U32);
    pol STATE_TAG_DIFF_1 = sel_mem_start_and_last * (memory_tag[1] - constants.MEM_TAG_U32);
    pol STATE_TAG_DIFF_2 = sel_mem_start_and_last * (memory_tag[2] - constants.MEM_TAG_U32);
    pol STATE_TAG_DIFF_3 = sel_mem_start_and_last * (memory_tag[3] - constants.MEM_TAG_U32);
    pol STATE_TAG_DIFF_4 = sel_mem_start_and_last * (memory_tag[4] - constants.MEM_TAG_U32);
    pol STATE_TAG_DIFF_5 = sel_mem_start_and_last * (memory_tag[5] - constants.MEM_TAG_U32);
    pol STATE_TAG_DIFF_6 = sel_mem_start_and_last * (memory_tag[6] - constants.MEM_TAG_U32);
    pol STATE_TAG_DIFF_7 = sel_mem_start_and_last * (memory_tag[7] - constants.MEM_TAG_U32);
    pol INPUT_TAG_DIFF =  sel_read_input_from_memory * (input_tag - constants.MEM_TAG_U32); 

    pol BATCHED_TAG_CHECK = 2**0 * STATE_TAG_DIFF_0 + 2**3 * STATE_TAG_DIFF_1
                          + 2**6 * STATE_TAG_DIFF_2 + 2**9 * STATE_TAG_DIFF_3
                          + 2**12 * STATE_TAG_DIFF_4 + 2**15 * STATE_TAG_DIFF_5
                          + 2**18 * STATE_TAG_DIFF_6 + 2**21 * STATE_TAG_DIFF_7
                          + 2**24 * INPUT_TAG_DIFF;

    pol commit batch_tag_inv;
    // BATCHED_TAG_CHECK != 0, sel_invalid_tag_err = 1 
    #[BATCH_ZERO_CHECK]
    BATCHED_TAG_CHECK * ((1 - sel_invalid_tag_err) * (1 - batch_tag_inv) + batch_tag_inv) - sel_invalid_tag_err = 0;

    // Consolidated error flag
    pol commit err;
    err = 1 - (1 - sel_state_out_of_range_err) * (1 - sel_input_out_of_range_err) * (1 - sel_dst_out_of_range_err)
        * (1 - sel_invalid_tag_err);
