// General/shared precomputed columns.
namespace precomputed;

// From 0 and incrementing up to the size of the circuit (2^21).
pol constant clk;

// A column of zeroes
pol constant zero;

// 1 only at row 0.
pol constant first_row;

// AND/OR/XOR of all 8-bit numbers.
// The tables are "stacked". First AND, then OR, then XOR.
// Note: think if we can avoid the selector.
pol constant sel_bitwise; // 1 in the first 3 * 256 rows.
pol constant bitwise_op_id; // identifies if operation is AND/OR/XOR.
pol constant bitwise_input_a; // column of all 8-bit numbers.
pol constant bitwise_input_b; // column of all 8-bit numbers.
pol constant bitwise_output; // output = a AND/OR/XOR b.

// Boolean selectors for 8-bit and 16-bit range checks.
// We reuse clk for the actual values.
pol constant sel_range_8;  // 1 in the first 2^8 rows [0, 2^8)
pol constant sel_range_16; // 1 in the first 2^16 rows [0, 2^16)

// All the powers of 2 from 0 to 255
// For a given row, the exponent is clk (value = 2^clk)
// Populated for the first 256 rows [0, 255]
pol constant power_of_2;

// SHA256 Round Params Lookup
pol constant sel_sha256_compression;
pol constant sha256_compression_round_constant;

// A mapping between a MemoryTag value and their respective parameters:
// {FF:0, U1: 1, U8: 1, U16: 2, ... , U128: 16}
//      | tag | byte_length | max_bits |  max_value  |
// FF   |  0  |      32     |    0     |   p - 1     |
// u1   |  1  |      1      |    1     |   2^1 - 1   |
// u8   |  2  |      1      |    8     |   2^8 - 1   |
// u16  |  3  |      2      |    16    |   2^16 - 1  |
// u32  |  4  |      4      |    32    |   2^32 - 1  |
// u64  |  5  |      8      |    64    |   2^64 - 1  |
// u128 |  6  |      16     |    128   |   2^128 - 1 |
// The enum values of MemoryTag are present in column clk.
pol constant sel_tag_parameters; // Toggle row with clk == FF,U1,U8,U16,...,U128
pol constant tag_byte_length;
pol constant tag_max_bits;
pol constant tag_max_value;

// Remark: A potential optimization may consist in using sel_bitwise instead of sel_integral_mem_tag.
//         However, it would extend this lookup table with pairs such as (0,0), (7,0), (8,0) which is
//         not without any danger.

// Toggled at every row where clk is a byte and outside of memory tag
pol constant sel_mem_tag_out_of_range;

// WIRE INSTRUCTION SPEC table
// The WIRE_INSTRUCTION_SPEC maps a WireOpCode to different values related to the instruction format such as:
// - array of decomposition selectors: sel_op_dc_XX
// - corresponding execution opcode: exec_opcode
// - instruction size (in bytes): instr_size
// - Selector on whether the instruction has a tag: sel_has_tag
// - Selector on whether operand op2 is a tag: sel_tag_is_op2

// Selectors for operands decomposition into bytes (required by instr_fetching.pil)
// This table is populated by a map generated by a cpp test defined in op_decomposition.test.cpp.
pol constant sel_op_dc_0;
pol constant sel_op_dc_1;
pol constant sel_op_dc_2;
pol constant sel_op_dc_3;
pol constant sel_op_dc_4;
pol constant sel_op_dc_5;
pol constant sel_op_dc_6;
pol constant sel_op_dc_7;
pol constant sel_op_dc_8;
pol constant sel_op_dc_9;
pol constant sel_op_dc_10;
pol constant sel_op_dc_11;
pol constant sel_op_dc_12;
pol constant sel_op_dc_13;
pol constant sel_op_dc_14;
pol constant sel_op_dc_15;
pol constant sel_op_dc_16;
pol constant sel_op_dc_17;

pol constant exec_opcode;
pol constant instr_size; // Instruction size in bytes
pol constant sel_has_tag; // With current instruction specs, tag can appear at op2 (SET_XXX) or op3 (CAST_8, CAST_16)
pol constant sel_tag_is_op2; // (sel_tag_is_op2 == 0 && sel_has_tag == 1) ==> op3 is a tag

// Toggled at rows whose clk interpreted as a byte does not correspond to a valid wire opcode
// Toggled only up to clk = 255. (within range specified by sel_range_8)
pol constant opcode_out_of_range;

// Used for getting the number of safe limbs for a given radix.
// The selector is on for 1 < clk <= 256
pol constant sel_to_radix_safe_limbs;
// Number of safe limbs for a given radix=clk.
pol constant to_radix_safe_limbs;

// Radix decompositions of P.
pol constant sel_p_decomposition;
pol constant p_decomposition_radix;
pol constant p_decomposition_limb_index;
pol constant p_decomposition_limb;

// EXECUTION INSTRUCTION SPEC table
// Maps an execution opcode value to useful information used during execution
// exec_opcode is clk
pol constant sel_exec_spec;
// Gas Costs
pol constant exec_opcode_opcode_gas;
pol constant exec_opcode_base_da_gas;
pol constant exec_opcode_dynamic_l2_gas;
pol constant exec_opcode_dynamic_da_gas;
// Registers: Memory Access
pol constant sel_mem_op_reg[7];
pol constant rw_reg[7];
// Registers: Tag Check
pol constant sel_tag_check_reg[7];
pol constant expected_tag_reg[7];
// Decomposed Subtrace/Gadget Selector
pol constant dyn_gas_id;
pol constant subtrace_id;
pol constant subtrace_operation_id;
// Whether an operand is an address
// NOTE: this could be encoded in bits in 1 column and reconstructed.
pol constant sel_op_is_address[7];

// Addressing gas
// Indirect is clk
pol constant sel_addressing_gas;
pol constant addressing_gas;

// Phase Table for Tx Trace
pol constant sel_phase; // Selector for phase table
pol constant phase_value; // { NR_PRIVATE_INSERTS, SETUP, R_PRIVATE_INSERTS, APPLOGIC, TEARDOWN}
pol constant is_public_call_request_phase;
pol constant is_l2_l1_message_phase;
pol constant is_revertible;
pol constant next_phase_on_revert;
pol constant read_public_input_offset;
pol constant read_public_input_length_offset;
pol constant write_public_input_offset;
pol constant sel_non_revertible_append_note_hash;
pol constant sel_non_revertible_append_nullifier;
pol constant sel_revertible_append_note_hash;
pol constant sel_revertible_append_nullifier;
pol constant sel_collect_fee;

// Keccak round constants
// Store the 24 round constants with indices ranging from 1 to 24.
// Warning: Not a standard 0-based array!
pol constant sel_keccak;
pol constant keccak_round_constant;

// GETENVVAR opcode precomputed columns
// see opcodes/get_env_var.pil for ascii table
pol constant invalid_envvar_enum;
pol constant sel_envvar_pi_lookup_col0;
pol constant sel_envvar_pi_lookup_col1;
pol constant envvar_pi_row_idx;
pol constant is_address;
pol constant is_sender;
pol constant is_transactionfee;
pol constant is_feeperl2gas;
pol constant is_isstaticcall;
pol constant is_l2gasleft;
pol constant is_dagasleft;
pol constant out_tag;

// GETCONTRACTINSTANCE opcode precomputed columns
// see opcodes/get_contract_instance.pil for ascii table
pol constant is_valid_member_enum;
pol constant is_deployer;
pol constant is_class_id;
pol constant is_init_hash;
