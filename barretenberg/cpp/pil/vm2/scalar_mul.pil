include "ecc.pil";

// Performs scalar_mul with Fr scalars doing the following algorithm:
//
// let bits = bit_representation(s)  # the vector of bits (from LSB to MSB) representing s
// let res = O # point at infinity
// let temp = P  # track doubled P val
// for bit in bits:
//     if bit == 1:
//         res = res + temp  # point add
//     temp = temp + temp  # double
// return res
//
// Needs to radix, update when implemented

namespace scalar_mul;

    #[skippable_if]
    sel = 0;

    pol commit sel;
    sel * (1 - sel) = 0;

    // These are the inputs to perform the scalar mul, a point and a scalar
    pol commit scalar;
    pol commit point_x;
    pol commit point_y;
    pol commit point_inf;
    point_inf * (1 - point_inf) = 0; // Validate the input


    // LIFECYCLE

    // We do reverse aggregation, the start row contains the output
    // so is the selector with which other subtraces will reference
    pol commit start;
    start * (1 - start) = 0;

    pol commit end;
    end * (1 - end) = 0;
    // end and first_row are NAND
    end * precomputed.first_row = 0;
    pol LATCH_CONDITION = end + precomputed.first_row;

    #[START_AFTER_LATCH]
    sel' * (start' - LATCH_CONDITION) = 0;

    // Next selector must be current selector unless LATCH_CONDITION
    (sel' - sel)*(1 - LATCH_CONDITION) = 0;


    // BIT DECOMPOSITION

    pol commit bit;
    // Should we have an explicit end boolean or callers should look up rows where bit_idx is 253?
    pol commit bit_idx;

    // We start with bit index 253
    start * (bit_idx - 253) = 0;
    // End can only be 1 when bit_idx is 0. This should be correct because end is bool and bit_idx is being constrained to be 0..254
    end * bit_idx = 0;

    // Next bit index has to be 1 less except on LATCH_CONDITION
    LATCH_CONDITION*(bit_idx - (bit_idx' + 1)) = 0;

    pol BIT_RADIX = 2;

    // #[TO_RADIX]
    // sel { scalar, bit, bit_idx, BIT_RADIX }
    // in
    // to_radix.sel
    //     { to_radix.input, to_radix.limb, to_radix.limb_index, to_radix.radix };


    // TEMP COMPUTATION

    // Temp must be double of the next row. We need to call ecadd with next row as p,q
    // Except in the end row, where we say temp = point
    pol commit temp_x;
    pol commit temp_y;
    pol commit temp_inf;


    // if end, temp = point. Else, temp is unconstrained
    // Should I merge these into 1 expression?
    end * (temp_x - point_x) = 0;
    end * (temp_y - point_y) = 0;
    end * (temp_inf - point_inf) = 0;

    pol commit double_pred;
    // double_pred = SEL & !LATCH_CONDITION
    double_pred - sel*(1-LATCH_CONDITION) = 0;

    #[DOUBLE]
    double_pred { temp_x, temp_y, temp_inf, temp_x', temp_y', temp_inf', temp_x', temp_y', temp_inf' }
    in
    ecc.sel
        { ecc.r_x, ecc.r_y, ecc.r_is_inf, ecc.p_x, ecc.p_y, ecc.p_is_inf, ecc.q_x, ecc.q_y, ecc.q_is_inf };


    // RES COMPUTATION

    // res should be the next row if bit is zero, or next row + temp if bit is 1
    // Except in the end row, where res can be either infinity or the point

    // If end is true, conditional assign point or 0,0,1 (infinity)
    end*(point_x*bit - res_x) = 0;
    end*(point_y*bit - res_y) = 0;
    end*((point_inf - 1)*bit + 1 - res_inf) = 0;

    // If double_pred, res = bit? res + temp : res
    pol commit should_add;
    should_add - double_pred*bit = 0;

    (1 - should_add)(res_x - res_x') = 0;
    (1 - should_add)(res_y - res_y') = 0;
    (1 - should_add)(res_inf - res_inf') = 0;

    #[ADD]
    should_add { res_x, res_y, res_inf, res_x', res_y', res_inf', temp_x, temp_y, temp_inf }
    in
    ecc.sel
        { ecc.r_x, ecc.r_y, ecc.r_is_inf, ecc.p_x, ecc.p_y, ecc.p_is_inf, ecc.q_x, ecc.q_y, ecc.q_is_inf };


