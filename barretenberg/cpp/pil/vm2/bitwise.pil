include "precomputed.pil";

/**
 * The bitwise trace performs AND/OR/XOR operations on non-FF types. It does
 * this by decomposing the inputs into 8-bit chunks and looking up each the result
 * for each chunk in the precomputed bitwise table. The result is the re-composition
 * of these result chunks.
 * The precomputed bitwise table contains the results of all combinations of
 * bitwise operations for 8-bit values. These values are stored as a tuple of
 * <id, input_a, input_b, output_c>  where id is either AND/OR/XOR.
 * ERROR HANDLING:
 * The possible errors for this subtrace relate to the AVM memory tag:
 * 1) The inputs do not have the same tag.
 * 2) Either of the inputs tags is of type FF (i.e. bitwise being done over a field)
 * In either case, we do not attempt to perform the bitwise operation.
 */

namespace bitwise;

// Trace example for a AND b == c of type u32
// a = 0x52488425
// b = 0xC684486C (We omit acc_ib and ic_byte as it follows the very same behavior as for a and c)
// c = 0x42000024
//
//   ctr   sel   start   last       acc_ia     acc_ic     ia_byte     ic_byte
//    4     1      1      0       0x52488425  0x42000024    0x25        0x24
//    3     1      0      0       0x524884    0x420000      0x84        0x00
//    2     1      0      0       0x5248      0x4200        0x48        0x00
//    1     1      0      1       0x52        0x42          0x52        0x42

// Selector for Bitwise Operation
pol commit sel;
sel * (1 - sel) = 0;

// No relations will be checked if this identity is satisfied.
#[skippable_if]
sel + last = 0; // They are both boolean so it corresponds to sel == 0 AND last == 0.

pol commit start; // Identifies when we want to capture the output to the main trace.
// Must be constrained as a boolean as any selector used in a lookup/permutation.
start * (1 - start) = 0;

// To support dynamically sized memory operands we use a counter against a lookup
// This decrementing counter goes from [TAG_LEN, 0] where TAG_LEN is the number of bytes in the
// corresponding integer. i.e. TAG_LEN is between 1 (U1/U8) and 16 (U128).
// Consistency can be achieved with a lookup table between the tag and precomputed.tag_byte_length
pol commit ctr;

// The error flags for this subtrace
pol commit sel_tag_ff_err;
sel_tag_ff_err * (1 - sel_tag_ff_err) = 0;
pol commit sel_tag_mismatch_err;
sel_tag_mismatch_err * (1 - sel_tag_mismatch_err) = 0;

// Consolidated error flag
pol commit err;
err = 1 - (1 - sel_tag_mismatch_err) * (1 - sel_tag_ff_err);
// last is a boolean which serves to mark the end of the computation (end of latch)
pol commit last;
last * (1 - last) = 0;
#[LAST_ON_ERROR] // last = 1 if err = 1
err * (last - 1) = 0;

// Aggregated "no error" selector to gate lookups, boolean constrained based on prev relations 
pol commit sel_no_err;
sel_no_err = sel * (1 - err);

/////////////////////////////////
// Tag Checking / Error Handling
/////////////////////////////////
// The checks that need to be performed are: (1) the tags are not FF, and (2) that the input tags are the same.
// We can simplify the FF check by just checking that tag_a != FF and checking
// that tag_a == tag_b. It can be observed that we don't need to also check that tag_b != FF
// since it follows from the the tag check of (2)

// These are the tags {1,2,3,4,5,6} of the inputs (restricted to not be a field)
pol commit tag_a;
pol commit tag_b;
pol commit tag_c; // This is the tag of the result
// Sufficient to set tag_c == tag_a because we check that tag_a == tag_b
#[RES_TAG_SHOULD_MATCH_INPUT]
sel * (tag_c - tag_a) = 0;

// Check that the input tags are not FF
// Note: It is sufficient to check that just tag_a != 0 (i.e is not FF),
// since we separately check that tag_a == tag_b
pol commit tag_a_inv;
// If tag_a == 0, then sel_tag_ff_err = 1
#[INPUT_TAGS_CANNOT_BE_FF]
sel * (tag_a * (sel_tag_ff_err * (1 - tag_a_inv) + tag_a_inv) - 1 + sel_tag_ff_err) = 0;

// Check that the input tags match each other
pol TAG_AB_DIFF = tag_a - tag_b;
pol commit tag_ab_diff_inv;
// If TAG_AB_DIFF != 0, then sel_tag_mismatch_err = 1
#[INPUT_TAGS_SHOULD_MATCH]
sel * (TAG_AB_DIFF * ((1 - sel_tag_mismatch_err) * (1 - tag_ab_diff_inv) + tag_ab_diff_inv) - sel_tag_mismatch_err) = 0;

/////////////////////////////////
// Begin Executing Bitwise ops
/////////////////////////////////
// Byte recomposition column, the value in these columns are part of the equivalence
// check to main wherever Start is set to 1.
pol commit acc_ia;
pol commit acc_ib;
pol commit acc_ic;

// Little Endian bitwise decomposition of accumulators (which are processed top-down),
// constrained to be U8 given by the lookup to the byte_lookup
pol commit ia_byte;
pol commit ib_byte;
pol commit ic_byte;

// Selectors for bitwise operations, correctness checked by permutation to the main trace.
// Op Id is restricted to be the same during the same computation (i.e. between Starts)
pol commit op_id;

#[BITW_OP_ID_REL]
(op_id' - op_id) * (1 - last) = 0;

#[BITW_CTR_DECREMENT]
// Note: sel factor is required for an empty row to satisfy this relation
sel * (ctr' - ctr + 1) * (1 - last) = 0;

// sel is set to 1 if and only if ctr != 0. (and sel == 0 <==> ctr == 0)
// sel is a boolean that is set to 1 if ctr != 0.
// This is checked by following relation and utilising inverse of ctr: ctr_inv
pol commit ctr_inv;

#[BITW_SEL_CTR_NON_ZERO]
ctr * ((1 - sel) * (1 - ctr_inv) + ctr_inv) - sel = 0;

// Similarly, we prove that last == 1 <==> ctr - 1 == 0 <==> ctr == 1
// Note: sel factor is required for an empty row to satisfy this relation
pol commit ctr_min_one_inv;
#[BITW_LAST_FOR_CTR_ONE]
sel * (1 - err) * ((ctr - 1) * (last * (1 - ctr_min_one_inv) + ctr_min_one_inv) + last - 1) = 0;

// Forces accumulator to initialize with ia_byte, ib_byte, and ic_byte
#[BITW_INIT_A]
(1 - err) * last * (acc_ia - ia_byte) = 0;
#[BITW_INIT_B]
(1 - err) * last * (acc_ib - ib_byte) = 0;
#[BITW_INIT_C]
(1 - err) * last * (acc_ic - ic_byte) = 0;

#[BITW_ACC_REL_A]
(acc_ia - ia_byte - 256 * acc_ia') * (1 - last) = 0;
#[BITW_ACC_REL_B]
(acc_ib - ib_byte - 256 * acc_ib') * (1 - last) = 0;
#[BITW_ACC_REL_C]
(acc_ic - ic_byte - 256 * acc_ic') * (1 - last) = 0;

// Operations over FF are not supported, it is assumed this exclusion is handled
// outside of this subtrace. The below lookup will pass with FF, so we are not protected here:
#[INTEGRAL_TAG_LENGTH]
start { tag_a, ctr }
in
precomputed.sel_tag_parameters { precomputed.clk, precomputed.tag_byte_length };

#[BYTE_OPERATIONS]
sel_no_err { op_id, ia_byte, ib_byte, ic_byte }
in
precomputed.sel_bitwise { precomputed.bitwise_op_id, precomputed.bitwise_input_a, precomputed.bitwise_input_b, precomputed.bitwise_output };

// TODOs: See two following paragraphs

// ################################################
// Alternative implementation as potential speed-up
// ################################################
//
// In vm1, we had an approach which requires one extra row per bitwise operation but
// had 2 less columns and #[BITW_CTR_DECREMENT] would have degree 0 and the degree 4 relation
// #[BITW_LAST_FOR_CTR_ONE] is not present.
// The main difference is that we decrement ctr down to zero (extra line) and impose an initialization
// condition for acc_ia, acc_ib, acc_ic to be zero on this last row.
// Column last can be removed and sel is used instead of (1 - last).
// Note that sel == 0 on last row of each operation, but the skippable condition
// remains valid as the last row will be empty with our witness generator.
//
// It might be worth to measure the difference among both approaches.


// ################################################
// Recycling of bitwise operations of prefixes
// ################################################
//
// Observation: If two inputs are prefixes of other inputs which are already present in the
//              trace, then we could retrieve the result as a truncated trace of the larger.
//
// For instance, re-using example at the top, we consider the U16 and computation over
// a = 0x5248
// b = 0xC684
// c = 0x4200
// Then, we should activate the start selector where ctr == 2, and the following rows
// represent a valid trace for this computation.
// It is not clear if this would lead to some speed-up in practice.
