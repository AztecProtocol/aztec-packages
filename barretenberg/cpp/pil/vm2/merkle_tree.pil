include "./poseidon2_full.pil";

// Handles membership and insertion into a merkle tree
namespace merkle_tree(256);
    pol commit sel;
    #[MERKLE_SEL_IS_BOOL]
    sel * (1 - sel) = 0;
    // No relations will be checked if this identity is satisfied.
    #[skippable_if]
    sel = 0;

    // Gotta stop using clk for things that are more like foreign keys
    pol commit clk;
    // Inputs to the gadget
    pol commit leaf_value;
    pol commit leaf_index;
    pol commit path_len;
    pol commit expected_tree_root;
    // These are all hinted
    pol commit sibling_value;

    pol commit latch;
    #[LATCH_IS_BOOL]
    latch * (1 - latch) = 0;

    // If we are not done, the path_len decrements by 1
    #[PATH_LEN_DECREMENTS]
    sel * (1 - latch) * (path_len' - path_len + 1) = 0;

    pol commit path_len_inv;
    // latch == 1 when the path_len == 0
    #[LATCH_HIGH_WHEN_PATH_EMPTY]
    sel * (path_len * (latch * (1 - path_len_inv) + path_len_inv) - 1 + latch) = 0;

    // TODO: Constrain that this is indeed even.
    // Note this might be covered by the halving of the leaf index if the original index is constrained.
    pol commit leaf_index_is_even;
    #[LEAF_INDEX_IS_BOOL]
    leaf_index_is_even * (1 - leaf_index_is_even) = 0;
    pol LEAF_INDEX_IS_ODD = (1 - leaf_index_is_even);
    // If we are not done, the next leaf index is half the current leaf index;
    // We don't need to worry about underflowing the field since (leaf_index - LEAF_INDEX_IS_ODD)
    // will be even (over the integers) and as the field is not of characteristic 2, leaf_index' == leaf_index / 2 over the integers
    #[NEXT_LEAF_INDEX_IS_HALVED]
    sel * (1 - latch) * (leaf_index' * 2 + LEAF_INDEX_IS_ODD - leaf_index) = 0;

    // These are what are sent to poseidon2
    // These arrange the leaf_value and sibling_value in the correct order
    pol commit left_hash;
    pol commit right_hash;
    // This is accomplished by using leaf_index_is_even to toggle the (left_hash - right_hash) term.
    // If leaf index is even, left_hash (to send to poseidon2) is leaf_value and right_hash is sibling_value.
    // And vice-versa.
    #[ASSIGN_LEAF_VALUE_LEFT_OR_RIGHT]
    sel * leaf_index_is_even * (left_hash - right_hash) + right_hash - leaf_value = 0;
    #[ASSIGN_SIBLING_VALUE_LEFT_OR_RIGHT]
    sel * leaf_index_is_even * (right_hash - left_hash) + left_hash - sibling_value = 0;
    // NOTE: don't think these can be safely combined

    pol commit output_hash;
    // If we are not done, this row's output_hash is the next row's leaf_value input
    #[OUTPUT_HASH_IS_NEXT_ROWS_LEAF_VALUE]
    sel * (1 - latch) * (leaf_value' - output_hash) = 0;

    pol LAST_COMPUTE = sel * latch;
    // LAST_COMPUTE will be used in permutations to other traces

    // Permutation to the full poseidon2 gadget
    #[PERM_MERKLE_POSEIDON2]
    sel { clk, left_hash, right_hash, output_hash } is
    poseidon2_full.sel {poseidon2_full.clk, poseidon2_full.input_0, poseidon2_full.input_1, poseidon2_full.output };
