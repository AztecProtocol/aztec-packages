include "avm_mini.pil";

namespace aluChip(256);

    // ========= Table ALU-TR =================================================

    // References to main trace table of sub-operations, clk, intermediate
    // registers, operation selectors.
    // TODO: Think on optimizations to decrease the number of such "copied" columns
    pol commit alu_clk;
    pol commit alu_ia; // Intermediate registers
    pol commit alu_ib;
    pol commit alu_ic;
    pol commit alu_op_add; // Operation selectors
    pol commit alu_op_sub;
    pol commit alu_op_mul;
    pol commit alu_op_div;

    // Flattened boolean instruction tags
    pol commit alu_u8;
    pol commit alu_u16;
    pol commit alu_u32;
    pol commit alu_u64;
    pol commit alu_u128;

    // 8-bit slice registers
    pol commit alu_s1;
    pol commit alu_s2;
    pol commit alu_s3;
    pol commit alu_s4;
    pol commit alu_s5;
    pol commit alu_s6;
    pol commit alu_s7;
    pol commit alu_s8;
    pol commit alu_s9;
    pol commit alu_s10;
    pol commit alu_s11;
    pol commit alu_s12;
    pol commit alu_s13;
    pol commit alu_s14;
    pol commit alu_s15;
    pol commit alu_s16;

    // Carry flag
    pol commit alu_cf;

    // ========= Type Constraints =============================================
    // TODO: Range constraints for slice registers
    //       intermediate registers ia and ib (inputs) depending on flag
    //       Carry flag: We will have to constraint to ensure that the 
    //                   arithmetic expressions are not overflowing finite field size

    // Boolean flattened instructions tags
    alu_u8 * (1 - alu_u8) = 0;
    alu_u16 * (1 - alu_u16) = 0;
    alu_u32 * (1 - alu_u32) = 0;
    alu_u64 * (1 - alu_u64) = 0;
    alu_u128 * (1 - alu_u128) = 0;

    // Operation selectors are copied from main table and do not need to be constrained here.

    // ========= Inter-table Constraints ======================================
    // TODO: Equivalence between intermediate registers, clk, type flag, operation
    //       An ALU chiplet flag will be introduced in main trace to select relevant rows.



    // ============= Helper polynomial terms ============================
    // These are intermediate polynomial terms which are not commited but
    // serves to express commited polynomials in a more concise way.

    // 8-bit slice partial sums
    pol sum_8 =            alu_s1;
    pol sum_16 =  sum_8  + 2**8 * alu_s2;
    pol sum_32 =  sum_16 + 2**16 * alu_s3 + 2**24 * alu_s4;
    pol sum_64 =  sum_32 + 2**32 * alu_s5 + 2**40 * alu_s6 + 2**48 * alu_s7 + 2**56 * alu_s8;
    pol sum_96 =  sum_64 + 2**64 * alu_s9 + 2**72 * alu_s10 + 2**80 * alu_s11 + 2**88 * alu_s12;
    pol sum_128 = sum_96 + 2**96 * alu_s13 + 2**104 * alu_s14 + 2**112 * alu_s15 + 2**120 * alu_s16;


    // ========= ADDITION Operation Constraints ===============================

    // u8 addition
    alu_u8 * alu_op_add * (sum_8 + 2**8 * alu_cf - alu_ia - alu_ib) = 0;
    alu_u8 * alu_op_add * (sum_8 - alu_ic) = 0;

    // u16 addition
    alu_u16 * alu_op_add * (sum_16 + 2**16 * alu_cf - alu_ia - alu_ib) = 0;
    alu_u16 * alu_op_add * (sum_16 - alu_ic) = 0;

    // u32 addition
    alu_u32 * alu_op_add * (sum_32 + 2**32 * alu_cf - alu_ia - alu_ib) = 0;
    alu_u32 * alu_op_add * (sum_32 - alu_ic) = 0;

    // u64 addition
    alu_u64 * alu_op_add * (sum_64 + 2**64 * alu_cf - alu_ia - alu_ib) = 0;
    alu_u64 * alu_op_add * (sum_64 - alu_ic) = 0;

    // u128 addition
    alu_u128 * alu_op_add * (sum_128 + 2**128 * alu_cf - alu_ia - alu_ib) = 0;
    alu_u128 * alu_op_add * (sum_128 - alu_ic) = 0;

    // ========= SUBTRACTION Operation Constraints ===============================

    // a - b = c <==> c + b = a (mod 2^k)
    // Same constraints as for addition but we swap alu_ia with alu_ic

    // u8 subtraction
    alu_u8 * alu_op_sub * (sum_8 + 2**8 * alu_cf - alu_ic - alu_ib) = 0;
    alu_u8 * alu_op_sub * (sum_8 - alu_ia) = 0;

    // u16 subtraction
    alu_u16 * alu_op_sub * (sum_16 + 2**16 * alu_cf - alu_ic - alu_ib) = 0;
    alu_u16 * alu_op_sub * (sum_16 - alu_ia) = 0;

    // u32 subtraction
    alu_u32 * alu_op_sub * (sum_32 + 2**32 * alu_cf - alu_ic - alu_ib) = 0;
    alu_u32 * alu_op_sub * (sum_32 - alu_ia) = 0;

    // u64 subtraction
    alu_u64 * alu_op_sub * (sum_64 + 2**64 * alu_cf - alu_ic - alu_ib) = 0;
    alu_u64 * alu_op_sub * (sum_64 - alu_ia) = 0;

    // u128 subtraction
    alu_u128 * alu_op_sub * (sum_128 + 2**128 * alu_cf - alu_ic - alu_ib) = 0;
    alu_u128 * alu_op_sub * (sum_128 - alu_ia) = 0;