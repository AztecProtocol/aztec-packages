{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"7377815439820978508","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":112,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":456,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"dZDRCoQgEEX/ZZ59KENa9leWJcymEETFdGEJ/32nyLYeenGcuZ4rcxcYsE9Tp+3oZni+FuiDNkZPnXFKRu0sTZfMoLRdDIg0gpNOlJcBbYSnTcYw+EiTtkezl3arUQZSKwZoB6pkOGqD6y2zP13do7wRO9y09YGLK1/f803b8mLwEOJw4DznN3VS6XDZGSoSGdR05tU2aNkb3NMYk1WncOLXF6XE54NTOKSAq+mm0Tc/","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n#[deprecated(\"This functions is deprecated in favour of external verification libraries. To verify Barretenberg proofs, it's recommended to use the library https://github.com/AztecProtocol/aztec-packages/tree/next/barretenberg/noir/bb_proof_verification\")]\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"global HONK_VK_SIZE: u32 = 112;\nglobal HONK_PROOF_SIZE: u32 = 456;\nglobal HONK_IDENTIFIER: u32 = 1;\n\nfn main(\n    verification_key: [Field; HONK_VK_SIZE],\n    proof: [Field; HONK_PROOF_SIZE],\n    public_inputs: pub [Field; 1],\n) {\n    std::verify_proof_with_type(\n        verification_key,\n        proof,\n        public_inputs,\n        0x0,\n        HONK_IDENTIFIER,\n    );\n}\n","path":"/Users/zpedro/Documents/aztec-packages/barretenberg/docs/examples/fixtures/recursive/src/main.nr"}},"names":["main"],"brillig_names":[]}