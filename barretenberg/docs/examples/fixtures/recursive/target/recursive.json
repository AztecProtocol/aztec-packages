{"noir_version":"1.0.0-beta.7+1b0876fb24ff03949aa437c7d0187862c0c67c2d","hash":"2497663846293746635","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":112,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":507,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"dZDRCoMwDEX/Jc99sIpz+CtjSNUohdKW2A6G9N8XRZ0++NI0uT235M7QYxvHRtvBTVC/ZmhJG6PHxrhOBe0sT+ckYG+bQIg8gpPOlFeENkBtozECPsrE9dHklV1rUMRqJgBtz5UNB21wuSXxp7N7NC/KDS4qeeDllZf3vHwcBrKSz8Mhz1N6c6c6TZedIWNRgOQzLbakVWtwS2OItjuFE75+V/b4PLkO+0i4mK4af/MD","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"global HONK_VK_SIZE: u32 = 112;\nglobal HONK_PROOF_SIZE: u32 = 507;\nglobal HONK_IDENTIFIER: u32 = 1;\n\nfn main(\n    verification_key: [Field; HONK_VK_SIZE],\n    proof: [Field; HONK_PROOF_SIZE],\n    public_inputs: pub [Field; 1],\n) {\n    std::verify_proof_with_type(\n        verification_key,\n        proof,\n        public_inputs,\n        0x0,\n        HONK_IDENTIFIER,\n    );\n}","path":"/Users/zpedro/Documents/noir-in-an-afternoon-extended/recursive/src/main.nr"}},"names":["main"],"brillig_names":[]}