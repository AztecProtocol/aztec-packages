/**
 * Unified schema compiler with integrated strategies
 */

import { Buffer } from 'buffer';

// Core type definitions
export type Schema =
  | string
  | ObjectSchema
  | ['tuple', Schema[]]
  | ['map', [Schema, Schema]]
  | ['optional', [Schema]]
  | ['vector', [Schema]]
  | ['variant', Schema[]]
  | ['named_union', Array<[string, Schema]>]
  | ['shared_ptr', [Schema]]
  | ['array', [Schema, number]]
  | ['alias', [string, string]];

export type ObjectSchema = { [key: string]: Schema };

export interface TypeInfo {
  typeName: string;
  msgpackTypeName?: string;
  declaration?: string;
  toMethod?: string;
  fromMethod?: string;
}

export interface FunctionMetadata {
  name: string;
  commandType: string;
  responseType: string;
}

// Strategy interfaces
export interface ImportStrategy {
  getImports(): string[];
  getTypePrefix(): string;
}

export interface MethodGeneratorStrategy {
  generateMethod(metadata: FunctionMetadata): string;
  getWrapperClass(methods: FunctionMetadata[]): string;
}

// Helper functions
function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.substring(1);
}

function camelCase(s: string): string {
  return s
    .split('_')
    .map((part, index) => (index === 0 ? part.charAt(0).toLowerCase() + part.substring(1) : capitalize(part)))
    .join('');
}

function pascalCase(s: string): string {
  return s.split('_').map(capitalize).join('');
}

export class SchemaCompiler {
  private typeCache = new Map<string, TypeInfo>();
  private functionMetadata: FunctionMetadata[] = [];
  private usedTypes = new Set<string>();
  
  constructor(
    private importStrategy: ImportStrategy,
    private methodGenerator?: MethodGeneratorStrategy,
  ) {}

  /**
   * Process API schema and extract function metadata
   */
  processApiSchema(commandsSchema: Schema, responsesSchema: Schema): void {
    // Process types
    this.processSchema(commandsSchema);
    this.processSchema(responsesSchema);

    // Extract function metadata from named unions
    if (!Array.isArray(commandsSchema) || commandsSchema[0] !== 'named_union' ||
        !Array.isArray(responsesSchema) || responsesSchema[0] !== 'named_union') {
      throw new Error('Expected named_union schema format');
    }

    const commands = commandsSchema[1] as Array<[string, Schema]>;
    const responses = responsesSchema[1] as Array<[string, Schema]>;

    for (let i = 0; i < commands.length; i++) {
      const [commandName] = commands[i];
      const [responseName] = responses[i];
      
      this.functionMetadata.push({
        name: camelCase(commandName),
        commandType: pascalCase(commandName),
        responseType: pascalCase(responseName),
      });
    }
  }

  /**
   * Process a schema and populate type cache
   */
  processSchema(schema: Schema): TypeInfo {
    const key = this.getSchemaKey(schema);
    if (this.typeCache.has(key)) {
      return this.typeCache.get(key)!;
    }

    const typeInfo = this.generateTypeInfo(schema);
    this.typeCache.set(key, typeInfo);
    return typeInfo;
  }

  /**
   * Generate the complete output
   */
  compile(): string {
    const parts: string[] = [
      '// AUTOGENERATED FILE - DO NOT EDIT',
      '',
    ];

    // Add type declarations and conversion functions
    const sortedTypes = Array.from(this.typeCache.values())
      .filter(t => t.declaration)
      .sort((a, b) => a.typeName.localeCompare(b.typeName));
    
    // For non-api_types files, generate imports
    const needsApiTypesImport = this.importStrategy.getTypePrefix() === 'apiTypes.';
    
    if (needsApiTypesImport) {
      // Add base imports first
      parts.push(...this.importStrategy.getImports());
      
      // Collect all types and functions we need to import
      const typesToImport = new Set<string>();
      const functionsToImport = new Set<string>();
      
      // Add types and functions used in method signatures
      for (const metadata of this.functionMetadata) {
        typesToImport.add(metadata.commandType);
        typesToImport.add(metadata.responseType);
        functionsToImport.add(`from${metadata.commandType}`);
        functionsToImport.add(`to${metadata.responseType}`);
      }
      
      // Add any other tracked types
      for (const type of this.usedTypes) {
        typesToImport.add(type);
      }
      
      // For API compilers, we don't define any types locally, so don't remove any
      
      // Generate the combined import statement
      if (typesToImport.size > 0 || functionsToImport.size > 0) {
        // Sort all imports together alphabetically
        const allImports = [
          ...Array.from(typesToImport),
          ...Array.from(functionsToImport)
        ].sort();
        
        parts.push(`import { ${allImports.join(', ')} } from './api_types.js';`);
      }
    } else {
      // For api_types.ts, just add the base imports
      parts.push(...this.importStrategy.getImports());
    }
    
    parts.push('');

    // For API compilers, we don't generate declarations - only imports
    const isApiCompiler = needsApiTypesImport;
    
    // Group declarations
    const typeAliases = isApiCompiler ? [] : sortedTypes.filter(t => 
      t.declaration?.startsWith('export type') && !t.declaration?.includes('interface')
    );
    const publicInterfaces = isApiCompiler ? [] : sortedTypes.filter(t => 
      t.declaration?.includes('export interface')
    );
    const privateInterfaces = isApiCompiler ? [] : sortedTypes.filter(t => 
      t.declaration?.includes('interface Msgpack')
    );

    // Add type aliases if needed
    if (typeAliases.length > 0) {
      parts.push('// Type aliases');
      for (const type of typeAliases) {
        parts.push(type.declaration!);
      }
      parts.push('');
    }

    // Add tuple helper if needed
    if (this.needsTupleHelper()) {
      parts.push(
        '// Tuple type for fixed-size arrays',
        'type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;',
        'type _TupleOf<T, N extends number, R extends unknown[]> = R[\'length\'] extends N ? R : _TupleOf<T, N, [T, ...R]>;',
        '',
        '// Helper functions',
        'function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {',
        '  return tuple.map(fn) as Tuple<S, N>;',
        '}',
        ''
      );
    }

    // Add public interfaces
    if (publicInterfaces.length > 0) {
      parts.push('// Public interfaces (exported)');
      for (const type of publicInterfaces) {
        parts.push(type.declaration!, '');
      }
    }

    // Add private interfaces
    if (privateInterfaces.length > 0) {
      parts.push('// Private Msgpack interfaces (not exported)');
      for (const type of privateInterfaces) {
        parts.push(type.declaration!, '');
      }
    }

    // Add conversion functions (only for api_types.ts)
    const conversions = isApiCompiler ? [] : sortedTypes.filter(t => t.toMethod || t.fromMethod);
    if (conversions.length > 0) {
      parts.push('// Conversion functions (exported)');
      for (const type of conversions) {
        if (type.toMethod) {
          parts.push('export ' + type.toMethod, '');
        }
        if (type.fromMethod) {
          parts.push('export ' + type.fromMethod, '');
        }
      }
    }


    // Add API class if we have a method generator
    if (this.methodGenerator && this.functionMetadata.length > 0) {
      parts.push(this.methodGenerator.getWrapperClass(this.functionMetadata));
    }

    return parts.join('\n') + '\n';
  }

  private getSchemaKey(schema: Schema): string {
    if (typeof schema === 'string') return schema;
    if (Array.isArray(schema)) return JSON.stringify(schema);
    if (typeof schema === 'object') return (schema as any).__typename || JSON.stringify(schema);
    return String(schema);
  }

  private needsTupleHelper(): boolean {
    return Array.from(this.typeCache.values()).some(t => 
      t.typeName.includes('Tuple<')
    );
  }

  private trackTypeUsage(typeName: string): void {
    // Extract base types from complex types
    const baseTypes = this.extractBaseTypes(typeName);
    
    for (const type of baseTypes) {
      // Skip built-in types
      if (['string', 'number', 'boolean', 'Buffer'].includes(type)) {
        continue;
      }
      
      // Skip types that are defined in the current file
      if (this.typeCache.has(type) || this.typeCache.has(`empty_${type}`)) {
        continue;
      }
      
      // Add to used types
      this.usedTypes.add(type);
    }
  }

  private extractBaseTypes(typeName: string): string[] {
    const types: string[] = [];
    
    // Handle arrays
    const arrayMatch = typeName.match(/^(.+)\[\]$/);
    if (arrayMatch) {
      types.push(...this.extractBaseTypes(arrayMatch[1]));
      return types;
    }
    
    // Handle Tuple
    const tupleMatch = typeName.match(/^Tuple<(.+),\s*\d+>$/);
    if (tupleMatch) {
      types.push(...this.extractBaseTypes(tupleMatch[1]));
      return types;
    }
    
    // Handle Record
    const recordMatch = typeName.match(/^Record<(.+),\s*(.+)>$/);
    if (recordMatch) {
      types.push(...this.extractBaseTypes(recordMatch[1]));
      types.push(...this.extractBaseTypes(recordMatch[2]));
      return types;
    }
    
    // Handle union types
    if (typeName.includes(' | ')) {
      const parts = typeName.split(' | ');
      for (const part of parts) {
        types.push(...this.extractBaseTypes(part.trim()));
      }
      return types;
    }
    
    // Base case - simple type
    types.push(typeName);
    return types;
  }

  private generateTypeInfo(schema: Schema): TypeInfo {
    if (Array.isArray(schema)) {
      return this.processArraySchema(schema);
    } else if (typeof schema === 'string') {
      return this.processPrimitiveSchema(schema);
    } else if (typeof schema === 'object') {
      return this.processObjectSchema(schema);
    }
    throw new Error(`Unsupported schema type: ${schema}`);
  }

  private processArraySchema(schema: any[]): TypeInfo {
    const [type, ...args] = schema;
    
    switch (type) {
      case 'array': {
        const [subtype, size] = args[0];
        const subtypeInfo = this.processSchema(subtype);
        return {
          typeName: `Tuple<${subtypeInfo.typeName}, ${size}>`,
          msgpackTypeName: `Tuple<${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}, ${size}>`,
        };
      }
      
      case 'variant': {
        const variants = args[0] as Schema[];
        const variantInfos = variants.map(v => this.processSchema(v));
        const typeName = variantInfos.map(v => v.typeName).join(' | ');
        const msgpackUnion = variantInfos.map(v => v.msgpackTypeName || v.typeName).join(' | ');
        return {
          typeName,
          msgpackTypeName: `[number, ${msgpackUnion}]`,
        };
      }
      
      case 'named_union': {
        const namedTypes = args[0] as Array<[string, Schema]>;
        const tupleTypes: string[] = [];
        
        for (const [name, schemaOrName] of namedTypes) {
          let typeInfo: TypeInfo;
          if (typeof schemaOrName === 'string') {
            const typeName = pascalCase(schemaOrName);
            typeInfo = this.getOrCreateEmptyType(typeName);
          } else {
            typeInfo = this.processSchema(schemaOrName);
          }
          // Track usage of the type
          this.trackTypeUsage(typeInfo.typeName);
          tupleTypes.push(`["${name}", ${typeInfo.typeName}]`);
        }
        
        return {
          typeName: tupleTypes.join(' | '),
          msgpackTypeName: tupleTypes.join(' | '),
        };
      }
      
      case 'vector': {
        const [subtype] = args[0];
        if (subtype === 'unsigned char') {
          return { typeName: 'Buffer' };
        }
        const subtypeInfo = this.processSchema(subtype);
        return {
          typeName: `${subtypeInfo.typeName}[]`,
          msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
        };
      }
      
      case 'alias': {
        const [rawTypeName, msgpackName] = args[0];
        const typeName = pascalCase(rawTypeName);
        let targetType: string;
        
        if (msgpackName.startsWith('bin')) {
          targetType = 'Buffer';
        } else if (['int', 'unsigned int', 'unsigned short'].includes(msgpackName)) {
          targetType = 'number';
        } else {
          throw new Error(`Unsupported alias type: ${msgpackName}`);
        }
        
        // Create a proper type alias declaration
        return {
          typeName,
          msgpackTypeName: targetType,
          declaration: `export type ${typeName} = ${targetType};`,
        };
      }
      
      case 'shared_ptr': {
        const [subtype] = args[0];
        return this.processSchema(subtype);
      }
      
      case 'map': {
        const [keyType, valueType] = args[0];
        const keyInfo = this.processSchema(keyType);
        const valueInfo = this.processSchema(valueType);
        return {
          typeName: `Record<${keyInfo.typeName}, ${valueInfo.typeName}>`,
          msgpackTypeName: `Record<${keyInfo.msgpackTypeName || keyInfo.typeName}, ${valueInfo.msgpackTypeName || valueInfo.typeName}>`,
        };
      }
      
      default:
        throw new Error(`Unsupported array schema type: ${type}`);
    }
  }

  private processPrimitiveSchema(schema: string): TypeInfo {
    switch (schema) {
      case 'bool':
        return { typeName: 'boolean' };
      case 'int':
      case 'unsigned int':
      case 'unsigned short':
      case 'unsigned long':
      case 'double':
        return { typeName: 'number' };
      case 'string':
        return { typeName: 'string' };
      case 'bin32':
        return { typeName: 'Buffer' };
      default:
        return { typeName: pascalCase(schema) };
    }
  }

  private processObjectSchema(schema: ObjectSchema): TypeInfo {
    const typeName = pascalCase(schema.__typename as string);
    const msgpackTypeName = 'Msgpack' + typeName;
    
    const declaration = this.generateInterfaces(typeName, schema);
    const toMethod = this.generateToMethod(typeName, schema);
    const fromMethod = this.generateFromMethod(typeName, schema);
    
    return {
      typeName,
      msgpackTypeName,
      declaration,
      toMethod,
      fromMethod,
    };
  }

  private getOrCreateEmptyType(typeName: string): TypeInfo {
    const key = `empty_${typeName}`;
    if (this.typeCache.has(key)) {
      return this.typeCache.get(key)!;
    }
    
    const typeInfo: TypeInfo = {
      typeName,
      msgpackTypeName: 'Msgpack' + typeName,
      declaration: `export interface ${typeName} {}\n\ninterface Msgpack${typeName} {}`,
      toMethod: `function to${typeName}(o: Msgpack${typeName}): ${typeName} {\n  return {};\n}`,
      fromMethod: `function from${typeName}(o: ${typeName}): Msgpack${typeName} {\n  return {};\n}`,
    };
    
    this.typeCache.set(key, typeInfo);
    return typeInfo;
  }

  private generateInterfaces(name: string, schema: ObjectSchema): string {
    const publicInterface = this.generatePublicInterface(name, schema);
    const msgpackInterface = this.generateMsgpackInterface(name, schema);
    return publicInterface + '\n\n' + msgpackInterface;
  }

  private generatePublicInterface(name: string, schema: ObjectSchema): string {
    let result = `export interface ${name} {\n`;
    for (const [key, value] of Object.entries(schema)) {
      if (key === '__typename') continue;
      const typeInfo = this.processSchema(value);
      
      // Track type usage
      this.trackTypeUsage(typeInfo.typeName);
      
      result += `  ${camelCase(key)}: ${typeInfo.typeName};\n`;
    }
    result += '}';
    return result;
  }

  private generateMsgpackInterface(name: string, schema: ObjectSchema): string {
    let result = `interface Msgpack${name} {\n`;
    for (const [key, value] of Object.entries(schema)) {
      if (key === '__typename') continue;
      const typeInfo = this.processSchema(value);
      result += `  ${key}: ${typeInfo.msgpackTypeName || typeInfo.typeName};\n`;
    }
    result += '}';
    return result;
  }

  private generateToMethod(name: string, schema: ObjectSchema): string {
    const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
    
    if (fields.length === 0) {
      return `function to${name}(o: Msgpack${name}): ${name} {\n  return {};\n}`;
    }
    
    const checks = fields.map(([key]) =>
      `  if (o.${key} === undefined) { throw new Error("Expected ${key} in ${name} deserialization"); }`
    ).join('\n');
    
    const conversions = fields.map(([key, value]) => {
      const typeInfo = this.processSchema(value);
      const converter = this.generateConverter(typeInfo, `o.${key}`, 'to');
      return `    ${camelCase(key)}: ${converter},`;
    }).join('\n');
    
    return `function to${name}(o: Msgpack${name}): ${name} {
${checks};
  return {
${conversions}
  };
}`;
  }

  private generateFromMethod(name: string, schema: ObjectSchema): string {
    const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
    
    if (fields.length === 0) {
      return `function from${name}(o: ${name}): Msgpack${name} {\n  return {};\n}`;
    }
    
    const checks = fields.map(([key]) =>
      `  if (o.${camelCase(key)} === undefined) { throw new Error("Expected ${camelCase(key)} in ${name} serialization"); }`
    ).join('\n');
    
    const conversions = fields.map(([key, value]) => {
      const typeInfo = this.processSchema(value);
      const converter = this.generateConverter(typeInfo, `o.${camelCase(key)}`, 'from');
      return `  ${key}: ${converter},`;
    }).join('\n');
    
    return `function from${name}(o: ${name}): Msgpack${name} {
${checks};
  return {
${conversions}
  };
}`;
  }

  private generateConverter(typeInfo: TypeInfo, value: string, direction: 'to' | 'from'): string {
    const prefix = this.importStrategy.getTypePrefix();
    
    // Handle arrays/tuples
    if (typeInfo.typeName.includes('[]') || typeInfo.typeName.includes('Tuple<')) {
      const elementType = typeInfo.typeName.match(/^(.+)\[\]$/) || typeInfo.typeName.match(/^Tuple<(.+),/);
      if (elementType) {
        const isTuple = typeInfo.typeName.includes('Tuple<');
        const mapFn = isTuple ? 'mapTuple' : 'map';
        return `${value}.${mapFn}((v: any) => v)`; // Simplified for now
      }
    }
    
    // Handle custom types
    if (typeInfo.declaration) {
      return `${prefix}${direction}${typeInfo.typeName}(${value})`;
    }
    
    return value;
  }
}

// Factory methods for creating configured compilers
export function createSharedTypesCompiler(): SchemaCompiler {
  return new SchemaCompiler(
    {
      getImports: () => [`import { Buffer } from 'buffer';`],
      getTypePrefix: () => '',
    },
    undefined // No method generation for shared types
  );
}

export function createSyncApiCompiler(): SchemaCompiler {
  return new SchemaCompiler(
    {
      getImports: () => [
        `import { Buffer } from 'buffer';`,
        `import { BarretenbergWasmMain } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`
      ],
      getTypePrefix: () => 'apiTypes.',
    },
    {
      generateMethod: (metadata: FunctionMetadata) => `  ${metadata.name}(command: ${metadata.commandType}): ${metadata.responseType} {
    const msgpackCommand = from${metadata.commandType}(command);
    const [variantName, result] = this.wasm.msgpackCall('bbapi', ["${capitalize(metadata.name)}", msgpackCommand]);
    if (variantName !== '${metadata.responseType}') {
      throw new Error(\`Expected variant name '${metadata.responseType}' but got '\${variantName}'\`);
    }
    return to${metadata.responseType}(result);
  }`,
      getWrapperClass: (methods: FunctionMetadata[]) => {
        const methodsStr = methods.map(m => 
          `  ${m.name}(command: ${m.commandType}): ${m.responseType} {
    const msgpackCommand = from${m.commandType}(command);
    const [variantName, result] = this.wasm.msgpackCall('bbapi', ["${capitalize(m.name)}", msgpackCommand]);
    if (variantName !== '${m.responseType}') {
      throw new Error(\`Expected variant name '${m.responseType}' but got '\${variantName}'\`);
    }
    return to${m.responseType}(result);
  }`
        ).join('\n\n');
        
        return `export class SyncApi {
  constructor(protected wasm: BarretenbergWasmMain) {}

${methodsStr}
}`;
      }
    }
  );
}

export function createAsyncApiCompiler(): SchemaCompiler {
  return new SchemaCompiler(
    {
      getImports: () => [
        `import { Buffer } from 'buffer';`,
        `import { BarretenbergWasmMainWorker } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`
      ],
      getTypePrefix: () => 'apiTypes.',
    },
    {
      generateMethod: (metadata: FunctionMetadata) => `  async ${metadata.name}(command: ${metadata.commandType}): Promise<${metadata.responseType}> {
    const msgpackCommand = from${metadata.commandType}(command);
    const [variantName, result] = await this.wasm.msgpackCall('bbapi', ["${capitalize(metadata.name)}", msgpackCommand]);
    if (variantName !== '${metadata.responseType}') {
      throw new Error(\`Expected variant name '${metadata.responseType}' but got '\${variantName}'\`);
    }
    return to${metadata.responseType}(result);
  }`,
      getWrapperClass: (methods: FunctionMetadata[]) => {
        const methodsStr = methods.map(m => 
          `  async ${m.name}(command: ${m.commandType}): Promise<${m.responseType}> {
    const msgpackCommand = from${m.commandType}(command);
    const [variantName, result] = await this.wasm.msgpackCall('bbapi', ["${capitalize(m.name)}", msgpackCommand]);
    if (variantName !== '${m.responseType}') {
      throw new Error(\`Expected variant name '${m.responseType}' but got '\${variantName}'\`);
    }
    return to${m.responseType}(result);
  }`
        ).join('\n\n');
        
        return `export class AsyncApi {
  constructor(protected wasm: BarretenbergWasmMainWorker) {}

${methodsStr}
}`;
      }
    }
  );
}

export function createNativeApiCompiler(): SchemaCompiler {
  return new SchemaCompiler(
    {
      getImports: () => [
        `import { spawn, ChildProcess } from 'child_process';`,
        `import { Decoder, Encoder } from 'msgpackr';`
      ],
      getTypePrefix: () => 'apiTypes.',
    },
    {
      generateMethod: (metadata: FunctionMetadata) => `  async ${metadata.name}(command: ${metadata.commandType}): Promise<${metadata.responseType}> {
    const msgpackCommand = from${metadata.commandType}(command);
    const [variantName, result] = await this.sendCommand(["${capitalize(metadata.name)}", msgpackCommand]);
    if (variantName !== '${metadata.responseType}') {
      throw new Error(\`Expected variant name '${metadata.responseType}' but got '\${variantName}'\`);
    }
    return to${metadata.responseType}(result);
  }`,
      getWrapperClass: (methods: FunctionMetadata[]) => {
        // For native, we need to handle the case with/without method bodies
        const needsFullMethods = methods.some(m => 
          m.name.includes('ComputeStandaloneVk') || 
          m.name.includes('CheckPrecomputedVk')
        );
        
        const methodsStr = methods.map(m => {
          if (needsFullMethods) {
            return `  async ${m.name}(command: ${m.commandType}): Promise<${m.responseType}> {
    const msgpackCommand = from${m.commandType}(command);
    const [variantName, result] = await this.sendCommand(["${capitalize(m.name)}", msgpackCommand]);
    if (variantName !== '${m.responseType}') {
      throw new Error(\`Expected variant name '${m.responseType}' but got '\${variantName}'\`);
    }
    return to${m.responseType}(result);
  }`;
          } else {
            // For shorter method declarations that fit on fewer lines
            return `  async ${m.name}(
    command: ${m.commandType},
  ): Promise<${m.responseType}> {
    const msgpackCommand = from${m.commandType}(command);
    const [variantName, result] = await this.sendCommand(['${capitalize(m.name)}', msgpackCommand]);
    if (variantName !== '${m.responseType}') {
      throw new Error(\`Expected variant name '${m.responseType}' but got '\${variantName}'\`);
    }
    return to${m.responseType}(result);
  }`;
          }
        }).join('\n\n');
        
        return `interface NativeApiRequest {
  resolve: (value: any) => void;
  reject: (error: any) => void;
}

export class NativeApi {
  private decoder = new Decoder({ largeBigIntToString: false });
  private encoder = new Encoder();
  private requestCallbacks: NativeApiRequest[] = [];

  private constructor(private proc: ChildProcess) {}

  static async new(bbPath = 'bb', errorLogger = console.error): Promise<NativeApi> {
    const proc = spawn(bbPath, ['api'], {
      stdio: ['pipe', 'pipe', 'inherit'],
    });

    if (!proc.stdout || !proc.stdin) {
      throw new Error('Failed to initialize bb process');
    }

    const api = new NativeApi(proc);

    proc.stdout.on('data', (data: Buffer) => {
      try {
        const decoded = api.decoder.decode(data);
        if (!Array.isArray(decoded) || decoded.length !== 2) {
          throw new Error(\`Invalid response format: \${JSON.stringify(decoded)}\`);
        }
        const [variantName, result] = decoded;
        const callback = api.requestCallbacks.shift();
        if (!callback) {
          throw new Error('No request callback found for response');
        }
        callback.resolve([variantName, result]);
      } catch (error) {
        const callback = api.requestCallbacks.shift();
        if (callback) {
          callback.reject(error);
        } else {
          errorLogger('Error processing response:', error);
        }
      }
    });

    proc.on('error', err => {
      errorLogger('bb process error:', err);
    });

    return api;
  }

  private sendCommand(command: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.requestCallbacks.push({ resolve, reject });
      const encoded = this.encoder.encode(command);
      this.proc.stdin!.write(encoded);
    });
  }

  async close(): Promise<void> {
    if (this.proc && this.proc) {
      this.proc.kill();
    }
  }

${methodsStr}
}`;
      }
    }
  );
}