/**
 * Unified schema compiler with integrated strategies
 */

import { Buffer } from 'buffer';

// Core type definitions
export type Schema =
  | string
  | ObjectSchema
  | ['tuple', Schema[]]
  | ['map', [Schema, Schema]]
  | ['optional', [Schema]]
  | ['vector', [Schema]]
  | ['variant', Schema[]]
  | ['named_union', Array<[string, Schema]>]
  | ['shared_ptr', [Schema]]
  | ['array', [Schema, number]]
  | ['alias', [string, string]];

export type ObjectSchema = { [key: string]: Schema };

export interface TypeInfo {
  typeName: string;
  msgpackTypeName?: string;
  declaration?: string;
  toMethod?: string;
  fromMethod?: string;
}

export interface FunctionMetadata {
  name: string;
  commandType: string;
  responseType: string;
}

// Strategy interfaces
export interface ImportStrategy {
  getImports(): string[];
  getTypePrefix(): string;
}

export interface MethodGeneratorStrategy {
  generateMethod(metadata: FunctionMetadata): string;
  getWrapperClass(methods: FunctionMetadata[]): string;
}

// Helper functions
function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.substring(1);
}

function camelCase(s: string): string {
  return s
    .split('_')
    .map((part, index) => (index === 0 ? part.charAt(0).toLowerCase() + part.substring(1) : capitalize(part)))
    .join('');
}

function pascalCase(s: string): string {
  return s.split('_').map(capitalize).join('');
}

export class SchemaCompiler {
  private typeCache = new Map<string, TypeInfo>();
  private functionMetadata: FunctionMetadata[] = [];
  
  constructor(
    private importStrategy: ImportStrategy,
    private methodGenerator?: MethodGeneratorStrategy,
  ) {}

  /**
   * Process API schema and extract function metadata
   */
  processApiSchema(commandsSchema: Schema, responsesSchema: Schema): void {
    // Process types
    this.processSchema(commandsSchema);
    this.processSchema(responsesSchema);

    // Extract function metadata from named unions
    if (!Array.isArray(commandsSchema) || commandsSchema[0] !== 'named_union' ||
        !Array.isArray(responsesSchema) || responsesSchema[0] !== 'named_union') {
      throw new Error('Expected named_union schema format');
    }

    const commands = commandsSchema[1] as Array<[string, Schema]>;
    const responses = responsesSchema[1] as Array<[string, Schema]>;

    for (let i = 0; i < commands.length; i++) {
      const [commandName] = commands[i];
      const [responseName] = responses[i];
      
      this.functionMetadata.push({
        name: camelCase(commandName),
        commandType: pascalCase(commandName),
        responseType: pascalCase(responseName),
      });
    }
  }

  /**
   * Process a schema and populate type cache
   */
  processSchema(schema: Schema): TypeInfo {
    const key = this.getSchemaKey(schema);
    if (this.typeCache.has(key)) {
      return this.typeCache.get(key)!;
    }

    const typeInfo = this.generateTypeInfo(schema);
    this.typeCache.set(key, typeInfo);
    return typeInfo;
  }

  /**
   * Generate the complete output
   */
  compile(): string {
    const parts: string[] = [
      '// AUTOGENERATED FILE - DO NOT EDIT',
      '',
      ...this.importStrategy.getImports(),
      '',
    ];

    // Add type declarations and conversion functions
    const sortedTypes = Array.from(this.typeCache.values())
      .filter(t => t.declaration)
      .sort((a, b) => a.typeName.localeCompare(b.typeName));

    // Group declarations
    const typeAliases = sortedTypes.filter(t => t.typeName === 'Fr');
    const publicInterfaces = sortedTypes.filter(t => 
      t.declaration?.includes('export interface') && t.typeName !== 'Fr'
    );
    const privateInterfaces = sortedTypes.filter(t => 
      t.declaration?.includes('interface Msgpack')
    );

    // Add Fr type alias if needed
    if (typeAliases.length > 0) {
      parts.push('// Type aliases', 'export type Fr = Buffer;', '');
    }

    // Add tuple helper if needed
    if (this.needsTupleHelper()) {
      parts.push(
        '// Tuple type for fixed-size arrays',
        'type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;',
        'type _TupleOf<T, N extends number, R extends unknown[]> = R[\'length\'] extends N ? R : _TupleOf<T, N, [T, ...R]>;',
        '',
        '// Helper functions',
        'function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {',
        '  return tuple.map(fn) as Tuple<S, N>;',
        '}',
        ''
      );
    }

    // Add public interfaces
    if (publicInterfaces.length > 0) {
      parts.push('// Public interfaces (exported)');
      for (const type of publicInterfaces) {
        parts.push(type.declaration!, '');
      }
    }

    // Add private interfaces
    if (privateInterfaces.length > 0) {
      parts.push('// Private Msgpack interfaces (not exported)');
      for (const type of privateInterfaces) {
        parts.push(type.declaration!, '');
      }
    }

    // Add conversion functions
    const conversions = sortedTypes.filter(t => t.toMethod || t.fromMethod);
    if (conversions.length > 0) {
      parts.push('// Conversion functions (exported)');
      for (const type of conversions) {
        if (type.toMethod) {
          parts.push('export ' + type.toMethod, '');
        }
        if (type.fromMethod) {
          parts.push('export ' + type.fromMethod, '');
        }
      }
    }

    // Add re-exports for API compilers
    if (this.importStrategy.getTypePrefix() === 'apiTypes.') {
      parts.push(
        '// Re-export all types from api_types',
        'export * from \'./api_types.js\';',
        ''
      );
    }

    // Add API class if we have a method generator
    if (this.methodGenerator && this.functionMetadata.length > 0) {
      parts.push(this.methodGenerator.getWrapperClass(this.functionMetadata));
    }

    return parts.join('\n') + '\n';
  }

  private getSchemaKey(schema: Schema): string {
    if (typeof schema === 'string') return schema;
    if (Array.isArray(schema)) return JSON.stringify(schema);
    if (typeof schema === 'object') return (schema as any).__typename || JSON.stringify(schema);
    return String(schema);
  }

  private needsTupleHelper(): boolean {
    return Array.from(this.typeCache.values()).some(t => 
      t.typeName.includes('Tuple<')
    );
  }

  private generateTypeInfo(schema: Schema): TypeInfo {
    if (Array.isArray(schema)) {
      return this.processArraySchema(schema);
    } else if (typeof schema === 'string') {
      return this.processPrimitiveSchema(schema);
    } else if (typeof schema === 'object') {
      return this.processObjectSchema(schema);
    }
    throw new Error(`Unsupported schema type: ${schema}`);
  }

  private processArraySchema(schema: any[]): TypeInfo {
    const [type, ...args] = schema;
    
    switch (type) {
      case 'array': {
        const [subtype, size] = args[0];
        const subtypeInfo = this.processSchema(subtype);
        return {
          typeName: `Tuple<${subtypeInfo.typeName}, ${size}>`,
          msgpackTypeName: `Tuple<${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}, ${size}>`,
        };
      }
      
      case 'variant': {
        const variants = args[0] as Schema[];
        const variantInfos = variants.map(v => this.processSchema(v));
        const typeName = variantInfos.map(v => v.typeName).join(' | ');
        const msgpackUnion = variantInfos.map(v => v.msgpackTypeName || v.typeName).join(' | ');
        return {
          typeName,
          msgpackTypeName: `[number, ${msgpackUnion}]`,
        };
      }
      
      case 'named_union': {
        const namedTypes = args[0] as Array<[string, Schema]>;
        const tupleTypes: string[] = [];
        
        for (const [name, schemaOrName] of namedTypes) {
          let typeInfo: TypeInfo;
          if (typeof schemaOrName === 'string') {
            const typeName = pascalCase(schemaOrName);
            typeInfo = this.getOrCreateEmptyType(typeName);
          } else {
            typeInfo = this.processSchema(schemaOrName);
          }
          tupleTypes.push(`["${name}", ${this.importStrategy.getTypePrefix()}${typeInfo.typeName}]`);
        }
        
        return {
          typeName: tupleTypes.join(' | '),
          msgpackTypeName: tupleTypes.join(' | '),
        };
      }
      
      case 'vector': {
        const [subtype] = args[0];
        if (subtype === 'unsigned char') {
          return { typeName: 'Buffer' };
        }
        const subtypeInfo = this.processSchema(subtype);
        return {
          typeName: `${subtypeInfo.typeName}[]`,
          msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
        };
      }
      
      case 'alias': {
        const [rawTypeName, msgpackName] = args[0];
        const typeName = pascalCase(rawTypeName);
        let msgpackTypeName: string;
        
        if (msgpackName.startsWith('bin')) {
          msgpackTypeName = 'Buffer';
        } else if (['int', 'unsigned int', 'unsigned short'].includes(msgpackName)) {
          msgpackTypeName = 'number';
        } else {
          throw new Error(`Unsupported alias type: ${msgpackName}`);
        }
        
        return { typeName, msgpackTypeName };
      }
      
      case 'shared_ptr': {
        const [subtype] = args[0];
        return this.processSchema(subtype);
      }
      
      case 'map': {
        const [keyType, valueType] = args[0];
        const keyInfo = this.processSchema(keyType);
        const valueInfo = this.processSchema(valueType);
        return {
          typeName: `Record<${keyInfo.typeName}, ${valueInfo.typeName}>`,
          msgpackTypeName: `Record<${keyInfo.msgpackTypeName || keyInfo.typeName}, ${valueInfo.msgpackTypeName || valueInfo.typeName}>`,
        };
      }
      
      default:
        throw new Error(`Unsupported array schema type: ${type}`);
    }
  }

  private processPrimitiveSchema(schema: string): TypeInfo {
    switch (schema) {
      case 'bool':
        return { typeName: 'boolean' };
      case 'int':
      case 'unsigned int':
      case 'unsigned short':
      case 'unsigned long':
      case 'double':
        return { typeName: 'number' };
      case 'string':
        return { typeName: 'string' };
      case 'bin32':
        return { typeName: 'Buffer' };
      default:
        return { typeName: pascalCase(schema) };
    }
  }

  private processObjectSchema(schema: ObjectSchema): TypeInfo {
    const typeName = pascalCase(schema.__typename as string);
    const msgpackTypeName = 'Msgpack' + typeName;
    
    const declaration = this.generateInterfaces(typeName, schema);
    const toMethod = this.generateToMethod(typeName, schema);
    const fromMethod = this.generateFromMethod(typeName, schema);
    
    return {
      typeName,
      msgpackTypeName,
      declaration,
      toMethod,
      fromMethod,
    };
  }

  private getOrCreateEmptyType(typeName: string): TypeInfo {
    const key = `empty_${typeName}`;
    if (this.typeCache.has(key)) {
      return this.typeCache.get(key)!;
    }
    
    const typeInfo: TypeInfo = {
      typeName,
      msgpackTypeName: 'Msgpack' + typeName,
      declaration: `export interface ${typeName} {}\n\ninterface Msgpack${typeName} {}`,
      toMethod: `function to${typeName}(o: Msgpack${typeName}): ${typeName} {\n  return {};\n}`,
      fromMethod: `function from${typeName}(o: ${typeName}): Msgpack${typeName} {\n  return {};\n}`,
    };
    
    this.typeCache.set(key, typeInfo);
    return typeInfo;
  }

  private generateInterfaces(name: string, schema: ObjectSchema): string {
    const publicInterface = this.generatePublicInterface(name, schema);
    const msgpackInterface = this.generateMsgpackInterface(name, schema);
    return publicInterface + '\n\n' + msgpackInterface;
  }

  private generatePublicInterface(name: string, schema: ObjectSchema): string {
    let result = `export interface ${name} {\n`;
    for (const [key, value] of Object.entries(schema)) {
      if (key === '__typename') continue;
      const typeInfo = this.processSchema(value);
      result += `  ${camelCase(key)}: ${this.importStrategy.getTypePrefix()}${typeInfo.typeName};\n`;
    }
    result += '}';
    return result;
  }

  private generateMsgpackInterface(name: string, schema: ObjectSchema): string {
    let result = `interface Msgpack${name} {\n`;
    for (const [key, value] of Object.entries(schema)) {
      if (key === '__typename') continue;
      const typeInfo = this.processSchema(value);
      result += `  ${key}: ${typeInfo.msgpackTypeName || typeInfo.typeName};\n`;
    }
    result += '}';
    return result;
  }

  private generateToMethod(name: string, schema: ObjectSchema): string {
    const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
    
    if (fields.length === 0) {
      return `function to${name}(o: Msgpack${name}): ${name} {\n  return {};\n}`;
    }
    
    const checks = fields.map(([key]) =>
      `  if (o.${key} === undefined) { throw new Error("Expected ${key} in ${name} deserialization"); }`
    ).join('\n');
    
    const conversions = fields.map(([key, value]) => {
      const typeInfo = this.processSchema(value);
      const converter = this.generateConverter(typeInfo, `o.${key}`, 'to');
      return `    ${camelCase(key)}: ${converter},`;
    }).join('\n');
    
    return `function to${name}(o: Msgpack${name}): ${name} {
${checks};
  return {
${conversions}
  };
}`;
  }

  private generateFromMethod(name: string, schema: ObjectSchema): string {
    const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
    
    if (fields.length === 0) {
      return `function from${name}(o: ${name}): Msgpack${name} {\n  return {};\n}`;
    }
    
    const checks = fields.map(([key]) =>
      `  if (o.${camelCase(key)} === undefined) { throw new Error("Expected ${camelCase(key)} in ${name} serialization"); }`
    ).join('\n');
    
    const conversions = fields.map(([key, value]) => {
      const typeInfo = this.processSchema(value);
      const converter = this.generateConverter(typeInfo, `o.${camelCase(key)}`, 'from');
      return `  ${key}: ${converter},`;
    }).join('\n');
    
    return `function from${name}(o: ${name}): Msgpack${name} {
${checks};
  return {
${conversions}
  };
}`;
  }

  private generateConverter(typeInfo: TypeInfo, value: string, direction: 'to' | 'from'): string {
    const prefix = this.importStrategy.getTypePrefix();
    
    // Handle arrays/tuples
    if (typeInfo.typeName.includes('[]') || typeInfo.typeName.includes('Tuple<')) {
      const elementType = typeInfo.typeName.match(/^(.+)\[\]$/) || typeInfo.typeName.match(/^Tuple<(.+),/);
      if (elementType) {
        const isTuple = typeInfo.typeName.includes('Tuple<');
        const mapFn = isTuple ? 'mapTuple' : 'map';
        return `${value}.${mapFn}((v: any) => v)`; // Simplified for now
      }
    }
    
    // Handle custom types
    if (typeInfo.declaration) {
      return `${prefix}${direction}${typeInfo.typeName}(${value})`;
    }
    
    return value;
  }
}

// Factory methods for creating configured compilers
export function createSharedTypesCompiler(): SchemaCompiler {
  return new SchemaCompiler(
    {
      getImports: () => [`import { Buffer } from 'buffer';`],
      getTypePrefix: () => '',
    },
    undefined // No method generation for shared types
  );
}

export function createSyncApiCompiler(): SchemaCompiler {
  return new SchemaCompiler(
    {
      getImports: () => [
        `import { Buffer } from 'buffer';`,
        `import * as apiTypes from './api_types.js';`,
        `import { BarretenbergWasmMain } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`
      ],
      getTypePrefix: () => 'apiTypes.',
    },
    {
      generateMethod: (metadata: FunctionMetadata) => `  ${metadata.name}(command: apiTypes.${metadata.commandType}): apiTypes.${metadata.responseType} {
    const msgpackCommand = apiTypes.from${metadata.commandType}(command);
    const [variantName, result] = this.wasm.msgpackCall('bbapi', ["${capitalize(metadata.name)}", msgpackCommand]);
    if (variantName !== '${metadata.responseType}') {
      throw new Error(\`Expected variant name '${metadata.responseType}' but got '\${variantName}'\`);
    }
    return apiTypes.to${metadata.responseType}(result);
  }`,
      getWrapperClass: (methods: FunctionMetadata[]) => {
        const methodsStr = methods.map(m => 
          `  ${m.name}(command: apiTypes.${m.commandType}): apiTypes.${m.responseType} {
    const msgpackCommand = apiTypes.from${m.commandType}(command);
    const [variantName, result] = this.wasm.msgpackCall('bbapi', ["${capitalize(m.name)}", msgpackCommand]);
    if (variantName !== '${m.responseType}') {
      throw new Error(\`Expected variant name '${m.responseType}' but got '\${variantName}'\`);
    }
    return apiTypes.to${m.responseType}(result);
  }`
        ).join('\n\n');
        
        return `export class SyncApi {
  constructor(protected wasm: BarretenbergWasmMain) {}

${methodsStr}
}`;
      }
    }
  );
}

export function createAsyncApiCompiler(): SchemaCompiler {
  return new SchemaCompiler(
    {
      getImports: () => [
        `import { Buffer } from 'buffer';`,
        `import * as apiTypes from './api_types.js';`,
        `import { BarretenbergWasmMainWorker } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`
      ],
      getTypePrefix: () => 'apiTypes.',
    },
    {
      generateMethod: (metadata: FunctionMetadata) => `  async ${metadata.name}(command: apiTypes.${metadata.commandType}): Promise<apiTypes.${metadata.responseType}> {
    const msgpackCommand = apiTypes.from${metadata.commandType}(command);
    const [variantName, result] = await this.wasm.msgpackCall('bbapi', ["${capitalize(metadata.name)}", msgpackCommand]);
    if (variantName !== '${metadata.responseType}') {
      throw new Error(\`Expected variant name '${metadata.responseType}' but got '\${variantName}'\`);
    }
    return apiTypes.to${metadata.responseType}(result);
  }`,
      getWrapperClass: (methods: FunctionMetadata[]) => {
        const methodsStr = methods.map(m => 
          `  async ${m.name}(command: apiTypes.${m.commandType}): Promise<apiTypes.${m.responseType}> {
    const msgpackCommand = apiTypes.from${m.commandType}(command);
    const [variantName, result] = await this.wasm.msgpackCall('bbapi', ["${capitalize(m.name)}", msgpackCommand]);
    if (variantName !== '${m.responseType}') {
      throw new Error(\`Expected variant name '${m.responseType}' but got '\${variantName}'\`);
    }
    return apiTypes.to${m.responseType}(result);
  }`
        ).join('\n\n');
        
        return `export class AsyncApi {
  constructor(protected wasm: BarretenbergWasmMainWorker) {}

${methodsStr}
}`;
      }
    }
  );
}

export function createNativeApiCompiler(): SchemaCompiler {
  return new SchemaCompiler(
    {
      getImports: () => [
        `import { Buffer } from 'buffer';`,
        `import * as apiTypes from './api_types.js';`,
        `import { spawn, ChildProcess } from 'child_process';`,
        `import { Decoder, Encoder } from 'msgpackr';`
      ],
      getTypePrefix: () => 'apiTypes.',
    },
    {
      generateMethod: (metadata: FunctionMetadata) => `  async ${metadata.name}(command: apiTypes.${metadata.commandType}): Promise<apiTypes.${metadata.responseType}> {
    const msgpackCommand = apiTypes.from${metadata.commandType}(command);
    const [variantName, result] = await this.sendCommand(["${capitalize(metadata.name)}", msgpackCommand]);
    if (variantName !== '${metadata.responseType}') {
      throw new Error(\`Expected variant name '${metadata.responseType}' but got '\${variantName}'\`);
    }
    return apiTypes.to${metadata.responseType}(result);
  }`,
      getWrapperClass: (methods: FunctionMetadata[]) => {
        const methodsStr = methods.map(m => 
          `  async ${m.name}(command: apiTypes.${m.commandType}): Promise<apiTypes.${m.responseType}> {
    const msgpackCommand = apiTypes.from${m.commandType}(command);
    const [variantName, result] = await this.sendCommand(["${capitalize(m.name)}", msgpackCommand]);
    if (variantName !== '${m.responseType}') {
      throw new Error(\`Expected variant name '${m.responseType}' but got '\${variantName}'\`);
    }
    return apiTypes.to${m.responseType}(result);
  }`
        ).join('\n\n');
        
        return `export class NativeApi {
  private proc?: ChildProcess;
  private decoder = new Decoder({ largeBigIntToString: false });
  private encoder = new Encoder();
  
  constructor(private bbPath: string = 'bb') {}

  async init(): Promise<void> {
    this.proc = spawn(this.bbPath, ['api'], {
      stdio: ['pipe', 'pipe', 'inherit']
    });
    
    if (!this.proc.stdout || !this.proc.stdin) {
      throw new Error('Failed to initialize bb process');
    }
    
    this.proc.on('error', (err) => {
      console.error('bb process error:', err);
    });
  }

  private async sendCommand(command: any): Promise<any> {
    if (!this.proc || !this.proc.stdin || !this.proc.stdout) {
      throw new Error('bb process not initialized');
    }
    
    const encoded = this.encoder.encode(command);
    this.proc.stdin.write(encoded);
    
    return new Promise((resolve, reject) => {
      const onData = (data: Buffer) => {
        try {
          const decoded = this.decoder.decode(data);
          this.proc!.stdout!.off('data', onData);
          resolve(decoded);
        } catch (err) {
          reject(err);
        }
      };
      
      this.proc!.stdout!.once('data', onData);
    });
  }

  async destroy(): Promise<void> {
    if (this.proc) {
      this.proc.kill();
      this.proc = undefined;
    }
  }

  // Alias for backwards compatibility
  async close(): Promise<void> {
    return this.destroy();
  }

${methodsStr}
}`;
      }
    }
  );
}