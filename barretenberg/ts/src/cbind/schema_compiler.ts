/**
 * Unified schema compiler with integrated strategies
 */

import { Buffer } from 'buffer';

// Core type definitions
export type Schema =
  | string
  | ObjectSchema
  | ['tuple', Schema[]]
  | ['map', [Schema, Schema]]
  | ['optional', [Schema]]
  | ['vector', [Schema]]
  | ['variant', Schema[]]
  | ['named_union', Array<[string, Schema]>]
  | ['shared_ptr', [Schema]]
  | ['array', [Schema, number]]
  | ['alias', [string, string]];

export type ObjectSchema = { [key: string]: Schema };

export interface TypeInfo {
  typeName: string;
  msgpackTypeName?: string;
  declaration?: string;
  toMethod?: string;
  fromMethod?: string;
}

export interface FunctionMetadata {
  name: string;
  commandType: string;
  responseType: string;
}

// Compiler configuration
export interface CompilerConfig {
  mode: 'types' | 'sync' | 'async' | 'native';
  imports?: string[];
  wasmImport?: string;
}

// Helper functions
function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.substring(1);
}

function camelCase(s: string): string {
  return s
    .split('_')
    .map((part, index) => (index === 0 ? part.charAt(0).toLowerCase() + part.substring(1) : capitalize(part)))
    .join('');
}

function pascalCase(s: string): string {
  return s.split('_').map(capitalize).join('');
}

export class SchemaCompiler {
  private typeCache = new Map<string, TypeInfo>();
  private functionMetadata: FunctionMetadata[] = [];
  private referencedTypes = new Set<string>();

  constructor(private config: CompilerConfig) {}

  /**
   * Process API schema and extract function metadata
   */
  processApiSchema(commandsSchema: Schema, responsesSchema: Schema): void {
    // Process types
    this.processSchema(commandsSchema);
    this.processSchema(responsesSchema);

    // Extract function metadata from named unions
    if (!Array.isArray(commandsSchema) || commandsSchema[0] !== 'named_union' ||
        !Array.isArray(responsesSchema) || responsesSchema[0] !== 'named_union') {
      throw new Error('Expected named_union schema format');
    }

    const commands = commandsSchema[1] as Array<[string, Schema]>;
    const responses = responsesSchema[1] as Array<[string, Schema]>;

    for (let i = 0; i < commands.length; i++) {
      const [commandName] = commands[i];
      const [responseName] = responses[i];

      this.functionMetadata.push({
        name: camelCase(commandName),
        commandType: pascalCase(commandName),
        responseType: pascalCase(responseName),
      });
    }
  }

  /**
   * Process a schema and populate type cache
   */
  processSchema(schema: Schema): TypeInfo {
    const key = this.getSchemaKey(schema);
    if (this.typeCache.has(key)) {
      return this.typeCache.get(key)!;
    }

    const typeInfo = this.generateTypeInfo(schema);
    this.typeCache.set(key, typeInfo);
    return typeInfo;
  }

  /**
   * Generate the complete output
   */
  compile(): string {
    const parts: string[] = [
      '// AUTOGENERATED FILE - DO NOT EDIT',
      '',
    ];

    // Generate imports
    parts.push(...this.generateImports());
    parts.push('');

    // Generate type declarations only for 'types' mode
    if (this.config.mode === 'types') {
      const sortedTypes = Array.from(this.typeCache.values())
        .filter(t => t.declaration)
        .sort((a, b) => a.typeName.localeCompare(b.typeName));

      // Group declarations
      const typeAliases = sortedTypes.filter(t =>
        t.declaration?.startsWith('export type') && !t.declaration?.includes('interface')
      );
      const publicInterfaces = sortedTypes.filter(t =>
        t.declaration?.includes('export interface')
      );
      const privateInterfaces = sortedTypes.filter(t =>
        t.declaration?.includes('interface Msgpack')
      );

    // Add type aliases if needed
    if (typeAliases.length > 0) {
      parts.push('// Type aliases');
      for (const type of typeAliases) {
        parts.push(type.declaration!);
      }
      parts.push('');
    }

    // Add tuple helper if needed
    if (this.needsTupleHelper()) {
      parts.push(
        '// Tuple type for fixed-size arrays',
        'type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;',
        'type _TupleOf<T, N extends number, R extends unknown[]> = R[\'length\'] extends N ? R : _TupleOf<T, N, [T, ...R]>;',
        '',
        '// Helper functions',
        'function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {',
        '  return tuple.map(fn) as Tuple<S, N>;',
        '}',
        ''
      );
    }

    // Add public interfaces
    if (publicInterfaces.length > 0) {
      parts.push('// Public interfaces (exported)');
      for (const type of publicInterfaces) {
        parts.push(type.declaration!, '');
      }
    }

    // Add private interfaces
    if (privateInterfaces.length > 0) {
      parts.push('// Private Msgpack interfaces (not exported)');
      for (const type of privateInterfaces) {
        parts.push(type.declaration!, '');
      }
    }

      // Add conversion functions (only for api_types.ts)
      const conversions = sortedTypes.filter(t => t.toMethod || t.fromMethod);
      if (conversions.length > 0) {
        parts.push('// Conversion functions (exported)');
        for (const type of conversions) {
          if (type.toMethod) {
            parts.push('export ' + type.toMethod, '');
          }
          if (type.fromMethod) {
            parts.push('export ' + type.fromMethod, '');
          }
        }
      }
      
      // Add BbApiBase interface
      if (this.functionMetadata.length > 0) {
        parts.push('', '// Base API interface');
        parts.push(this.generateBbApiBaseInterface());
      }
    }

    // Add API class for non-types modes
    if (this.config.mode !== 'types' && this.functionMetadata.length > 0) {
      parts.push(this.generateApiClass());
    }

    return parts.join('\n') + '\n';
  }

  private getSchemaKey(schema: Schema): string {
    if (typeof schema === 'string') return schema;
    if (Array.isArray(schema)) return JSON.stringify(schema);
    if (typeof schema === 'object') return (schema as any).__typename || JSON.stringify(schema);
    return String(schema);
  }

  private needsTupleHelper(): boolean {
    return Array.from(this.typeCache.values()).some(t =>
      t.typeName.includes('Tuple<')
    );
  }

  private trackTypeUsage(typeName: string): void {
    // Only track for API modes
    if (this.config.mode === 'types') return;

    // Extract base types from complex types
    const baseTypes = this.extractBaseTypes(typeName);

    for (const type of baseTypes) {
      // Skip built-in types
      if (['string', 'number', 'boolean', 'Buffer'].includes(type)) {
        continue;
      }

      this.referencedTypes.add(type);
    }
  }

  private extractBaseTypes(typeName: string): string[] {
    const types: string[] = [];

    // Handle arrays
    const arrayMatch = typeName.match(/^(.+)\[\]$/);
    if (arrayMatch) {
      types.push(...this.extractBaseTypes(arrayMatch[1]));
      return types;
    }

    // Handle Tuple
    const tupleMatch = typeName.match(/^Tuple<(.+),\s*\d+>$/);
    if (tupleMatch) {
      types.push(...this.extractBaseTypes(tupleMatch[1]));
      return types;
    }

    // Handle Record
    const recordMatch = typeName.match(/^Record<(.+),\s*(.+)>$/);
    if (recordMatch) {
      types.push(...this.extractBaseTypes(recordMatch[1]));
      types.push(...this.extractBaseTypes(recordMatch[2]));
      return types;
    }

    // Handle union types
    if (typeName.includes(' | ')) {
      const parts = typeName.split(' | ');
      for (const part of parts) {
        types.push(...this.extractBaseTypes(part.trim()));
      }
      return types;
    }

    // Base case - simple type
    types.push(typeName);
    return types;
  }

  private generateTypeInfo(schema: Schema): TypeInfo {
    if (Array.isArray(schema)) {
      return this.processArraySchema(schema);
    } else if (typeof schema === 'string') {
      return this.processPrimitiveSchema(schema);
    } else if (typeof schema === 'object') {
      return this.processObjectSchema(schema);
    }
    throw new Error(`Unsupported schema type: ${schema}`);
  }

  private processArraySchema(schema: any[]): TypeInfo {
    const [type, ...args] = schema;

    switch (type) {
      case 'array': {
        const [subtype, size] = args[0];
        const subtypeInfo = this.processSchema(subtype);
        return {
          typeName: `Tuple<${subtypeInfo.typeName}, ${size}>`,
          msgpackTypeName: `Tuple<${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}, ${size}>`,
        };
      }

      case 'variant': {
        const variants = args[0] as Schema[];
        const variantInfos = variants.map(v => this.processSchema(v));
        const typeName = variantInfos.map(v => v.typeName).join(' | ');
        const msgpackUnion = variantInfos.map(v => v.msgpackTypeName || v.typeName).join(' | ');
        return {
          typeName,
          msgpackTypeName: `[number, ${msgpackUnion}]`,
        };
      }

      case 'named_union': {
        const namedTypes = args[0] as Array<[string, Schema]>;
        const tupleTypes: string[] = [];

        for (const [name, schemaOrName] of namedTypes) {
          let typeInfo: TypeInfo;
          if (typeof schemaOrName === 'string') {
            const typeName = pascalCase(schemaOrName);
            typeInfo = this.getOrCreateEmptyType(typeName);
          } else {
            typeInfo = this.processSchema(schemaOrName);
          }
          // Track usage of the type
          this.trackTypeUsage(typeInfo.typeName);
          tupleTypes.push(`["${name}", ${typeInfo.typeName}]`);
        }

        return {
          typeName: tupleTypes.join(' | '),
          msgpackTypeName: tupleTypes.join(' | '),
        };
      }

      case 'vector': {
        const [subtype] = args[0];
        if (subtype === 'unsigned char') {
          return { typeName: 'Buffer' };
        }
        const subtypeInfo = this.processSchema(subtype);
        return {
          typeName: `${subtypeInfo.typeName}[]`,
          msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
        };
      }

      case 'alias': {
        const [rawTypeName, msgpackName] = args[0];
        const typeName = pascalCase(rawTypeName);
        let targetType: string;

        if (msgpackName.startsWith('bin')) {
          targetType = 'Buffer';
        } else if (['int', 'unsigned int', 'unsigned short'].includes(msgpackName)) {
          targetType = 'number';
        } else {
          throw new Error(`Unsupported alias type: ${msgpackName}`);
        }

        // Create a proper type alias declaration
        return {
          typeName,
          msgpackTypeName: targetType,
          declaration: `export type ${typeName} = ${targetType};`,
        };
      }

      case 'shared_ptr': {
        const [subtype] = args[0];
        return this.processSchema(subtype);
      }

      case 'map': {
        const [keyType, valueType] = args[0];
        const keyInfo = this.processSchema(keyType);
        const valueInfo = this.processSchema(valueType);
        return {
          typeName: `Record<${keyInfo.typeName}, ${valueInfo.typeName}>`,
          msgpackTypeName: `Record<${keyInfo.msgpackTypeName || keyInfo.typeName}, ${valueInfo.msgpackTypeName || valueInfo.typeName}>`,
        };
      }

      default:
        throw new Error(`Unsupported array schema type: ${type}`);
    }
  }

  private processPrimitiveSchema(schema: string): TypeInfo {
    switch (schema) {
      case 'bool':
        return { typeName: 'boolean' };
      case 'int':
      case 'unsigned int':
      case 'unsigned short':
      case 'unsigned long':
      case 'double':
        return { typeName: 'number' };
      case 'string':
        return { typeName: 'string' };
      case 'bin32':
        return { typeName: 'Buffer' };
      default:
        return { typeName: pascalCase(schema) };
    }
  }

  private processObjectSchema(schema: ObjectSchema): TypeInfo {
    const typeName = pascalCase(schema.__typename as string);
    const msgpackTypeName = 'Msgpack' + typeName;

    const declaration = this.generateInterfaces(typeName, schema);
    const toMethod = this.generateToMethod(typeName, schema);
    const fromMethod = this.generateFromMethod(typeName, schema);

    return {
      typeName,
      msgpackTypeName,
      declaration,
      toMethod,
      fromMethod,
    };
  }

  private getOrCreateEmptyType(typeName: string): TypeInfo {
    const key = `empty_${typeName}`;
    if (this.typeCache.has(key)) {
      return this.typeCache.get(key)!;
    }

    const typeInfo: TypeInfo = {
      typeName,
      msgpackTypeName: 'Msgpack' + typeName,
      declaration: `export interface ${typeName} {}\n\ninterface Msgpack${typeName} {}`,
      toMethod: `function to${typeName}(o: Msgpack${typeName}): ${typeName} {\n  return {};\n}`,
      fromMethod: `function from${typeName}(o: ${typeName}): Msgpack${typeName} {\n  return {};\n}`,
    };

    this.typeCache.set(key, typeInfo);
    return typeInfo;
  }

  private generateInterfaces(name: string, schema: ObjectSchema): string {
    const publicInterface = this.generatePublicInterface(name, schema);
    const msgpackInterface = this.generateMsgpackInterface(name, schema);
    return publicInterface + '\n\n' + msgpackInterface;
  }

  private generatePublicInterface(name: string, schema: ObjectSchema): string {
    let result = `export interface ${name} {\n`;
    for (const [key, value] of Object.entries(schema)) {
      if (key === '__typename') continue;
      const typeInfo = this.processSchema(value);

      // Track type usage
      this.trackTypeUsage(typeInfo.typeName);

      result += `  ${camelCase(key)}: ${typeInfo.typeName};\n`;
    }
    result += '}';
    return result;
  }

  private generateMsgpackInterface(name: string, schema: ObjectSchema): string {
    let result = `interface Msgpack${name} {\n`;
    for (const [key, value] of Object.entries(schema)) {
      if (key === '__typename') continue;
      const typeInfo = this.processSchema(value);
      result += `  ${key}: ${typeInfo.msgpackTypeName || typeInfo.typeName};\n`;
    }
    result += '}';
    return result;
  }

  private generateToMethod(name: string, schema: ObjectSchema): string {
    const fields = Object.entries(schema).filter(([key]) => key !== '__typename');

    if (fields.length === 0) {
      return `function to${name}(o: Msgpack${name}): ${name} {\n  return {};\n}`;
    }

    const checks = fields.map(([key]) =>
      `  if (o.${key} === undefined) { throw new Error("Expected ${key} in ${name} deserialization"); }`
    ).join('\n');

    const conversions = fields.map(([key, value]) => {
      const typeInfo = this.processSchema(value);
      const converter = this.generateConverter(typeInfo, `o.${key}`, 'to');
      return `    ${camelCase(key)}: ${converter},`;
    }).join('\n');

    return `function to${name}(o: Msgpack${name}): ${name} {
${checks};
  return {
${conversions}
  };
}`;
  }

  private generateFromMethod(name: string, schema: ObjectSchema): string {
    const fields = Object.entries(schema).filter(([key]) => key !== '__typename');

    if (fields.length === 0) {
      return `function from${name}(o: ${name}): Msgpack${name} {\n  return {};\n}`;
    }

    const checks = fields.map(([key]) =>
      `  if (o.${camelCase(key)} === undefined) { throw new Error("Expected ${camelCase(key)} in ${name} serialization"); }`
    ).join('\n');

    const conversions = fields.map(([key, value]) => {
      const typeInfo = this.processSchema(value);
      const converter = this.generateConverter(typeInfo, `o.${camelCase(key)}`, 'from');
      return `  ${key}: ${converter},`;
    }).join('\n');

    return `function from${name}(o: ${name}): Msgpack${name} {
${checks};
  return {
${conversions}
  };
}`;
  }

  private generateConverter(typeInfo: TypeInfo, value: string, direction: 'to' | 'from'): string {
    // Handle arrays/tuples
    if (typeInfo.typeName.includes('[]') || typeInfo.typeName.includes('Tuple<')) {
      const elementType = typeInfo.typeName.match(/^(.+)\[\]$/) || typeInfo.typeName.match(/^Tuple<(.+),/);
      if (elementType) {
        const isTuple = typeInfo.typeName.includes('Tuple<');
        const mapFn = isTuple ? 'mapTuple' : 'map';
        return `${value}.${mapFn}((v: any) => v)`; // Simplified for now
      }
    }

    // Handle custom types
    if (typeInfo.declaration) {
      return `${direction}${typeInfo.typeName}(${value})`;
    }

    return value;
  }

  private generateImports(): string[] {
    const imports: string[] = [];

    // Base imports
    if (this.config.imports) {
      imports.push(...this.config.imports);
    }

    // For API modes, import from api_types
    if (this.config.mode !== 'types') {
      const neededImports = new Set<string>();

      // Add types and conversion functions from function metadata
      for (const metadata of this.functionMetadata) {
        neededImports.add(metadata.commandType);
        neededImports.add(metadata.responseType);
        neededImports.add(`from${metadata.commandType}`);
        neededImports.add(`to${metadata.responseType}`);
      }

      // Add referenced types
      for (const type of this.referencedTypes) {
        neededImports.add(type);
      }
      
      // Add BbApiBase interface
      neededImports.add('BbApiBase');

      if (neededImports.size > 0) {
        const sortedImports = Array.from(neededImports).sort();
        imports.push(`import { ${sortedImports.join(', ')} } from './api_types.js';`);
      }
    }

    return imports;
  }

  private generateBbApiBaseInterface(): string {
    const methods = this.functionMetadata.map(m => 
      `  ${m.name}(command: ${m.commandType}): Promise<${m.responseType}>;`
    ).join('\n');
    
    return `export interface BbApiBase {
${methods}
  destroy(): Promise<void>;
}`;
  }

  private generateApiClass(): string {
    const className = this.getApiClassName();
    const methods = this.functionMetadata.map(m => this.generateApiMethod(m)).join('\n\n');

    if (this.config.mode === 'native') {
      return this.generateNativeApiClass(methods);
    }

    return `export class ${className} implements BbApiBase {
  constructor(protected wasm: ${this.getWasmType()}) {}

${methods}

  async destroy(): Promise<void> {
    await this.wasm.destroy();
  }
}`;
  }

  private getApiClassName(): string {
    switch (this.config.mode) {
      case 'sync': return 'SyncApi';
      case 'async': return 'AsyncApi';
      case 'native': return 'NativeApi';
      default: throw new Error(`Invalid mode: ${this.config.mode}`);
    }
  }

  private getWasmType(): string {
    switch (this.config.mode) {
      case 'sync': return 'BarretenbergWasmMain';
      case 'async': return 'BarretenbergWasmMainWorker';
      default: return '';
    }
  }

  private generateApiMethod(metadata: FunctionMetadata): string {
    const { name, commandType, responseType } = metadata;
    const isAsync = this.config.mode !== 'sync';
    const asyncPrefix = isAsync ? 'async ' : '';
    const asyncSuffix = isAsync ? 'await ' : '';
    const returnType = isAsync ? `Promise<${responseType}>` : responseType;

    if (this.config.mode === 'native') {
      return `  async ${name}(command: ${commandType}): Promise<${responseType}> {
    const msgpackCommand = from${commandType}(command);
    const [variantName, result] = await this.sendCommand(['${metadata.commandType}', msgpackCommand]);
    if (variantName !== '${responseType}') {
      throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
    }
    return to${responseType}(result);
  }`;
    }

    return `  ${asyncPrefix}${name}(command: ${commandType}): ${returnType} {
    const msgpackCommand = from${commandType}(command);
    const [variantName, result] = ${asyncSuffix}this.wasm.msgpackCall('bbapi', ["${capitalize(name)}", msgpackCommand]);
    if (variantName !== '${responseType}') {
      throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
    }
    return to${responseType}(result);
  }`;
  }

  private generateNativeApiClass(methods: string): string {
    return `interface NativeApiRequest {
  resolve: (value: any) => void;
  reject: (error: any) => void;
}

class StreamBuffer {
  private buffer = Buffer.alloc(0);
  private expectedLength: number | null = null;

  addData(data: Buffer): Buffer[] {
    // Create buffer to grow as needed
    const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
    this.buffer.copy(newBuffer, 0);
    data.copy(newBuffer, this.buffer.length);
    this.buffer = newBuffer;

    const messages: Buffer[] = [];

    while (true) {
      if (this.expectedLength === null) {
        if (this.buffer.length < 4) break;
        this.expectedLength = this.buffer.readUInt32LE(0);
        this.buffer = this.buffer.subarray(4);
      }

      if (this.buffer.length < this.expectedLength) break;

      // Extract complete message
      const messageBuffer = this.buffer.subarray(0, this.expectedLength);
      messages.push(messageBuffer);
      this.buffer = this.buffer.subarray(this.expectedLength);
      this.expectedLength = null;
    }

    return messages;
  }
}

export class NativeApi implements BbApiBase {
  private decoder = new Decoder({ useRecords: false });
  private encoder = new Encoder({ useRecords: false });
  private pendingRequests: NativeApiRequest[] = [];

  private constructor(private proc: ChildProcess) {}

  static async new(bbPath = 'bb', logger = console.log): Promise<NativeApi> {
    const proc = spawn(bbPath, ['msgpack', 'run'], {
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    if (!proc.stdout || !proc.stdin) {
      throw new Error('Failed to initialize bb process');
    }

    const api = new NativeApi(proc);
    const streamBuffer = new StreamBuffer();

    proc.stdout.on('data', (data: Buffer) => {
      const messages = streamBuffer.addData(data);

      for (const messageBuffer of messages) {
        const pendingRequest = api.pendingRequests.shift();
        if (!pendingRequest) {
          throw new Error('Received response without a pending request');
        }

        try {
          const decoded = api.decoder.decode(messageBuffer);
          if (!Array.isArray(decoded) || decoded.length !== 2) {
            throw new Error(\`Invalid response format: \${JSON.stringify(decoded)}\`);
          }
          const [variantName, result] = decoded;
          pendingRequest.resolve([variantName, result]);
        } catch (error) {
          pendingRequest.reject(error);
          break;
        }
      }
    });

    proc.stderr.on('data', (data: Buffer) => {
      logger(data.toString().trim());
    });

    proc.on('error', err => {
      throw new Error(err.message);
    });
    return api;
  }

  private sendCommand(command: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.pendingRequests.push({ resolve, reject });
      const encoded = this.encoder.encode(command);

      // Write length prefix (4 bytes, little-endian)
      const lengthBuffer = Buffer.allocUnsafe(4);
      lengthBuffer.writeUInt32LE(encoded.length, 0);

      // Write length prefix followed by the encoded data
      this.proc.stdin!.write(lengthBuffer);
      this.proc.stdin!.write(encoded);
    });
  }

  async close(): Promise<void> {
    this.proc.kill();
  }

  async destroy(): Promise<void> {
    await this.close();
  }

${methods}
}`;
  }
}

// Factory methods for creating configured compilers
export function createSharedTypesCompiler(): SchemaCompiler {
  return new SchemaCompiler({
    mode: 'types',
    imports: [`import { Buffer } from 'buffer';`],
  });
}

export function createSyncApiCompiler(): SchemaCompiler {
  return new SchemaCompiler({
    mode: 'sync',
    imports: [
      `import { Buffer } from 'buffer';`,
      `import { BarretenbergWasmMain } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`
    ],
  });
}

export function createAsyncApiCompiler(): SchemaCompiler {
  return new SchemaCompiler({
    mode: 'async',
    imports: [
      `import { Buffer } from 'buffer';`,
      `import { BarretenbergWasmMainWorker } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`
    ],
  });
}

export function createNativeApiCompiler(): SchemaCompiler {
  return new SchemaCompiler({
    mode: 'native',
    imports: [
      `import { spawn, ChildProcess } from 'child_process';`,
      `import { Decoder, Encoder } from 'msgpackr';`
    ],
  });
}
