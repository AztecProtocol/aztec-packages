import { MsgpackSchemaCompiler } from './msgpack_schema_compiler.js';

/**
 * Compiler for generating shared types file (api_types.gen.ts)
 * This extracts all the type definitions that are common across sync, async, and native APIs
 */
export class SharedTypesCompiler extends MsgpackSchemaCompiler {
  constructor() {
    super('sync'); // Mode doesn't matter for shared types
  }

  /**
   * Process API schema to extract all types
   */
  processApiSchema(commandsSchema: any, responsesSchema: any) {
    // Process the command and response schemas to get type information
    this.getTypeInfo(commandsSchema);
    this.getTypeInfo(responsesSchema);
  }

  /**
   * Generate the shared types file containing all API types and conversion functions
   */
  compile(): string {

    // Generate imports
    const imports = [`import { Buffer } from 'buffer';`];

    // Sort type names for consistent output
    const sortedTypeNames = Object.keys(this.typeInfos).sort();

    // Collect all declarations
    const publicDeclarations: string[] = [];
    const privateDeclarations: string[] = [];
    const toFunctions: string[] = [];
    const fromFunctions: string[] = [];

    for (const typeName of sortedTypeNames) {
      const typeInfo = this.typeInfos[typeName];

      if (typeInfo.declaration) {
        const lines = typeInfo.declaration.split('\n');
        let currentDeclaration: string[] = [];
        let isPublic = false;

        for (const line of lines) {
          if (line.startsWith('export interface')) {
            // Start of a public interface
            if (currentDeclaration.length > 0) {
              if (isPublic) {
                publicDeclarations.push(currentDeclaration.join('\n'));
              } else {
                privateDeclarations.push(currentDeclaration.join('\n'));
              }
            }
            currentDeclaration = [line];
            isPublic = true;
          } else if (line.startsWith('interface Msgpack')) {
            // Start of a private interface
            if (currentDeclaration.length > 0) {
              if (isPublic) {
                publicDeclarations.push(currentDeclaration.join('\n'));
              } else {
                privateDeclarations.push(currentDeclaration.join('\n'));
              }
            }
            currentDeclaration = [line];
            isPublic = false;
          } else if (line.trim() !== '') {
            currentDeclaration.push(line);
          }
        }

        // Don't forget the last declaration
        if (currentDeclaration.length > 0) {
          if (isPublic) {
            publicDeclarations.push(currentDeclaration.join('\n'));
          } else {
            privateDeclarations.push(currentDeclaration.join('\n'));
          }
        }
      }

      if (typeInfo.toClassMethod) {
        toFunctions.push(typeInfo.toClassMethod);
      }

      if (typeInfo.fromClassMethod) {
        fromFunctions.push(typeInfo.fromClassMethod);
      }
    }

    // Generate type alias for Fr
    const frAlias = `export type Fr = Buffer;`;

    // Generate Tuple type
    const tupleType = `type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;
type _TupleOf<T, N extends number, R extends unknown[]> = R['length'] extends N ? R : _TupleOf<T, N, [T, ...R]>;`;

    // Generate mapTuple helper
    const mapTupleHelper = `function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {
  return tuple.map(fn) as Tuple<S, N>;
}`;

    // Combine all parts
    const parts = [
      '// AUTOGENERATED FILE - DO NOT EDIT',
      '// This file contains shared types used across sync, async, and native APIs',
      '',
      ...imports,
      '',
      '// Type aliases',
      frAlias,
      '',
      '// Tuple type for fixed-size arrays',
      tupleType,
      '',
      '// Helper functions',
      mapTupleHelper,
      '',
      '// Public interfaces (exported)',
      ...publicDeclarations,
      '',
      '// Private Msgpack interfaces (not exported)',
      ...privateDeclarations,
      '',
      '// Conversion functions (exported)',
      ...toFunctions.map(fn => 'export ' + fn),
      '',
      ...fromFunctions.map(fn => 'export ' + fn),
    ];

    return parts.join('\n') + '\n';
  }
}
