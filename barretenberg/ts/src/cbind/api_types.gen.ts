// AUTOGENERATED FILE - DO NOT EDIT
// This file contains shared types used across sync, async, and native APIs

import { Buffer } from 'buffer';

// Type aliases
export type Fr = Buffer;

// Tuple type for fixed-size arrays
type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;
type _TupleOf<T, N extends number, R extends unknown[]> = R['length'] extends N ? R : _TupleOf<T, N, [T, ...R]>;

// Helper functions
function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {
  return tuple.map(fn) as Tuple<S, N>;
}

// Public interfaces (exported)
export interface CircuitBenchmark {
  circuit: CircuitInput;
  witness: Buffer;
  settings: ProofSystemSettings;
  numIterations: number;
  benchmarkWitnessGeneration: boolean;
  benchmarkProving: boolean;
}
export interface CircuitBenchmarkResponse {
  witnessGenerationTimeMs: number;
  provingTimeMs: number;
  verificationTimeMs: number;
  peakMemoryBytes: number;
}
export interface CircuitCheck {
  circuit: CircuitInput;
  witness: Buffer;
  settings: ProofSystemSettings;
}
export interface CircuitCheckResponse {
  satisfied: boolean;
}
export interface CircuitComputeVk {
  circuit: CircuitInputNoVK;
  settings: ProofSystemSettings;
}
export interface CircuitComputeVkResponse {
  bytes: Buffer;
}
export interface CircuitInfo {
  circuit: CircuitInput;
  includeGatesPerOpcode: boolean;
  settings: ProofSystemSettings;
}
export interface CircuitInfoResponse {
  totalGates: number;
  subgroupSize: number;
  gatesPerOpcode: Record<string, number>;
}
export interface CircuitInput {
  name: string;
  bytecode: Buffer;
  verificationKey: Buffer;
}
export interface CircuitInputNoVK {
  name: string;
  bytecode: Buffer;
}
export interface CircuitProve {
  circuit: CircuitInput;
  witness: Buffer;
  settings: ProofSystemSettings;
}
export interface CircuitProveAndVerify {
  circuit: CircuitInput;
  witness: Buffer;
  settings: ProofSystemSettings;
}
export interface CircuitProveAndVerifyResponse {
  verified: boolean;
  proof: Fr[];
  publicInputs: Fr[];
}
export interface CircuitProveResponse {
  publicInputs: Fr[];
  proof: Fr[];
}
export interface CircuitVerify {
  verificationKey: Buffer;
  publicInputs: Fr[];
  proof: Fr[];
  settings: ProofSystemSettings;
}
export interface CircuitVerifyResponse {
  verified: boolean;
}
export interface CircuitWriteSolidityVerifier {
  verificationKey: Buffer;
  settings: ProofSystemSettings;
}
export interface CircuitWriteSolidityVerifierResponse {
  solidityCode: string;
}
export interface ClientIvcAccumulate {
  witness: Buffer;
}
export interface ClientIvcAccumulateResponse {}
export interface ClientIvcCheckPrecomputedVk {
  circuit: CircuitInput;
  functionName: string;
}
export interface ClientIvcCheckPrecomputedVkResponse {
  valid: boolean;
}
export interface ClientIvcComputeIvcVk {
  circuit: CircuitInputNoVK;
}
export interface ClientIvcComputeIvcVkResponse {
  bytes: Buffer;
}
export interface ClientIvcComputeStandaloneVk {
  circuit: CircuitInputNoVK;
}
export interface ClientIvcComputeStandaloneVkResponse {
  bytes: Buffer;
  fields: Fr[];
}
export interface ClientIvcLoad {
  circuit: CircuitInput;
}
export interface ClientIvcLoadResponse {}
export interface ClientIvcProve {}
export interface ClientIvcProveResponse {
  proof: Proof;
}
export interface ClientIvcStart {
  numCircuits: number;
}
export interface ClientIvcStartResponse {}
export interface ECCVMProof {
  preIpaProof: Fr[];
  ipaProof: Fr[];
}
export interface GoblinProof {
  mergeProof: Fr[];
  eccvmProof: ECCVMProof;
  translatorProof: Fr[];
}
export interface Proof {
  megaProof: Fr[];
  goblinProof: GoblinProof;
}
export interface ProofAsFields {
  proof: Fr[];
}
export interface ProofAsFieldsResponse {
  fields: Fr[];
}
export interface ProofSystemSettings {
  ipaAccumulation: boolean;
  oracleHashType: string;
  disableZk: boolean;
  honkRecursion: number;
  recursive: boolean;
}
export interface VkAsFields {
  verificationKey: Buffer;
  isMegaHonk: boolean;
}
export interface VkAsFieldsResponse {
  fields: Fr[];
}

// Private Msgpack interfaces (not exported)
interface MsgpackCircuitBenchmark {
  circuit: MsgpackCircuitInput;
  witness: Buffer;
  settings: MsgpackProofSystemSettings;
  num_iterations: number;
  benchmark_witness_generation: boolean;
  benchmark_proving: boolean;
}
interface MsgpackCircuitBenchmarkResponse {
  witness_generation_time_ms: number;
  proving_time_ms: number;
  verification_time_ms: number;
  peak_memory_bytes: number;
}
interface MsgpackCircuitCheck {
  circuit: MsgpackCircuitInput;
  witness: Buffer;
  settings: MsgpackProofSystemSettings;
}
interface MsgpackCircuitCheckResponse {
  satisfied: boolean;
}
interface MsgpackCircuitComputeVk {
  circuit: MsgpackCircuitInputNoVK;
  settings: MsgpackProofSystemSettings;
}
interface MsgpackCircuitComputeVkResponse {
  bytes: Buffer;
}
interface MsgpackCircuitInfo {
  circuit: MsgpackCircuitInput;
  include_gates_per_opcode: boolean;
  settings: MsgpackProofSystemSettings;
}
interface MsgpackCircuitInfoResponse {
  total_gates: number;
  subgroup_size: number;
  gates_per_opcode: Record<string, number>;
}
interface MsgpackCircuitInput {
  name: string;
  bytecode: Buffer;
  verification_key: Buffer;
}
interface MsgpackCircuitInputNoVK {
  name: string;
  bytecode: Buffer;
}
interface MsgpackCircuitProve {
  circuit: MsgpackCircuitInput;
  witness: Buffer;
  settings: MsgpackProofSystemSettings;
}
interface MsgpackCircuitProveAndVerify {
  circuit: MsgpackCircuitInput;
  witness: Buffer;
  settings: MsgpackProofSystemSettings;
}
interface MsgpackCircuitProveAndVerifyResponse {
  verified: boolean;
  proof: Buffer[];
  public_inputs: Buffer[];
}
interface MsgpackCircuitProveResponse {
  public_inputs: Buffer[];
  proof: Buffer[];
}
interface MsgpackCircuitVerify {
  verification_key: Buffer;
  public_inputs: Buffer[];
  proof: Buffer[];
  settings: MsgpackProofSystemSettings;
}
interface MsgpackCircuitVerifyResponse {
  verified: boolean;
}
interface MsgpackCircuitWriteSolidityVerifier {
  verification_key: Buffer;
  settings: MsgpackProofSystemSettings;
}
interface MsgpackCircuitWriteSolidityVerifierResponse {
  solidity_code: string;
}
interface MsgpackClientIvcAccumulate {
  witness: Buffer;
}
interface MsgpackClientIvcAccumulateResponse {}
interface MsgpackClientIvcCheckPrecomputedVk {
  circuit: MsgpackCircuitInput;
  function_name: string;
}
interface MsgpackClientIvcCheckPrecomputedVkResponse {
  valid: boolean;
}
interface MsgpackClientIvcComputeIvcVk {
  circuit: MsgpackCircuitInputNoVK;
}
interface MsgpackClientIvcComputeIvcVkResponse {
  bytes: Buffer;
}
interface MsgpackClientIvcComputeStandaloneVk {
  circuit: MsgpackCircuitInputNoVK;
}
interface MsgpackClientIvcComputeStandaloneVkResponse {
  bytes: Buffer;
  fields: Buffer[];
}
interface MsgpackClientIvcLoad {
  circuit: MsgpackCircuitInput;
}
interface MsgpackClientIvcLoadResponse {}
interface MsgpackClientIvcProve {}
interface MsgpackClientIvcProveResponse {
  proof: MsgpackProof;
}
interface MsgpackClientIvcStart {
  num_circuits: number;
}
interface MsgpackClientIvcStartResponse {}
interface MsgpackECCVMProof {
  pre_ipa_proof: Buffer[];
  ipa_proof: Buffer[];
}
interface MsgpackGoblinProof {
  merge_proof: Buffer[];
  eccvm_proof: MsgpackECCVMProof;
  translator_proof: Buffer[];
}
interface MsgpackProof {
  mega_proof: Buffer[];
  goblin_proof: MsgpackGoblinProof;
}
interface MsgpackProofAsFields {
  proof: Buffer[];
}
interface MsgpackProofAsFieldsResponse {
  fields: Buffer[];
}
interface MsgpackProofSystemSettings {
  ipa_accumulation: boolean;
  oracle_hash_type: string;
  disable_zk: boolean;
  honk_recursion: number;
  recursive: boolean;
}
interface MsgpackVkAsFields {
  verification_key: Buffer;
  is_mega_honk: boolean;
}
interface MsgpackVkAsFieldsResponse {
  fields: Buffer[];
}

// Conversion functions (exported)
export function toCircuitBenchmark(o: MsgpackCircuitBenchmark): CircuitBenchmark {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitBenchmark deserialization"); }
  if (o.witness === undefined) { throw new Error("Expected witness in CircuitBenchmark deserialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitBenchmark deserialization"); }
  if (o.num_iterations === undefined) { throw new Error("Expected num_iterations in CircuitBenchmark deserialization"); }
  if (o.benchmark_witness_generation === undefined) { throw new Error("Expected benchmark_witness_generation in CircuitBenchmark deserialization"); }
  if (o.benchmark_proving === undefined) { throw new Error("Expected benchmark_proving in CircuitBenchmark deserialization"); };
  return {
    circuit: toCircuitInput(o.circuit),
    witness: o.witness,
    settings: toProofSystemSettings(o.settings),
    numIterations: o.num_iterations,
    benchmarkWitnessGeneration: o.benchmark_witness_generation,
    benchmarkProving: o.benchmark_proving,
  };
}
export function toCircuitBenchmarkResponse(o: MsgpackCircuitBenchmarkResponse): CircuitBenchmarkResponse {
  if (o.witness_generation_time_ms === undefined) { throw new Error("Expected witness_generation_time_ms in CircuitBenchmarkResponse deserialization"); }
  if (o.proving_time_ms === undefined) { throw new Error("Expected proving_time_ms in CircuitBenchmarkResponse deserialization"); }
  if (o.verification_time_ms === undefined) { throw new Error("Expected verification_time_ms in CircuitBenchmarkResponse deserialization"); }
  if (o.peak_memory_bytes === undefined) { throw new Error("Expected peak_memory_bytes in CircuitBenchmarkResponse deserialization"); };
  return {
    witnessGenerationTimeMs: o.witness_generation_time_ms,
    provingTimeMs: o.proving_time_ms,
    verificationTimeMs: o.verification_time_ms,
    peakMemoryBytes: o.peak_memory_bytes,
  };
}
export function toCircuitCheck(o: MsgpackCircuitCheck): CircuitCheck {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitCheck deserialization"); }
  if (o.witness === undefined) { throw new Error("Expected witness in CircuitCheck deserialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitCheck deserialization"); };
  return {
    circuit: toCircuitInput(o.circuit),
    witness: o.witness,
    settings: toProofSystemSettings(o.settings),
  };
}
export function toCircuitCheckResponse(o: MsgpackCircuitCheckResponse): CircuitCheckResponse {
  if (o.satisfied === undefined) { throw new Error("Expected satisfied in CircuitCheckResponse deserialization"); };
  return {
    satisfied: o.satisfied,
  };
}
export function toCircuitComputeVk(o: MsgpackCircuitComputeVk): CircuitComputeVk {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitComputeVk deserialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitComputeVk deserialization"); };
  return {
    circuit: toCircuitInputNoVK(o.circuit),
    settings: toProofSystemSettings(o.settings),
  };
}
export function toCircuitComputeVkResponse(o: MsgpackCircuitComputeVkResponse): CircuitComputeVkResponse {
  if (o.bytes === undefined) { throw new Error("Expected bytes in CircuitComputeVkResponse deserialization"); };
  return {
    bytes: o.bytes,
  };
}
export function toCircuitInfo(o: MsgpackCircuitInfo): CircuitInfo {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitInfo deserialization"); }
  if (o.include_gates_per_opcode === undefined) { throw new Error("Expected include_gates_per_opcode in CircuitInfo deserialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitInfo deserialization"); };
  return {
    circuit: toCircuitInput(o.circuit),
    includeGatesPerOpcode: o.include_gates_per_opcode,
    settings: toProofSystemSettings(o.settings),
  };
}
export function toCircuitInfoResponse(o: MsgpackCircuitInfoResponse): CircuitInfoResponse {
  if (o.total_gates === undefined) { throw new Error("Expected total_gates in CircuitInfoResponse deserialization"); }
  if (o.subgroup_size === undefined) { throw new Error("Expected subgroup_size in CircuitInfoResponse deserialization"); }
  if (o.gates_per_opcode === undefined) { throw new Error("Expected gates_per_opcode in CircuitInfoResponse deserialization"); };
  return {
    totalGates: o.total_gates,
    subgroupSize: o.subgroup_size,
    gatesPerOpcode: o.gates_per_opcode,
  };
}
export function toCircuitInput(o: MsgpackCircuitInput): CircuitInput {
  if (o.name === undefined) { throw new Error("Expected name in CircuitInput deserialization"); }
  if (o.bytecode === undefined) { throw new Error("Expected bytecode in CircuitInput deserialization"); }
  if (o.verification_key === undefined) { throw new Error("Expected verification_key in CircuitInput deserialization"); };
  return {
    name: o.name,
    bytecode: o.bytecode,
    verificationKey: o.verification_key,
  };
}
export function toCircuitInputNoVK(o: MsgpackCircuitInputNoVK): CircuitInputNoVK {
  if (o.name === undefined) { throw new Error("Expected name in CircuitInputNoVK deserialization"); }
  if (o.bytecode === undefined) { throw new Error("Expected bytecode in CircuitInputNoVK deserialization"); };
  return {
    name: o.name,
    bytecode: o.bytecode,
  };
}
export function toCircuitProve(o: MsgpackCircuitProve): CircuitProve {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitProve deserialization"); }
  if (o.witness === undefined) { throw new Error("Expected witness in CircuitProve deserialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitProve deserialization"); };
  return {
    circuit: toCircuitInput(o.circuit),
    witness: o.witness,
    settings: toProofSystemSettings(o.settings),
  };
}
export function toCircuitProveAndVerify(o: MsgpackCircuitProveAndVerify): CircuitProveAndVerify {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitProveAndVerify deserialization"); }
  if (o.witness === undefined) { throw new Error("Expected witness in CircuitProveAndVerify deserialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitProveAndVerify deserialization"); };
  return {
    circuit: toCircuitInput(o.circuit),
    witness: o.witness,
    settings: toProofSystemSettings(o.settings),
  };
}
export function toCircuitProveAndVerifyResponse(o: MsgpackCircuitProveAndVerifyResponse): CircuitProveAndVerifyResponse {
  if (o.verified === undefined) { throw new Error("Expected verified in CircuitProveAndVerifyResponse deserialization"); }
  if (o.proof === undefined) { throw new Error("Expected proof in CircuitProveAndVerifyResponse deserialization"); }
  if (o.public_inputs === undefined) { throw new Error("Expected public_inputs in CircuitProveAndVerifyResponse deserialization"); };
  return {
    verified: o.verified,
    proof: o.proof.map((v: Buffer) => v),
    publicInputs: o.public_inputs.map((v: Buffer) => v),
  };
}
export function toCircuitProveResponse(o: MsgpackCircuitProveResponse): CircuitProveResponse {
  if (o.public_inputs === undefined) { throw new Error("Expected public_inputs in CircuitProveResponse deserialization"); }
  if (o.proof === undefined) { throw new Error("Expected proof in CircuitProveResponse deserialization"); };
  return {
    publicInputs: o.public_inputs.map((v: Buffer) => v),
    proof: o.proof.map((v: Buffer) => v),
  };
}
export function toCircuitVerify(o: MsgpackCircuitVerify): CircuitVerify {
  if (o.verification_key === undefined) { throw new Error("Expected verification_key in CircuitVerify deserialization"); }
  if (o.public_inputs === undefined) { throw new Error("Expected public_inputs in CircuitVerify deserialization"); }
  if (o.proof === undefined) { throw new Error("Expected proof in CircuitVerify deserialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitVerify deserialization"); };
  return {
    verificationKey: o.verification_key,
    publicInputs: o.public_inputs.map((v: Buffer) => v),
    proof: o.proof.map((v: Buffer) => v),
    settings: toProofSystemSettings(o.settings),
  };
}
export function toCircuitVerifyResponse(o: MsgpackCircuitVerifyResponse): CircuitVerifyResponse {
  if (o.verified === undefined) { throw new Error("Expected verified in CircuitVerifyResponse deserialization"); };
  return {
    verified: o.verified,
  };
}
export function toCircuitWriteSolidityVerifier(o: MsgpackCircuitWriteSolidityVerifier): CircuitWriteSolidityVerifier {
  if (o.verification_key === undefined) { throw new Error("Expected verification_key in CircuitWriteSolidityVerifier deserialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitWriteSolidityVerifier deserialization"); };
  return {
    verificationKey: o.verification_key,
    settings: toProofSystemSettings(o.settings),
  };
}
export function toCircuitWriteSolidityVerifierResponse(o: MsgpackCircuitWriteSolidityVerifierResponse): CircuitWriteSolidityVerifierResponse {
  if (o.solidity_code === undefined) { throw new Error("Expected solidity_code in CircuitWriteSolidityVerifierResponse deserialization"); };
  return {
    solidityCode: o.solidity_code,
  };
}
export function toClientIvcAccumulate(o: MsgpackClientIvcAccumulate): ClientIvcAccumulate {
  if (o.witness === undefined) { throw new Error("Expected witness in ClientIvcAccumulate deserialization"); };
  return {
    witness: o.witness,
  };
}
export function toClientIvcAccumulateResponse(o: MsgpackClientIvcAccumulateResponse): ClientIvcAccumulateResponse {
  return {};
}
export function toClientIvcCheckPrecomputedVk(o: MsgpackClientIvcCheckPrecomputedVk): ClientIvcCheckPrecomputedVk {
  if (o.circuit === undefined) { throw new Error("Expected circuit in ClientIvcCheckPrecomputedVk deserialization"); }
  if (o.function_name === undefined) { throw new Error("Expected function_name in ClientIvcCheckPrecomputedVk deserialization"); };
  return {
    circuit: toCircuitInput(o.circuit),
    functionName: o.function_name,
  };
}
export function toClientIvcCheckPrecomputedVkResponse(o: MsgpackClientIvcCheckPrecomputedVkResponse): ClientIvcCheckPrecomputedVkResponse {
  if (o.valid === undefined) { throw new Error("Expected valid in ClientIvcCheckPrecomputedVkResponse deserialization"); };
  return {
    valid: o.valid,
  };
}
export function toClientIvcComputeIvcVk(o: MsgpackClientIvcComputeIvcVk): ClientIvcComputeIvcVk {
  if (o.circuit === undefined) { throw new Error("Expected circuit in ClientIvcComputeIvcVk deserialization"); };
  return {
    circuit: toCircuitInputNoVK(o.circuit),
  };
}
export function toClientIvcComputeIvcVkResponse(o: MsgpackClientIvcComputeIvcVkResponse): ClientIvcComputeIvcVkResponse {
  if (o.bytes === undefined) { throw new Error("Expected bytes in ClientIvcComputeIvcVkResponse deserialization"); };
  return {
    bytes: o.bytes,
  };
}
export function toClientIvcComputeStandaloneVk(o: MsgpackClientIvcComputeStandaloneVk): ClientIvcComputeStandaloneVk {
  if (o.circuit === undefined) { throw new Error("Expected circuit in ClientIvcComputeStandaloneVk deserialization"); };
  return {
    circuit: toCircuitInputNoVK(o.circuit),
  };
}
export function toClientIvcComputeStandaloneVkResponse(o: MsgpackClientIvcComputeStandaloneVkResponse): ClientIvcComputeStandaloneVkResponse {
  if (o.bytes === undefined) { throw new Error("Expected bytes in ClientIvcComputeStandaloneVkResponse deserialization"); }
  if (o.fields === undefined) { throw new Error("Expected fields in ClientIvcComputeStandaloneVkResponse deserialization"); };
  return {
    bytes: o.bytes,
    fields: o.fields.map((v: Buffer) => v),
  };
}
export function toClientIvcLoad(o: MsgpackClientIvcLoad): ClientIvcLoad {
  if (o.circuit === undefined) { throw new Error("Expected circuit in ClientIvcLoad deserialization"); };
  return {
    circuit: toCircuitInput(o.circuit),
  };
}
export function toClientIvcLoadResponse(o: MsgpackClientIvcLoadResponse): ClientIvcLoadResponse {
  return {};
}
export function toClientIvcProve(o: MsgpackClientIvcProve): ClientIvcProve {
  return {};
}
export function toClientIvcProveResponse(o: MsgpackClientIvcProveResponse): ClientIvcProveResponse {
  if (o.proof === undefined) { throw new Error("Expected proof in ClientIvcProveResponse deserialization"); };
  return {
    proof: toProof(o.proof),
  };
}
export function toClientIvcStart(o: MsgpackClientIvcStart): ClientIvcStart {
  if (o.num_circuits === undefined) { throw new Error("Expected num_circuits in ClientIvcStart deserialization"); };
  return {
    numCircuits: o.num_circuits,
  };
}
export function toClientIvcStartResponse(o: MsgpackClientIvcStartResponse): ClientIvcStartResponse {
  return {};
}
export function toECCVMProof(o: MsgpackECCVMProof): ECCVMProof {
  if (o.pre_ipa_proof === undefined) { throw new Error("Expected pre_ipa_proof in ECCVMProof deserialization"); }
  if (o.ipa_proof === undefined) { throw new Error("Expected ipa_proof in ECCVMProof deserialization"); };
  return {
    preIpaProof: o.pre_ipa_proof.map((v: Buffer) => v),
    ipaProof: o.ipa_proof.map((v: Buffer) => v),
  };
}
export function toGoblinProof(o: MsgpackGoblinProof): GoblinProof {
  if (o.merge_proof === undefined) { throw new Error("Expected merge_proof in GoblinProof deserialization"); }
  if (o.eccvm_proof === undefined) { throw new Error("Expected eccvm_proof in GoblinProof deserialization"); }
  if (o.translator_proof === undefined) { throw new Error("Expected translator_proof in GoblinProof deserialization"); };
  return {
    mergeProof: o.merge_proof.map((v: Buffer) => v),
    eccvmProof: toECCVMProof(o.eccvm_proof),
    translatorProof: o.translator_proof.map((v: Buffer) => v),
  };
}
export function toProof(o: MsgpackProof): Proof {
  if (o.mega_proof === undefined) { throw new Error("Expected mega_proof in Proof deserialization"); }
  if (o.goblin_proof === undefined) { throw new Error("Expected goblin_proof in Proof deserialization"); };
  return {
    megaProof: o.mega_proof.map((v: Buffer) => v),
    goblinProof: toGoblinProof(o.goblin_proof),
  };
}
export function toProofAsFields(o: MsgpackProofAsFields): ProofAsFields {
  if (o.proof === undefined) { throw new Error("Expected proof in ProofAsFields deserialization"); };
  return {
    proof: o.proof.map((v: Buffer) => v),
  };
}
export function toProofAsFieldsResponse(o: MsgpackProofAsFieldsResponse): ProofAsFieldsResponse {
  if (o.fields === undefined) { throw new Error("Expected fields in ProofAsFieldsResponse deserialization"); };
  return {
    fields: o.fields.map((v: Buffer) => v),
  };
}
export function toProofSystemSettings(o: MsgpackProofSystemSettings): ProofSystemSettings {
  if (o.ipa_accumulation === undefined) { throw new Error("Expected ipa_accumulation in ProofSystemSettings deserialization"); }
  if (o.oracle_hash_type === undefined) { throw new Error("Expected oracle_hash_type in ProofSystemSettings deserialization"); }
  if (o.disable_zk === undefined) { throw new Error("Expected disable_zk in ProofSystemSettings deserialization"); }
  if (o.honk_recursion === undefined) { throw new Error("Expected honk_recursion in ProofSystemSettings deserialization"); }
  if (o.recursive === undefined) { throw new Error("Expected recursive in ProofSystemSettings deserialization"); };
  return {
    ipaAccumulation: o.ipa_accumulation,
    oracleHashType: o.oracle_hash_type,
    disableZk: o.disable_zk,
    honkRecursion: o.honk_recursion,
    recursive: o.recursive,
  };
}
export function toVkAsFields(o: MsgpackVkAsFields): VkAsFields {
  if (o.verification_key === undefined) { throw new Error("Expected verification_key in VkAsFields deserialization"); }
  if (o.is_mega_honk === undefined) { throw new Error("Expected is_mega_honk in VkAsFields deserialization"); };
  return {
    verificationKey: o.verification_key,
    isMegaHonk: o.is_mega_honk,
  };
}
export function toVkAsFieldsResponse(o: MsgpackVkAsFieldsResponse): VkAsFieldsResponse {
  if (o.fields === undefined) { throw new Error("Expected fields in VkAsFieldsResponse deserialization"); };
  return {
    fields: o.fields.map((v: Buffer) => v),
  };
}

export function fromCircuitBenchmark(o: CircuitBenchmark): MsgpackCircuitBenchmark {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitBenchmark serialization"); }
  if (o.witness === undefined) { throw new Error("Expected witness in CircuitBenchmark serialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitBenchmark serialization"); }
  if (o.numIterations === undefined) { throw new Error("Expected numIterations in CircuitBenchmark serialization"); }
  if (o.benchmarkWitnessGeneration === undefined) { throw new Error("Expected benchmarkWitnessGeneration in CircuitBenchmark serialization"); }
  if (o.benchmarkProving === undefined) { throw new Error("Expected benchmarkProving in CircuitBenchmark serialization"); };
  return {
  circuit: fromCircuitInput(o.circuit),
  witness: o.witness,
  settings: fromProofSystemSettings(o.settings),
  num_iterations: o.numIterations,
  benchmark_witness_generation: o.benchmarkWitnessGeneration,
  benchmark_proving: o.benchmarkProving,};
}
export function fromCircuitBenchmarkResponse(o: CircuitBenchmarkResponse): MsgpackCircuitBenchmarkResponse {
  if (o.witnessGenerationTimeMs === undefined) { throw new Error("Expected witnessGenerationTimeMs in CircuitBenchmarkResponse serialization"); }
  if (o.provingTimeMs === undefined) { throw new Error("Expected provingTimeMs in CircuitBenchmarkResponse serialization"); }
  if (o.verificationTimeMs === undefined) { throw new Error("Expected verificationTimeMs in CircuitBenchmarkResponse serialization"); }
  if (o.peakMemoryBytes === undefined) { throw new Error("Expected peakMemoryBytes in CircuitBenchmarkResponse serialization"); };
  return {
  witness_generation_time_ms: o.witnessGenerationTimeMs,
  proving_time_ms: o.provingTimeMs,
  verification_time_ms: o.verificationTimeMs,
  peak_memory_bytes: o.peakMemoryBytes,};
}
export function fromCircuitCheck(o: CircuitCheck): MsgpackCircuitCheck {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitCheck serialization"); }
  if (o.witness === undefined) { throw new Error("Expected witness in CircuitCheck serialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitCheck serialization"); };
  return {
  circuit: fromCircuitInput(o.circuit),
  witness: o.witness,
  settings: fromProofSystemSettings(o.settings),};
}
export function fromCircuitCheckResponse(o: CircuitCheckResponse): MsgpackCircuitCheckResponse {
  if (o.satisfied === undefined) { throw new Error("Expected satisfied in CircuitCheckResponse serialization"); };
  return {
  satisfied: o.satisfied,};
}
export function fromCircuitComputeVk(o: CircuitComputeVk): MsgpackCircuitComputeVk {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitComputeVk serialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitComputeVk serialization"); };
  return {
  circuit: fromCircuitInputNoVK(o.circuit),
  settings: fromProofSystemSettings(o.settings),};
}
export function fromCircuitComputeVkResponse(o: CircuitComputeVkResponse): MsgpackCircuitComputeVkResponse {
  if (o.bytes === undefined) { throw new Error("Expected bytes in CircuitComputeVkResponse serialization"); };
  return {
  bytes: o.bytes,};
}
export function fromCircuitInfo(o: CircuitInfo): MsgpackCircuitInfo {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitInfo serialization"); }
  if (o.includeGatesPerOpcode === undefined) { throw new Error("Expected includeGatesPerOpcode in CircuitInfo serialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitInfo serialization"); };
  return {
  circuit: fromCircuitInput(o.circuit),
  include_gates_per_opcode: o.includeGatesPerOpcode,
  settings: fromProofSystemSettings(o.settings),};
}
export function fromCircuitInfoResponse(o: CircuitInfoResponse): MsgpackCircuitInfoResponse {
  if (o.totalGates === undefined) { throw new Error("Expected totalGates in CircuitInfoResponse serialization"); }
  if (o.subgroupSize === undefined) { throw new Error("Expected subgroupSize in CircuitInfoResponse serialization"); }
  if (o.gatesPerOpcode === undefined) { throw new Error("Expected gatesPerOpcode in CircuitInfoResponse serialization"); };
  return {
  total_gates: o.totalGates,
  subgroup_size: o.subgroupSize,
  gates_per_opcode: o.gatesPerOpcode,};
}
export function fromCircuitInput(o: CircuitInput): MsgpackCircuitInput {
  if (o.name === undefined) { throw new Error("Expected name in CircuitInput serialization"); }
  if (o.bytecode === undefined) { throw new Error("Expected bytecode in CircuitInput serialization"); }
  if (o.verificationKey === undefined) { throw new Error("Expected verificationKey in CircuitInput serialization"); };
  return {
  name: o.name,
  bytecode: o.bytecode,
  verification_key: o.verificationKey,};
}
export function fromCircuitInputNoVK(o: CircuitInputNoVK): MsgpackCircuitInputNoVK {
  if (o.name === undefined) { throw new Error("Expected name in CircuitInputNoVK serialization"); }
  if (o.bytecode === undefined) { throw new Error("Expected bytecode in CircuitInputNoVK serialization"); };
  return {
  name: o.name,
  bytecode: o.bytecode,};
}
export function fromCircuitProve(o: CircuitProve): MsgpackCircuitProve {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitProve serialization"); }
  if (o.witness === undefined) { throw new Error("Expected witness in CircuitProve serialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitProve serialization"); };
  return {
  circuit: fromCircuitInput(o.circuit),
  witness: o.witness,
  settings: fromProofSystemSettings(o.settings),};
}
export function fromCircuitProveAndVerify(o: CircuitProveAndVerify): MsgpackCircuitProveAndVerify {
  if (o.circuit === undefined) { throw new Error("Expected circuit in CircuitProveAndVerify serialization"); }
  if (o.witness === undefined) { throw new Error("Expected witness in CircuitProveAndVerify serialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitProveAndVerify serialization"); };
  return {
  circuit: fromCircuitInput(o.circuit),
  witness: o.witness,
  settings: fromProofSystemSettings(o.settings),};
}
export function fromCircuitProveAndVerifyResponse(o: CircuitProveAndVerifyResponse): MsgpackCircuitProveAndVerifyResponse {
  if (o.verified === undefined) { throw new Error("Expected verified in CircuitProveAndVerifyResponse serialization"); }
  if (o.proof === undefined) { throw new Error("Expected proof in CircuitProveAndVerifyResponse serialization"); }
  if (o.publicInputs === undefined) { throw new Error("Expected publicInputs in CircuitProveAndVerifyResponse serialization"); };
  return {
  verified: o.verified,
  proof: o.proof.map((v: Fr) => v),
  public_inputs: o.publicInputs.map((v: Fr) => v),};
}
export function fromCircuitProveResponse(o: CircuitProveResponse): MsgpackCircuitProveResponse {
  if (o.publicInputs === undefined) { throw new Error("Expected publicInputs in CircuitProveResponse serialization"); }
  if (o.proof === undefined) { throw new Error("Expected proof in CircuitProveResponse serialization"); };
  return {
  public_inputs: o.publicInputs.map((v: Fr) => v),
  proof: o.proof.map((v: Fr) => v),};
}
export function fromCircuitVerify(o: CircuitVerify): MsgpackCircuitVerify {
  if (o.verificationKey === undefined) { throw new Error("Expected verificationKey in CircuitVerify serialization"); }
  if (o.publicInputs === undefined) { throw new Error("Expected publicInputs in CircuitVerify serialization"); }
  if (o.proof === undefined) { throw new Error("Expected proof in CircuitVerify serialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitVerify serialization"); };
  return {
  verification_key: o.verificationKey,
  public_inputs: o.publicInputs.map((v: Fr) => v),
  proof: o.proof.map((v: Fr) => v),
  settings: fromProofSystemSettings(o.settings),};
}
export function fromCircuitVerifyResponse(o: CircuitVerifyResponse): MsgpackCircuitVerifyResponse {
  if (o.verified === undefined) { throw new Error("Expected verified in CircuitVerifyResponse serialization"); };
  return {
  verified: o.verified,};
}
export function fromCircuitWriteSolidityVerifier(o: CircuitWriteSolidityVerifier): MsgpackCircuitWriteSolidityVerifier {
  if (o.verificationKey === undefined) { throw new Error("Expected verificationKey in CircuitWriteSolidityVerifier serialization"); }
  if (o.settings === undefined) { throw new Error("Expected settings in CircuitWriteSolidityVerifier serialization"); };
  return {
  verification_key: o.verificationKey,
  settings: fromProofSystemSettings(o.settings),};
}
export function fromCircuitWriteSolidityVerifierResponse(o: CircuitWriteSolidityVerifierResponse): MsgpackCircuitWriteSolidityVerifierResponse {
  if (o.solidityCode === undefined) { throw new Error("Expected solidityCode in CircuitWriteSolidityVerifierResponse serialization"); };
  return {
  solidity_code: o.solidityCode,};
}
export function fromClientIvcAccumulate(o: ClientIvcAccumulate): MsgpackClientIvcAccumulate {
  if (o.witness === undefined) { throw new Error("Expected witness in ClientIvcAccumulate serialization"); };
  return {
  witness: o.witness,};
}
export function fromClientIvcAccumulateResponse(o: ClientIvcAccumulateResponse): MsgpackClientIvcAccumulateResponse {
  return {};
}
export function fromClientIvcCheckPrecomputedVk(o: ClientIvcCheckPrecomputedVk): MsgpackClientIvcCheckPrecomputedVk {
  if (o.circuit === undefined) { throw new Error("Expected circuit in ClientIvcCheckPrecomputedVk serialization"); }
  if (o.functionName === undefined) { throw new Error("Expected functionName in ClientIvcCheckPrecomputedVk serialization"); };
  return {
  circuit: fromCircuitInput(o.circuit),
  function_name: o.functionName,};
}
export function fromClientIvcCheckPrecomputedVkResponse(o: ClientIvcCheckPrecomputedVkResponse): MsgpackClientIvcCheckPrecomputedVkResponse {
  if (o.valid === undefined) { throw new Error("Expected valid in ClientIvcCheckPrecomputedVkResponse serialization"); };
  return {
  valid: o.valid,};
}
export function fromClientIvcComputeIvcVk(o: ClientIvcComputeIvcVk): MsgpackClientIvcComputeIvcVk {
  if (o.circuit === undefined) { throw new Error("Expected circuit in ClientIvcComputeIvcVk serialization"); };
  return {
  circuit: fromCircuitInputNoVK(o.circuit),};
}
export function fromClientIvcComputeIvcVkResponse(o: ClientIvcComputeIvcVkResponse): MsgpackClientIvcComputeIvcVkResponse {
  if (o.bytes === undefined) { throw new Error("Expected bytes in ClientIvcComputeIvcVkResponse serialization"); };
  return {
  bytes: o.bytes,};
}
export function fromClientIvcComputeStandaloneVk(o: ClientIvcComputeStandaloneVk): MsgpackClientIvcComputeStandaloneVk {
  if (o.circuit === undefined) { throw new Error("Expected circuit in ClientIvcComputeStandaloneVk serialization"); };
  return {
  circuit: fromCircuitInputNoVK(o.circuit),};
}
export function fromClientIvcComputeStandaloneVkResponse(o: ClientIvcComputeStandaloneVkResponse): MsgpackClientIvcComputeStandaloneVkResponse {
  if (o.bytes === undefined) { throw new Error("Expected bytes in ClientIvcComputeStandaloneVkResponse serialization"); }
  if (o.fields === undefined) { throw new Error("Expected fields in ClientIvcComputeStandaloneVkResponse serialization"); };
  return {
  bytes: o.bytes,
  fields: o.fields.map((v: Fr) => v),};
}
export function fromClientIvcLoad(o: ClientIvcLoad): MsgpackClientIvcLoad {
  if (o.circuit === undefined) { throw new Error("Expected circuit in ClientIvcLoad serialization"); };
  return {
  circuit: fromCircuitInput(o.circuit),};
}
export function fromClientIvcLoadResponse(o: ClientIvcLoadResponse): MsgpackClientIvcLoadResponse {
  return {};
}
export function fromClientIvcProve(o: ClientIvcProve): MsgpackClientIvcProve {
  return {};
}
export function fromClientIvcProveResponse(o: ClientIvcProveResponse): MsgpackClientIvcProveResponse {
  if (o.proof === undefined) { throw new Error("Expected proof in ClientIvcProveResponse serialization"); };
  return {
  proof: fromProof(o.proof),};
}
export function fromClientIvcStart(o: ClientIvcStart): MsgpackClientIvcStart {
  if (o.numCircuits === undefined) { throw new Error("Expected numCircuits in ClientIvcStart serialization"); };
  return {
  num_circuits: o.numCircuits,};
}
export function fromClientIvcStartResponse(o: ClientIvcStartResponse): MsgpackClientIvcStartResponse {
  return {};
}
export function fromECCVMProof(o: ECCVMProof): MsgpackECCVMProof {
  if (o.preIpaProof === undefined) { throw new Error("Expected preIpaProof in ECCVMProof serialization"); }
  if (o.ipaProof === undefined) { throw new Error("Expected ipaProof in ECCVMProof serialization"); };
  return {
  pre_ipa_proof: o.preIpaProof.map((v: Fr) => v),
  ipa_proof: o.ipaProof.map((v: Fr) => v),};
}
export function fromGoblinProof(o: GoblinProof): MsgpackGoblinProof {
  if (o.mergeProof === undefined) { throw new Error("Expected mergeProof in GoblinProof serialization"); }
  if (o.eccvmProof === undefined) { throw new Error("Expected eccvmProof in GoblinProof serialization"); }
  if (o.translatorProof === undefined) { throw new Error("Expected translatorProof in GoblinProof serialization"); };
  return {
  merge_proof: o.mergeProof.map((v: Fr) => v),
  eccvm_proof: fromECCVMProof(o.eccvmProof),
  translator_proof: o.translatorProof.map((v: Fr) => v),};
}
export function fromProof(o: Proof): MsgpackProof {
  if (o.megaProof === undefined) { throw new Error("Expected megaProof in Proof serialization"); }
  if (o.goblinProof === undefined) { throw new Error("Expected goblinProof in Proof serialization"); };
  return {
  mega_proof: o.megaProof.map((v: Fr) => v),
  goblin_proof: fromGoblinProof(o.goblinProof),};
}
export function fromProofAsFields(o: ProofAsFields): MsgpackProofAsFields {
  if (o.proof === undefined) { throw new Error("Expected proof in ProofAsFields serialization"); };
  return {
  proof: o.proof.map((v: Fr) => v),};
}
export function fromProofAsFieldsResponse(o: ProofAsFieldsResponse): MsgpackProofAsFieldsResponse {
  if (o.fields === undefined) { throw new Error("Expected fields in ProofAsFieldsResponse serialization"); };
  return {
  fields: o.fields.map((v: Fr) => v),};
}
export function fromProofSystemSettings(o: ProofSystemSettings): MsgpackProofSystemSettings {
  if (o.ipaAccumulation === undefined) { throw new Error("Expected ipaAccumulation in ProofSystemSettings serialization"); }
  if (o.oracleHashType === undefined) { throw new Error("Expected oracleHashType in ProofSystemSettings serialization"); }
  if (o.disableZk === undefined) { throw new Error("Expected disableZk in ProofSystemSettings serialization"); }
  if (o.honkRecursion === undefined) { throw new Error("Expected honkRecursion in ProofSystemSettings serialization"); }
  if (o.recursive === undefined) { throw new Error("Expected recursive in ProofSystemSettings serialization"); };
  return {
  ipa_accumulation: o.ipaAccumulation,
  oracle_hash_type: o.oracleHashType,
  disable_zk: o.disableZk,
  honk_recursion: o.honkRecursion,
  recursive: o.recursive,};
}
export function fromVkAsFields(o: VkAsFields): MsgpackVkAsFields {
  if (o.verificationKey === undefined) { throw new Error("Expected verificationKey in VkAsFields serialization"); }
  if (o.isMegaHonk === undefined) { throw new Error("Expected isMegaHonk in VkAsFields serialization"); };
  return {
  verification_key: o.verificationKey,
  is_mega_honk: o.isMegaHonk,};
}
export function fromVkAsFieldsResponse(o: VkAsFieldsResponse): MsgpackVkAsFieldsResponse {
  if (o.fields === undefined) { throw new Error("Expected fields in VkAsFieldsResponse serialization"); };
  return {
  fields: o.fields.map((v: Fr) => v),};
}
