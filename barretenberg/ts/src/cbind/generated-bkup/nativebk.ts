// AUTOGENERATED FILE - DO NOT EDIT

import { spawn, ChildProcess } from 'child_process';
import { Decoder, Encoder } from 'msgpackr';
import { CircuitBenchmark, CircuitBenchmarkResponse, CircuitCheck, CircuitCheckResponse, CircuitComputeVk, CircuitComputeVkResponse, CircuitInfo, CircuitInfoResponse, CircuitInput, CircuitInputNoVK, CircuitProve, CircuitProveAndVerify, CircuitProveAndVerifyResponse, CircuitProveResponse, CircuitVerify, CircuitVerifyResponse, CircuitWriteSolidityVerifier, CircuitWriteSolidityVerifierResponse, ClientIvcAccumulate, ClientIvcAccumulateResponse, ClientIvcCheckPrecomputedVk, ClientIvcCheckPrecomputedVkResponse, ClientIvcComputeIvcVk, ClientIvcComputeIvcVkResponse, ClientIvcComputeStandaloneVk, ClientIvcComputeStandaloneVkResponse, ClientIvcLoad, ClientIvcLoadResponse, ClientIvcProve, ClientIvcProveResponse, ClientIvcStart, ClientIvcStartResponse, ECCVMProof, Fr, GoblinProof, Proof, ProofAsFields, ProofAsFieldsResponse, ProofSystemSettings, VkAsFields, VkAsFieldsResponse, fromCircuitBenchmark, fromCircuitCheck, fromCircuitComputeVk, fromCircuitInfo, fromCircuitProve, fromCircuitProveAndVerify, fromCircuitVerify, fromCircuitWriteSolidityVerifier, fromClientIvcAccumulate, fromClientIvcCheckPrecomputedVk, fromClientIvcComputeIvcVk, fromClientIvcComputeStandaloneVk, fromClientIvcLoad, fromClientIvcProve, fromClientIvcStart, fromProofAsFields, fromVkAsFields, toCircuitBenchmarkResponse, toCircuitCheckResponse, toCircuitComputeVkResponse, toCircuitInfoResponse, toCircuitProveAndVerifyResponse, toCircuitProveResponse, toCircuitVerifyResponse, toCircuitWriteSolidityVerifierResponse, toClientIvcAccumulateResponse, toClientIvcCheckPrecomputedVkResponse, toClientIvcComputeIvcVkResponse, toClientIvcComputeStandaloneVkResponse, toClientIvcLoadResponse, toClientIvcProveResponse, toClientIvcStartResponse, toProofAsFieldsResponse, toVkAsFieldsResponse } from '../generated/api_types.js';

interface NativeApiRequest {
  resolve: (value: any) => void;
  reject: (error: any) => void;
}

class StreamBuffer {
  private buffer = Buffer.alloc(0);
  private expectedLength: number | null = null;

  addData(data: Buffer): Buffer[] {
    console.log(data.length, data);
    // Use a more efficient approach by growing buffer only when needed
    const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
    this.buffer.copy(newBuffer, 0);
    data.copy(newBuffer, this.buffer.length);
    this.buffer = newBuffer;

    const messages: Buffer[] = [];

    while (true) {
      if (this.expectedLength === null) {
        if (this.buffer.length < 4) break;
        console.log("READING LENGTH")
        this.expectedLength = this.buffer.readUInt32LE(0);
        this.buffer = this.buffer.subarray(4);
      }

      if (this.buffer.length < this.expectedLength) break;

      // Extract complete message
      console.log("EXTRACTING", this.expectedLength, "bytes from buffer");
      const messageBuffer = this.buffer.subarray(0, this.expectedLength);
      messages.push(messageBuffer);
      this.buffer = this.buffer.subarray(this.expectedLength);
      this.expectedLength = null;
    }

    return messages;
  }
}

export class NativeApi {
  private decoder = new Decoder({ useRecords: false });
  private encoder = new Encoder({ useRecords: false });
  private pendingRequests: NativeApiRequest[] = [];

  private constructor(private proc: ChildProcess) {}

  static async new(bbPath = 'bb', errorLogger = console.error): Promise<NativeApi> {
    const proc = spawn(bbPath, ['msgpack', 'run'], {
      stdio: ['pipe', 'pipe', 'inherit'],
    });

    if (!proc.stdout || !proc.stdin) {
      throw new Error('Failed to initialize bb process');
    }

    const api = new NativeApi(proc);
    const streamBuffer = new StreamBuffer();

    proc.stdout.on('data', (data: Buffer) => {
      const messages = streamBuffer.addData(data);

      for (const messageBuffer of messages) {
        const pendingRequest = api.pendingRequests.shift();
        if (!pendingRequest) {
          throw new Error('Received response without a pending request');
        }

        try {
          const decoded = api.decoder.decode(messageBuffer);
          if (!Array.isArray(decoded) || decoded.length !== 2) {
            throw new Error(`Invalid response format: ${JSON.stringify(decoded)}`);
          }
          const [variantName, result] = decoded;
          pendingRequest.resolve([variantName, result]);
        } catch (error) {
          pendingRequest.reject(error);
          break;
        }
      }
    });

    proc.on('error', err => {
      errorLogger('bb process error:', err);
    });

    return api;
  }

  private sendCommand(command: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.pendingRequests.push({ resolve, reject });
      const encoded = this.encoder.encode(command);

      // Write length prefix (4 bytes, little-endian)
      const lengthBuffer = Buffer.allocUnsafe(4);
      lengthBuffer.writeUInt32LE(encoded.length, 0);

      // Write length prefix followed by the encoded data
      this.proc.stdin!.write(lengthBuffer);
      this.proc.stdin!.write(encoded);
    });
  }

  async close(): Promise<void> {
    this.proc.kill();
  }

  async circuitProve(command: CircuitProve): Promise<CircuitProveResponse> {
    const msgpackCommand = fromCircuitProve(command);
    const [variantName, result] = await this.sendCommand(['CircuitProve', msgpackCommand]);
    if (variantName !== 'CircuitProveResponse') {
      throw new Error(`Expected variant name 'CircuitProveResponse' but got '${variantName}'`);
    }
    return toCircuitProveResponse(result);
  }

  async circuitComputeVk(command: CircuitComputeVk): Promise<CircuitComputeVkResponse> {
    const msgpackCommand = fromCircuitComputeVk(command);
    const [variantName, result] = await this.sendCommand(['CircuitComputeVk', msgpackCommand]);
    if (variantName !== 'CircuitComputeVkResponse') {
      throw new Error(`Expected variant name 'CircuitComputeVkResponse' but got '${variantName}'`);
    }
    return toCircuitComputeVkResponse(result);
  }

  async circuitInfo(command: CircuitInfo): Promise<CircuitInfoResponse> {
    const msgpackCommand = fromCircuitInfo(command);
    const [variantName, result] = await this.sendCommand(['CircuitInfo', msgpackCommand]);
    if (variantName !== 'CircuitInfoResponse') {
      throw new Error(`Expected variant name 'CircuitInfoResponse' but got '${variantName}'`);
    }
    return toCircuitInfoResponse(result);
  }

  async circuitCheck(command: CircuitCheck): Promise<CircuitCheckResponse> {
    const msgpackCommand = fromCircuitCheck(command);
    const [variantName, result] = await this.sendCommand(['CircuitCheck', msgpackCommand]);
    if (variantName !== 'CircuitCheckResponse') {
      throw new Error(`Expected variant name 'CircuitCheckResponse' but got '${variantName}'`);
    }
    return toCircuitCheckResponse(result);
  }

  async circuitVerify(command: CircuitVerify): Promise<CircuitVerifyResponse> {
    const msgpackCommand = fromCircuitVerify(command);
    const [variantName, result] = await this.sendCommand(['CircuitVerify', msgpackCommand]);
    if (variantName !== 'CircuitVerifyResponse') {
      throw new Error(`Expected variant name 'CircuitVerifyResponse' but got '${variantName}'`);
    }
    return toCircuitVerifyResponse(result);
  }

  async clientIvcComputeStandaloneVk(
    command: ClientIvcComputeStandaloneVk,
  ): Promise<ClientIvcComputeStandaloneVkResponse> {
    const msgpackCommand = fromClientIvcComputeStandaloneVk(command);
    const [variantName, result] = await this.sendCommand(['ClientIvcComputeStandaloneVk', msgpackCommand]);
    if (variantName !== 'ClientIvcComputeStandaloneVkResponse') {
      throw new Error(`Expected variant name 'ClientIvcComputeStandaloneVkResponse' but got '${variantName}'`);
    }
    return toClientIvcComputeStandaloneVkResponse(result);
  }

  async clientIvcComputeIvcVk(command: ClientIvcComputeIvcVk): Promise<ClientIvcComputeIvcVkResponse> {
    const msgpackCommand = fromClientIvcComputeIvcVk(command);
    const [variantName, result] = await this.sendCommand(['ClientIvcComputeIvcVk', msgpackCommand]);
    if (variantName !== 'ClientIvcComputeIvcVkResponse') {
      throw new Error(`Expected variant name 'ClientIvcComputeIvcVkResponse' but got '${variantName}'`);
    }
    return toClientIvcComputeIvcVkResponse(result);
  }

  async clientIvcStart(command: ClientIvcStart): Promise<ClientIvcStartResponse> {
    const msgpackCommand = fromClientIvcStart(command);
    const [variantName, result] = await this.sendCommand(['ClientIvcStart', msgpackCommand]);
    if (variantName !== 'ClientIvcStartResponse') {
      throw new Error(`Expected variant name 'ClientIvcStartResponse' but got '${variantName}'`);
    }
    return toClientIvcStartResponse(result);
  }

  async clientIvcLoad(command: ClientIvcLoad): Promise<ClientIvcLoadResponse> {
    const msgpackCommand = fromClientIvcLoad(command);
    const [variantName, result] = await this.sendCommand(['ClientIvcLoad', msgpackCommand]);
    if (variantName !== 'ClientIvcLoadResponse') {
      throw new Error(`Expected variant name 'ClientIvcLoadResponse' but got '${variantName}'`);
    }
    return toClientIvcLoadResponse(result);
  }

  async clientIvcAccumulate(command: ClientIvcAccumulate): Promise<ClientIvcAccumulateResponse> {
    const msgpackCommand = fromClientIvcAccumulate(command);
    const [variantName, result] = await this.sendCommand(['ClientIvcAccumulate', msgpackCommand]);
    if (variantName !== 'ClientIvcAccumulateResponse') {
      throw new Error(`Expected variant name 'ClientIvcAccumulateResponse' but got '${variantName}'`);
    }
    return toClientIvcAccumulateResponse(result);
  }

  async clientIvcProve(command: ClientIvcProve): Promise<ClientIvcProveResponse> {
    const msgpackCommand = fromClientIvcProve(command);
    const [variantName, result] = await this.sendCommand(['ClientIvcProve', msgpackCommand]);
    if (variantName !== 'ClientIvcProveResponse') {
      throw new Error(`Expected variant name 'ClientIvcProveResponse' but got '${variantName}'`);
    }
    return toClientIvcProveResponse(result);
  }

  async proofAsFields(command: ProofAsFields): Promise<ProofAsFieldsResponse> {
    const msgpackCommand = fromProofAsFields(command);
    const [variantName, result] = await this.sendCommand(['ProofAsFields', msgpackCommand]);
    if (variantName !== 'ProofAsFieldsResponse') {
      throw new Error(`Expected variant name 'ProofAsFieldsResponse' but got '${variantName}'`);
    }
    return toProofAsFieldsResponse(result);
  }

  async vkAsFields(command: VkAsFields): Promise<VkAsFieldsResponse> {
    const msgpackCommand = fromVkAsFields(command);
    const [variantName, result] = await this.sendCommand(['VkAsFields', msgpackCommand]);
    if (variantName !== 'VkAsFieldsResponse') {
      throw new Error(`Expected variant name 'VkAsFieldsResponse' but got '${variantName}'`);
    }
    return toVkAsFieldsResponse(result);
  }

  async circuitWriteSolidityVerifier(
    command: CircuitWriteSolidityVerifier,
  ): Promise<CircuitWriteSolidityVerifierResponse> {
    const msgpackCommand = fromCircuitWriteSolidityVerifier(command);
    const [variantName, result] = await this.sendCommand(['CircuitWriteSolidityVerifier', msgpackCommand]);
    if (variantName !== 'CircuitWriteSolidityVerifierResponse') {
      throw new Error(`Expected variant name 'CircuitWriteSolidityVerifierResponse' but got '${variantName}'`);
    }
    return toCircuitWriteSolidityVerifierResponse(result);
  }

  async circuitProveAndVerify(command: CircuitProveAndVerify): Promise<CircuitProveAndVerifyResponse> {
    const msgpackCommand = fromCircuitProveAndVerify(command);
    const [variantName, result] = await this.sendCommand(['CircuitProveAndVerify', msgpackCommand]);
    if (variantName !== 'CircuitProveAndVerifyResponse') {
      throw new Error(`Expected variant name 'CircuitProveAndVerifyResponse' but got '${variantName}'`);
    }
    return toCircuitProveAndVerifyResponse(result);
  }

  async circuitBenchmark(command: CircuitBenchmark): Promise<CircuitBenchmarkResponse> {
    const msgpackCommand = fromCircuitBenchmark(command);
    const [variantName, result] = await this.sendCommand(['CircuitBenchmark', msgpackCommand]);
    if (variantName !== 'CircuitBenchmarkResponse') {
      throw new Error(`Expected variant name 'CircuitBenchmarkResponse' but got '${variantName}'`);
    }
    return toCircuitBenchmarkResponse(result);
  }

  async clientIvcCheckPrecomputedVk(
    command: ClientIvcCheckPrecomputedVk,
  ): Promise<ClientIvcCheckPrecomputedVkResponse> {
    const msgpackCommand = fromClientIvcCheckPrecomputedVk(command);
    const [variantName, result] = await this.sendCommand(['ClientIvcCheckPrecomputedVk', msgpackCommand]);
    if (variantName !== 'ClientIvcCheckPrecomputedVkResponse') {
      throw new Error(`Expected variant name 'ClientIvcCheckPrecomputedVkResponse' but got '${variantName}'`);
    }
    return toClientIvcCheckPrecomputedVkResponse(result);
  }
}
