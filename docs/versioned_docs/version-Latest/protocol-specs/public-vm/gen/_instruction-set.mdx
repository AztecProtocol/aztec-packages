[comment]: # (THIS IS A GENERATED FILE! DO NOT EDIT!)
[comment]: # (Generated via `yarn preprocess`)

[comment]: # (Generated by genMarkdown.js, InstructionSet.js, InstructionSize.js)

import Markdown from 'react-markdown'
import CodeBlock from '@theme/CodeBlock'


## Instructions Table

Click on an instruction name to jump to its section.

<table>
<th>Opcode</th><th>Name</th><th>Summary</th><th>Expression</th>
<tr>
	<td style={{'text-align': 'center'}}>0x00</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-add'/><Markdown>\[\`ADD\`\](#isa-section-add)</Markdown></td>
	<td><Markdown>Addition (a + b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] + M[bOffset] mod 2^k`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x01</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-sub'/><Markdown>\[\`SUB\`\](#isa-section-sub)</Markdown></td>
	<td><Markdown>Subtraction (a - b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] - M[bOffset] mod 2^k`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x02</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-mul'/><Markdown>\[\`MUL\`\](#isa-section-mul)</Markdown></td>
	<td><Markdown>Multiplication (a * b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] * M[bOffset] mod 2^k`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x03</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-div'/><Markdown>\[\`DIV\`\](#isa-section-div)</Markdown></td>
	<td><Markdown>Unsigned integer division (a / b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] / M[bOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x04</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-fdiv'/><Markdown>\[\`FDIV\`\](#isa-section-fdiv)</Markdown></td>
	<td><Markdown>Field division (a / b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] / M[bOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x05</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-eq'/><Markdown>\[\`EQ\`\](#isa-section-eq)</Markdown></td>
	<td><Markdown>Equality check (a == b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] == M[bOffset] ? 1 : 0`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x06</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-lt'/><Markdown>\[\`LT\`\](#isa-section-lt)</Markdown></td>
	<td><Markdown>Less-than check (a &lt; b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] < M[bOffset] ? 1 : 0`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x07</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-lte'/><Markdown>\[\`LTE\`\](#isa-section-lte)</Markdown></td>
	<td><Markdown>Less-than-or-equals check (a &lt;= b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] <= M[bOffset] ? 1 : 0`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x08</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-and'/><Markdown>\[\`AND\`\](#isa-section-and)</Markdown></td>
	<td><Markdown>Bitwise AND (a & b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] AND M[bOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x09</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-or'/><Markdown>\[\`OR\`\](#isa-section-or)</Markdown></td>
	<td><Markdown>Bitwise OR (a | b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] OR M[bOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x0a</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-xor'/><Markdown>\[\`XOR\`\](#isa-section-xor)</Markdown></td>
	<td><Markdown>Bitwise XOR (a ^ b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] XOR M[bOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x0b</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-not'/><Markdown>\[\`NOT\`\](#isa-section-not)</Markdown></td>
	<td><Markdown>Bitwise NOT (inversion)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = NOT M[aOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x0c</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-shl'/><Markdown>\[\`SHL\`\](#isa-section-shl)</Markdown></td>
	<td><Markdown>Bitwise leftward shift (a &lt;&lt; b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] << M[bOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x0d</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-shr'/><Markdown>\[\`SHR\`\](#isa-section-shr)</Markdown></td>
	<td><Markdown>Bitwise rightward shift (a &gt;&gt; b)</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[aOffset] >> M[bOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x0e</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-cast'/><Markdown>\[\`CAST\`\](#isa-section-cast)</Markdown></td>
	<td><Markdown>Type cast</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = cast<dstTag>(M[srcOffset])`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x0f</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-getenv'/><Markdown>\[\`GETENVVAR_16\`\](#isa-section-getenv)</Markdown></td>
	<td><Markdown>Get an entry from the context's execution environment</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = context.environment[varEnum]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x10</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-calldatacopy'/><Markdown>\[\`CALLDATACOPY\`\](#isa-section-calldatacopy)</Markdown></td>
	<td><Markdown>Copy a range of words from calldata to memory</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset+M[copySizeOffset]] = context.environment.calldata[cdStartOffset+M[copySizeOffset]]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x11</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-returndatasize'/><Markdown>\[\`RETURNDATASIZE\`\](#isa-section-returndatasize)</Markdown></td>
	<td><Markdown>Get the size of the returndata buffer</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = context.machineState.nestedReturndata.length`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x12</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-returndatacopy'/><Markdown>\[\`RETURNDATACOPY\`\](#isa-section-returndatacopy)</Markdown></td>
	<td><Markdown>Copy a range of words from returndata to memory</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset+M[copySizeOffset]] = context.machineState.nestedReturndata[rdStartOffset+M[copySizeOffset]]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x13</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-jump'/><Markdown>\[\`JUMP_32\`\](#isa-section-jump)</Markdown></td>
	<td><Markdown>Jump to a location in the bytecode</Markdown></td>
	<td><CodeBlock language="jsx">{
		`context.machineState.pc = M[jumpOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x14</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-jumpi'/><Markdown>\[\`JUMPI_32\`\](#isa-section-jumpi)</Markdown></td>
	<td><Markdown>Conditionally jump to a location in the bytecode</Markdown></td>
	<td><CodeBlock language="jsx">{
		`if M[condOffset] > 0: context.machineState.pc = loc`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x15</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-internalcall'/><Markdown>\[\`INTERNALCALL\`\](#isa-section-internalcall)</Markdown></td>
	<td><Markdown>Make an internal call. Push the next PC to the internal call stack and jump to the target location.</Markdown></td>
	<td><CodeBlock language="jsx">
{`context.machineState.internalCallStack.push(context.machineState.nextPc)
context.machineState.pc = loc`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x16</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-internalreturn'/><Markdown>\[\`INTERNALRETURN\`\](#isa-section-internalreturn)</Markdown></td>
	<td><Markdown>Return from an internal call. Pop from the internal call stack and jump to the popped location.</Markdown></td>
	<td><CodeBlock language="jsx">{
		`context.machineState.pc = context.machineState.internalCallStack.pop()`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x17</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-set'/><Markdown>\[\`SET\`\](#isa-section-set)</Markdown></td>
	<td><Markdown>Set a word in memory from a constant in the bytecode</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = cast<inTag>(value)`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x18</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-mov'/><Markdown>\[\`MOV\`\](#isa-section-mov)</Markdown></td>
	<td><Markdown>Move a word from source memory location to destination</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = M[srcOffset]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x19</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-sload'/><Markdown>\[\`SLOAD\`\](#isa-section-sload)</Markdown></td>
	<td><Markdown>Load a word from this contract's persistent public storage. If this slot has never been written before, the value zero is loaded.</Markdown></td>
	<td><CodeBlock language="jsx">
{`M[dstOffset] = S[M[slotOffset]]`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x1a</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-sstore'/><Markdown>\[\`SSTORE\`\](#isa-section-sstore)</Markdown></td>
	<td><Markdown>Write a word to this contract's persistent public storage</Markdown></td>
	<td><CodeBlock language="jsx">
{`S[M[slotOffset]] = M[srcOffset]`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x1b</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-notehashexists'/><Markdown>\[\`NOTEHASHEXISTS\`\](#isa-section-notehashexists)</Markdown></td>
	<td><Markdown>Check whether a note hash exists in the note hash tree</Markdown></td>
	<td><CodeBlock language="jsx">
{`siloedNoteHash = hash(context.environment.address, M[noteHashOffset])
gotSiloedNoteHash = context.worldState.noteHashes.get(/*leafIndex=*/ M[leafIndexOffset])
exists = siloedNoteHash == gotSiloedNoteHash
M[existsOffset] = exists`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x1c</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-emitnotehash'/><Markdown>\[\`EMITNOTEHASH\`\](#isa-section-emitnotehash)</Markdown></td>
	<td><Markdown>Insert a new note hash into the note hash tree</Markdown></td>
	<td><CodeBlock language="jsx">
{`context.worldState.noteHashes.append(
    hash(context.environment.address, M[noteHashOffset])
)`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x1d</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-nullifierexists'/><Markdown>\[\`NULLIFIEREXISTS\`\](#isa-section-nullifierexists)</Markdown></td>
	<td><Markdown>Check whether a nullifier exists in the nullifier tree</Markdown></td>
	<td><CodeBlock language="jsx">
{`exists = context.worldState.nullifiers.has(
    hash(M[addressOffset], M[nullifierOffset])
)
M[existsOffset] = exists`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x1e</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-emitnullifier'/><Markdown>\[\`EMITNULLIFIER\`\](#isa-section-emitnullifier)</Markdown></td>
	<td><Markdown>Insert a new nullifier into the nullifier tree</Markdown></td>
	<td><CodeBlock language="jsx">
{`context.worldState.nullifiers.append(
    hash(context.environment.address, M[nullifierOffset])
)`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x1f</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-l1tol2msgexists'/><Markdown>\[\`L1TOL2MSGEXISTS\`\](#isa-section-l1tol2msgexists)</Markdown></td>
	<td><Markdown>Check if a message exists in the L1-to-L2 message tree</Markdown></td>
	<td><CodeBlock language="jsx">
{`exists = context.worldState.l1ToL2Messages.has({
    leafIndex: M[msgLeafIndexOffset], leaf: M[msgHashOffset]
})
M[existsOffset] = exists`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x20</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-getcontractinstance'/><Markdown>\[\`GETCONTRACTINSTANCE\`\](#isa-section-getcontractinstance)</Markdown></td>
	<td><Markdown>Get a member from the contract instance at the specified address</Markdown></td>
	<td><CodeBlock language="jsx">{
		`M[dstOffset] = context.worldState.contracts.get(M[addressOffset])[memberEnum]`
	}</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x21</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-emitpubliclog'/><Markdown>\[\`EMITPUBLICLOG\`\](#isa-section-emitpubliclog)</Markdown></td>
	<td><Markdown>Emit a public log</Markdown></td>
	<td><CodeBlock language="jsx">
{`context.worldState.publicLogs.append(
    PublicLog {
        address: context.environment.address,
        log: M[logOffset:logOffset+M[logSizeOffset]],
    }
)`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x22</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-sendl2tol1msg'/><Markdown>\[\`SENDL2TOL1MSG\`\](#isa-section-sendl2tol1msg)</Markdown></td>
	<td><Markdown>Send an L2-to-L1 message</Markdown></td>
	<td><CodeBlock language="jsx">
{`context.worldState.l2ToL1Messages.append(
    L2ToL1Message {
        recipientAddress: M[recipientOffset],
        content: M[contentOffset]
    }.scope(context.environment.address)
)`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x23</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-call'/><Markdown>\[\`CALL\`\](#isa-section-call)</Markdown></td>
	<td><Markdown>Call into another contract</Markdown></td>
	<td><CodeBlock language="jsx">
{`contractAddress = M[addrOffset]
allocatedGas = { l2Gas: M[gasOffset], daGas: M[gasOffset+1] }
calldata = M[argsOffset:argsOffset+M[argsSizeOffset]]
isStaticCall = context.environment.isStaticCall
nestedContext = context.createNestedContractCallContext(contractAddress, calldata, allocatedGas, isStaticCall)
output = execute(nestedContext)
context.machineState.nestedReturndata = output`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x24</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-staticcall'/><Markdown>\[\`STATICCALL\`\](#isa-section-staticcall)</Markdown></td>
	<td><Markdown>Call into another contract, disallowing World State modifications</Markdown></td>
	<td><CodeBlock language="jsx">
{`contractAddress = M[addrOffset]
allocatedGas = { l2Gas: M[gasOffset], daGas: M[gasOffset+1] }
calldata = M[argsOffset:argsOffset+M[argsSizeOffset]]
isStaticCall = true
nestedContext = context.createNestedContractCallContext(contractAddress, calldata, allocatedGas, isStaticCall)
output = execute(nestedContext)
context.machineState.nestedReturndata = output`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x25</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-return'/><Markdown>\[\`RETURN\`\](#isa-section-return)</Markdown></td>
	<td><Markdown>Halt execution within this context (without revert), optionally returning some data</Markdown></td>
	<td><CodeBlock language="jsx">
{`context.contractCallResults.output = M[retOffset:retOffset+retSize]
halt`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x26</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-revert'/><Markdown>\[\`REVERT\`\](#isa-section-revert)</Markdown></td>
	<td><Markdown>Halt execution within this context as `reverted`, optionally returning some data</Markdown></td>
	<td><CodeBlock language="jsx">
{`context.contractCallResults.output = M[retOffset:retOffset+retSize]
context.contractCallResults.reverted = true
halt`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x27</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-debuglog'/><Markdown>\[\`DEBUGLOG\`\](#isa-section-debuglog)</Markdown></td>
	<td><Markdown>Print a debug logging message</Markdown></td>
	<td><CodeBlock language="jsx">
{`context.contractCallResults.output = M[retOffset:retOffset+retSize]
context.contractCallResults.reverted = true
halt`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x28</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-poseidon2permutation'/><Markdown>\[\`POSEIDON2PERMUTATION\`\](#isa-section-poseidon2permutation)</Markdown></td>
	<td><Markdown>Convert a word to an array of limbs in little-endian radix form</Markdown></td>
	<td><CodeBlock language="jsx">
{`M[dstOffset:dstOffset+M[numLimbsOffset]] = toRadixBe<M[radixOffset], M[numLimbsOffset], M[outputBitsOffset]>(M[srcOffset])`}
	</CodeBlock></td>
</tr>
<tr>
	<td style={{'text-align': 'center'}}>0x29</td>
	<td style={{'text-align': 'center'}}><a id='isa-table-to_radix_be'/><Markdown>\[\`TORADIXBE\`\](#isa-section-to_radix_be)</Markdown></td>
	<td><Markdown>Convert a word to an array of limbs in little-endian radix form</Markdown></td>
	<td><CodeBlock language="jsx">
{`M[dstOffset:dstOffset+M[numLimbsOffset]] = toRadixBe<M[radixOffset], M[numLimbsOffset], M[outputBitsOffset]>(M[srcOffset])`}
	</CodeBlock></td>
</tr>
</table>


## Instructions

### <a id='isa-section-add'/>`ADD`
Addition (a + b)

[See in table.](#isa-table-add)

- **Opcode**: 0x00
- **Category**: Compute - Arithmetic
- **Variants**: 
	- **ADD_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **ADD_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] + M[bOffset] mod 2^k`
- **Details**: Wraps on overflow
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/ADD.png)](/img/protocol-specs/public-vm/bit-formats/ADD.png)

### <a id='isa-section-sub'/>`SUB`
Subtraction (a - b)

[See in table.](#isa-table-sub)

- **Opcode**: 0x01
- **Category**: Compute - Arithmetic
- **Variants**: 
	- **SUB_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **SUB_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] - M[bOffset] mod 2^k`
- **Details**: Wraps on underflow
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/SUB.png)](/img/protocol-specs/public-vm/bit-formats/SUB.png)

### <a id='isa-section-mul'/>`MUL`
Multiplication (a * b)

[See in table.](#isa-table-mul)

- **Opcode**: 0x02
- **Category**: Compute - Arithmetic
- **Variants**: 
	- **MUL_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **MUL_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] * M[bOffset] mod 2^k`
- **Details**: Wraps on overflow
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/MUL.png)](/img/protocol-specs/public-vm/bit-formats/MUL.png)

### <a id='isa-section-div'/>`DIV`
Unsigned integer division (a / b)

[See in table.](#isa-table-div)

- **Opcode**: 0x03
- **Category**: Compute - Arithmetic
- **Variants**: 
	- **DIV_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **DIV_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] / M[bOffset]`
- **Exceptions**: Exceptional halt if the input is field (is not integral)
- **Tag checks**: `T[aOffset] == T[bOffset] != field`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/DIV.png)](/img/protocol-specs/public-vm/bit-formats/DIV.png)

### <a id='isa-section-fdiv'/>`FDIV`
Field division (a / b)

[See in table.](#isa-table-fdiv)

- **Opcode**: 0x04
- **Category**: Compute - Arithmetic
- **Variants**: 
	- **FDIV_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **FDIV_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] / M[bOffset]`
- **Tag checks**: `T[aOffset] == T[bOffset] == field`
- **Tag updates**: `T[dstOffset] = field`
- **Bit-size**: 120


### <a id='isa-section-eq'/>`EQ`
Equality check (a \=\= b)

[See in table.](#isa-table-eq)

- **Opcode**: 0x05
- **Category**: Compute - Comparators
- **Variants**: 
	- **EQ_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **EQ_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] == M[bOffset] ? 1 : 0`
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = u1`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/EQ.png)](/img/protocol-specs/public-vm/bit-formats/EQ.png)

### <a id='isa-section-lt'/>`LT`
Less-than check (a \< b)

[See in table.](#isa-table-lt)

- **Opcode**: 0x06
- **Category**: Compute - Comparators
- **Variants**: 
	- **LT_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **LT_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] < M[bOffset] ? 1 : 0`
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = u1`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/LT.png)](/img/protocol-specs/public-vm/bit-formats/LT.png)

### <a id='isa-section-lte'/>`LTE`
Less-than-or-equals check (a \<\= b)

[See in table.](#isa-table-lte)

- **Opcode**: 0x07
- **Category**: Compute - Comparators
- **Variants**: 
	- **LTE_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **LTE_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] <= M[bOffset] ? 1 : 0`
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = u1`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/LTE.png)](/img/protocol-specs/public-vm/bit-formats/LTE.png)

### <a id='isa-section-and'/>`AND`
Bitwise AND (a & b)

[See in table.](#isa-table-and)

- **Opcode**: 0x08
- **Category**: Compute - Bitwise
- **Variants**: 
	- **AND_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **AND_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] AND M[bOffset]`
- **Exceptions**: Exceptional halt if the input is field (is not integral)
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/AND.png)](/img/protocol-specs/public-vm/bit-formats/AND.png)

### <a id='isa-section-or'/>`OR`
Bitwise OR (a | b)

[See in table.](#isa-table-or)

- **Opcode**: 0x09
- **Category**: Compute - Bitwise
- **Variants**: 
	- **OR_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **OR_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] OR M[bOffset]`
- **Exceptions**: Exceptional halt if the input is field (is not integral)
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/OR.png)](/img/protocol-specs/public-vm/bit-formats/OR.png)

### <a id='isa-section-xor'/>`XOR`
Bitwise XOR (a ^ b)

[See in table.](#isa-table-xor)

- **Opcode**: 0x0a
- **Category**: Compute - Bitwise
- **Variants**: 
	- **XOR_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **XOR_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] XOR M[bOffset]`
- **Exceptions**: Exceptional halt if the input is field (is not integral)
- **Tag checks**: `T[aOffset] == T[bOffset]`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/XOR.png)](/img/protocol-specs/public-vm/bit-formats/XOR.png)

### <a id='isa-section-not'/>`NOT`
Bitwise NOT (inversion)

[See in table.](#isa-table-not)

- **Opcode**: 0x0b
- **Category**: Compute - Bitwise
- **Variants**: 
	- **NOT_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **NOT_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **aOffset**: memory offset of the operation's input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = NOT M[aOffset]`
- **Exceptions**: Exceptional halt if the input is field (is not integral)
- **Tag checks**: `T[aOffset]`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 88

[![](/img/protocol-specs/public-vm/bit-formats/NOT.png)](/img/protocol-specs/public-vm/bit-formats/NOT.png)

### <a id='isa-section-shl'/>`SHL`
Bitwise leftward shift (a \<\< b)

[See in table.](#isa-table-shl)

- **Opcode**: 0x0c
- **Category**: Compute - Bitwise
- **Variants**: 
	- **SHL_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **SHL_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
	- **inTag**: The [tag/size](./memory-model#tags-and-tagged-memory) to check inputs against and tag the destination with. `field` type is NOT supported for this instruction.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] << M[bOffset]`
- **Tag checks**: `T[aOffset]`, `T[bOffset] == u8`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 128

[![](/img/protocol-specs/public-vm/bit-formats/SHL.png)](/img/protocol-specs/public-vm/bit-formats/SHL.png)

### <a id='isa-section-shr'/>`SHR`
Bitwise rightward shift (a \>\> b)

[See in table.](#isa-table-shr)

- **Opcode**: 0x0d
- **Category**: Compute - Bitwise
- **Variants**: 
	- **SHR_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **SHR_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
	- **inTag**: The [tag/size](./memory-model#tags-and-tagged-memory) to check inputs against and tag the destination with. `field` type is NOT supported for this instruction.
- **Args**: 
	- **aOffset**: memory offset of the operation's left input
	- **bOffset**: memory offset of the operation's right input
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: `M[dstOffset] = M[aOffset] >> M[bOffset]`
- **Tag checks**: `T[aOffset]`, `T[bOffset] == u8`
- **Tag updates**: `T[dstOffset] = T[aOffset]`
- **Bit-size**: 128

[![](/img/protocol-specs/public-vm/bit-formats/SHR.png)](/img/protocol-specs/public-vm/bit-formats/SHR.png)

### <a id='isa-section-cast'/>`CAST`
Type cast

[See in table.](#isa-table-cast)

- **Opcode**: 0x0e
- **Category**: Type Conversions
- **Variants**: 
	- **CAST_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **CAST_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **srcOffset**: memory offset of word to cast
	- **dstOffset**: memory offset specifying where to store operation's result
	- **dstTag**: The [tag/type](./memory-model#tags-and-tagged-memory) to tag the destination with.
- **Expression**: `M[dstOffset] = cast<dstTag>(M[srcOffset])`
- **Details**: Cast a word in memory based on the `dstTag` specified in the bytecode. Truncates (`M[dstOffset] = M[aOffset] mod 2^dstsize`) when casting to a smaller type, left-zero-pads when casting to a larger type. See [here](./memory-model#cast-and-tag-conversions) for more details.
- **Tag updates**: `T[dstOffset] = dstTag`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/CAST.png)](/img/protocol-specs/public-vm/bit-formats/CAST.png)

### <a id='isa-section-getenv'/>`GETENVVAR_16`
Get an entry from the context's execution environment

[See in table.](#isa-table-getenv)

- **Opcode**: 0x0f
- **Category**: Execution Environment
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **dstOffset**: memory offset specifying where to store operation's result
	- **varEnum**: enum value specifying which item to get from the execution environment
- **Expression**: `M[dstOffset] = context.environment[varEnum]`
- **Details**: `Enum: [ ADDRESS, SENDER, TRANSACTIONFEE, CHAINID, VERSION, BLOCKNUMBER, TIMESTAMP, FEEPERL2GAS, FEEPERDAGAS, ISSTATICCALL, L2GASLEFT, DAGASLEFT ]`
- **Tag updates**: `T[dstOffset] = varEnum == TIMESTAMP ? u64 : field`
- **Bit-size**: 64


### <a id='isa-section-calldatacopy'/>`CALLDATACOPY`
Copy a range of words from calldata to memory

[See in table.](#isa-table-calldatacopy)

- **Opcode**: 0x10
- **Category**: Memory - Calldata & Returndata
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **cdStartOffset**: calldata offset specifying the first word to copy to memory
	- **copySizeOffset**: number of words to copy to memory
	- **dstOffset**: memory offset specifying where to store the first copied word
- **Expression**: `M[dstOffset+M[copySizeOffset]] = context.environment.calldata[cdStartOffset+M[copySizeOffset]]`
- **Details**: If the copy would surpass the bounds of calldata, the result is zero-padded to copySizeOffset.
- **Tag updates**: `T[dstOffset+M[copySizeOffset]] = field`
- **Bit-size**: 120

[![](/img/protocol-specs/public-vm/bit-formats/CALLDATACOPY.png)](/img/protocol-specs/public-vm/bit-formats/CALLDATACOPY.png)

### <a id='isa-section-returndatasize'/>`RETURNDATASIZE`
Get the size of the returndata buffer

[See in table.](#isa-table-returndatasize)

- **Opcode**: 0x11
- **Category**: Memory - Calldata & Returndata
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **dstOffset**: memory offset specifying where to store the first copied word
- **Expression**: `M[dstOffset] = context.machineState.nestedReturndata.length`
- **Details**: The returndata buffer holds the returndata from only the latest nested call. If no nested call has been made yet from this context, size zero.
- **Tag updates**: `T[dstOffset+M[copySizeOffset]] = u32`
- **Bit-size**: 56


### <a id='isa-section-returndatacopy'/>`RETURNDATACOPY`
Copy a range of words from returndata to memory

[See in table.](#isa-table-returndatacopy)

- **Opcode**: 0x12
- **Category**: Memory - Calldata & Returndata
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **rdStartOffset**: returndata offset specifying the first word to copy to memory
	- **copySizeOffset**: number of words to copy to memory
	- **dstOffset**: memory offset specifying where to store the first copied word
- **Expression**: `M[dstOffset+M[copySizeOffset]] = context.machineState.nestedReturndata[rdStartOffset+M[copySizeOffset]]`
- **Details**: The returndata buffer holds the returndata from only the latest nested call. If the copy would surpass the bounds of returndata, the result is zero-padded to copySizeOffset.
- **Tag updates**: `T[dstOffset+M[copySizeOffset]] = field`
- **Bit-size**: 120


### <a id='isa-section-jump'/>`JUMP_32`
Jump to a location in the bytecode

[See in table.](#isa-table-jump)

- **Opcode**: 0x13
- **Category**: Machine State - Control Flow
- **Args**: 
	- **loc**: target location to jump to
- **Expression**: `context.machineState.pc = M[jumpOffset]`
- **Details**: Target location is an immediate value (a constant in the bytecode).
- **Bit-size**: 48


### <a id='isa-section-jumpi'/>`JUMPI_32`
Conditionally jump to a location in the bytecode

[See in table.](#isa-table-jumpi)

- **Opcode**: 0x14
- **Category**: Machine State - Control Flow
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **loc**: target location to conditionally jump to
	- **condOffset**: memory offset of the operations 'conditional' input
- **Expression**: `if M[condOffset] > 0: context.machineState.pc = loc`
- **Details**: Target location is an immediate value (a constant in the bytecode). `T[condOffset]` is not checked because the greater-than-zero suboperation is the same regardless of type.
- **Bit-size**: 88


### <a id='isa-section-internalcall'/>`INTERNALCALL`
Make an internal call. Push the next PC to the internal call stack and jump to the target location.

[See in table.](#isa-table-internalcall)

- **Opcode**: 0x15
- **Category**: Machine State - Control Flow
- **Args**: 
	- **loc**: target location to jump/call to
- **Expression**: 
<CodeBlock language="jsx">
{`context.machineState.internalCallStack.push(context.machineState.nextPc)
context.machineState.pc = loc`}
</CodeBlock>
- **Details**: Target location is an immediate value (a constant in the bytecode).
- **Bit-size**: 48


### <a id='isa-section-internalreturn'/>`INTERNALRETURN`
Return from an internal call. Pop from the internal call stack and jump to the popped location.

[See in table.](#isa-table-internalreturn)

- **Opcode**: 0x16
- **Category**: Machine State - Control Flow
- **Expression**: `context.machineState.pc = context.machineState.internalCallStack.pop()`
- **Bit-size**: 16

[![](/img/protocol-specs/public-vm/bit-formats/INTERNALRETURN.png)](/img/protocol-specs/public-vm/bit-formats/INTERNALRETURN.png)

### <a id='isa-section-set'/>`SET`
Set a word in memory from a constant in the bytecode

[See in table.](#isa-table-set)

- **Opcode**: 0x17
- **Category**: Machine State - Memory
- **Variants**: 
	- **SET_8**: Imemediate 'value' operand is 8 bits wide. Note that this does not mean that the destination type/tag will necessarily be 'u8'.
	- **SET_16**: Imemediate 'value' operand is 16 bits wide. Note that this does not mean that the destination type/tag will necessarily be 'u16'.
	- **SET_32**: Imemediate 'value' operand is 32 bits wide. Note that this does not mean that the destination type/tag will necessarily be 'u32'.
	- **SET_64**: Imemediate 'value' operand is 64 bits wide. Note that this does not mean that the destination type/tag will necessarily be 'u64'.
	- **SET_128**: Imemediate 'value' operand is 128 bits wide. Note that this does not mean that the destination type/tag will necessarily be 'u128'.
	- **SET_FF**: Imemediate 'value' operand is a full 254-bit field (FF).  Note that this does not mean that the destination type/tag will necessarily be 'field'.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **dstOffset**: memory offset specifying where to store `value`
	- **inTag**: The [type/size](./memory-model#tags-and-tagged-memory) to cast `value` to and to tag the destination with.
	- **value**: an constant value from the bytecode to store in memory
- **Expression**: `M[dstOffset] = cast<inTag>(value)`
- **Tag updates**: `T[dstOffset] = inTag`
- **Bit-size**: 88+N

[![](/img/protocol-specs/public-vm/bit-formats/SET.png)](/img/protocol-specs/public-vm/bit-formats/SET.png)

### <a id='isa-section-mov'/>`MOV`
Move a word from source memory location to destination

[See in table.](#isa-table-mov)

- **Opcode**: 0x18
- **Category**: Machine State - Memory
- **Variants**: 
	- **MOV_8**: Memory offset operands are 8 bits wide. Note that this does not mean that the resolved memory value is u8.
	- **MOV_16**: Memory offset operands are 16 bits wide. Note that this does not mean that the resolved memory value is u16.
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **srcOffset**: memory offset of the word to move
	- **dstOffset**: memory offset specifying where to store that word
- **Expression**: `M[dstOffset] = M[srcOffset]`
- **Tag updates**: `T[dstOffset] = T[srcOffset]`
- **Bit-size**: 88

[![](/img/protocol-specs/public-vm/bit-formats/MOV.png)](/img/protocol-specs/public-vm/bit-formats/MOV.png)

### <a id='isa-section-sload'/>`SLOAD`
Load a word from this contract's persistent public storage. If this slot has never been written before, the value zero is loaded.

[See in table.](#isa-table-sload)

- **Opcode**: 0x19
- **Category**: World State - Public Storage
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **slotOffset**: memory offset of the storage slot to load from
	- **dstOffset**: memory offset specifying where to store operation's result
- **Expression**: 
<CodeBlock language="jsx">
{`M[dstOffset] = S[M[slotOffset]]`}
</CodeBlock>
- **Details**: Silo the storage slot (hash with contract address), and perform a membership check in the public data tree.
- **Tag updates**: `T[dstOffset] = field`
- **Bit-size**: 88

[![](/img/protocol-specs/public-vm/bit-formats/SLOAD.png)](/img/protocol-specs/public-vm/bit-formats/SLOAD.png)

### <a id='isa-section-sstore'/>`SSTORE`
Write a word to this contract's persistent public storage

[See in table.](#isa-table-sstore)

- **Opcode**: 0x1a
- **Category**: World State - Public Storage
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **srcOffset**: memory offset of the word to store
	- **slotOffset**: memory offset containing the storage slot to store to
- **Expression**: 
<CodeBlock language="jsx">
{`S[M[slotOffset]] = M[srcOffset]`}
</CodeBlock>
- **Details**: Silo the storage slot (hash with contract address), and perform a merkle insertion in the public data tree.
- **Exceptions**: Exceptional halt if this instruction occurs during a static call's execution (`context.environment.isStaticCall == true`).
- **Bit-size**: 88

[![](/img/protocol-specs/public-vm/bit-formats/SSTORE.png)](/img/protocol-specs/public-vm/bit-formats/SSTORE.png)

### <a id='isa-section-notehashexists'/>`NOTEHASHEXISTS`
Check whether a note hash exists in the note hash tree

[See in table.](#isa-table-notehashexists)

- **Opcode**: 0x1b
- **Category**: World State - Notes & Nullifiers
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **noteHashOffset**: memory offset of the note hash
	- **leafIndexOffset**: memory offset of the leaf index
	- **existsOffset**: memory offset specifying where to store operation's result (whether the note hash leaf exists)
- **Expression**: 
<CodeBlock language="jsx">
{`siloedNoteHash = hash(context.environment.address, M[noteHashOffset])
gotSiloedNoteHash = context.worldState.noteHashes.get(/*leafIndex=*/ M[leafIndexOffset])
exists = siloedNoteHash == gotSiloedNoteHash
M[existsOffset] = exists`}
</CodeBlock>
- **Details**: Silo the note hash (hash with storage contract address), and perform a membership check of the note hash tree
- **Tag checks**: T[noteHashOffset] == T[leafIndexOffset] == field
- **Tag updates**: `T[existsOffset] = u1`
- **Bit-size**: 120


### <a id='isa-section-emitnotehash'/>`EMITNOTEHASH`
Insert a new note hash into the note hash tree

[See in table.](#isa-table-emitnotehash)

- **Opcode**: 0x1c
- **Category**: World State - Notes & Nullifiers
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **noteHashOffset**: memory offset of the note hash
- **Expression**: 
<CodeBlock language="jsx">
{`context.worldState.noteHashes.append(
    hash(context.environment.address, M[noteHashOffset])
)`}
</CodeBlock>
- **Details**: Silo the note hash (hash with contract address), make it unique (hash with nonce) and insert into note hash tree
- **Exceptions**: Exceptional halt if this instruction occurs during a static call's execution (`context.environment.isStaticCall == true`).
- **Tag checks**: T[nullifierOffset] == field
- **Bit-size**: 56

[![](/img/protocol-specs/public-vm/bit-formats/EMITNOTEHASH.png)](/img/protocol-specs/public-vm/bit-formats/EMITNOTEHASH.png)

### <a id='isa-section-nullifierexists'/>`NULLIFIEREXISTS`
Check whether a nullifier exists in the nullifier tree

[See in table.](#isa-table-nullifierexists)

- **Opcode**: 0x1d
- **Category**: World State - Notes & Nullifiers
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **nullifierOffset**: memory offset of the unsiloed nullifier
	- **addressOffset**: memory offset of the storage address
	- **existsOffset**: memory offset specifying where to store operation's result (whether the nullifier exists)
- **Expression**: 
<CodeBlock language="jsx">
{`exists = context.worldState.nullifiers.has(
    hash(M[addressOffset], M[nullifierOffset])
)
M[existsOffset] = exists`}
</CodeBlock>
- **Details**: Silo nullifier (hash with storage contract address), check membership in the nullifier tree
- **Tag checks**: T[nullifierOffset] == T[addressOffset] == field
- **Tag updates**: `T[existsOffset] = u1`
- **Bit-size**: 120


### <a id='isa-section-emitnullifier'/>`EMITNULLIFIER`
Insert a new nullifier into the nullifier tree

[See in table.](#isa-table-emitnullifier)

- **Opcode**: 0x1e
- **Category**: World State - Notes & Nullifiers
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **nullifierOffset**: memory offset of nullifier
- **Expression**: 
<CodeBlock language="jsx">
{`context.worldState.nullifiers.append(
    hash(context.environment.address, M[nullifierOffset])
)`}
</CodeBlock>
- **Details**: Silo nullifier (hash with contract address), assert non-membership and insert into nullifier tree
- **Exceptions**: Exceptional halt if the specified nullifier already exists or if this instruction occurs during a static call's execution (`context.environment.isStaticCall == true`).
- **Tag checks**: T[nullifierOffset] == field
- **Bit-size**: 56

[![](/img/protocol-specs/public-vm/bit-formats/EMITNULLIFIER.png)](/img/protocol-specs/public-vm/bit-formats/EMITNULLIFIER.png)

### <a id='isa-section-l1tol2msgexists'/>`L1TOL2MSGEXISTS`
Check if a message exists in the L1-to-L2 message tree

[See in table.](#isa-table-l1tol2msgexists)

- **Opcode**: 0x1f
- **Category**: World State - Messaging
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **msgHashOffset**: memory offset of the message hash
	- **msgLeafIndexOffset**: memory offset of the message's leaf index in the L1-to-L2 message tree
	- **existsOffset**: memory offset specifying where to store operation's result (whether the message exists in the L1-to-L2 message tree)
- **Expression**: 
<CodeBlock language="jsx">
{`exists = context.worldState.l1ToL2Messages.has({
    leafIndex: M[msgLeafIndexOffset], leaf: M[msgHashOffset]
})
M[existsOffset] = exists`}
</CodeBlock>
- **Tag checks**: T[msgHashOffset] == T[msgLeafIndexOffset] == field
- **Tag updates**: T[existsOffset] = u1
- **Bit-size**: 120


### <a id='isa-section-getcontractinstance'/>`GETCONTRACTINSTANCE`
Get a member from the contract instance at the specified address

[See in table.](#isa-table-getcontractinstance)

- **Opcode**: 0x20
- **Category**: Other
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **addressOffset**: memory offset of the contract instance address
	- **dstOffset**: location to write the contract instance member to
	- **existsOffset**: memory offset specifying where to store whether the contract instance exists
	- **memberEnum**: enum value specifying which item to get from the specified contract instance (DEPLOYER, CLASS_ID, INIT_HASH)
- **Expression**: `M[dstOffset] = context.worldState.contracts.get(M[addressOffset])[memberEnum]`
- **Details**: M[dstOffset] will be assigned zero if the contract instance does not exist or if memberEnum is invalid
- **Tag checks**: T[addressOffset] == field
- **Tag updates**: T[dstOffset] = field; T[existsOffset] = u1
- **Bit-size**: 128


### <a id='isa-section-emitpubliclog'/>`EMITPUBLICLOG`
Emit a public log

[See in table.](#isa-table-emitpubliclog)

- **Opcode**: 0x21
- **Category**: World state - Logs
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **logOffset**: memory offset of the data to log
	- **logSizeOffset**: memory offset to number of words to log
- **Expression**: 
<CodeBlock language="jsx">
{`context.worldState.publicLogs.append(
    PublicLog {
        address: context.environment.address,
        log: M[logOffset:logOffset+M[logSizeOffset]],
    }
)`}
</CodeBlock>
- **Tag checks**: T[logSizeOffset] == u32 && T[logOffset:logOffset+M[logSizeOffset]] == field
- **Bit-size**: 88


### <a id='isa-section-sendl2tol1msg'/>`SENDL2TOL1MSG`
Send an L2-to-L1 message

[See in table.](#isa-table-sendl2tol1msg)

- **Opcode**: 0x22
- **Category**: World state - Messaging
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **recipientOffset**: memory offset of the message recipient
	- **contentOffset**: memory offset of the message content
- **Expression**: 
<CodeBlock language="jsx">
{`context.worldState.l2ToL1Messages.append(
    L2ToL1Message {
        recipientAddress: M[recipientOffset],
        content: M[contentOffset]
    }.scope(context.environment.address)
)`}
</CodeBlock>
- **Exceptions**: Exceptional halt if this instruction occurs during a static call's execution (`context.environment.isStaticCall == true`).
- **Tag checks**: T[recipientOffset] == T[contentOffset] == field
- **Bit-size**: 88

[![](/img/protocol-specs/public-vm/bit-formats/SENDL2TOL1MSG.png)](/img/protocol-specs/public-vm/bit-formats/SENDL2TOL1MSG.png)

### <a id='isa-section-call'/>`CALL`
Call into another contract

[See in table.](#isa-table-call)

- **Opcode**: 0x23
- **Category**: Control Flow - External Contract Calls
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **gasOffset**: offset to two words containing `{l2GasLeft, daGasLeft}`: amount of gas to provide to the callee
	- **addrOffset**: address of the contract to call
	- **argsOffset**: memory offset to args (will become the callee's calldata)
	- **argsSizeOffset**: memory offset for the number of words to pass via callee's calldata
	- **successOffset**: destination memory offset specifying where to store the call's success (0: failure, 1: success)
- **Expression**: 
<CodeBlock language="jsx">
{`contractAddress = M[addrOffset]
allocatedGas = { l2Gas: M[gasOffset], daGas: M[gasOffset+1] }
calldata = M[argsOffset:argsOffset+M[argsSizeOffset]]
isStaticCall = context.environment.isStaticCall
nestedContext = context.createNestedContractCallContext(contractAddress, calldata, allocatedGas, isStaticCall)
output = execute(nestedContext)
context.machineState.nestedReturndata = output`}
</CodeBlock>
- **Details**: Creates a new (nested) execution context and triggers execution within that context.
                    Execution proceeds in the nested context until it reaches a halt at which point
                    execution resumes in the current/calling context.
                    A non-existent contract or one with no code will exceptionally halt when called. 
    ["Nested contract calls"](./nested-calls) provides a full explanation of this
    instruction along with the shorthand used in the expression above.
    The explanation includes details on charging gas for nested calls,
    nested context derivation, world state, and updating the parent context
    after the nested call halts.
- **Tag checks**: 
<CodeBlock language="jsx">
{`T[gasOffset] == T[gasOffset+1] == field
T[addrOffset] == field
T[argsSizeOffset] == u32`}
</CodeBlock>
- **Tag updates**: 
<CodeBlock language="jsx">
{`T[successOffset] = u1`}
</CodeBlock>
- **Bit-size**: 184

[![](/img/protocol-specs/public-vm/bit-formats/CALL.png)](/img/protocol-specs/public-vm/bit-formats/CALL.png)

### <a id='isa-section-staticcall'/>`STATICCALL`
Call into another contract, disallowing World State modifications

[See in table.](#isa-table-staticcall)

- **Opcode**: 0x24
- **Category**: Control Flow - External Contract Calls
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **gasOffset**: offset to two words containing `{l2GasLeft, daGasLeft}`: amount of gas to provide to the callee
	- **addrOffset**: address of the contract to call
	- **argsOffset**: memory offset to args (will become the callee's calldata)
	- **argsSizeOffset**: memory offset for the number of words to pass via callee's calldata
	- **successOffset**: destination memory offset specifying where to store the call's success (0: failure, 1: success)
- **Expression**: 
<CodeBlock language="jsx">
{`contractAddress = M[addrOffset]
allocatedGas = { l2Gas: M[gasOffset], daGas: M[gasOffset+1] }
calldata = M[argsOffset:argsOffset+M[argsSizeOffset]]
isStaticCall = true
nestedContext = context.createNestedContractCallContext(contractAddress, calldata, allocatedGas, isStaticCall)
output = execute(nestedContext)
context.machineState.nestedReturndata = output`}
</CodeBlock>
- **Details**: Same as `CALL`, but disallows World State modifications. 
    ["Nested contract calls"](./nested-calls) provides a full explanation of this
    instruction along with the shorthand used in the expression above.
    The explanation includes details on charging gas for nested calls,
    nested context derivation, world state, and updating the parent context
    after the nested call halts.
- **Tag checks**: 
<CodeBlock language="jsx">
{`T[gasOffset] == T[gasOffset+1] == field
T[addrOffset] == field
T[argsSizeOffset] == u32`}
</CodeBlock>
- **Tag updates**: 
<CodeBlock language="jsx">
{`T[successOffset] = u1`}
</CodeBlock>
- **Bit-size**: 184

[![](/img/protocol-specs/public-vm/bit-formats/STATICCALL.png)](/img/protocol-specs/public-vm/bit-formats/STATICCALL.png)

### <a id='isa-section-return'/>`RETURN`
Halt execution within this context (without revert), optionally returning some data

[See in table.](#isa-table-return)

- **Opcode**: 0x25
- **Category**: Control Flow - Contract Calls
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **retOffset**: memory offset of first word to return
	- **retSizeOffset**: meomry offset for the number of words to return
- **Expression**: 
<CodeBlock language="jsx">
{`context.contractCallResults.output = M[retOffset:retOffset+retSize]
halt`}
</CodeBlock>
- **Details**: Return control flow to the calling context/contract. Caller will accept World State modifications. See ["Halting"](./execution#halting) to learn more. See ["Nested contract calls"](./nested-calls) to see how the caller updates its context after the nested call halts.
- **Tag checks**: `T[returnSizeOffset] == u32`
- **Bit-size**: 88

[![](/img/protocol-specs/public-vm/bit-formats/RETURN.png)](/img/protocol-specs/public-vm/bit-formats/RETURN.png)

### <a id='isa-section-revert'/>`REVERT`
Halt execution within this context as `reverted`, optionally returning some data

[See in table.](#isa-table-revert)

- **Opcode**: 0x26
- **Category**: Control Flow - Contract Calls
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **retOffset**: memory offset of first word to return
	- **retSize**: meomry offset for the number of words to return
- **Expression**: 
<CodeBlock language="jsx">
{`context.contractCallResults.output = M[retOffset:retOffset+retSize]
context.contractCallResults.reverted = true
halt`}
</CodeBlock>
- **Details**: Return control flow to the calling context/contract. Caller will reject World State modifications. See ["Halting"](./execution#halting) to learn more. See ["Nested contract calls"](./nested-calls) to see how the caller updates its context after the nested call halts.
- **Tag checks**: `T[returnSizeOffset] == u32`
- **Bit-size**: 88

[![](/img/protocol-specs/public-vm/bit-formats/REVERT.png)](/img/protocol-specs/public-vm/bit-formats/REVERT.png)

### <a id='isa-section-debuglog'/>`DEBUGLOG`
Print a debug logging message

[See in table.](#isa-table-debuglog)

- **Opcode**: 0x27
- **Category**: Debugging
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **messageOffset**: memory offset of first word in the debug message
	- **fieldsOffset**: memory offset of first field to format into the debug message
	- **fieldsSizeOffset**: memory offset of number of fields to be formatted into the debug message
	- **messageSize**: number of characters in the debug message at messageOffset
- **Expression**: 
<CodeBlock language="jsx">
{`context.contractCallResults.output = M[retOffset:retOffset+retSize]
context.contractCallResults.reverted = true
halt`}
</CodeBlock>
- **Details**: Each memory word in 'message' is interpreted as a character code. The message string is then interpreted as a formattable string like 'My debug string with some fields: {0} {1}', where '{0}' will be filled in with the 0th field referenced by fieldsOffset.
- **Tag checks**: 
<CodeBlock language="jsx">
{`T[messageOffset:messageOffset+messageSize] == u8
T[fieldsSizeOffset] == u32
T[fieldsOffset:fieldsOffset+fieldsSizeOffset] == field`}
</CodeBlock>
- **Bit-size**: 136


### <a id='isa-section-poseidon2permutation'/>`POSEIDON2PERMUTATION`
Convert a word to an array of limbs in little-endian radix form

[See in table.](#isa-table-poseidon2permutation)

- **Opcode**: 0x28
- **Category**: Conversions
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **srcOffset**: memory offset of word to convert.
	- **radixOffset**: memory offset to the radix (maximum bit-size of each limb).
	- **numLimbsOffset**: memory offset to the number of limbs the word will be converted into.
	- **outputBitsOffset**: memory offset to the a boolean whether the output should be in bits format (1 bit per memory word)
	- **dstOffset**: memory offset specifying where the first limb of the radix-conversion result is stored.
- **Expression**: 
<CodeBlock language="jsx">
{`M[dstOffset:dstOffset+M[numLimbsOffset]] = toRadixBe<M[radixOffset], M[numLimbsOffset], M[outputBitsOffset]>(M[srcOffset])`}
</CodeBlock>
- **Details**: 
<CodeBlock language="jsx">
{`value = M[srcOffset]
radix = M[radixOffset]
numLimbs = M[numLimbsOffset]
for (let i = numLimbs - 1; i >= 0; i--) {
  const limb = value % radix;
  M[dstOffset+i] = limb;
  value /= radix;
}`}
</CodeBlock>
- **Exceptions**: Exceptional halt if radix < 2 or radix > 256, if numLimbs < 1 but M[srcOffset] is nonzero, if outputBits is true but radix is not 2
- **Tag checks**: 
<CodeBlock language="jsx">
{`T[srcOffset] == field
T[radixOffset] == u32
T[numLimbsOffset] == u32
T[outputBitsOffset] == u1`}
</CodeBlock>
- **Tag updates**: T[dstOffset:dstOffset+M[numLimbsOffset]] = M[outputBitsOffset] ? u1 : u8
- **Bit-size**: 184


### <a id='isa-section-to_radix_be'/>`TORADIXBE`
Convert a word to an array of limbs in little-endian radix form

[See in table.](#isa-table-to_radix_be)

- **Opcode**: 0x29
- **Category**: Conversions
- **Flags**: 
	- **indirect**: Toggles whether each memory-offset argument is an indirect offset. Rightmost bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.
- **Args**: 
	- **srcOffset**: memory offset of word to convert.
	- **radixOffset**: memory offset to the radix (maximum bit-size of each limb).
	- **numLimbsOffset**: memory offset to the number of limbs the word will be converted into.
	- **outputBitsOffset**: memory offset to the a boolean whether the output should be in bits format (1 bit per memory word)
	- **dstOffset**: memory offset specifying where the first limb of the radix-conversion result is stored.
- **Expression**: 
<CodeBlock language="jsx">
{`M[dstOffset:dstOffset+M[numLimbsOffset]] = toRadixBe<M[radixOffset], M[numLimbsOffset], M[outputBitsOffset]>(M[srcOffset])`}
</CodeBlock>
- **Details**: 
<CodeBlock language="jsx">
{`value = M[srcOffset]
radix = M[radixOffset]
numLimbs = M[numLimbsOffset]
for (let i = numLimbs - 1; i >= 0; i--) {
  const limb = value % radix;
  M[dstOffset+i] = limb;
  value /= radix;
}`}
</CodeBlock>
- **Exceptions**: Exceptional halt if radix < 2 or radix > 256, if numLimbs < 1 but M[srcOffset] is nonzero, if outputBits is true but radix is not 2
- **Tag checks**: 
<CodeBlock language="jsx">
{`T[srcOffset] == field
T[radixOffset] == u32
T[numLimbsOffset] == u32
T[outputBitsOffset] == u1`}
</CodeBlock>
- **Tag updates**: T[dstOffset:dstOffset+M[numLimbsOffset]] = M[outputBitsOffset] ? u1 : u8
- **Bit-size**: 184

