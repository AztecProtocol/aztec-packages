const TOPICS_IN_TABLE = [
    'Name', 'Summary', 'Expression'
];
const TOPICS_IN_SECTIONS = [
    'Name', 'Summary', 'Category', 'Args', 'Expression', 'Details', 'Tag checks', 'Tag suboperations'
];
const INSTRUCTION_SET = [
    {
        "code": "",
        "id": "add",
        "Name": "`ADD`",
        "Category": "arithmetic",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] + M[bOffset] mod 2^k`",
        "Summary": "Addition (a + b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "sub",
        "Name": "`SUB`",
        "Category": "arithmetic",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] - M[bOffset] mod 2^k`",
        "Summary": "Subtraction (a - b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "div",
        "Name": "`DIV`",
        "Category": "arithmetic",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] / M[bOffset]`",
        "Summary": "Unsigned division (a / b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "eq",
        "Name": "`EQ`",
        "Category": "conditional",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result", "type": "u8"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] == M[bOffset] ? 1 : 0`",
        "Summary": "Equality check (a == b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "lt",
        "Name": "`LT`",
        "Category": "conditional",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result", "type": "u8"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] < M[bOffset] ? 1 : 0`",
        "Summary": "Less-than check (a < b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "lte",
        "Name": "`LTE`",
        "Category": "conditional",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result", "type": "u8"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] <= M[bOffset] ? 1 : 0`",
        "Summary": "Less-than-or-equals check (a <= b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "and",
        "Name": "`AND`",
        "Category": "bitwise",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] AND M[bOffset]`",
        "Summary": "Bitwise AND (a & b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "or",
        "Name": "`OR`",
        "Category": "bitwise",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] OR M[bOffset]`",
        "Summary": "Bitwise OR (a | b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "xor",
        "Name": "`XOR`",
        "Category": "bitwise",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] XOR M[bOffset]`",
        "Summary": "Bitwise XOR (a ^ b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "not",
        "Name": "`NOT`",
        "Category": "bitwise",
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = NOT M[aOffset]`",
        "Summary": "Bitwise NOT (inversion)",
        "Details": "",
        "Tag checks": "`T[aOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "shl",
        "Name": "`SHL`",
        "Category": "bitwise",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] << M[bOffset]`",
        "Summary": "Bitwise leftward shift (a << b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "shr",
        "Name": "`SHR`",
        "Category": "bitwise",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] >> M[bOffset]`",
        "Summary": "Bitwise rightward shift (a >> b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == op-type`",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "set",
        "Name": "`SET`",
        "Category": "memory",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "const", "description": "a constant value from the bytecode to store in memory", "mode": "immediate", "type": "not field"},
            {"name": "dstOffset", "description": "memory offset specifying where to store the constant"},
        ],
        "Expression": "`M[dstOffset] = const`",
        "Summary": "Set a memory word from a constant in the bytecode.",
        "Details": "Set memory word at `dstOffset` to `const`'s immediate value. `const` _cannot be `field` type_!",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "mov",
        "Name": "`MOV`",
        "Category": "memory",
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "srcOffset", "description": "memory offset of word to move"},
            {"name": "dstOffset", "description": "memory offset specifying where to store that word"},
        ],
        "Expression": "`M[dstOffset] = M[srcOffset]`",
        "Summary": "Move a word from source memory location to destination`.",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = op-type`",
    },
    {
        "code": "",
        "id": "cmov",
        "Name": "`CMOV`",
        "Category": "memory",
        "#memreads": "3",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of word 'a' to conditionally move"},
            {"name": "bOffset", "description": "memory offset of word 'b' to conditionally move"},
            {"name": "condOffset", "description": "memory offset of the operations 'conditional' input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[condOffset] > 0 ? M[aOffset] : M[bOffset]`",
        "Summary": "Move a word (conditionally chosen) from one memory location to another (`d = cond > 0 ? a : b`).",
        "Details": "One of two source memory locations is chosen based on the condition. `T[condOffset]` is not checked because the greater-than-zero suboperation is the same regardless of type.",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = M[condOffset] > 0 ? T[aOffset] : T[bOffset]`",
    },
    {
        "code": "",
        "id": "cast",
        "Name": "`CAST`",
        "Category": "types",
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of word to cast"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = cast<dest-type>(M[aOffset])`",
        "Summary": "Type cast",
        "Details": "Cast a word in memory based on the `dest-type` specified in the bytecode.",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = dest-type`",
    },
    {
        "code": "",
        "id": "calldatacopy",
        "Name": "`CALLDATACOPY`",
        "Category": "contract calls",
        "#memreads": "`s1`",
        "#memwrites": "`s1`",
        "Args": [
            {"name": "cdOffset", "description": "offset into calldata to copy from"},
            {"name": "size", "description": "number of words to copy", "mode": "immediate", "type": "u24"},
            {"name": "dstOffset", "description": "memory offset specifying where to copy the first word to"},
        ],
        "Expression": "`M[dstOffset:dstOffset+size] = calldata[cdOffset:cdOffset+size]`",
        "Summary": "Copy calldata into memory.",
        "Details": "Calldata is read-only and cannot be directly operated on by other instructions. This instruction moves words from calldata into memory so they can be operated on normally.",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset:dstOffset+size] = field`",
    },
    {
        "code": "",
        "id": "sload",
        "Name": "`SLOAD`",
        "Category": "storage",
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "slotOffset", "description": "memory offset of the storage slot to load from"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = storage[M[slotOffset]]`",
        "Summary": "Load a word from storage.",
        "Details": "Load a word from this contract's persistent storage into memory.",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = field`",
    },
    {
        "code": "",
        "id": "sstore",
        "Name": "`SSTORE`",
        "Category": "storage",
        "#memreads": "2",
        "#memwrites": "0",
        "Args": [
            {"name": "srcOffset", "description": "memory offset of the word to store"},
            {"name": "slotOffset", "description": "memory offset containing the storage slot to store to"},
        ],
        "Expression": "`storage[M[slotOffset]] = M[srcOffset]`",
        "Summary": "Write a word to storage.",
        "Details": "Store a word from memory into this contract's persistent storage.",
        "Tag checks": "",
        "Tag suboperations": "",
    },
    {
        "code": "",
        "id": "jump",
        "Name": "`JUMP`",
        "Category": "control",
        "#memreads": "0",
        "#memwrites": "0",
        "Args": [
            {"name": "loc", "description": "target location to jump to", "mode": "immediate", "type": "u24"},
        ],
        "Expression": "`PC = loc`",
        "Summary": "Jump to a location in the bytecode.",
        "Details": "Target location is an immediate value (a constant in the bytecode).",
        "Tag checks": "",
        "Tag suboperations": "",
    },
    {
        "code": "",
        "id": "jumpi",
        "Name": "`JUMPI`",
        "Category": "control",
        "#memreads": "3",
        "#memwrites": "0",
        "Args": [
            {"name": "loc", "description": "target location conditionally jump to", "mode": "immediate", "type": "u24"},
            {"name": "condOffset", "description": "memory offset of the operations 'conditional' input"},
        ],
        "Expression": "`PC = M[condOffset] > 0 ? loc : PC`",
        "Summary": "Conditionally jump to a location in the bytecode.",
        "Details": "Target location is an immediate value (a constant in the bytecode). `T[condOffset]` is not checked because the greater-than-zero suboperation is the same regardless of type.",
        "Tag checks": "",
        "Tag suboperations": "",
    },
    {
        "code": "",
        "id": "return",
        "Name": "`RETURN`",
        "Category": "contract calls",
        "#memreads": "`s1`",
        "#memwrites": "0",
        "Args": [
            {"name": "offset", "description": "memory offset of first word to return"},
            {"name": "size", "description": "number of words to return", "mode": "immediate", "type": "u24"},
        ],
        "Expression": "`return(M[offset:offset+size])`",
        "Summary": "Halt execution with `success`, optionally returning some data.",
        "Details": "Return control flow to the calling context/contract.",
        "Tag checks": "",
        "Tag suboperations": "",
    },
    {
        "code": "",
        "id": "revert",
        "Name": "`REVERT`",
        "Category": "contract calls",
        "#memreads": "`s1`",
        "#memwrites": "0",
        "Args": [
            {"name": "offset", "description": "memory offset of first word to return"},
            {"name": "size", "description": "number of words to return", "mode": "immediate", "type": "u24"},
        ],
        "Expression": "`revert(M[offset:offset+size])`",
        "Summary": "Halt execution with `failure`, optionally returning some data.",
        "Details": "Return control flow to the calling context/contract.",
        "Tag checks": "",
        "Tag suboperations": "",
    },
    {
        "code": "",
        "id": "call",
        "Name": "`CALL`",
        "Category": "contract calls",
        "#memreads": "5",
        "#memwrites": "`1+retSize`",
        "Args": [
            {"name": "l1GasOffset", "description": "amount of L1 gas to provide to the callee"},
            {"name": "l2GasOffset", "description": "amount of L2 gas to provide to the callee"},
            {"name": "addrOffset", "description": "address of the contract to call"},
            {"name": "argsOffset", "description": "memory offset to args (will become the callee's calldata)"},
            {"name": "argsSize", "description": "number of words to pass via callee's calldata", "mode": "immediate", "type": "u24"},
            {"name": "retOffset", "description": "destination memory offset specifying where to store the data returned from the callee"},
            {"name": "retSize", "description": "number of words to copy from data returned by callee", "mode": "immediate", "type": "u24"},
            {"name": "successOffset", "description": "destination memory offset specifying where to store the call's success (0: failure, 1: success)", "type": "u8"},
        ],
        "Expression":`
M[successOffset] = call(
    M[l1GasOffset], M[l2GasOffset], M[addrOffset],
    M[argsOffset], M[argsSize],
    M[retOffset], M[retSize])
`,
        "Summary": "Call into another contract.",
        "Details": `Creates a new CallContext, triggers execution of the corresponding contract code,
                    and then resumes execution in the current CallContext. A non-existent contract or one
                    with no code will return success. Nested call has an incremented \`CallContext.calldepth\`.`,
        "Tag checks": "`T[l1GasOffset] == T[l2GasOffset] == u32`",
        "Tag suboperations": `
T[successOffset] = u8
T[retOffset:retOffset+retSize] = field
`,
    },
    {
        "code": "",
        "id": "staticcall",
        "Name": "`STATICCALL`",
        "Category": "contract calls",
        "#memreads": "5",
        "#memwrites": "`1+retSize`",
        "Args": [
            {"name": "l1GasOffset", "description": "amount of L1 gas to provide to the callee"},
            {"name": "l2GasOffset", "description": "amount of L2 gas to provide to the callee"},
            {"name": "addrOffset", "description": "address of the contract to call"},
            {"name": "argsOffset", "description": "memory offset to args (will become the callee's calldata)"},
            {"name": "argsSize", "description": "number of words to pass via callee's calldata", "mode": "immediate", "type": "u24"},
            {"name": "retOffset", "description": "destination memory offset specifying where to store the data returned from the callee"},
            {"name": "retSize", "description": "number of words to copy from data returned by callee", "mode": "immediate", "type": "u24"},
            {"name": "successOffset", "description": "destination memory offset specifying where to store the call's success (0: failure, 1: success)", "type": "u8"},
        ],
        "Expression": `
M[successOffset] = staticcall(
    M[l1GasOffset], M[l2GasOffset], M[addrOffset],
    M[argsOffset], M[argsSize],
    M[retOffset], M[retSize])
`,
        "Summary": "Call into another contract, disallowing persistent state modifications.",
        "Details": "Same as `CALL`, but the callee is cannot modify persistent state. Disallowed instructions are `SSTORE`, `ULOG`, `CALL`.",
        "Tag checks": "`T[l1GasOffset] == T[l2GasOffset] == u32`",
        "Tag suboperations": `
T[successOffset] = u8
T[retOffset:retOffset+retSize] = field
`,
    },
    {
        "code": "",
        "id": "ulog",
        "Name": "`ULOG`",
        "Category": "logging",
        "#memreads": "`s1`",
        "#memwrites": "0",
        "Args": [
            {"name": "offset", "description": "memory offset of the data to log"},
            {"name": "size", "description": "number of words to log", "mode": "immediate", "type": "u24"},
        ],
        "Expression": "`ulog(M[offset:offset+size])`",
        "Summary": "Emit an unencrypted log with data from the `field` memory page",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "",
    },
    {
        "code": "",
        "id": "chainid",
        "Name": "`CHAINID`",
        "Category": "block info",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.chainId`",
        "Summary": "Get this rollup's L1 chain ID",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "version",
        "Name": "`VERSION`",
        "Category": "block info",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.version`",
        "Summary": "Get this rollup's L2 version ID",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "blocknumber",
        "Name": "`BLOCKNUMBER`",
        "Category": "block info",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.blocknumber`",
        "Summary": "Get this block's number",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "timestamp",
        "Name": "`TIMESTAMP`",
        "Category": "block info",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.timestamp`",
        "Summary": "Get this L2 block's timestamp",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u64`",
    },
    {
        "code": "",
        "id": "coinbase",
        "Name": "`COINBASE`",
        "Category": "block info",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.coinbase`",
        "Summary": "Get the block's beneficiary address",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "blockl1gaslimit",
        "Name": "`TXL1GASLIMIT`",
        "Category": "block info",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.l1GasLimit`",
        "Summary": "Total amount of \"L1 gas\" that a block can consume",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "blockl2gaslimit",
        "Name": "`BLOCKL2GASLIMIT`",
        "Category": "block info",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.l2GasLimit`",
        "Summary": "Total amount of \"L2 gas\" that a block can consume",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "origin",
        "Name": "`ORIGIN`",
        "Category": "tx context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = TxContext.origin`",
        "Summary": "Get the transaction's origination address",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "refundee",
        "Name": "`REFUNDEE`",
        "Category": "tx context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = TxContext.refundee`",
        "Summary": "The recipient of fee refunds for this transaction",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "feeperl1gas",
        "Name": "`FEEPERL1GAS`",
        "Category": "tx context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = TxContext.feePerL1Gas`",
        "Summary": "The fee to be paid per \"L1 gas\" - set by the transaction's original caller",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "feeperl2gas",
        "Name": "`FEEPERL2GAS`",
        "Category": "tx context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = TxContext.feePerL2Gas`",
        "Summary": "The fee to be paid per \"L2 gas\" - set by the transaction's original caller",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "caller",
        "Name": "`CALLER`",
        "Category": "call context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = CallContext.sender`",
        "Summary": "Get the address of the sender (the caller's context)",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "address",
        "Name": "`ADDRESS`",
        "Category": "call context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = CallContext.storageContractAddress`",
        "Summary": "Get the address of the currently executing l2 contract",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "portal",
        "Name": "`PORTAL`",
        "Category": "call context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = CallContext.portalAddress`",
        "Summary": "Get the address of the l1 portal contract",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "calldepth",
        "Name": "`CALLDEPTH`",
        "Category": "call context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = CallContext.calldepth`",
        "Summary": "Get how many calls deep the current call context is",
        "Details": "Note: security issues with EVM's tx.origin can be resolved by asserting the `calldepth == 0`.",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u8`",
    },
    {
        "code": "",
        "id": "l1gas",
        "Name": "`L1GAS`",
        "Category": "latest context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = LatestContext.l1Gas`",
        "Summary": "Remaining \"L1 gas\" for this call (after this instruction).",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "l2gas",
        "Name": "`L2GAS`",
        "Category": "latest context",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = LatestContext.l2Gas`",
        "Summary": "Remaining \"L2 gas\" for this call (after this instruction).",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = u32`",
    },
    {
        "code": "",
        "id": "historicroot",
        "Name": "`<HISTORICROOT>`",
        "Category": "historic access",
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricBlockData.<root>`",
        "Summary": "Get an root from the HistoricBlockData",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dstOffset] = field`",
    },
    {
        "code": "",
        "id": "l1l2msg",
        "Name": "`L1L2MSG`",
        "Category": "l1-l2 messaging",
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "keyOffset", "description": "memory offset of the message key"},
            {"name": "dstMsgOffset", "description": "memory offset specifying where to store the `L1_TO_L2_MESSAGE_LENGTH` words of the retrieved message"},
            {"name": "dstSibPathOffset", "description": "memory offset specifying where to store the `L1_TO_L2_MSG_TREE_HEIGHT` words of the retrieved message's sibling path"},
            {"name": "dstLeafIndexOffset", "description": "memory offset specifying where to store the retrieved message's leaf index"},
            {"name": "dstRootOffset", "description": "memory offset specifying where to store the retrieved message tree root"},
        ],
        "Expression": `
{
    M[dstMsgOffset],
    M[dstSibPathOffset],
    M[dstLeafIndexOffset],
    M[dstRootOffset]
} = getL1ToL2Message(M[keyOffset])
`,
        "Summary": "Retrieve an L1-to-L2 message by key",
        "Details": "",
        "Tag checks": "",
        "Tag suboperations": "`T[dst*Offset] = field`",
    },
];

module.exports = {
  TOPICS_IN_TABLE,
  TOPICS_IN_SECTIONS,
  INSTRUCTION_SET,
};
