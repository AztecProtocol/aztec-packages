const {instructionSize} = require('./InstructionSize');

const TOPICS_IN_TABLE = [
    "Name", "Summary", "Bit-size", "Expression",
];
const TOPICS_IN_SECTIONS = [
    "Name", "Summary", "Category", "Flags", "Args", "Expression", "Details", "Tag checks", "Tag updates", "Bit-size",
];

const IN_TAG_DESCRIPTION = "The [tag/size](./state-model#tags-and-tagged-memory) to check inputs against and tag the destination with.";
const DST_TAG_DESCRIPTION = "The [tag/size](./state-model#tags-and-tagged-memory) to tag the destination with but not to check inputs against.";
const INDIRECT_FLAG_DESCRIPTION = "Toggles whether each memory-offset argument is an indirect offset. 0th bit corresponds to 0th offset arg, etc. Indirect offsets result in memory accesses like `M[M[offset]]` instead of the more standard `M[offset]`.";

const INSTRUCTION_SET_RAW = [
    {
        "id": "add",
        "Name": "`ADD`",
        "Category": "arithmetic",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] + M[bOffset] mod 2^k`",
        "Summary": "Addition (a + b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "sub",
        "Name": "`SUB`",
        "Category": "arithmetic",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] - M[bOffset] mod 2^k`",
        "Summary": "Subtraction (a - b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "div",
        "Name": "`DIV`",
        "Category": "arithmetic",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] / M[bOffset]`",
        "Summary": "Unsigned division (a / b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "eq",
        "Name": "`EQ`",
        "Category": "conditional",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result", "type": "u8"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] == M[bOffset] ? 1 : 0`",
        "Summary": "Equality check (a == b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "lt",
        "Name": "`LT`",
        "Category": "conditional",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result", "type": "u8"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] < M[bOffset] ? 1 : 0`",
        "Summary": "Less-than check (a < b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "lte",
        "Name": "`LTE`",
        "Category": "conditional",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result", "type": "u8"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] <= M[bOffset] ? 1 : 0`",
        "Summary": "Less-than-or-equals check (a <= b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "and",
        "Name": "`AND`",
        "Category": "bitwise",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] AND M[bOffset]`",
        "Summary": "Bitwise AND (a & b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "or",
        "Name": "`OR`",
        "Category": "bitwise",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] OR M[bOffset]`",
        "Summary": "Bitwise OR (a | b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "xor",
        "Name": "`XOR`",
        "Category": "bitwise",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] XOR M[bOffset]`",
        "Summary": "Bitwise XOR (a ^ b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "not",
        "Name": "`NOT`",
        "Category": "bitwise",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = NOT M[aOffset]`",
        "Summary": "Bitwise NOT (inversion)",
        "Details": "",
        "Tag checks": "`T[aOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "shl",
        "Name": "`SHL`",
        "Category": "bitwise",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] << M[bOffset]`",
        "Summary": "Bitwise leftward shift (a << b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "shr",
        "Name": "`SHR`",
        "Category": "bitwise",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": IN_TAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of the operation's left input"},
            {"name": "bOffset", "description": "memory offset of the operation's right input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[aOffset] >> M[bOffset]`",
        "Summary": "Bitwise rightward shift (a >> b)",
        "Details": "",
        "Tag checks": "`T[aOffset] == T[bOffset] == in-tag`",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "cast",
        "Name": "`CAST`",
        "Category": "types",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "dst-tag", "description": DST_TAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of word to cast"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = cast<dst-tag>(M[aOffset])`",
        "Summary": "Type cast",
        "Details": "Cast a word in memory based on the `dst-tag` specified in the bytecode. Truncates (`M[dstOffset] = M[aOffset] mod 2^dstsize`) when casting to a smaller type, left-zero-pads when casting to a larger type. See [here](./state-model#cast-and-tag-conversions) for more details.",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = dst-tag`",
    },
    {
        "id": "set",
        "Name": "`SET`",
        "Category": "memory",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
            {"name": "in-tag", "description": "The [type/size](./state-model#tags-and-tagged-memory) to check inputs against and tag the destination with. `field` type is NOT supported for SET."},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "const", "description": "an N-bit constant value from the bytecode to store in memory (any type except `field`)", "mode": "immediate"},
            {"name": "dstOffset", "description": "memory offset specifying where to store the constant"},
        ],
        "Expression": "`M[dstOffset] = const`",
        "Summary": "Set a memory word from a constant in the bytecode.",
        "Details": "Set memory word at `dstOffset` to `const`'s immediate value. `const`'s bit-size (N) can be 8, 16, 32, 64, or 128 based on `in-tag`. It _cannot be 254 (`field` type)_!",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = in-tag`",
    },
    {
        "id": "mov",
        "Name": "`MOV`",
        "Category": "memory",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "srcOffset", "description": "memory offset of word to move"},
            {"name": "dstOffset", "description": "memory offset specifying where to store that word"},
        ],
        "Expression": "`M[dstOffset] = M[srcOffset]`",
        "Summary": "Move a word from source memory location to destination`.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = T[srcOffset]`",
    },
    {
        "id": "cmov",
        "Name": "`CMOV`",
        "Category": "memory",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "3",
        "#memwrites": "1",
        "Args": [
            {"name": "aOffset", "description": "memory offset of word 'a' to conditionally move"},
            {"name": "bOffset", "description": "memory offset of word 'b' to conditionally move"},
            {"name": "condOffset", "description": "memory offset of the operations 'conditional' input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = M[condOffset] > 0 ? M[aOffset] : M[bOffset]`",
        "Summary": "Move a word (conditionally chosen) from one memory location to another (`d = cond > 0 ? a : b`).",
        "Details": "One of two source memory locations is chosen based on the condition. `T[condOffset]` is not checked because the greater-than-zero suboperation is the same regardless of type.",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = M[condOffset] > 0 ? T[aOffset] : T[bOffset]`",
    },
    {
        "id": "calldatacopy",
        "Name": "`CALLDATACOPY`",
        "Category": "contract calls",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "`s1`",
        "#memwrites": "`s1`",
        "Args": [
            {"name": "cdOffset", "description": "offset into calldata to copy from"},
            {"name": "copySize", "description": "number of words to copy", "mode": "immediate", "type": "u32"},
            {"name": "dstOffset", "description": "memory offset specifying where to copy the first word to"},
        ],
        "Expression": "`M[dstOffset:dstOffset+copySize] = calldata[cdOffset:cdOffset+copySize]`",
        "Summary": "Copy calldata into memory.",
        "Details": "Calldata is read-only and cannot be directly operated on by other instructions. This instruction moves words from calldata into memory so they can be operated on normally.",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset:dstOffset+copySize] = field`",
    },
    {
        "id": "sload",
        "Name": "`SLOAD`",
        "Category": "storage & messaging",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "1",
        "Args": [
            {"name": "slotOffset", "description": "memory offset of the storage slot to load from"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = storage[M[slotOffset]]`",
        "Summary": "Load a word from storage.",
        "Details": "Load a word from this contract's persistent public storage into memory.",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "sstore",
        "Name": "`SSTORE`",
        "Category": "storage & messaging",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "2",
        "#memwrites": "0",
        "Args": [
            {"name": "srcOffset", "description": "memory offset of the word to store"},
            {"name": "slotOffset", "description": "memory offset containing the storage slot to store to"},
        ],
        "Expression": "`storage[M[slotOffset]] = M[srcOffset]`",
        "Summary": "Write a word to storage.",
        "Details": "Store a word from memory into this contract's persistent public storage.",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "emitnotehash",
        "Name": "`EMITNOTEHASH`",
        "Category": "storage & messaging",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "0",
        "Args": [
            {"name": "noteHashOffset", "description": "memory offset of the note hash"},
        ],
        "Expression": `emitNoteHash(M[contentOffset])`,
        "Summary": "Emit a new note hash to be inserted into the notes tree",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "emitnullifier",
        "Name": "`EMITNULLIFIER`",
        "Category": "storage & messaging",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "0",
        "Args": [
            {"name": "nullifierOffset", "description": "memory offset of nullifier"},
        ],
        "Expression": `emitNullifier(M[nullifierOffset])`,
        "Summary": "Emit a new nullifier to be inserted into the nullifier tree",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "sendl2tol1msg",
        "Name": "`SENDL2TOL1MSG`",
        "Category": "storage & messaging",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "0",
        "Args": [
            {"name": "contentOffset", "description": "memory offset of the message content"},
        ],
        "Expression": `sendL2ToL1Message(M[contentOffset])`,
        "Summary": "Send an L2-to-L1 message",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "jump",
        "Name": "`JUMP`",
        "Category": "control",
        "Flags": [],
        "#memreads": "0",
        "#memwrites": "0",
        "Args": [
            {"name": "loc", "description": "target location to jump to", "mode": "immediate", "type": "u32"},
        ],
        "Expression": "`PC = loc`",
        "Summary": "Jump to a location in the bytecode.",
        "Details": "Target location is an immediate value (a constant in the bytecode).",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "jumpi",
        "Name": "`JUMPI`",
        "Category": "control",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "3",
        "#memwrites": "0",
        "Args": [
            {"name": "loc", "description": "target location conditionally jump to", "mode": "immediate", "type": "u32"},
            {"name": "condOffset", "description": "memory offset of the operations 'conditional' input"},
        ],
        "Expression": "`PC = M[condOffset] > 0 ? loc : PC`",
        "Summary": "Conditionally jump to a location in the bytecode.",
        "Details": "Target location is an immediate value (a constant in the bytecode). `T[condOffset]` is not checked because the greater-than-zero suboperation is the same regardless of type.",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "return",
        "Name": "`RETURN`",
        "Category": "contract calls",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "`s1`",
        "#memwrites": "0",
        "Args": [
            {"name": "retOffset", "description": "memory offset of first word to return"},
            {"name": "retSize", "description": "number of words to return", "mode": "immediate", "type": "u32"},
        ],
        "Expression": "`return(M[retOffset:retOffset+retSize])`",
        "Summary": "Halt execution with `success`, optionally returning some data.",
        "Details": "Return control flow to the calling context/contract.",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "revert",
        "Name": "`REVERT`",
        "Category": "contract calls",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "`s1`",
        "#memwrites": "0",
        "Args": [
            {"name": "retOffset", "description": "memory offset of first word to return"},
            {"name": "retSize", "description": "number of words to return", "mode": "immediate", "type": "u32"},
        ],
        "Expression": "`revert(M[retOffset:retOffset+retSize])`",
        "Summary": "Halt execution with `failure`, reverting state changes and optionally returning some data.",
        "Details": "Return control flow to the calling context/contract.",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "call",
        "Name": "`CALL`",
        "Category": "contract calls",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "7",
        "#memwrites": "`1+retSize`",
        "Args": [
            {"name": "gasOffset", "description": "offset to two words containing `{l1Gas, l2Gas}`: amount of L1 and L2 gas to provide to the callee"},
            {"name": "addrOffset", "description": "address of the contract to call"},
            {"name": "argsOffset", "description": "memory offset to args (will become the callee's calldata)"},
            {"name": "argsSize", "description": "number of words to pass via callee's calldata", "mode": "immediate", "type": "u32"},
            {"name": "retOffset", "description": "destination memory offset specifying where to store the data returned from the callee"},
            {"name": "retSize", "description": "number of words to copy from data returned by callee", "mode": "immediate", "type": "u32"},
            {"name": "successOffset", "description": "destination memory offset specifying where to store the call's success (0: failure, 1: success)", "type": "u8"},
        ],
        "Expression":`
M[successOffset] = call(
    M[gasOffset], M[gasOffset+1], M[addrOffset],
    M[argsOffset], M[argsSize],
    M[retOffset], M[retSize])
`,
        "Summary": "Call into another contract.",
        "Details": `Creates a new CallContext, triggers execution of the corresponding contract code,
                    and then resumes execution in the current CallContext. A non-existent contract or one
                    with no code will return success. Nested call has an incremented \`CallContext.calldepth\`.`,
        "Tag checks": "`T[gasOffset] == T[gasOffset+1] == u32`",
        "Tag updates": `
T[successOffset] = u8
T[retOffset:retOffset+retSize] = field
`,
    },
    {
        "id": "staticcall",
        "Name": "`STATICCALL`",
        "Category": "contract calls",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "7",
        "#memwrites": "`1+retSize`",
        "Args": [
            {"name": "gasOffset", "description": "offset to two words containing `{l1Gas, l2Gas}`: amount of L1 and L2 gas to provide to the callee"},
            {"name": "addrOffset", "description": "address of the contract to call"},
            {"name": "argsOffset", "description": "memory offset to args (will become the callee's calldata)"},
            {"name": "argsSize", "description": "number of words to pass via callee's calldata", "mode": "immediate", "type": "u32"},
            {"name": "retOffset", "description": "destination memory offset specifying where to store the data returned from the callee"},
            {"name": "retSize", "description": "number of words to copy from data returned by callee", "mode": "immediate", "type": "u32"},
            {"name": "successOffset", "description": "destination memory offset specifying where to store the call's success (0: failure, 1: success)", "type": "u8"},
        ],
        "Expression": `
M[successOffset] = staticcall(
    M[gasOffset], M[gasOffset+1], M[addrOffset],
    M[argsOffset], M[argsSize],
    M[retOffset], M[retSize])
`,
        "Summary": "Call into another contract, disallowing persistent state modifications.",
        "Details": "Same as `CALL`, but the callee is cannot modify persistent state. Disallowed instructions are `SSTORE`, `ULOG`, `CALL`.",
        "Tag checks": "`T[gasOffset] == T[gasOffset+1] == u32`",
        "Tag updates": `
T[successOffset] = u8
T[retOffset:retOffset+retSize] = field
`,
    },
    {
        "id": "ulog",
        "Name": "`ULOG`",
        "Category": "logging",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "`s1`",
        "#memwrites": "0",
        "Args": [
            {"name": "logOffset", "description": "memory offset of the data to log"},
            {"name": "logSize", "description": "number of words to log", "mode": "immediate", "type": "u32"},
        ],
        "Expression": "`ulog(M[logOffset:logOffset+logSize])`",
        "Summary": "Emit an unencrypted log with data from the `field` memory page",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "",
    },
    {
        "id": "chainid",
        "Name": "`CHAINID`",
        "Category": "block info",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.chainId`",
        "Summary": "Get this rollup's L1 chain ID",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "version",
        "Name": "`VERSION`",
        "Category": "block info",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.version`",
        "Summary": "Get this rollup's L2 version ID",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "blocknumber",
        "Name": "`BLOCKNUMBER`",
        "Category": "block info",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.blocknumber`",
        "Summary": "Get this block's number",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "timestamp",
        "Name": "`TIMESTAMP`",
        "Category": "block info",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.timestamp`",
        "Summary": "Get this L2 block's timestamp",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u64`",
    },
    {
        "id": "coinbase",
        "Name": "`COINBASE`",
        "Category": "block info",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.coinbase`",
        "Summary": "Get the block's beneficiary address",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "blockl1gaslimit",
        "Name": "`BLOCKL1GASLIMIT`",
        "Category": "block info",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.l1GasLimit`",
        "Summary": "Total amount of \"L1 gas\" that a block can consume",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "blockl2gaslimit",
        "Name": "`BLOCKL2GASLIMIT`",
        "Category": "block info",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = Globals.l2GasLimit`",
        "Summary": "Total amount of \"L2 gas\" that a block can consume",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "notesroot",
        "Name": "`NOTESROOT`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].note_hash_tree_root`",
        "Summary": "Get the historical note-hash tree root as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "nullroot",
        "Name": "`NULLIFIERSROOT`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].nullifier_tree_root`",
        "Summary": "Get the historical nullifier tree root as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "contractsroot",
        "Name": "`CONTRACTSROOT`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].contracts_tree_root`",
        "Summary": "Get the historical contracts tree root as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "msgsroot",
        "Name": "`MSGSROOT`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].l1_to_l2_message_tree_root`",
        "Summary": "Get the historical l1-to-l2 message tree root as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "notesroot",
        "Name": "`NOTESROOT`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].note_hash_tree_root`",
        "Summary": "Get the historical note-hash tree root as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "publicdataroot",
        "Name": "`PUBLICDATAROOT`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].public_data_tree_root`",
        "Summary": "Get the historical public data tree root as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "globalshash",
        "Name": "`GLOBALSHASH`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].global_variables_hash`",
        "Summary": "Get the historical global variables hash as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "blocksroot",
        "Name": "`BLOCKSROOT`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].archive_root`",
        "Summary": "Get the historical blocks tree root as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "grandroot",
        "Name": "`GRANDROOT`",
        "Category": "historical access",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "1",
        "#memwrites": "1",
        "Args": [
            {"name": "blockNumOffset", "description": "memory offset of the block number input"},
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = HistoricalBlockData[M[blockNumOffset]].grandfather_tree_root`",
        "Summary": "Get the historical grandfather tree root as of the specified block number.",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = field`",
    },
    {
        "id": "origin",
        "Name": "`ORIGIN`",
        "Category": "tx context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = TxContext.origin`",
        "Summary": "Get the transaction's origination address",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "refundee",
        "Name": "`REFUNDEE`",
        "Category": "tx context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = TxContext.refundee`",
        "Summary": "The recipient of fee refunds for this transaction",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "feeperl1gas",
        "Name": "`FEEPERL1GAS`",
        "Category": "tx context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = TxContext.feePerL1Gas`",
        "Summary": "The fee to be paid per \"L1 gas\" - set by the transaction's original caller",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "feeperl2gas",
        "Name": "`FEEPERL2GAS`",
        "Category": "tx context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = TxContext.feePerL2Gas`",
        "Summary": "The fee to be paid per \"L2 gas\" - set by the transaction's original caller",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "caller",
        "Name": "`CALLER`",
        "Category": "call context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = CallContext.sender`",
        "Summary": "Get the address of the sender (the caller's context)",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "address",
        "Name": "`ADDRESS`",
        "Category": "call context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = CallContext.storageContractAddress`",
        "Summary": "Get the address of the currently executing l2 contract",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "portal",
        "Name": "`PORTAL`",
        "Category": "call context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = CallContext.portalAddress`",
        "Summary": "Get the address of the l1 portal contract",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "calldepth",
        "Name": "`CALLDEPTH`",
        "Category": "call context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = CallContext.calldepth`",
        "Summary": "Get how many calls deep the current call context is",
        "Details": "Note: security issues with EVM's tx.origin can be resolved by asserting the `calldepth == 0`.",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u8`",
    },
    {
        "id": "l1gas",
        "Name": "`L1GAS`",
        "Category": "latest context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = LatestContext.l1Gas`",
        "Summary": "Remaining \"L1 gas\" for this call (after this instruction).",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
    {
        "id": "l2gas",
        "Name": "`L2GAS`",
        "Category": "latest context",
        "Flags": [
            {"name": "indirect", "description": INDIRECT_FLAG_DESCRIPTION},
        ],
        "#memreads": "0",
        "#memwrites": "1",
        "Args": [
            {"name": "dstOffset", "description": "memory offset specifying where to store operation's result"},
        ],
        "Expression": "`M[dstOffset] = LatestContext.l2Gas`",
        "Summary": "Remaining \"L2 gas\" for this call (after this instruction).",
        "Details": "",
        "Tag checks": "",
        "Tag updates": "`T[dstOffset] = u32`",
    },
];
const INSTRUCTION_SET = INSTRUCTION_SET_RAW.map((instr) => {instr['Bit-size'] = instructionSize(instr); return instr;});

module.exports = {
  TOPICS_IN_TABLE,
  TOPICS_IN_SECTIONS,
  INSTRUCTION_SET,
};
