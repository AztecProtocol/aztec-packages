const fs = require("fs");
const path = require("path");

const {
    TOPICS_IN_TABLE,
    TOPICS_IN_SECTIONS,
    INSTRUCTION_SET,
    instructionSize
} = require('./InstructionSet');

function escapeBraces(str) {
    return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function stripBraces(str) {
    return str.replace(/[<>]/g, '');
}

function instructionSetPreface() {
    let preface = "[comment]: # (THIS IS A GENERATED FILE! DO NOT EDIT!)\n";
    preface += "[comment]: # (Generated via `yarn preprocess`)\n\n";
    preface += "[comment]: # (Generated by genMarkdown.js, InstructionSet.js, InstructionSize.js)\n\n";
    preface += "import Markdown from 'react-markdown'\n";
    preface += "import CodeBlock from '@theme/CodeBlock'\n\n";
    return preface;
}

function toOpcode(index) {
    return '0x' + index.toString(16).padStart(2, '0');
}

function htmlInstructionSetTable() {
    let table = "## Instructions Table\n";
    table += "\nClick on an instruction name to jump to its section.\n";
    table += "\n<table>\n";
    let header = "<th>Opcode</th>";
    for (let t = 0; t < TOPICS_IN_TABLE.length; t++) {
        header += `<th>${TOPICS_IN_TABLE[t]}</th>`;
    }
    table += `${header}\n`;

    for (let i = 0; i < INSTRUCTION_SET.length; i++) {
        const instr = INSTRUCTION_SET[i];
        const name = instr['Name'];
        let row = `<tr>\n`;
        row += `\t<td style={{'text-align': 'center'}}>${toOpcode(i)}</td>`;
        row += `\t<td style={{'text-align': 'center'}}><a id='isa-table-${instr['id']}'/><Markdown>[${stripBraces(name)}](#isa-section-${instr['id']})</Markdown></td>`;

        for (let t = 0; t < TOPICS_IN_TABLE.length; t++) {
            const topic = TOPICS_IN_TABLE[t];

            if (topic == 'Name') continue; // skip
            let cell = instr[topic];
            if (cell[0] == '\n') { // if string starts with newline, assume it's a multi-line code block
                cell = `<CodeBlock language="jsx">\n{\`${cell.trim()}\`}\n\t</CodeBlock>`;
            } else if (cell[0] == '`' && topic != 'Name') {
                cell = `<CodeBlock language="jsx">{\n\t\t\`${cell.replace(/`/g, '')}\`\n\t}</CodeBlock>`;
            } else {
                cell = escapeBraces(cell); // escape html
                cell = `<Markdown>${cell}</Markdown>`;
            }
            row += `\n\t<td>${cell}</td>`;
        }
        row += "\n</tr>";
        table += `${row}\n`;
    }
    table += "</table>\n";
    return table;
}

function markdownSublist(items) {
    let markdown = "";
    for (let i = 0; i < items.length; i++) {
        let item = items[i];
        if (typeof item === 'string') {
            markdown += `\n\t- ${item}`;
        } else {
            markdown += `\n\t- **${item['name']}**: ${item['description']}`;
        }
    }
    return markdown;
}

function markdownInstructionSetSection(pathToGenDir) {
    let markdown = "## Instructions\n";
    for (let i = 0; i < INSTRUCTION_SET.length; i++) {
        const instr = INSTRUCTION_SET[i];
        const name = instr['Name'];
        let subsection = `### <a id='isa-section-${instr['id']}'/>${name}\n`;
        subsection += `${instr['Summary']}\n\n`;
        subsection += `[See in table.](#isa-table-${instr['id']})\n\n`;
        subsection += `- **Opcode**: ${toOpcode(i)}\n`;
        for (let t = 0; t < TOPICS_IN_SECTIONS.length; t++) {
            const topic = TOPICS_IN_SECTIONS[t];
            let field = instr[topic];
            if (topic == 'Name' || topic == 'Summary' || !field || field.length == 0) continue; // skip

            let item = `- **${topic}**: `
            if (Array.isArray(field) ) {
                item += markdownSublist(field);
            } else if (field[0] == '\n') { // if string starts with newline, assume it's a multi-line code block
                item += `\n<CodeBlock language="jsx">\n{\`${field.trim()}\`}\n</CodeBlock>`;
            } else {
                item += field;
            }
            subsection += `${item}\n`;
        }
        const bitFormatPath = `./images/bit-formats/${name.replace(/`/g, '')}.png`;
        if (fs.existsSync(`${pathToGenDir}/${bitFormatPath}`)) {
            subsection += `\n[![](${bitFormatPath})](${bitFormatPath})`;
        }
        markdown += `\n${subsection}\n`;
    }
    return markdown;
}

async function generateInstructionSet() {
    const rootDir = path.join(__dirname, "../../../");
    const docsDir = path.join(rootDir, "docs", "docs");

    const relPath = path.relative(docsDir, "docs/public-vm/gen/_instruction-set.mdx");
    const docsFilePath = path.resolve(docsDir, relPath);
    const docsDirName = path.dirname(docsFilePath);
    if (!fs.existsSync(docsDirName)) {
        fs.mkdirSync(docsDirName, { recursive: true });
    }

    const preface = instructionSetPreface();
    const table = htmlInstructionSetTable();
    const section = markdownInstructionSetSection(docsDirName);
    const doc = `${preface}\n${table}\n\n${section}`;
    fs.writeFileSync(docsFilePath, doc);

    console.log("Preprocessing complete.");
}

module.exports = {
    generateInstructionSet,
};