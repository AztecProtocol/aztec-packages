From a90de148a9b444d5a9958bc18a5732537aa051a7 Mon Sep 17 00:00:00 2001
From: TomAFrench <tom@tomfren.ch>
Date: Sat, 15 Mar 2025 15:36:12 +0000
Subject: [PATCH 1/4] chore: turn on `skipLibCheck`

---
 tooling/noir_codegen/tsconfig.json | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tooling/noir_codegen/tsconfig.json b/tooling/noir_codegen/tsconfig.json
index 30dd2a7..a2712fd 100644
--- a/tooling/noir_codegen/tsconfig.json
+++ b/tooling/noir_codegen/tsconfig.json
@@ -10,6 +10,7 @@
     "resolveJsonModule": true,
     "strict": true,
     "noImplicitAny": false,
+    "skipLibCheck": true
   },
   "include": [
     "src/**/*.ts"
-- 
2.43.0

From 2832f741bfbc9dc6e99fd81702afb9c76ff8c7cb Mon Sep 17 00:00:00 2001
From: aakoshh <akosh@aztecprotocol.com>
Date: Mon, 17 Mar 2025 12:10:58 +0000
Subject: [PATCH 2/4] Ignore package.tgz

---
 .gitignore | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/.gitignore b/.gitignore
index 3349018..c93fe8e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -59,3 +59,6 @@ codegen
 
 mutants.out
 mutants.out.old
+
+# Artifacts created by `noir/bootstrap.sh build_packages`
+**/package.tgz
-- 
2.43.0

From 222cd7dea6005b540f710684d89d6e63727df9ed Mon Sep 17 00:00:00 2001
From: sirasistant <sirasistant@gmail.com>
Date: Fri, 21 Mar 2025 15:04:11 +0000
Subject: [PATCH 4/4] fix: ecadd and scalar mul blackbox interface

---
 acvm-repo/brillig_vm/src/black_box.rs               |  6 +++---
 compiler/noirc_evaluator/src/acir/mod.rs            |  2 +-
 .../src/ssa/ir/instruction/call/blackbox.rs         | 11 +++++------
 noir_stdlib/src/embedded_curve_ops.nr               | 13 ++++---------
 noir_stdlib/src/hash/mod.nr                         |  2 +-
 5 files changed, 14 insertions(+), 20 deletions(-)

diff --git a/acvm-repo/brillig_vm/src/black_box.rs b/acvm-repo/brillig_vm/src/black_box.rs
index 74ea356..7ea7201 100644
--- a/acvm-repo/brillig_vm/src/black_box.rs
+++ b/acvm-repo/brillig_vm/src/black_box.rs
@@ -1,4 +1,4 @@
-use acir::brillig::{BlackBoxOp, HeapArray, HeapVector};
+use acir::brillig::{BlackBoxOp, HeapArray, HeapVector, IntegerBitSize};
 use acir::{AcirField, BlackBoxFunc};
 use acvm_blackbox_solver::{
     BigIntSolverWithId, BlackBoxFunctionSolver, BlackBoxResolutionError, aes128_encrypt, blake2s,
@@ -173,7 +173,7 @@ pub(crate) fn evaluate_black_box<F: AcirField, Solver: BlackBoxFunctionSolver<F>
                 &[
                     MemoryValue::new_field(x),
                     MemoryValue::new_field(y),
-                    MemoryValue::new_field(is_infinite),
+                    MemoryValue::new_integer(is_infinite.to_u128(), IntegerBitSize::U1),
                 ],
             );
             Ok(())
@@ -206,7 +206,7 @@ pub(crate) fn evaluate_black_box<F: AcirField, Solver: BlackBoxFunctionSolver<F>
                 &[
                     MemoryValue::new_field(x),
                     MemoryValue::new_field(y),
-                    MemoryValue::new_field(infinite),
+                    MemoryValue::new_integer(infinite.to_u128(), IntegerBitSize::U1),
                 ],
             );
             Ok(())
diff --git a/compiler/noirc_evaluator/src/acir/mod.rs b/compiler/noirc_evaluator/src/acir/mod.rs
index 749f3e0..f36764a 100644
--- a/compiler/noirc_evaluator/src/acir/mod.rs
+++ b/compiler/noirc_evaluator/src/acir/mod.rs
@@ -2188,7 +2188,7 @@ impl<'a> Context<'a> {
                 let inputs = vecmap(&arguments_no_slice_len, |arg| self.convert_value(*arg, dfg));
 
                 let output_count = result_ids.iter().fold(0usize, |sum, result_id| {
-                    sum + dfg.try_get_array_length(*result_id).unwrap_or(1) as usize
+                    sum + dfg.type_of_value(*result_id).flattened_size() as usize
                 });
 
                 let vars = self.acir_context.black_box_function(black_box, inputs, output_count)?;
diff --git a/compiler/noirc_evaluator/src/ssa/ir/instruction/call/blackbox.rs b/compiler/noirc_evaluator/src/ssa/ir/instruction/call/blackbox.rs
index b369661..f9894ea 100644
--- a/compiler/noirc_evaluator/src/ssa/ir/instruction/call/blackbox.rs
+++ b/compiler/noirc_evaluator/src/ssa/ir/instruction/call/blackbox.rs
@@ -52,10 +52,9 @@ pub(super) fn simplify_ec_add(
 
             let result_x = dfg.make_constant(result_x, NumericType::NativeField);
             let result_y = dfg.make_constant(result_y, NumericType::NativeField);
-            let result_is_infinity =
-                dfg.make_constant(result_is_infinity, NumericType::NativeField);
+            let result_is_infinity = dfg.make_constant(result_is_infinity, NumericType::bool());
 
-            let typ = Type::Array(Arc::new(vec![Type::field()]), 3);
+            let typ = Type::Array(Arc::new(vec![Type::field(), Type::field(), Type::bool()]), 1);
 
             let elements = im::vector![result_x, result_y, result_is_infinity];
             let instruction = Instruction::MakeArray { elements, typ };
@@ -148,11 +147,11 @@ pub(super) fn simplify_msm(
             if var_scalars.is_empty() {
                 let result_x = dfg.make_constant(result_x, NumericType::NativeField);
                 let result_y = dfg.make_constant(result_y, NumericType::NativeField);
-                let result_is_infinity =
-                    dfg.make_constant(result_is_infinity, NumericType::NativeField);
+                let result_is_infinity = dfg.make_constant(result_is_infinity, NumericType::bool());
 
                 let elements = im::vector![result_x, result_y, result_is_infinity];
-                let typ = Type::Array(Arc::new(vec![Type::field()]), 3);
+                let typ =
+                    Type::Array(Arc::new(vec![Type::field(), Type::field(), Type::bool()]), 1);
                 let instruction = Instruction::MakeArray { elements, typ };
                 let result_array =
                     dfg.insert_instruction_and_results(instruction, block, None, call_stack);
diff --git a/noir_stdlib/src/embedded_curve_ops.nr b/noir_stdlib/src/embedded_curve_ops.nr
index 6b225ee..295c26f 100644
--- a/noir_stdlib/src/embedded_curve_ops.nr
+++ b/noir_stdlib/src/embedded_curve_ops.nr
@@ -107,15 +107,14 @@ pub fn multi_scalar_mul<let N: u32>(
 ) -> EmbeddedCurvePoint
 // docs:end:multi_scalar_mul
 {
-    let point_array = multi_scalar_mul_array_return(points, scalars);
-    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }
+    multi_scalar_mul_array_return(points, scalars)[0]
 }
 
 #[foreign(multi_scalar_mul)]
 pub(crate) fn multi_scalar_mul_array_return<let N: u32>(
     points: [EmbeddedCurvePoint; N],
     scalars: [EmbeddedCurveScalar; N],
-) -> [Field; 3] {}
+) -> [EmbeddedCurvePoint; 1] {}
 
 // docs:start:fixed_base_scalar_mul
 pub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint
@@ -172,7 +171,7 @@ pub fn embedded_curve_add(
 fn embedded_curve_add_array_return(
     _point1: EmbeddedCurvePoint,
     _point2: EmbeddedCurvePoint,
-) -> [Field; 3] {}
+) -> [EmbeddedCurvePoint; 1] {}
 
 /// This function assumes that:
 /// The points are on the curve, and
@@ -199,9 +198,5 @@ pub fn embedded_curve_add_unsafe(
     point1: EmbeddedCurvePoint,
     point2: EmbeddedCurvePoint,
 ) -> EmbeddedCurvePoint {
-    let point_array = embedded_curve_add_array_return(point1, point2);
-    let x = point_array[0];
-    let y = point_array[1];
-
-    EmbeddedCurvePoint { x, y, is_infinite: false }
+    embedded_curve_add_array_return(point1, point2)[0]
 }
diff --git a/noir_stdlib/src/hash/mod.nr b/noir_stdlib/src/hash/mod.nr
index bd1c2b8..9a55a99 100644
--- a/noir_stdlib/src/hash/mod.nr
+++ b/noir_stdlib/src/hash/mod.nr
@@ -80,7 +80,7 @@ pub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u3
     let length_generator: [EmbeddedCurvePoint; 1] =
         derive_generators("pedersen_hash_length".as_bytes(), 0);
     generators[N] = length_generator[0];
-    multi_scalar_mul_array_return(generators, scalars)[0]
+    multi_scalar_mul_array_return(generators, scalars)[0].x
 }
 
 #[field(bn254)]
-- 
2.43.0

