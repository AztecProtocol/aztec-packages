// Given a local benchmark json aggregated file, reformats it in markdown
// and comments on the PR that prompted it. If the CI is rerun, the comment
// is updated.

const https = require("https");
const fs = require("fs");

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const OWNER = "AztecProtocol";
const REPO = "aztec3-packages";
const COMMENT_MARK = "<!-- AUTOGENERATED BENCHMARK COMMENT -->";

const { ROLLUP_SIZES, BENCHMARK_FILE_JSON } = require("./benchmark_shared.js");

// Returns the md content to post
function getContent() {
  const benchmark = JSON.parse(fs.readFileSync(BENCHMARK_FILE_JSON, "utf-8"));
  delete benchmark.timestamp;

  const sizes = ROLLUP_SIZES;
  const header = `| Metric | ${sizes.map((i) => `${i} txs`).join(" | ")} |`;
  const separator = `| - | ${sizes.map(() => "-").join(" | ")} |`;
  const rows = Object.keys(benchmark).map((key) => {
    const metric = benchmark[key];
    return `${key} | ${sizes.map((i) => metric[i]).join(" | ")} |`;
  });

  return `
# Benchmark results

### On rollup published to L1

${header}
${separator}
${rows.join("\n")}

${COMMENT_MARK}
`;
}

// Returns the number of the current PR
function getPrNumber() {
  if (!process.env.CIRCLE_PULL_REQUEST) throw new Error(`Not in Circle PR`);
  const fragments = process.env.CIRCLE_PULL_REQUEST.split("/");
  return fragments[fragments.length - 1];
}

// Function to check if a bench comment already exists
async function getExistingComment() {
  try {
    const response = await sendGitHubRequest(
      `/repos/${OWNER}/${REPO}/issues/${getPrNumber()}/comments`
    );
    const comments = JSON.parse(response);
    return comments.find((comment) => comment.body.includes(COMMENT_MARK));
  } catch (error) {
    console.error("Error checking for existing comments:", error.message);
    process.exit(1);
  }
}

// Function to create or update a comment
async function upsertComment(existingCommentId) {
  try {
    const commentContent = getContent();
    const commentData = { body: commentContent };

    const requestMethod = existingCommentId ? "PATCH" : "POST";
    const requestUrl = existingCommentId
      ? `/repos/${OWNER}/${REPO}/issues/comments/${existingCommentId}`
      : `/repos/${OWNER}/${REPO}/issues/${getPrNumber()}/comments`;

    await sendGitHubRequest(requestUrl, requestMethod, commentData);
    console.log("Comment added or updated successfully.");
  } catch (error) {
    console.error("Error adding or updating comment:", error.message);
    process.exit(1);
  }
}

// Function to send a request to the GitHub API
async function sendGitHubRequest(url, method = "GET", data = null) {
  const apiUrl = url.startsWith("http") ? url : `https://api.github.com${url}`;
  const headers = {
    Authorization: `Bearer ${GITHUB_TOKEN}`,
    "User-Agent": OWNER,
  };
  if (data) headers["Content-Type"] = "application/json";

  const requestOptions = { method, headers };
  if (data) requestOptions.body = JSON.stringify(data);

  return new Promise((resolve, reject) => {
    const req = https.request(apiUrl, requestOptions, (res) => {
      if (
        res.statusCode === 301 ||
        res.statusCode === 302 ||
        res.statusCode === 307
      ) {
        sendGitHubRequest(res.headers.location, method, data)
          .then(resolve)
          .catch(reject);
        return;
      } else {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });

        res.on("end", () => {
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve(data);
          } else {
            reject(
              new Error(
                `GitHub API request failed with ${res.statusCode}: ${data}`
              )
            );
          }
        });
      }
    });

    req.on("error", (error) => {
      reject(error);
    });

    req.end();
  });
}

async function main() {
  const existingComment = await getExistingComment();
  await upsertComment(existingComment?.id);
}

main();
