import { createConsoleLogger } from '@aztec/foundation/log';
import { type NoirCompiledCircuit, type NoirFunctionAbi } from '@aztec/types/noir';

import { pascalCase } from 'change-case';
import fs from 'fs/promises';

import {
  type AbiTypeWithGenerics,
  type BindingId,
  type StructType,
  findAllStructsInType,
  mapAbiTypeToAbiTypeWithGenerics,
} from './abi_type_with_generics.js';
import { Demonomorphizer } from './demonomorphizer.js';

const log = createConsoleLogger('aztec:noir-contracts');

/**
 * Keep track off all of the Noir primitive types that were used.
 * Most of these will not have a 1-1 definition in TypeScript,
 * so we will need to generate type aliases for them.
 *
 * We want to generate type aliases
 * for specific types that are used in the ABI.
 *
 * For example:
 * - If `Field` is used we want to alias that
 * with `number`.
 * - If `u32` is used we want to alias that with `number` too.
 */
type PrimitiveTypesUsed = {
  /**
   * The name of the type alias that we will generate.
   */
  aliasName: string;
  /**
   * The TypeScript type that we will alias to.
   */
  tsType: string;
};

/**
 * Returns the last component of a path, e.g. "foo::bar::baz" -\> "baz"
 * Note: that if we have a path such as "Baz", we will return "Baz".
 *
 * Since these paths corresponds to structs, we can assume that we
 * cannot have "foo::bar::".
 *
 * We also make the assumption that since these paths are coming from
 * Noir, then we will not have two paths that look like this:
 * - foo::bar::Baz
 * - cat::dog::Baz
 * ie the last component of the path (struct name) is enough to uniquely identify
 * the whole path.
 *
 * TODO: We should double check this assumption when we use type aliases,
 * I expect that `foo::bar::Baz as Dog` would effectively give `foo::bar::Dog`
 * @param str - The path to get the last component of.
 * @returns The last component of the path.
 */
function getLastComponentOfPath(str: string): string {
  const parts = str.split('::');
  const lastPart = parts[parts.length - 1];
  return lastPart;
}

/**
 * Replaces a numeric binding with the corresponding generics name or the actual value.
 */
function replaceNumericBinding(id: number | BindingId, genericsNameMap: Map<number, string>): string {
  if (typeof id === 'number') {
    return id.toString();
  } else {
    return genericsNameMap.get(id.id) ?? 'unknown';
  }
}

class TypingsGenerator {
  /** All the types in the ABIs */
  private allTypes: AbiTypeWithGenerics[] = [];
  /** The demonomorphized ABIs of the circuits */
  private demonomorphizedAbis: {
    circuitName: string;
    params: { name: string; type: AbiTypeWithGenerics }[];
    returnType?: AbiTypeWithGenerics;
  }[] = [];
  /** Maps struct id to name for structs with the same name and different field sets */
  private structIdToTsName = new Map<string, string>();
  /** Collect all the primitives used in the types to add them to the codegen */
  private primitiveTypesUsed = new Map<string, PrimitiveTypesUsed>();

  constructor(circuits: { abi: NoirFunctionAbi; circuitName: string }[]) {
    // Map all the types used in the ABIs to the demonomorphized types
    for (const { abi, circuitName } of circuits) {
      const params = abi.parameters.map(param => {
        const type = mapAbiTypeToAbiTypeWithGenerics(param.type);
        this.allTypes.push(type);
        return { name: param.name, type };
      });
      if (abi.return_type) {
        const returnType = mapAbiTypeToAbiTypeWithGenerics(abi.return_type.abi_type);
        this.allTypes.push(returnType);
        this.demonomorphizedAbis.push({ circuitName, params, returnType });
      } else {
        this.demonomorphizedAbis.push({ circuitName, params });
      }
    }
    // Demonomorphize the types
    Demonomorphizer.demonomorphize(this.allTypes);
  }

  public codegen(): string {
    this.primitiveTypesUsed = new Map<string, PrimitiveTypesUsed>();
    const structsCode = this.codegenAllStructs();
    const interfacesCode = this.codegenAllInterfaces();
    const primitivesCode = this.codegenAllPrimitives();

    return `
    /* Autogenerated file, do not edit! */
    /* eslint-disable */
    ${primitivesCode}
    ${structsCode}
    ${interfacesCode}`;
  }

  private codegenAllStructs(): string {
    const allStructs = this.allTypes.flatMap(findAllStructsInType);
    // First, deduplicate the structs used
    const structTypesToExport = new Map<string, StructType>();
    for (const struct of allStructs) {
      const id = Demonomorphizer.buildIdForStruct(struct.structType);
      if (structTypesToExport.has(id)) {
        continue;
      }
      structTypesToExport.set(id, struct.structType);
    }

    // Then, we have to consider the case where we have struct with the same name but different fields.
    // For those, we'll naively append a number to the name.
    const idsPerName = new Map<string, string[]>();
    for (const [id, structType] of structTypesToExport.entries()) {
      const name = getLastComponentOfPath(structType.path);
      const ids = idsPerName.get(name) ?? [];
      ids.push(id);
      idsPerName.set(name, ids);
    }

    this.structIdToTsName = new Map();
    for (const [name, ids] of idsPerName.entries()) {
      if (ids.length !== 1) {
        ids.forEach((id, index) => {
          this.structIdToTsName.set(id, `${name}${index + 1}`);
        });
      }
    }
    // Now we can just generate the code for the structs
    let resultCode = '';

    for (const structType of structTypesToExport.values()) {
      resultCode += this.codegenStructType(structType);
    }

    return resultCode;
  }

  private getStructName(structType: StructType): string {
    return (
      this.structIdToTsName.get(Demonomorphizer.buildIdForStruct(structType)) || getLastComponentOfPath(structType.path)
    );
  }

  private codegenStructType(structType: StructType): string {
    // Generate names for the generic bindings.
    const genericsNameMap = new Map<number, string>();
    structType.generics.forEach((generic, index) => {
      genericsNameMap.set(generic.id, String.fromCharCode('A'.charCodeAt(0) + index));
    });

    const name = this.getStructName(structType);
    const generics = structType.generics.length
      ? `<${structType.generics
          .map(generic => `${genericsNameMap.get(generic.id)}${generic.isNumeric ? ' extends number' : ''}`)
          .join(', ')}>`
      : '';

    let resultCode = `export interface ${name}${generics} {\n`;

    for (const field of structType.fields) {
      resultCode += `  ${field.name}: ${this.codegenType(field.type, genericsNameMap)};\n`;
    }

    resultCode += '}\n\n';

    return resultCode;
  }

  private codegenType(type: AbiTypeWithGenerics, genericsNameMap: Map<number, string>): string {
    switch (type.kind) {
      case 'field':
        this.addIfUnique({ aliasName: 'Field', tsType: 'string' });
        return 'Field';
      case 'boolean':
        return 'boolean';
      case 'integer': {
        let tsIntType = '';
        if (type.sign === 'signed') {
          tsIntType = `i${type.width}`;
        } else {
          tsIntType = `u${type.width}`;
        }
        this.addIfUnique({ aliasName: tsIntType, tsType: 'string' });
        return tsIntType;
      }
      case 'binding':
        return genericsNameMap.get(type.id.id) ?? 'unknown';
      case 'constant':
        return type.value.toString();
      case 'string':
        return `string`;
      case 'array':
        return `FixedLengthArray<${this.codegenType(type.type, genericsNameMap)}, ${replaceNumericBinding(
          type.length,
          genericsNameMap,
        )}>`;
      case 'tuple':
        throw new Error('Unimplemented');
      case 'struct': {
        const name = this.getStructName(type.structType);
        if (type.args.length) {
          const args = type.args.map(arg => this.codegenType(arg, genericsNameMap)).join(', ');
          return `${name}<${args}>`;
        } else {
          return name;
        }
      }
    }
  }

  /**
   * Typescript does not allow us to check for equality of non-primitive types
   * easily, so we create a addIfUnique function that will only add an item
   * to the map if it is not already there by using JSON.stringify.
   * @param item - The item to add to the map.
   */
  private addIfUnique(item: PrimitiveTypesUsed) {
    const key = JSON.stringify(item);
    if (!this.primitiveTypesUsed.has(key)) {
      this.primitiveTypesUsed.set(key, item);
    }
  }

  /**
   * Codegen all the interfaces for the circuits.
   * For a circuit named Foo, we'll codegen FooInputType and FooReturnType.
   */
  private codegenAllInterfaces(): string {
    let resultCode = '';
    for (const { circuitName, params, returnType } of this.demonomorphizedAbis) {
      resultCode += this.codegenStructType({
        path: `${circuitName}InputType`,
        fields: params,
        generics: [],
      });
      if (returnType) {
        resultCode += `export type ${circuitName}ReturnType = ${this.codegenType(returnType, new Map())};\n`;
      }
    }
    return resultCode;
  }

  private codegenAllPrimitives(): string {
    let primitiveTypeAliases =
      'export type FixedLengthArray<T, L extends number> = L extends 0 ? never[]: T[] & { length: L }\n';
    for (const [, value] of this.primitiveTypesUsed) {
      primitiveTypeAliases += `export type ${value.aliasName} = ${value.tsType};\n`;
    }
    return primitiveTypeAliases;
  }
}

const circuits = [
  'parity_base',
  'parity_root',
  'private_kernel_init',
  'private_kernel_inner',
  'private_kernel_tail',
  'private_kernel_tail_to_public',
  'public_kernel_setup',
  'public_kernel_app_logic',
  'public_kernel_teardown',
  'public_kernel_tail',
  'rollup_base',
  'rollup_merge',
  'rollup_root',
];

const main = async () => {
  try {
    await fs.access('./src/types/');
  } catch (error) {
    await fs.mkdir('./src/types', { recursive: true });
  }

  const allAbis = [];

  // Collect all abis
  for (const circuit of circuits) {
    const rawData = await fs.readFile(`./src/target/${circuit}.json`, 'utf-8');
    const abiObj: NoirCompiledCircuit = JSON.parse(rawData);
    allAbis.push({
      abi: abiObj.abi,
      circuitName: pascalCase(circuit),
    });
  }
  const interfaces = new TypingsGenerator(allAbis).codegen();
  await fs.writeFile('./src/types/index.ts', interfaces);
};

try {
  await main();
} catch (err: unknown) {
  log(`Error generating types ${err}`);
  process.exit(1);
}
