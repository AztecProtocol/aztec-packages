import { createConsoleLogger } from '@aztec/foundation/log';
import { BENCHMARK_HISTORY_BLOCK_SIZE, Metrics } from '@aztec/types/stats';

import * as fs from 'fs';
import pick from 'lodash.pick';

import { BaseBenchFile, BenchFile } from './paths.js';

// Input file paths
const inputFile = BenchFile;

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const baseFile = BaseBenchFile;

const COMMENT_MARK = '<!-- AUTOGENERATED BENCHMARK COMMENT -->';

const log = createConsoleLogger();

/** Formats a numeric value for display. */
function formatValue(value: number) {
  return value;
}

/** Transposes an object topmost and nested keys. */
function transpose(obj: any) {
  const transposed: any = {};
  for (const outerKey in obj) {
    const innerObj = obj[outerKey];
    for (const innerKey in innerObj) {
      if (!transposed[innerKey]) transposed[innerKey] = {};
      transposed[innerKey][outerKey] = innerObj[innerKey];
    }
  }
  return transposed;
}

/** Creates a table in md out of the data (rows and cols). */
function getTableContent(data: Record<string, Record<string, number>>, groupUnit = '', col1Title = 'Metric') {
  const rowKeys = Object.keys(data);
  const groups = [...new Set(rowKeys.flatMap(key => Object.keys(data[key])))];
  const header = `| ${col1Title} | ${groups.map(i => `${i} ${groupUnit}`).join(' | ')} |`;
  const separator = `| - | ${groups.map(() => '-').join(' | ')} |`;
  const rows = rowKeys.map(key => {
    const metric = data[key];
    return `${key} | ${groups.map(i => formatValue(metric[i])).join(' | ')} |`;
  });

  return `
${header}
${separator}
${rows.join('\n')}
  `;
}

/** Creates a md with the benchmark contents. */
export function getMarkdown() {
  const benchmark = JSON.parse(fs.readFileSync(inputFile, 'utf-8'));
  const metricsByBlockSize = Metrics.filter(m => m.groupBy === 'block-size').map(m => m.name);
  const metricsByChainLength = Metrics.filter(m => m.groupBy === 'chain-length').map(m => m.name);
  const metricsByCircuitName = Metrics.filter(m => m.groupBy === 'circuit-name').map(m => m.name);

  return `
## Benchmark results

All benchmarks are run on txs on the \`Benchmarking\` contract on the repository. Each tx consists of a batch call to \`create_note\` and \`increment_balance\`, which guarantees that each tx has a private call, a nested private call, a public call, and a nested public call, as well as an emitted private note, an unencrypted log, and public storage read and write.

### L2 block published to L1

Each column represents the number of txs on an L2 block published to L1.
${getTableContent(pick(benchmark, metricsByBlockSize), 'txs')}

### L2 chain processing

Each column represents the number of blocks on the L2 chain where each block has ${BENCHMARK_HISTORY_BLOCK_SIZE} txs.
${getTableContent(pick(benchmark, metricsByChainLength), 'blocks')}

### Circuits stats

Stats on running time and I/O sizes collected for every circuit run across all benchmarks.
${getTableContent(transpose(pick(benchmark, metricsByCircuitName)), '', 'Circuit')}

${COMMENT_MARK}
`;
}

/** Entrypoint */
export function main() {
  log(getMarkdown());
}
