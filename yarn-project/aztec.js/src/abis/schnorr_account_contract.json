{
  "name": "SchnorrAccount",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "signing_pub_key_x",
          "type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        {
          "name": "signing_pub_key_y",
          "type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "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dPZ6Ons9nb2ezl5PZ6+ns9fT2evp7PV09no6ez2dvZ7OXk9nr6ez1+nsdTp7nc5ep7PX6ex1Onudzl6ns9fp7HU6e53OXqez1+nsdTp7nc5ep7PX6ex1Onudzl6ns9fp7HU6e53OXqez1+nsdTp7nc5ep7PX6ex1Onudzl6ns9fp7HU6e53OXqez1+nsdTp7nc5ep7PX6ex1Onudzl6ns9dZ7HXN6ytb9ydkeSWY5ZVglleCWV4JZnkllBV7xSyvBLO8EszySjBzKyn2iplbSbFXzNxKir1SVuwVM7eSYq+YuZUUe8XMraTYK2ZuJcVeMXMrKfaKmVtJsVfM3EqKvWLmVlLsFTO3kmKvmLmVFHvFzK2k2CtmbiXFXjFzKyn2iplbSbFXzNxKir1i5lZS7BUzt5Jir5i5lRR7xcytpNgrZmolq9grZmolq9grZmolq9grZmolq9grZmolq9grZm4lxV4xcysp9oqZW0mxV8zcSoq9YuZWUuwVM7eSYq+YuZUUe8XMraTYK2ZuJcVeMXMrKfaKmVtJsVfM3EqKvWLmVlLsFTO3kmKvmLmVFHvFzK2k2CtmbiXFXjFzK3H2upy9Lmevy9nrcva6nL0uZ6/L2ety9rqcvS5nr8vZ63L2upy9Lmevy9nrcva6nL0uZ6/L2ety9rqcvS5nr8vZ63L2upy9Lmevy9nrcva6nL0uZ6/L2ety9rqcvS5nr8vZ63L2upy9Lmevy9nrcva6nL0uZ6/L2ety9rqcvS5nr8vZ63L2upy9Lmevy9nrcva6nL0uZ6/L2evl7PVy9no5e72cvV7OXi9nr5ez18vZ6+Xs9XL2ejl7vZy9Xs5eL2evl7PXy9nr5ez1cvZ6OXu9nL1ezl4vZ6+Xs9fL2evl7PVy9no5e72cvV7OXi9nr5ez18vZ6+Xs9XL2ejl7vZy9Xs5eL2evl7PXy9nr5ez1cvZ6OXu9nL1ezl4vZ6+Xs9fL2evl7PVy9no5e72cvV7OXi9nr5ez18vZ6+Xs9XL2ejl7vZy9Xs5eL2evl7PXy9nr5ez1cvZ6OXu9nL1ezl4vZ6+Xs9fL2evl7PVy9no5e72cvV7OXi9nr5ez18vZ6+Xs9XL2ejl7vZy9Xs5eL2evl7PXy9nr5ez1cvZ6OXu9nL1ezl4vZ6+Xs9fL2evl7PVy9no5e72cvd7OXm9nr7ez19vZ6+3s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l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5l+y7Lzq5F+m7p/TdU/ruKX33lL57St89pe+e0ndP6bun9N1T+u4pffeUvntK3z2l757Sd0/pu6f03VP67il995S+e0rfPaXvntJ3T+m7p/TdKX13St+d0nen9N0pfXdK353Sd6f03Sl9d0rfndJ3p/TdKX13St+d0nen9N0pfXdK353Sd6f03Sl9d0rfndJ3p/TdKX13St+d0nen9N0pfXdK353Sd6f03Sl9d0rfndJ3p/TdKX13St+d0nen9N0pfXdK353Sd6f03Sl9d0rfndJ3p/TdKX13St+d0nen9N0pfXdK353Sd6f03Sl9d0rfndJ3p/TdKX13St+d0nen9N0pfXdK353Sd6f03Sl9d0rfndJ3p/TdKX13St+d0nen9N0pfXdK353Sd6f03Sl9d0rfndJ3p/TdKX13St+d0nen9N0pfXdK353Sd6f03Sl9d0rfndJ3p/TdKX13St+d0nen9N0lfXdJ313Sd5f03SV9d0nfXdJ3l/TdJX13Sd9d0neX9N0lfXdJ313Sd5f03SV9d0nfXdJ3l/TdJX13Sd9d0neX9N0lfXdJ313Sd5f03SV9d0nfXdJ3l/TdJX13Sd9d0neX9N0lfXdJ313Sd5f03SV9d0nfXdJ3l/TdJX13Sd9d0neX9N0lfXdJ313Sd5f03SV9d0nfXdJ3l/TdJX13Sd9d0neX9N0lfXdJ313Sd5f03SV9d0nfXdJ3l/TdJX13Sd9d0neX9N0lfXdJ313Sd5f03VV8dzu/7p8Yz3eVurwX7vJeuMt7wa74Lnd5L9zlvXCX98Jd3gt3eS/cyb0U3+VO7qX4LnbFd7mTeym+y53cS/Fd7uReiu9yJ/dSfJc7t5er+C53bi9X8V3u3F6u4rvcub1cxXe5c3u5iu9yJ/dSfJc7uZfiu9zJvRTf5U7upfgud3IvxXe5k3spvsud3EvxXe7kXorvcif3UnyXO7mX4rvcyb0U3+VO7qX4LndyL8V3uZN7Kb7LndxL8V3u5F6K73In91J8lzu5l+K73Mm9FN/lTu6l+C53ci/Fd7mTeym+y53cS/Fd7uReiu9yJ/dSfJc7uZfiu9zJvRTf5U7upfgud3IvxXe5k3spvsud3EvxXe7kXorvcif3UnyXO7kX6buX9N1L+u4lffeSvntJ372k717Sdy/pu5f03Uv67iV995K+e0nfvaTvXtJ3L+m7l/TdS/ruJX33kr57Sd+9pO9e0ndv6bu39N1b+u4tffeWvntL372l797Sd2/pu7f03Vv67i1995a+e0vfvaXv3tJ3b+m7t/TdW/ruLX33lr57S9+9pe/e0ndv6bu39N1b+u4tffeWvntL372l797Sd2/pu7f03Vv67i1995a+e0vfvaXv3tJ3b+m7t/TdW/ruLX33lr57S9+9pe/e0ndv6bu39N1b+u4tffeWvntL372l797Sd2/pu7f03Vv67i1995a+e0vfvaXv3tJ3b+m7t/TdW/ruLX33lr57S9+9pe/e0ndv6bu39N1b+u4tffeWvntL372l797Sd2/pu7f03Vv67i1995a+e0vfvaXv3tJ3b+m7t/TdW/ruLX33lr57S9+9pe/e0ndv6bu39N1b+u7tfHf/ON99OrWXp1N7eTq1l6dTe3k6tZenU3t5OrWXp1N7eTq5F+e7Tyf34nz36eRenO8+ndyL892nk3txvvt0ci/Od59O7sX57tPJvTjffTq5F+e7Tyf34nz36eRenO8+ndyL892nk3txvvt0ci/Od59O7sX57tPJvTjffTq5F+e7Tyf34nz36eRenO8+ndyL892nk3txvvt0ci/Od59O7sX57tPJvTjffTq5F+e7Tyf34nz36eRenO8+ndyL892nk3txvvt0ci/Od59O7sX57tPJvTjffTq5F+e7Tyf34nz36eRenO8+ndyL892nk3txvvt0ci/Od59O7sX57tPJvTjffTq5F+e7Tyf34nz36eRenO8+ndyL892nk3txvvt0bi+b9N1N+u4mfXeTvrtJ392k727Sdzfpu5v03U367iZ9d5O+u0nf3aTvbtJ3N+m7m/TdTfruJn13k767Sd/dpO9u0nc36bub9N1N+u4mfXeTvrtJ392k727SdzfpGpt0jU26xiZdY5OusUnX2KRrbNI1NukaW3aN5x/Hv2TPD/Z3NT/fVfwWsIrfAVbxG6AqOwFW8dPHKn72WMWfnG3cX9W4U6U+jfxb8HZcX9W5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",
      "eJzt3d1uI0mSpuF7qePGgGFm/te3stiDxu4MMMCgZ7DdZ426943KSlKqojnd9GbQRCp5VgXkJxpDXzidjxjBf/3yX//9f/72z//877//45e//uuXtv3y1//1r1/+8T9/+/tv//uPf/7t//3zl79u41T/8su///3//vafqr/+5Zf/+M//+vdf/nr69S/X/1a1lfM/Vivt8q91+/V//+WXJnd/BL37I9jdH6Hc/RHq3R+h3f0R+t0fYdz7Efrp7o9w93O63/2c7nc/p/vdz+l+93O63/2c7nc/p/vdz+l+93N63P2cHnc/p8fdz+lxwDldtF8eoYr++REOOKcXj3DAOb14hAPO6cUjHHBOLx7hgHN68QgHnNO3H2E7HXBSrx7igLN69RAHnNarh7j7eb2d7n5ib6e7n9nb6e6n9nZyz205mXxPyWmcbj+EtXF+hKJv/9a6849tf8Dv/9j2f/32j0+/T+OuA3ecpm7naUT+MI3zk092ebE69XY1urvAPMXom7twPcfo7oL4HKO7C+1zjO4u4A8y+v4Kdv7J+4p3Nbr7wvAco7svOM8xuvtC9hyjZ79AHjh68qupVDuPriKL0Yu1y0+u755n/X305FfTA0eX5FfTI0dPfjX90OitXrret/5+dOcnt/MO2cbin269XiYe29vE3Zx/vB+K85F4d7rp7wcv+fX8bgevXN5elFJu/1Pp5zcXfxhBPnrokvcTHzl0+yLcLoOftkWZtn45v8Ts9j/up/Meq9fFz/2UPifvlJ7ul/IJ50nyDvBBfiWXQg8Zq/PkvHkq2t4f529HL3kTer+jJ+WymutJbv/jWs8tbSpXhyR5c/tor1nl6oD4W2a5bMpFrb47IN8y/l5V++mcsVO/eRD1sivT9jbS/px/+/Hq7ycP+/H+nu+wH+/vig778f7O4bAf778GHvbj/fX8sB/vL3iH/Xh/8Tjsx/un4mE//r5nrd33rLX7nrV237PW7nvW2n3PWrvvWWv3PWvtvmet3festfueteW+Z22571lb7nvWlvueteW+Z22571lb7nvWlvueteW+Z22571lb73vW1vuetfW+Z22971lb73vW1vuetfW+Z22971lb73vW1vuete2+Z61/ocJxP/6+Z61/icJxP/6+Z61/ccJxP/6+Z61/WcJxP/6+Z61/QcJhP96/GuG4H3/fs9a/DuG4H3/f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"
    ],
    "fileMap": {
      "0": {
        "source": "mod storage;\nmod public_key_note;\n\n// Account contract that uses Schnorr signatures for authentication.\n// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.\ncontract SchnorrAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::private_call_stack_item::PrivateCallStackItem;\n    use dep::aztec::public_call_stack_item::PublicCallStackItem;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::log::emit_encrypted_log;\n    use dep::aztec::oracle::get_public_key::get_public_key;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::note::utils as note_utils;\n    use dep::aztec::note::note_header::NoteHeader;\n    use dep::aztec::constants_gen::MAX_NOTE_FIELDS_LENGTH;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    use crate::storage::Storage;\n    use crate::public_key_note::PublicKeyNote;\n    use crate::public_key_note::PublicKeyNoteMethods;\n    use crate::public_key_note::PUBLIC_KEY_NOTE_LEN;\n\n    fn entrypoint(\n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        signature: pub [u8;64], // schnorr signature of the payload hash\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Initialize context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64\n        let mut args: BoundedVec<Field, 77> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in signature { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Load public key from storage\n        let storage = Storage::init();\n        let public_key = storage.signing_public_key.get_note(&mut context);\n\n        // Verify payload signature\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n\n        // Verify signature of the payload bytes\n        let verification = std::schnorr::verify_signature(public_key.x, public_key.y, signature, message_bytes);\n        assert(verification == true);\n\n        // Execute calls\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Constructs the contract\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n        signing_pub_key_x: pub Field,\n        signing_pub_key_y: pub Field,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        let storage = Storage::init();\n        \n        let mut context = PrivateContext::new(inputs, abi::hash_args([signing_pub_key_x, signing_pub_key_y]));\n        \n        let this = context.this_address();\n        let mut pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\n        storage.signing_public_key.initialise(&mut context, &mut pub_key_note);\n        \n        emit_encrypted_log(\n            &mut context,\n            this,\n            storage.signing_public_key.storage_slot,\n            get_public_key(this),\n            pub_key_note.serialise(),\n        );\n\n        context.finish()\n    }\n\n    // Computes notes hash and nullifier.\n    // Note 1: Needs to be defined by every contract producing logs.\n    // Note 2: Having it in all the contracts gives us the ability to compute the note hash and nullifier differently for different kind of notes.\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; PUBLIC_KEY_NOTE_LEN]) -> [Field; 4] {\n        assert(storage_slot == 1);\n        let note_header = NoteHeader { contract_address, nonce, storage_slot };\n        note_utils::compute_note_hash_and_nullifier(PublicKeyNoteMethods, note_header, preimage)\n    }\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-contracts/src/contracts/schnorr_account_contract/src/main"
      },
      "3": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\nfn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\nfn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\nfn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\nfn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\nfn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\nfn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\nfn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "29": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    fn unwrap_or_else(self, default: fn() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    fn map<U>(self, f: fn(T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    fn map_or<U>(self, default: U, f: fn(T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    fn map_or_else<U>(self, default: fn() -> U, f: fn(T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    fn and_then<U>(self, f: fn(T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    fn or_else<U>(self, default: fn() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    fn filter(self, predicate: fn(T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, msg: Field) {\n        self.new_l2_to_l1_msgs.push(msg);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "33": {
        "source": "use crate::context::PrivateContext;\nuse crate::oracle;\nuse crate::types::point::Point;\n\nfn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\nfn emit_unencrypted_log<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let _ = oracle::logs::emit_unencrypted_log(log);\n    context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/log"
      },
      "39": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::create_commitment::create_commitment;\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\nfn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn create_note_hash_from_public<Note, N>(\n    context: PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = context.this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    create_commitment(inner_note_hash);\n}\n\nfn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // 0 nonce implies \"transient\" nullifier (must nullify a commitment in this TX).\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.nonce == 0) {\n        // TODO(suyash): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(storage_slot, nullifier, preimage, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/lifecycle"
      },
      "40": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort},\n    note_interface::NoteInterface,\n    note_header::NoteHeader,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n    utils::compute_unique_siloed_note_hash,\n    utils::compute_inner_note_hash,\n    utils::compute_siloed_note_hash,\n};\nuse crate::messaging::get_commitment_getter_data::make_commitment_getter_data;\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn ensure_note_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    let saved_note = get_note_internal(storage_slot, note_interface);\n\n    // Only copy over the header to the original note to make sure the preimage is the same.\n    let get_header = note_interface.get_header;\n    let set_header = note_interface.set_header;\n    let note_header = get_header(saved_note);\n    set_header(note, note_header);\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, *note);\n    context.push_read_request(note_hash_for_read_request);\n}\n\n// Ensure a note's hash exists in the tree without retrieving the entire\n// notes via the oracle.\n// Modifies the note by populating it with header info.\nfn ensure_note_hash_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    // Initialize header of note. Must be done before computing note hashes as it initializes the:\n    // - storage slot (used in inner note hash)\n    // - the contract address (used in siloed note hash)\n    // - and the nonce (used in the unique siloed note hash)\n    let set_header = note_interface.set_header;\n    let note_header = NoteHeader {\n        contract_address: (*context).this_address(),\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n        // real nonce (once public kernel applies nonces).\n        nonce: 0,\n        storage_slot\n    };\n    set_header(note, note_header);\n\n    // Get a note from oracle and early out if it doesn't exist.\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let raw_oracle_ret = oracle::get_commitment::get_commitment(inner_note_hash);\n    let deserialized_oracle_ret = make_commitment_getter_data(raw_oracle_ret, 0);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // unique_siloed_note_hash once public kernel applies nonces\n    let saved_siloed_note_hash = deserialized_oracle_ret.message;\n\n    assert(saved_siloed_note_hash != 0); // TODO(dbanks12): necessary?\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    // Ensure that the note hash retrieved from oracle matches the one computed from note.\n    let computed_siloed_note_hash = compute_siloed_note_hash(note_interface, *note);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // compute_note_hash_for_read_or_nullify once public kernel applies nonces\n    assert(computed_siloed_note_hash == saved_siloed_note_hash);\n\n    context.push_read_request(computed_siloed_note_hash);\n}\n\nfn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\nfn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        let mut note_hash_for_read_request = 0;\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            check_note_header(*context, storage_slot, note_interface, note);\n            note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n        };\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n        // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n        context.push_read_request(note_hash_for_read_request);\n    };\n\n    // TODO(#1660)\n    // Move it back to get_notes_internal and only make read request for selected notes.\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/note_getter"
      },
      "42": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\nfn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\nfn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/note_hash"
      },
      "46": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nfn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\nfn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\nfn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    if (header.nonce == 0) {\n        // when nonce is zero, that means we are reading a pending note (doesn't have a nonce yet),\n        // so we just read the inner_note_hash (kernel will silo by contract address)\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\nfn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    let mut note = deserialise(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/utils"
      },
      "48": {
        "source": "use dep::std::hash::pedersen_with_separator;\nuse crate::context::PrivateContext;\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle;\nuse crate::constants_gen::{\n    GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n    EMPTY_NULLIFIED_COMMITMENT,\n};\n\nstruct ImmutableSingleton<Note, N> {\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    fn new(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Self {\n        ImmutableSingleton { storage_slot, note_interface }\n    }\n\n    unconstrained fn is_initialised(self) -> bool {\n        let nullifier = self.compute_initialisation_nullifier();\n        oracle::notes::is_nullifier_emitted(nullifier)\n    }\n\n    fn initialise(self, context: &mut PrivateContext, note: &mut Note) {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialisation_nullifier();\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n\n    fn compute_initialisation_nullifier(self) -> Field {\n        pedersen_with_separator([self.storage_slot], GENERATOR_INDEX__INITIALISATION_NULLIFIER)[0]\n    }\n    \n    fn get_note(self, context: &mut PrivateContext) -> Note {\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n\n    unconstrained fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/state_vars/immutable_singleton"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "60": {
        "source": "fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/utils"
      },
      "61": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/private_call_stack_item"
      },
      "62": {
        "source": "use crate::{\n    abi,\n    abi::{\n        PublicCircuitPublicInputs,\n        FunctionData,\n    },\n};\nuse crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__CALL_STACK_ITEM,\n};\n\n// oracles\nuse crate::oracle::{\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n};\n\nstruct PublicCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PublicCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PublicCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}\n\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/public_call_stack_item"
      },
      "65": {
        "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: Field,\n    _function_selector: Field,\n    _args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained fn call_private_function_internal(\n    contract_address: Field,\n    function_selector: Field,\n    args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n    )\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/call_private_function"
      },
      "73": {
        "source": "use crate::types::point::Point;\nuse dep::std::hash;\nuse crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n\n#[oracle(getPublicKey)]\nfn get_public_key_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_internal(address: Field) -> [Field; 3] {\n  get_public_key_oracle(address)\n}\n\nfn get_public_key(address: Field) -> Point {\n  let result = get_public_key_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = hash::pedersen_with_separator([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_public_key"
      },
      "74": {
        "source": "use crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(_owner: Point) -> Field {}\n\nunconstrained fn get_secret_key(owner: Point) -> Field {\n    get_secret_key_oracle(owner)\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_secret_key"
      },
      "76": {
        "source": "\n// contract_address + \n// args_hash +\n// crate::abi::FUNCTION_DATA_SIZE +\n// crate::abi::CALL_CONTEXT_SIZE +\n// = 2 + 4 + 6\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE: Field = 12;\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: Field, \n    _function_selector: Field, \n    _args_hash: Field,\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {}\n\nunconstrained fn enqueue_public_function_call_internal(\n    contract_address: Field, \n    function_selector: Field,\n    args_hash: Field\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {\n    enqueue_public_function_call_oracle(\n        contract_address, \n        function_selector, \n        args_hash,\n    )\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/enqueue_public_function_call"
      },
      "78": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _storage_slot: Field,\n    _nullifier: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn notify_nullified_note<N>(\n    storage_slot: Field,\n    nullifier: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(storage_slot, nullifier, preimage, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialise the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialise the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_some.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let header = NoteHeader { contract_address, nonce, storage_slot };\n            let is_some = fields[read_offset + 1] as bool;\n            if is_some {\n                let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n                let mut note = deserialise(preimage);\n                set_header(&mut note, header);\n                placeholder_opt_notes[i] = Option::some(note);\n            }\n        };\n    };\n    placeholder_opt_notes\n}\n\nunconstrained fn is_nullifier_emitted(nullifier: Field) -> bool {\n    // TODO\n    nullifier == 0\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/notes"
      },
      "80": {
        "source": "use crate::types::point::Point;\nuse crate::constants_gen::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: Field,\n    _storage_slot: Field,\n    _encryption_pub_key: Point,\n    _preimage: [Field; N],\n)  -> Field {}\n\nunconstrained fn emit_encrypted_log<N>(\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    preimage: [Field; N],\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(\n        contract_address,\n        storage_slot,\n        encryption_pub_key,\n        preimage,\n    ), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_message: T)  -> Field {}\n\nunconstrained fn emit_unencrypted_log<T>(message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(message), 0]\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/logs"
      },
      "81": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      },
      "84": {
        "source": "use dep::std::hash::pedersen;\nuse dep::aztec::note::note_interface::NoteInterface;\nuse dep::aztec::note::note_header::NoteHeader;\nuse dep::aztec::oracle::get_secret_key::get_secret_key;\nuse dep::aztec::oracle::get_public_key::get_public_key;\nuse dep::aztec::note::utils::compute_unique_siloed_note_hash;\n\nglobal PUBLIC_KEY_NOTE_LEN: Field = 3;\n\n// Stores a public key composed of two fields\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\nstruct PublicKeyNote {\n    x: Field,\n    y: Field,\n    owner: Field, // We store the owner address only to get the secret key to compute the nullifier\n    header: NoteHeader,\n}\n\nimpl PublicKeyNote {\n    fn new(x: Field, y: Field, owner: Field) -> Self {\n        PublicKeyNote {\n            x,\n            y,\n            owner,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // Serialise the note as 3 fields\n    fn serialise(self) -> [Field; PUBLIC_KEY_NOTE_LEN] {\n        [self.x, self.y, self.owner]\n    }\n\n    fn compute_nullifier(self) -> Field {\n        let unique_siloed_note_hash = compute_unique_siloed_note_hash(PublicKeyNoteMethods, self);\n        let owner_nullifying_public_key = get_public_key(self.owner);\n        let secret = get_secret_key(owner_nullifying_public_key);\n        dep::std::hash::pedersen([\n            unique_siloed_note_hash,\n            secret,\n        ])[0]\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n}\n\nfn deserialise(preimage: [Field; PUBLIC_KEY_NOTE_LEN]) -> PublicKeyNote {\n    PublicKeyNote {\n        x: preimage[0],\n        y: preimage[1],\n        owner: preimage[2],\n        header: NoteHeader::empty(),\n    }\n}\n\nfn serialise(note: PublicKeyNote) -> [Field; PUBLIC_KEY_NOTE_LEN] {\n    note.serialise()\n}\n\nfn compute_note_hash(note: PublicKeyNote) -> Field {\n    dep::std::hash::pedersen(note.serialise())[0]\n}\n\nfn compute_nullifier(note: PublicKeyNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: PublicKeyNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut PublicKeyNote, header: NoteHeader) {\n    note.set_header(header);\n}\n\nglobal PublicKeyNoteMethods = NoteInterface {\n    deserialise,\n    serialise,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n};\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-contracts/src/contracts/schnorr_account_contract/src/public_key_note"
      }
    }
  }
}
