{
  "name": "EcdsaAccount",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 5,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+3dTY8bSZ7fcTL5nEkWH6pIFuv5SVKVVJJYJanVLfV05zzszOzDTI9334EXM4YBGxgbs4BtYNHjo2H4YsC+2pcx4IN93Zex78BX33w2YGDgTlb+p36KCpbErsyur2YjgQIjI8n8fyKSRWZGRgR7lUqlWrlaat/81Ss3F9ue5o/zuy0X1eL2NS/TGX0kzlqBzszWqJR7/Osl1GvRxsZHYGx+BMbWR2BsV4r9/zGjfZZ2vvmLv/lLvvnrVq6XX8+ut9v/XE1eY6+PJK/m1EFHttvSlHRaTLleNYuv93kj91fkUcu7lpelVWzcC62jeuW6nltyDGx7Tx6zvHaxlsumlL2gfb7I9hkXu8+X2T6TEt5T3WL3+UlTjllB+3xt5a7IezOLs1ZsnItq5d0llbTFUksNZKmDLA2QpQmytECWNsjSAVlikCUBWbogSw9kqd6zpSOGiuTZ9rbk9SVtj4M8HUve0ClnljfK013JW8/TPcnbyNN6zjzO03puPcnTeo4+zdMNydNzUcuz/Wh5bD8DybP9DCXPvg9Gkmefy+uSZ/W2IXlWb2PJs3qbSJ7Vm5bnb2W7PVfraOrZj6X1PWax0/xxfrdl8R7TOKmsW6xYDBOApQeydEGWBGSJQZYOyNIGWVogSxNkaYAsdZClBrJEjkXPM6aSFzmvbeXugtsoXmWxtG3R/Lqkki7xHHae7bNf8D6zfQzEb2XVc2Lb3peyDYp1LN4fa5V369TWBxI3lL/QuKH8lVD+f8jlD23QoQ3621pCG3Rog17FEtqgQxv0KpY+yEJvD9c2bTtf0DZtayvWtuXb2qC1vdm+/2wf2XfQb9o340WeeAOPq+y61DiprFssbfcdACx9kKUHsnRBlgRkiUGWDsjSBllaIEsTZGmALHWQpQayRI4ltBGENoJvawltBKGNYBVLaCMIbQSrWEhtBGV/d69iGYIs9LYT7Ufntolk36X/U9o67B68tnVs5mntB5gPwXmnH+CW7NPytvN0U/J28nTLY9U+ANbXb1PyrK/fTPKsr9+W5Fm/gW3Jsz4HOx6LHkN7TZo/zu+2LI6hxkll3WJpm80OwDIEWQYgSx9k6YEsXZAlAVlikKUDsrRBlhbI0gRZGiBLHWSpgSyRx7JVrOVSz+MqYtIllbSeh80cc+bbLKGuZo7F1i1WIoa10iyXi/5GbuwSynzZccqcLbcdEz2HtnPsmfh2i/UtjsnUsdi6xdK6GpVmuTombuwSynzZccqcLbcdE4ufvW4vT0/Ft1+sb3FM9hyLrVssrav1Ei2JJ3YJcS47Tpmz5bZjYvGz1x3k6T3xHRZcD1WJY/u1dYuldbVRoiXxxC4hzqXWrS23HROLn73uKE8fiO+44HqoShzbr61bLK2rcYmWxBO7hDiXHafM2XLbMbH42etO8vSR+B4UXA9ViWP7tXWLpXU1KdGSLIlti95DPCmhHipOPdhy4rHUQJY6yNIAWZogSwtkaYMsHZAlBlkSkKULsvRAljWQpQ+yDECWIcgyAlnWQZYNkGUMskxAlinIsgmyzECWLZBlG2TZAVl2QZY9kGUfZDkAWQ5BliOQ5Rhkqd6zZVk/NduufbWsXU37eT3M09pH7FGe3pO80zx9IHlnefpI8h7naZ1r74mk7fE8T+tce5GnbNbW9kDy6nn6oeRZ29MjybM2oFPJs7aYM8kz62PJM6vazWr2LOZf9W+WSd8T9vo0f5zfbVm8JzROKusWS/u9nQMsxyDLEchyCLIcgCz7IMseyLILsuyALNsgyxbIMgNZNkGWKcgyAVnGIMsGyLIOsoxAliHIMgBZ+iDLGsjSA1m6IEsCssQgSwdkaYMsLZClCbI0QJY6yFIDWSLHEst2HYNhbXEzybM2u6nkWdvenuRZG+CB5FlbobX/aBtuJPVSRh9LXVJJ+/o51kCWOsjSAFmaIEsLZGmDLB2QJQZZEpClC7L0QJY1kKUPsgxAliHIMgJZ1kGWDZBlDLKUOY5nVcsUZNkEWWYgyxbIsg2y7IAsuyDLHsiyD7IcgCyHIMsRyHIMsjwEWR6BLKcgyxnI8hhkeQKynIMs1Xu2LOsvbNt17knrh6t9YJ/mae0r+yxPa5/a53la+97O87T20b3I09qXN/KYrV1c+wab9ankNfL0M8mz9trnkmftpnPJs/ZLM2X7+l3/pj/y+OeecuqxttipPb+AY61xUlm3WNoPeA6wnIMsT0CWxyDLGchyCrI8AlkegizHIMsRyHIIshyALPsgyx7Isguy7IAs2yDLFsgyA1k2QZYpyDIBWcYgywbIsg6yjECWIcgyAFn6IMsayNIDWbogSwKyxCBLB2RpgywtkKUJsjRAljrIUgNZIseyrI99GT5dUkk/91hqIEsdZGmALE2QpQWytEGWDsgSgywJyNIFWXogyxrI0gdZBiDLEGQZgSzrIMsGyDIGWSYgyxRk2QRZZiDLFsiyDbLsgCy7IMseyLIPshyALIcgyxHIcgyyPARZHoEspyDLGcjyGGR5ArKcgyxlt4WvYrkAWar3bFk29kDvIVie9d+/kLzIsz9ry7fnZ23Yvx3c3Hfk2fdzj0Hr6KlTlvndlkUdaZxU1p9KHVQd331aLkCWOchyDrI8AVkegyxnIMspyPIIZHkIshyDLEcgyyHIcgCy7IMseyDLLsiyA7JsgyxbIMsMZNkEWaYgywRkGYMsGyDLOsgyAlmGIMsAZOmDLGsgSw9k6YIsCcgSgywdkKUNsrRAlibI0gBZ6iBLDWRx7zUsG8tQhk+XVNJPPZYayFIHWRogSxNkaYEsbZClA7LEIEsCsnRBlh7Isgay9EGWAcgyBFlGIMs6yLIBsoxBlgnIMgVZNkGWGciyBbJsgyw7IMsuyLIHsuyDLAcgyyHIcgSyHIMsD0GWRyDLKchyBrI8BlmegCznIMszkKXsdvlVLHOQ5QJkqd6zZdkYD9veljz7LQf9rYbIsz/3tx+ytv2/G9zcd+TZ91OPQeuojN/g0DiprFssHePxFGC5AFnmIMtzkOUZyHIOsjwBWR6DLGcgyynI8ghkeQiyHIMsRyDLIchyALLsgyx7IMsuyLIDsmyDLFsgywxk2QRZpiDLBGQZgywbIMs6yDICWYYgywBksX5KBMsayNIDWbogSwKyxCBLB2RpgywtkKUJsjRAljrIUgNZ3Hswy8a+3PdvqddAljrI0gBZmiBLC2RpgywdkCUGWRKQpQuy9ECWNZClD7IMQJYhyDICWdZBlg2QZQyyTECWKciyCbLMQJYtkGUbZNkBWXZBlj2QZR9kOQBZDkGWI5DlGGQ5AVkegiyPQJZTkOUMZHkMsjwBWc5BlrLb5VexPANZnoMsc5DlAmSp3rNl2Zgg3W6Pl3n6RPIiz/7s3o89v/HN398Pbu478uz7gcegdfTCKcv8bsuijjROKusWS8cEPQBYLkCWOcjyHGR5BrI8BVnOQZYnIMtjkOUMZDkFWR6BLA9BlhOQ5RhkOQJZDkGWA5BlH2TZA1l2QZYdkGUbZNkCWWYgyybIMgVZJiDLGGTZAFnWQZYRyDIEWQYgSx9kWQNZeiBLF2RJQJYYZOmALG2QpQWyNEGWBshSB1lqIIt7byqW7duS9zJPzyTvVZ6eSt4neXpP8l7n6QPJ+zRPW/vPsjFan1WKrxddUkl/5rHUQJY6yNIAWZogSwtkaYMsHZAlBlkSkKULsvRAljWQpQ+yDECWIcgyAlnWQZYNkGUMskxAlinIsgmyzECWLZBlG2TZAVl2QZY9kGUfZDkAWQ5BliOQ5RhkOQFZHoAsD0GWRyDLKchyBrI8BlmegCznIMtTkOUZyPIcZJmDLBcgyyXI8gJkeQmyvAJZPgFZXoMsn4Is1Xu2LBsDatsbkvcmT7+QvLd5+qXkfZ6nX0ne9/L0J5L3RZ5+LXlf5ulPJS/ymO3+9RvJs/vIbyXP/J9Lnt1X/Z7k2f3NLyTP7jOaKdvX7/o3/ZHH/4WnnHqsLXaaP87vtiyOtcZJZd1i6VjWLwCWT0GW1yDLJyDLK5DlJcjyAmS5BFkuQJY5yPIcZHkGsjwFWc5Blicgy2OQ5QxkOQVZHoEsD0GWByDLCchyDLIcgSyHIMsByLIPsuyBLLsgyw7Isg2ybIEsM5BlE2SZgiwTkGUMsmyALOsgywhkGYIsA5ClD7KsgSw9kKULsiQgSwyydECWNsjSAlmaIEsDZKmDLDWQJfJYPi/W8lL7AFTEpEsq6c/F8rZYy+K20BuJZS6Lk8h27aP3pljH4vi8dcpv6+r7UOvJR2S9/IisX96zVfvZaJ+VyDG3cmOzWOOl9qOx5bb/3aYY7XtR51Vol1CHLcdi6xYrEUOtPMurxBM7XlIPnWJjz7XPku07+877t+3rmEnB5c32uVZwObLjadcC2fK1lEvHrJcRt+fETZy41cq78yx8LVZ7bU2e8x/a18fh3+VpvQbU/nV9J5b+j9u2VuXd61n9vxxI2uqrLnkjSUfOa7TtQMd5WztLmj/O77a86jiObLnts0THeY+LtSyOt45RTiWGxp0WG/dC41bzP4th+TVJ/1c7mPK8bLH3gJm1jU6fp+mR85pEtm+UXOaxOFJZt1jZe/U/SVk3PG79PLftOkfCRsHubB/r4mg7to6UQz/bJ99h/U2kThpOfZVgWXzHubHLqvvxe+re8ux57vddvVjTpfY9tuW2zy+d26rY87LLxff9tzkvyx5bhVrm8xLOpRbXaR3xW1nNnsh2nROq4POqW88vdf6nUP5C44byV0L5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5v/vydySvds+WRAzl9be8nCcV//ug4DJfdpwyZ8tt/TzUUmx/z6s+J/EKFv0dqG6hlvL6nGgfUCtrV8pj2/V/rles48LtA5tWbvYzDeUP5Q/lLzRuKH8llD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+U/37K35G81j1btC9IXJrlqs+J731QcJkX74M1KXPkxNT5esubk+uqvK4hi9MvNM7VMdYllbTFUksNZKmDLA2QpQmytECWNsjSAVlikCUBWbogSw9kWQNZqvds6VT8vyNt27uSN8jTt81zmeXZd6w9P/tu+d+D6+02x10kr7G5+mqSZ/PF1T2Gkce6Lnk2t+CGZ39a5wXPk7moc42TyrrF0t9z3gBY1kCWHsjSBVkSkCUGWTogSxtkaYEsTZClAbLUQZYayBJ5LEW3k+g5h+07Ox6/jq9jFjtv9cWvsn1uFlwOnZM6W76Wcm1K/ZURd+rEHTtxs+fofMZfi9VeW5PnnPevj8O/yo+D/t6htt1sFVuexZzF9tuX2WLvQYujvwG5LY7vqt1su9A4t18bWKxl7Wb3bamDLA2QpQmytECWNsjSAVlikCUBWbogSw9kWQNZ+iDLAGQZgiwjkGUdZNkAWcYgywRkmYIsmyDLDGTZAlmq92xZdh/Hts8kbydP++7j6P7sms+e797H2cvz9T7Ofp7W+zgHebruMex5rPuSt5unDzz70zq316T54/xuy6LONU4q6xZL7+McACxbIMsMZNkEWaYgywRkGYMsGyDLOsgyAlmGIMsAZOmDLGsgSw9k6YIsCcgSgywdkKUNsrRAlibI0gBZ6iBLDWSJPJa9Yi2L++IW0/brXuuW0beg6uw/lRh6TW7POc8/+HslebJ9HFWuF7u2H8vxOMzTRyXWS7bP40L3eTWXqpYtW6rOeirpYynfg0ItV++3h7L/VGJo3EfFxr3QuNX8z2JYfk3SX0pj2aPr5B+uzc2cvS9OPM/T9JHzmkS2n5Rc5gfiSGXdYmWfvS+lrCce91jctt3+F7L3lh037XNxUkJZjivvluXYMet8zEelWa76vLixSyjzZbYPPX6REzMWxwNxfFd9fAr+bLi13Vj/d2ypgSx1kKUBsjRBlhbI0gZZOiBLDLIkIEsXZOmBLGsgSx9kGYAsQ5BlBLKsgywbIMsYZJmALFOQZRNkmYEsWyDLNsiyA7Lsgix7IMs+yHIAshyCLEcgS4ntxCtbTkCW6j1blvWtdNvZszxr7/b1rdT9WVubPb9Rebdv5WmeH8lrzvK09q18nKfrHsOpx3omedZm/dizP61ze02aP87vtizqXOOksm6xtG/lY4DlBGQ5BlmOQJZDkOUAZNkHWfZAll2QZQdk2QZZtkCWGciyCbJMQZYJyDIGWTZAlnWQZQSyDEGWAcjSB1nWQJYeyNIFWRKQJQZZOiBLG2RpgSxNkKUBstRBlhrIEnksZcyVZzF1rrwX3euYZfTbflpwObJ6fFK5Xr6Wcj2V+isj7rkTd+zEzZ5zKoavxWqvrclzGjJX3tv8OMSyP+2b97zY8rxY7KNyvdh70OJkjmcWSxzfVT/aeaFxbr9HYLGW9aO9b0sdZGmALE2QpQWytEGWDsgSgywJyNIFWXogyxrI0gdZBiDLEGQZgSzrIMsGyDIGWSYgyxRk2QRZZiDLFsiyDbLsgCy7IMseyLIPshyALIcgyxHIcgyynIAsD0CWhyDLI5DlFGQ5A1kegyxPQJZzkOUpyPIMZHkOslTv2bJsLIVtfyZ5F3naN5ZC92f3W+z57liKF3l+JK95mad1LMWrPF33GF54rC8l7zJPv/LsT+vcXpNaOQqoc42TyrrFisXwCmB5DrI8A1megiznIMsTkOUxyHIGspyCLI9AlocgywOQ5QRkOQZZjkCWQ5DlAGTZB1n2QJZdkGUHZNkGWbZAlhnIsgmyTEGWCcgyBlk2QJZ1kGUEsgxBlgHI0gdZ1kCWHsjSBVkSkCUGWTogSxtkaYEsTZClAbLUQZYayBJ5LC+KtSzGg1lM2697n6mMMXVVZ/+pxND7Yfacf55/IZb5GzGvK9eL3Vcby/H4JE+/LrFesn1+Wug+r34jRsuWLbfdH/1UyvemUMvV++2t7D+VGBr382LjXmjcav5nMSy/Junf2gmYPC9b7L6YmbP3xWee52n6tfOaRLZ/VnKZ34gjlXWLlX32/o2U9TOPeyxu227/C9l7y46bjh37rISyfFp5tyyfOuZEDK9Ls1yN9XRjx5JXk7zPPHXztlDPfPFxqe83+954Kw73uC8br1rGe1CXVNI+Sw1kqYMsDZClCbK0QJY2yNIBWWKQJQFZuiBLD2RZA1n6IMsAZBmCLCOQZR1k2QBZxiDLBGSZgiybIMsMZNkCWbZBlh2QZRdk2QNZ9kGWA5DlEGQ5AlmOQZYTkOUByPIQZHkEspyCLGcgy2OQ5QnIcg6yPAVZnoEsz0GWOchyAbJcgiwvQJaXIMsrkOUTkOU1yFJ2/4dVLGX3S1jF8gZkeQuyVO/Z4ps/IbtPvTm83v5lnh/Ja9I8rfMdfD9P63wHFudLyfue48nyvsjT3/fsT+sodV47v9uyqCONk8q6xdD5Dr4PsLwFWd6ALJ+BLJ+CLK9Blk9Allcgy0uQ5QXIcgmyXIAsc5DlOcjyDGR5CrKcgyxPQJbHIMsZyHIKsjwCWR6CLA9AlhOQ5RhkOQJZDkGWA5BlH2TZA1l2QZYdkGUbZNkCWWYgyybIMgVZJiDLGGTZAFnWQZYRyDIEWQYgSx9kWQNZeiBLF2RJQJYYZOmALG2QpQWyNEGWBshSB1lqIEvkWLTvwqeSZ/0TPpO8H+TpN5L3wzyt/Sd+lKe/J3l/kqe/kLzI8elvTWj/CDuWP5A8e6/9UPLsf+FHkmf/qxY/W4+d9Ur+2i3HM7/bcqGWbLH2bB179YNiYy7movmhxMz2+9Cpv6qk7b34I6c+a/KcXn5C1XOs2WJtrvb6rG6/dJ6XxfhxoeW8mv9HHVauilN2W34slp8Warmq8z+V/acSQ+P+WbFxLzRuNf+zGJZfk/SenRjL87LF/hfMnB3Dn3iep+nUeU0i239Scpl/6jh+6viyz4t1KetPnOdny5m4bfuX4i7js+DH4nA/Czri0M+kgt+ri/pz68PW9Vi2nLjFW67mHHJjl1X3P3lP3VuePS97D73IL1Ji8dVKdv6pONcdZxbzz4uNOdfPDNuvXctbrKqk7fPNnH8m9WLPeel8X/xM9m//lvb6rG7/wnleFuPnhZbz6vtCHVauilN2W34ull8Uarmq838k+08lhsb9y2LjXmhc+76wGJZfk/SfyGfoX14n//C/YObsGH7leZ6mf+a8JpHtX5Vc5l+II5V1i5X9r7+Rsn7lca+L27b/hbjL+Cz4uTjcz4KOOPQzqeD36qL+vnLqz9b1WNac+irecvV94cYuq+6/ek/dW549L3sP/Tq+rg9bInEmBTtv+/xKKjctNZClDrI0QJYmyNICWdogSwdkiUGW6j1blv32qW2PJM/uP+h4HTtf1fE6dv+mIXk6f5rl2TlzS/Ls/lxb8kaStkf7LoklL/KUzaxdyTNrT/LMqr/rata+5Jl1IHlmHUqeWdVuVrNnMY+GN8uk7wl7fZo/zu+2LN4TGieVdYulY5XWAZYYZOmALG2QpQWyNEGWBshSB1lqIEvkWFq5Jy7WsxieZZ8fdYlrcWqyPR5cP++/96/rqFusaTF8LfGY9Lvetv8PaaNadr3WK9Z36zmMxVp2vXbfljrI0gBZmiBLC2RpgywdkCUGWRKQpQuyVO/Zsuw61rbrNatd4+k1q13j6TWrzrNteXaNp9esdi6h16yRx2cGvcY0g15jmkGvMc2g15hmGIn9Z8Ob1shjHXrKpMfQYqf54/xuy+IYapxU1i2WXncOAZYuyJKALDHI0gFZ2iBLC2RpgiwNkKUOstRAlsix6HexfX9lddceXG/vO/vJtv9tvrLsWnWthPLpkkraYi27Vr1vSx1kaYAsTZClBbK0QZYOyBKDLAnI0gVZ+iDLAGQZgiwjkKV6z5ZlbRu2/X334/V+s+Xpb0JZno2l1rYNG+vta9tQnxm0vcO936RtGxuSZ4ax5JlhIvZ/P7xpjTzWsadMegwtdpo/zu+2LI6hxkll3WJp28YYYBmBLEOQZQCy9EGWLsiSgCwxyNIBWdogSwtkaYIsDZClDrLUQJbIsWhbl53vaFuXntvpPaXI2bf1cWkUW65LPe+rSPl0SSWtbT3NYi1zK2dF6qkicXTMnrYLtop1LI510ym/ravvQ621e7Yua08t+Pjdem3U9FhqIEsdZCnxf2xlS/WeLcuupW27XjdHzmuzeuyMrre7nx26H72GbnnK3i6h7BonlXWLpdegLYClAbLUQZYayBJ5LJ1iLXOLVZEYFYkTOybbFjte/Z+NxR3Oc8J5zrexlnCsXpbwv3yp3zG23PZe1Ht3Bf8vX3Zzi36PWiytW30fFjzubfH/0L0u7o3zVm230XFhXdlueZHzvPB5Ej5Pvq21hGP1InyeXC0f++dJvUjzxXyu99r0/mDLk6fv22y57VjrdY0dd637gsdMLeZ90X4MaeXdczvLL3hc1IXGreZ/FiOROrT0/xtcP9eelx3T30s91WV/Pam73zuvsed0JK37sde6aTuOsTj1fqztq/0eX7NSTh9+PcdPZV3vWf+fwbWh6M81rdN6xX/NU0LZ5/qesPewe1zK6ltgce09bDF0fN8f+rnbjVh5ntkqYtbrMe0D4Pu/LKNMsZQplfU1yV/2HP1/8ZUxlsfE87zb6iWp+PuP3BZHX1N2nzoteyrrOh7m93IfwYzab0Q/iy3P3Prd4F6Hax8RnZ+h7pTdvg+jYss//1j2qd/bvnZFzfO1P1q64an3pqfeW/Ko73k9fu68Hzovel3y3Hk/tA+Dvu9vm/dDzyXKGA8uH3GL/dq6xUoqN+cRKd5yNS+XG1vroVZa7A+vB3fulPuoh3ppsT+8Htz5YsqwvK8eGoB6MEP7HuuhCagHt336PuqhBagHM8TfcT20KsvvQZdxn6Ti1IUtbakLW2ogSx1kaYAsTZCl7Ht8q1jKvj/9Psuye/NuO5POr6btWPY5pG2FVj49H9bzGcuz73bfNYz6NJ496jmw5Vk8vdaxeNpGaPF64hyNblojj9XX1qjHsIz5BDVOWrnZJqZ9DLoASwtkaYIsDZClDrLUQBb3XoF+nmn7oXu9Gs6PPswSzo/C+dEqlnB+xDg/+r/rN63h/OjbWcL5UTg/mv+RnB8tO+cpw6dLKunEYwm/IeG3hN+Q8FtIvyFR9v/5KpYeyFL2ecT7LMvOBT/k+jD7v/sXG9fb7bws8uzH199ey15wf79b+3foeICq47tPSw9k6YIsLZClCbI0QJY6yFIDWSKPpeBr/kW/Yu0bZp+5OtbJTNrPTtP2GDnPs35UtYLNf+RjH/7Q31yvHypSj+bU78qWs02Ph/avKqNPawn/Iy9K6Mf9soTzpFcl9Pv+pIT+v6+XXZeG+UevlzD/aJh/dBVLmH80zD+6ioU0/2gPZKnes2VZO4Y7JkLnPdLzXp033PKGTjmzPOs7qPeEbF5KbSux+ZH0/M7mXtJ7Wzr3kuVN87TeS9vM03ovbZanfffSfHNqarktnv42iDunvd5L076j7m/06b1DnY/T6lfnnLL6nUie1e9U8qx+NyXP6tfKnXn/jbQ/2XO1zmee/Vha37MWO80f53dbFu9ZjZPKusXS9qdNgKUHsnRBlgRkiUGWDsjSBllaIEsTZGmALHWQpQayRI5lWZtDGT5dUklPPZYayFIHWRogSxNkaYEsbZClA7LEIEsCsnRBlh7IUvb35SqWGchS9nXt+yzL2mJsu+/+lrZ5/K/x9Xbf73NYG0PNs29ta7A2hg3Pa7WOxk5Z5ndbFnWkcVJZt1h67b8BsMxAlk2QpQeydEGWBGSJQZYOyNIGWVogSxNkaYAsdZClBrJEjmVZm0gZPl1SSY89lhrIUgdZGiBLE2RpgSxtkKUDssQgSwKydEGWHshS9vflKpYJyDIFWTZBlhnIUnabzPssy9qtbLu2b1nfF+3HEnn2Z+dk+tu5/3Fyc9+RZ9/v+/3ZMuZrW/ZbchZL263GAMsMZNkEWaYgywRk2QBZeiBLF2RJQJYYZOmALG2QpQWyNEGWBshSB1lqIEvksQyLtVxqv/WKmHRJJa1zJA+KtSzGqvYllrksTiLb9dqkX6xjcXwGTvltXX0fal2/Z+uyNumCj9+t11EDj6UGstRBlgbI0gRZWiBLG2TpgCwxyJKALF2QpQeylHg+sbJlBLKsgywbIMsYZJmALFOQZRNkmYEs1Xu2LLuHYdt1HG/kvDY7J/3Pcm/Cri0iz350LHHfU/YyxoBrnFTWLZbem+gDLDOQZRNkmYIsE5BlDLJsgCzrIMsIZBmCLD2QpQuyJCBLDLJ0QJY2yNICWZogSwNkqYMsNZAl8li2irXMs31sV64Xux7ZEoeZ7HkdSeu8SJHzPJtbs+B5MC91fqSK1KMuqaS1rbfg+TPnOt+Stm8XPP/l4j2TOOWzdf2dBZ2jtixL4oldQpzLjlPmbLntOKuljOOsvydvce7j9+C1/sucVzDxxC4hzmXHKXO23Hac1VL0vWFtk9E2/4L7ENx6D1rnyfNdBxRtSTyxy65b23f23T/buI5Z9O+Yl9D3eZ4dO7uGzpavpVza1l5G3A0n7siJW3WO4ddi1XH+9pwfb1wfh0M5DpNC7Re/yvYxFbudK1gcba/RfuG+frdl2GZiq3ls1t43E5s7F2L2PDtv0u9hOx/S743dQsswf5V5dirvLrd9hu6KZa9Yy+Kccl9imWtP6sG2b4ljv1jH4jN2zym/ravvQ63Tj8i6/RFZZx+RtX7P1o7k7Uhe5Jjt2quMz0qLUZX967nMgaRdVyxlORD/gVPO7HmHeVo/S4/ytJ4vHkss28+RbD+R9KHzmiz2AydOVm8P83SaP87vtiyO7QNxpLJusfT67aRES+KJXdZ7xeIse688krR979prYvHZ8zqSfijPO5U6tLyzPK3vlcf5YyT7OZPtTyR96rwmi33uxMnq7WmeTvPH+d2WxXvlXByprD+V+IljLsOSeGLHkqfXSM+KjH1xdR5hMSOJ+UyOx3OPY16kIz8eFsf2a+tzOR49p57KsCSe2GVcq1WcMvv6KViePc+9lgu/cbTS8qrM3zha1p89/NbN9RJ+6yb81s0qlvBbN+G3blaxhN+6Cb91ky3v+62byOMr+zdnstf9l8nNMum5hsXWeWLNWPeUSV0jj3/oKael9T1Rxvg/jZPKusXSvq9l3m/6UEsPZOmCLAnIEoMsHZClDbK0QJYmyNIAWeogSw1kcc8Lll3Tl+HTJZW0b7x8DWSpgywNkKUJsrRAljbI0gFZYpAlAVm6IEsPZCn7+3IVS5l92la1jECWsufYWcVS9vX++yzL2oBsu7aDWLuGtoNY3zptB7E+a/q7wzr+3fKsX5H+7rD1KdO2J+17Zo/aT9/y3P5m2jdM256sD5iv7Unrxcqp7Tnubxto25POs2rl1HldrZzaz8/9vVH9vWMtt5VzS/KsnDo+wcqpfWSsnFbuzPvfpM3LnqvHetezH0vre9Zip/nj/G7L4j2rcVJZt1jaRrUDsKyDLCOQZQiyrIEsPZClC7IkIEsMsnRAljbI0gJZmiBLA2Spgyw1kCVyLMvaNMvw6ZJKettjqYEsdZClAbI0QZYWyNIGWTogSwyyJCBLF2TpgSxrIMsQZBmBLOsgS9nnV6tYdkGWstvN3mdZ1tZr27WfnLUz7kpe5NmfnR/a87Pzor8f3Nx35Nm3b14VraOZU5b53ZZFHWmcVNYtlrYtbgMsuyDLDsiyDrKMQJYhyLIGsvRAli7IkoAsMcjSAVnaIEsLZGmCLA2QpQ6y1EAW3/mrbdf76pHz2tvGkRY81vfW83iLteya4j4sy64pak5dab3atux/Jt683u4b5+uOAdbnadkLHh+9KLvGSWXdYum1Qh1giTyWgsdqL4be23dApfLu/QFzmEnbgtsF10m2j47HoXOmaL8icxQ8P+Jltg/f/ZJYHi2+tnUWPGfki7vMGdkr1rJ4j6xJLHPpPJK2vezx3u+bU3IVa9ljsIu0lj0u+n3WEt5Xvyqhj+Sljr205UP6TWaWgn+X5YXNg2HH1Z2P05x6/lHG57v+xqcez2zRNgZ9nqXrsl2/7237ZHJdpmXnVOvFlunW8xiLteye931b6iBLA2RpgiwtkKUNsnRAlhhkSUCWLsjSA1nWQJY+yDIAWYYgywhkqd6zZVmbkM65Ynk2jkav1SPP/uycbEP2MZS2Ixt7o21HNvbGN15p7HFNPK/Vuix4XvNFXWqcVNYtlrYxTQCWEcgyBFkGIEsfZFkDWXogSxdkSUCWGGTpgCxtkKUFsjRBlgbIUgdZaiBL5Fj03FHHdNsYbT0HjZz96XmpjmXP/lft8/2f/PI3f/XLv/6Xv/zNn//yX+s5sXuv003rOWvDeY1a9F5bCfeA/9jnnr4sc+5pHd+v1zwdJ5aO7/ddB+lcCPq+sEdz6D7CvNfvt4R5r8O816tYwrzXYd7rVSxh3usw73W2hHmvw7zXq1rCvNdh3utVLGHe6zDv9SqWMO91mPf6Np8uqaTDvNcfbgnzXod5r1exhHmvw7zXq1jCvNdh3utVLGHe6zDvdbb8Q573eiJ9BsO813ezhHmvw7zXq1jCvNdh3utVLGHe6zDv9SqWMO91mPf6Np8uqaR9czWGea/9ljDvtd8S5r32W8K8135LmPfabwnzXvstYd5rvyXMe+23hHmv320f9LX12nYd43GXea//Lsx7XZglzHvtt4R5r/2WMO+13xLmvfZbwrzXfkuY99pvCfNe+y1h3mu/5Y9l3uum1GtajPuFnj9XxK9LKmmLn30eyLjqX/zNP/5n//SvZVx1VfZb8+xXz8UbzvOWjaleNi/1ba/XPiE1zz7D2Nz3W8LY3DA2dxVLG2QJY3PD2NxVLGFsbhibW6mEsbl2DhvG5oaxuXe1hLG5YWzuKpYwNjeMzV3F4p4XhLG577eEsblhbO4qljbIEsbmhrG5q1jC2NwwNncVSxib++Fjc7V9w9o1tF1Ix6jao84BbHkTp+w6NlfbhWyMKnHcbLav3/Vv+iOPf+oppx5ri53mj/O7LYtjrXFSWbdY2rYzBVjWQZYRyDIEWdZAlh7I0gVZEpAlBlk6IEsbZGmBLE2QpQGy1EGWGsgSOZZlbYFl+HRJJT3xWGogSx1kaYAsTZClBbK0QZYOyBKDLAnI0gVZeiDLGsgyBFlGIMs6yFL2+dUqlk2Qpex2s/dZlrWR2nbtc2btjDrXXuTZn50f6jyGvx3c3Hfk2ffEY9A62nDKMr/bsqijZb/3ZrG0bXECsGyCLFOQZR1kGYEsQ5BlDWTpgSxdkCUBWWKQpQOytEGWFsjSBFkaIEsdZKmBLL7zV9uu99Uj57Wtys3z5sLwbYFHeYVlB7CRV5b9OLAt2pHBPsCzL5T/D+y5GNuVYgQA",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "signing_pub_key_x",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "signing_pub_key_y",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "eJyd3c2uHct5pOF74VgwVtaXf6VbMTwQ3G7AgCE3WpoJunengbM3CSjiROqdHQ9eWNwVi+R6mFX1tx//9d///qe//ud///kvP/74tx+ff3l//PFf//bjL//vT3/+3//7L3/90///648/9mfvP/z4jz//n/Of9el//8OP//uf//UfP/74+fu//eE07UOiRqKHRCWjeudX1N/PP0SdRINEk0SLRJtEehG/Hz16ESHSiwiRXkSIyCIesoiHLOIhi3jIIh6yiIcsosgiiiyiyCKKLKLIIoososgiiiyiyCKKLKKTRXSyiE4W0ckiOllEJ4voZBGdLKKTRXSyiEEWMcgiBlnEIIsYZBGDLGKQRQyyiEEWMcgiJlnEJIuYZBGTLGKSRUyyiEkWMckiJlnEJItYZBGLLGKRRSyyiEUWscgiFlnEIotYZBGLLGKTRWyyiE0WsckiNlnEJovYZBGbLGKTRWyyiJcs4iWLeMkiXrKIlyziJYt4ySJesoiXLOIli2gfMon2IZtoHzKK9kFK9UFM9UFO9UFQ9UFS9UFU9UHbMHyZKrQNA5ipQttghMkMkyEmU0zGmMgxG4LMhiSzaSt85mf9Vj2zt++qz69M/uhzJn/2OZM//JzJn37MtBrmTP78cyY/nDmTn86cyY9nzthKtCDmjK1EK2LO2Eq0JOaMrURrYs7YSrQo5oytRKtizthKtCzmjK1E62LO2Eq0MOaMrUQrY87YSrQ05oytRGtjzthKtDjmjK1Eq2PO2Eq0POaMrUTrY87YSrRA5oytRCtkzthKtETmjK1Ea2TO2Eq0SOaMrUSrZM7YSrRM5oytROtkzthKtFDmjK1EK2XO2Eq0VOaMrURrZc7YSrRY5oytRKtlzthKtFzmjK1E62XO0EoeDZg5Qyt5NGHmDK3k0YiZM7SSRzNmztBKHg2ZOWMr0ZSZM7YSjZk5YyvRnJkzthINmjljK9GkmTO2Eo2aOWMr0Sc0c8ZWok9p5oythNnrw+z1Yfb6MHt9mL0+zF4fZq8Ps9eH2evD7PVh9vowe32YvT7MXh9mrw+z14fZ68Ps9WH2+jB7fZi9PsxeH2avD7PXx9jreMfP7BGZXknM9EpiplcSM72SmOmVxEyvJGZ6JTHTK4mZXknKjL3GjK3E2GvM2EqMvcaMrcTYa8zYSoy9xoytxNhrzNhKjL3GjK3E2GvM2EqMvcaMrcTYa8zYSoy9xoytxNhrzNhKjL3GjK3E2GvM2EqMvcaMrcTYa8zYSoy9xoytxNhrzNhKjL3GjK3E2GvM0ErK2GvM0ErK2GvM0ErK2GvM0ErK2GvM0ErK2GvM2EqMvcaMrcTYa8zYSoy9xoytxNhrzNhKjL3GjK3E2GvM2EqMvcaMrcTYa8zYSoy9xoytxNhrzNhKjL3GjK3E2GvM2EqMvcaMrcTYa8zYSoy9xoytxNhrzNhKjL3GjK3E2GvM2EqMvcaMrcTYa8zYSpi9FrPXYvZazF6L2Wsxey1mr8XstZi9FrPXYvZazF6L2Wsxey1mr8XstZi9FrPXYvZazF6L2Wsxey1mr8XstZi9FrPXYvZazF6L2Wsxey1mr8XstZi9FrPXYvZazF6L2Wsxey1mr8XstZi9FrPXYvZazF6L2Wsxey1mr8XstZi9FrPXzuy1M3vtzF47s9fO7LUze+3MXjuz187stTN77cxeO7PXzuy1M3vtzF47s9fO7LW7c6/9/c62yswppJSZU0ghc+deU2bOqqXMnFVLmTmrljK9kpiZs2opM2fVUsZW4s69poytxJ17TRlbiTv3mjK2EnfuNWVsJe7ca8rYSty515SxlbhzryljK3HnXlPGVuLOvaaMrcSde00ZW4k795oythL3zIGUsZW4Zw6kjK3EPXMgZWwl7pkDKWMrcc8cSBlbiXvmQMrYStwzB1LGVuKeOZAythL3zIGUsZW4Zw6kjK3EPXMgZWwl7pkDKWMrcc8cSBlbiXvmQMrYStwzB1LGVuKeOZAythL3zIGUsZW4Zw6kjK3EPXMgZWwl7pkDKWMrcc8cSBlbiXvmQMrYStwzB1LGVuKeOZAythL3zIGUoZUM98yBlKGVDPfMgZShlQxjrzFDKxnumQMpQysZ7pkDKWMrcc8cSBlbiXvmQMrYStwzB1LGVuKeOZAythJmr4PZ62D2Opi9Dmavg9nrYPY6mL0OZq+D2etg9jqYvQ5mr4PZ62D2Opi9Dmavg9nrYPY6mL0OZq+D2etg9jqYvQ5mr4PZ62D2Opi9Dmavg9nrYPY6mL0OZq+D2etg9jqYvQ5mr4PZ62D2Opi9Dmavg9nrYPY6mL0OZq+D2etg9jqYvQ5mr4PZ62D2Opi9Dmavg9nrYPY6mL0OZq+D2etg9jqYvQ5mr4PZ62D2Opi9Dmavg9nrYPY6mL0OZq+D2etg9jqYvQ5mr4PZ62D2Opi9Dmavg9nrYPY6mL0OZq+D2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9TmOva+6vbP3ycsefmV5JzPRKYqZXEjO9kpjplaTM2GvM9EpiplcSM72SmLGVGHuNGVuJsdeYsZUYe02ZsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ihlSxjrzFDK1nGXmOGVrKMvcYMrWQZe40ZWsky9hozthJjrzFjKzH2GjO2EmOvMWMrMfYaM7YSY68xYysx9hozthJjrzFjKzH2GjO2EmOvMWMrMfYaM7YSY68xYysx9hozthJjrzFjKzH2GjO2EmOvMWMrMfYaM7YSY68xYysx9hozthJjrzFjKzH2GjO2EmOvMWMrMfYaM7YSZq+L2eti9rqYvS5mr4vZ62L2upi9Lmavi9nrYva6mL0uZq+L2eti9rqYvS5mr4vZ62L2upi9Lmavi9nrYva6mL0uZq+L2eti9rqYvS5mr4vZ62L2upi9Lmavi9nrYva6mL0uZq+L2eti9rqYvS5mr4vZ62L2upi9Lmavi9nrZva6mb1uZq+b2etm9rqZvW5mr5vZ62b2upm9bmavm9nrZva6mb1uZq+b2etm9rqZvW5mr5vZ62b2upm9bmavm9nrZva6mb1uZq+b2etm9rqZvW5mr5vZ62b2upm9bmavm9nrZva6mb1uZq+b2etm9rqZvW5mr5vZ62b2upm9bmavm9nrZva6mb1uZq+b2etm9rqZvW5mr5vZ62b2upm9bmavm9nrZva6mb1uZq+b2etm9rqZvW5mr5vZ62b2upm9bmavm9nrZva6mb1uZq+b2etm9rqZvW5mr5vZ62b2upm9bmavm9nrZva6mb1uZq+b2etm9rqZvW5mr5vZ62b2upm9bmavm9nrZva6mb1uZq+b2evL7PVl9voye32Zvb7MXl9m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Fx3ci/bdiw7uRfvuRQf3on33ooN70b570cG9aN+96OBetO9edHAv2ncvOrgX7bsXHdyL9t2LDu5F++5FB/eiffeig3vRvnvRwb1o373o4F607150cC/ady86uBftuxcd3Iv23YsO7kX77kUH96J996KDe9G+e9HBvWjfvejgXqDvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ou8v4bhtfz5+o89lWnd5L7vRecqf3Ejvju7nTe8md3kvu9F5yp/eSO72X3MG9GN/NHdyL8d3UbeO7uWN72cZ3c8f2so3v5o7tZRvfzR3byza+mzu4F+O7uYN7Mb6bO7gX47u5g3sxvps7uBfju7mDezG+mzu4F+O7uYN7Mb6bO7gX47u5g3sxvps7uBfju7mDezG+mzu4F+O7uYN7Mb6bO7gX47u5g3sxvps7uBfju7mDezG+mzu4F+O7uYN7Mb6bO7gX47u5g3sxvps7uBfju7mDezG+mzu4F+O7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rNA2tIvGCm1Du2is0Da0i8YKbUO7aKzQNrSLxgptQ7torNA2tIvGCm1Du2is0Da0i8YKbUO7aKzQNrSLxgptQ7torNA2jIumCm0DuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuehCLrqQiy7kogu56EIuupCLLnNCcX2/vvfX0xFfb+Vc2tl+/2WUSzNbiuQKUwRe5bm0saUIvMpzaUVZ36cp1vr55tzvM2lLK0qotlaUWMkFxkquIlZyFrGSu4iVHEas5DJiJacRK7KNrRUlVVpRYoW2oRUlVmgbWlFihbahFSVWaBtaUWKFtqEVJVZoG1pRYoW2oRUlVmgbWlFihbahFSVWaBtaUWKFtqEVJVZoG1pRYoW2oRUlVmgbWlFihbahFSVWaBtaUWKFtqEVJVZoG1pRYoW2oRUlVmgbWlFihbahFSVWaBtaUWKFtqEVJVZoG1pRYoW2oRUlVmgbWlFihbahFSVWaBtaUWKFtqEVJVZoG1pRYoW2oRUlVmgb+nRZrNA29OmyWKFtaFOKFdqGPl0WK7QNrV6xQtvQ7hUrtA0tX7FC29Cny2KFtqFPl8UKbUOfLosV2oY+XRYrtA19uixWchv7M36rzh/cqpLbiJXcRqhe7aKxktuIldxGrOQ2YiW3ESu5jVjJbcSKbOPVLhortA3torFC29AuGiu0De2isULb0C4aK7QN7aKxQtvQLhortA3torFC29AuGiu0De2isULb0C4aK7QN7aKxQtvQLhortA3torFC29AuGiu0De2isULb0C4aK7QN7aKxQtvQLhortA3torFC29AuGiu0De2isULb0C4aK7QN7aKxQtvQLhortA3torFC29AuGiu0De2isULb0C4aK7QN7aKxQtvQLhortA3torFC29AuGiu0De2isULb0C4aK7QN7aKxQtvQLhortA3torFC29AuGiu0De2isULb0C4aK7QN7aKxQtvQLhortA3torFC29AuGiu0DeSiL3HR+SEueiqwjVOBbZwKbONUYBunAts4FdjGqcA2TgW2cSq0DeKip0LbIC56KrQN4qKnQtsgLnoqtA3ioqdC2yAueiq0DeKip0LbIC56KrQN4qKnQtswLjq/njn5Pq+q9DZCZVw0VXobqdLbSJXeRqr0NlKlt5EqvY1U6W2kCm3DuGiojIumCm3DuGiq0DaM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KYk75HuflMQd8r1PSuIO+d4nJXGHfO+TkrhDvvdJSdwh3/ukJO6Q731SknYo+94nJWmHsu99UpJ2KPveJyVph7LvfVKSdij73iclcYd875OSuEO+90lJ3CHf+6Qk7pDvfVISd8j3PimJO+R7n5TEHfK9T0riDvneJyVxh3zvk5K4Q773SUncIf97qVISd8jXSSmJO+TrpJTEHfJ1UkriDvnfS5WSuEOBiCpJ3CH/e6lSEnfI91spiTvk+62UxB3yv5cqJXGHfDOWkrhDvhlLSdwh34ylJO5QYMZKEncoMGMliTsUmLGSxB3yv5cqJXGHIqcWkrhD2KkzduqMnTpjp87YqTN26oydOmOnztipM3bqjJ06Y6fO2KkzduqMnTpjp87YqTN26oydOmOnztipM3bqjJ06Y6fO2KkzduqMnTpjp87YqTN26oydOmOnztipM3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqWvk1P2WtIt7JaoaObWQDDokJIMOCcmgQ/Nk5NRCMuiQkAw6JCSDDgnJoENCEncocmohiTsUObWQxB2KnFpI4g5FTi0kcYcipxaSuEORUwtJ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rtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGn7tipO3bqjp26Y6fu2Kk7duqOnbpjp+7YqTt26o6dumOn7tipO3bqjp26Y6fu2Kk7duqOnbpjp+7YqTt26o6dumOn7tipO3bqjp26Y6fu2Kk7duqOnbpjp+7YqTt26o6dumOn7tipO3bqjp26Y6fu2Kk7duqOnbpjp+7YqTt26o6dumOn7tipO3bqjp26Y6fu2Kk7duqOnbpjp+7YqTt26o6dumOn7tipO3bqjp26Y6fu2Kk7duqOnbpjp+7YqTt26o6dumOn7tipO3bqjp26Y6fu2Kk7duqOnbpjp+7YqTt26o6dumOn7tipO3bqjp26Y6fu2Kk7duqOnbpjp+7YqTt26o6dumOn7tipO3bqjp26Y6ce2KkHduqBnXpgpx7YqQd26oGdemCnHtipB3bqgZ16YKce2KkHduqBnXpgpx7YqQd26oGdemCnHtipB3bqgZ16YKce2KlH9DuKo1yT+3/6yeD3y4Rk8PtlQjL4/TIhGfx+2TwZ/Y6ikAx+v0xIBr+BJySD38ATkn6HlCTuUPQ7ikISdyj6HUUhiTsU/Y6ikMQdin5HUUjiDkW/oygkcYei31EUkrhD0e8oCkncoeh3FIUk7lDg1EoSdyhwaiWJOxQ4tZLE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"
    ],
    "fileMap": {
      "0": {
        "source": "mod storage;\nmod ecdsa_public_key_note;\n\n// Account contract that uses ECDSA signatures for authentication on the same curve as Ethereum.\n// The signing key is stored in an immutable private note and should be different from the signing key.\ncontract EcdsaAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::log::emit_encrypted_log;\n    use dep::aztec::oracle::get_public_key::get_public_key;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    use dep::aztec::constants_gen::MAX_NOTE_FIELDS_LENGTH;\n    use dep::aztec::note::{\n        note_header::{NoteHeader},\n        utils as note_utils,\n    };\n\n    use crate::storage::Storage;\n    use crate::ecdsa_public_key_note::EcdsaPublicKeyNote;\n    use crate::ecdsa_public_key_note::EcdsaPublicKeyNoteInterface;\n    use crate::ecdsa_public_key_note::ECDSA_PUBLIC_KEY_NOTE_LEN;\n\n    // All calls made by this account will be routed through this entrypoint\n    fn entrypoint(  \n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        signature: pub [u8;64],\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        \n        // Initialise context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64\n        let mut args: BoundedVec<Field, 77> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in signature { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Load public key from storage\n        let storage = Storage::init();\n        let public_key = storage.public_key.get_note(&mut context);\n\n        // Verify payload signature using Ethereum's signing scheme\n        // Note that noir expects the hash of the message/challenge as input to the ECDSA verification.\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n        let hashed_message: [u8; 32] = std::hash::sha256(message_bytes);\n        let verification = std::ecdsa_secp256k1::verify_signature(public_key.x, public_key.y, signature, hashed_message);\n        assert(verification == true);\n\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Creates a new account out of an ECDSA public key to use for signature verification\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n        signing_pub_key_x: pub [u8;32],\n        signing_pub_key_y: pub [u8;32],\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        let storage = Storage::init();\n        \n        let mut args: BoundedVec<Field, 64> = BoundedVec::new(0);\n        for byte in signing_pub_key_x { args.push(byte as Field); }\n        for byte in signing_pub_key_y { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n        \n        let this = context.this_address();\n        let mut pub_key_note = EcdsaPublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\n        storage.public_key.initialise(&mut context, &mut pub_key_note);\n        \n        emit_encrypted_log(\n            &mut context,\n            this,\n            storage.public_key.storage_slot,\n            get_public_key(this),\n            pub_key_note.serialise(),\n        );\n\n        context.finish()\n    }\n\n    // Computes note hash and nullifier.\n    // Note 1: Needs to be defined by every contract producing logs.\n    // Note 2: Having it in all the contracts gives us the ability to compute the note hash and nullifier differently for different kind of notes.\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> [Field; 4] {\n        assert(storage_slot == 1);\n        let note_header = NoteHeader { contract_address, nonce, storage_slot };\n        note_utils::compute_note_hash_and_nullifier(EcdsaPublicKeyNoteInterface, note_header, preimage)\n    }\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-contracts/src/contracts/ecdsa_account_contract/src/main"
      },
      "3": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\nfn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\nfn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\nfn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\nfn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\nfn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\nfn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\nfn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "29": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    fn unwrap_or_else(self, default: fn() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    fn map<U>(self, f: fn(T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    fn map_or<U>(self, default: U, f: fn(T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    fn map_or_else<U>(self, default: fn() -> U, f: fn(T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    fn and_then<U>(self, f: fn(T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    fn or_else<U>(self, default: fn() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    fn filter(self, predicate: fn(T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, msg: Field) {\n        self.new_l2_to_l1_msgs.push(msg);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "33": {
        "source": "use crate::context::PrivateContext;\nuse crate::oracle;\nuse crate::types::point::Point;\n\nfn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\nfn emit_unencrypted_log<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let _ = oracle::logs::emit_unencrypted_log(log);\n    context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/log"
      },
      "39": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::create_commitment::create_commitment;\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\nfn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn create_note_hash_from_public<Note, N>(\n    context: PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = context.this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    create_commitment(inner_note_hash);\n}\n\nfn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // 0 nonce implies \"transient\" nullifier (must nullify a commitment in this TX).\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.nonce == 0) {\n        // TODO(suyash): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(storage_slot, nullifier, preimage, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/lifecycle"
      },
      "40": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort},\n    note_interface::NoteInterface,\n    note_header::NoteHeader,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n    utils::compute_unique_siloed_note_hash,\n    utils::compute_inner_note_hash,\n    utils::compute_siloed_note_hash,\n};\nuse crate::messaging::get_commitment_getter_data::make_commitment_getter_data;\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn ensure_note_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    let saved_note = get_note_internal(storage_slot, note_interface);\n\n    // Only copy over the header to the original note to make sure the preimage is the same.\n    let get_header = note_interface.get_header;\n    let set_header = note_interface.set_header;\n    let note_header = get_header(saved_note);\n    set_header(note, note_header);\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, *note);\n    context.push_read_request(note_hash_for_read_request);\n}\n\n// Ensure a note's hash exists in the tree without retrieving the entire\n// notes via the oracle.\n// Modifies the note by populating it with header info.\nfn ensure_note_hash_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    // Initialize header of note. Must be done before computing note hashes as it initializes the:\n    // - storage slot (used in inner note hash)\n    // - the contract address (used in siloed note hash)\n    // - and the nonce (used in the unique siloed note hash)\n    let set_header = note_interface.set_header;\n    let note_header = NoteHeader {\n        contract_address: (*context).this_address(),\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n        // real nonce (once public kernel applies nonces).\n        nonce: 0,\n        storage_slot\n    };\n    set_header(note, note_header);\n\n    // Get a note from oracle and early out if it doesn't exist.\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let raw_oracle_ret = oracle::get_commitment::get_commitment(inner_note_hash);\n    let deserialized_oracle_ret = make_commitment_getter_data(raw_oracle_ret, 0);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // unique_siloed_note_hash once public kernel applies nonces\n    let saved_siloed_note_hash = deserialized_oracle_ret.message;\n\n    assert(saved_siloed_note_hash != 0); // TODO(dbanks12): necessary?\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    // Ensure that the note hash retrieved from oracle matches the one computed from note.\n    let computed_siloed_note_hash = compute_siloed_note_hash(note_interface, *note);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // compute_note_hash_for_read_or_nullify once public kernel applies nonces\n    assert(computed_siloed_note_hash == saved_siloed_note_hash);\n\n    context.push_read_request(computed_siloed_note_hash);\n}\n\nfn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\nfn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        let mut note_hash_for_read_request = 0;\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            check_note_header(*context, storage_slot, note_interface, note);\n            note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n        };\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n        // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n        context.push_read_request(note_hash_for_read_request);\n    };\n\n    // TODO(#1660)\n    // Move it back to get_notes_internal and only make read request for selected notes.\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/note_getter"
      },
      "42": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\nfn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\nfn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/note_hash"
      },
      "46": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nfn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\nfn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\nfn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    if (header.nonce == 0) {\n        // when nonce is zero, that means we are reading a pending note (doesn't have a nonce yet),\n        // so we just read the inner_note_hash (kernel will silo by contract address)\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\nfn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    let mut note = deserialise(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/utils"
      },
      "48": {
        "source": "use dep::std::hash::pedersen_with_separator;\nuse crate::context::PrivateContext;\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle;\nuse crate::constants_gen::{\n    GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n    EMPTY_NULLIFIED_COMMITMENT,\n};\n\nstruct ImmutableSingleton<Note, N> {\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    fn new(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Self {\n        ImmutableSingleton { storage_slot, note_interface }\n    }\n\n    unconstrained fn is_initialised(self) -> bool {\n        let nullifier = self.compute_initialisation_nullifier();\n        oracle::notes::is_nullifier_emitted(nullifier)\n    }\n\n    fn initialise(self, context: &mut PrivateContext, note: &mut Note) {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialisation_nullifier();\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n\n    fn compute_initialisation_nullifier(self) -> Field {\n        pedersen_with_separator([self.storage_slot], GENERATOR_INDEX__INITIALISATION_NULLIFIER)[0]\n    }\n    \n    fn get_note(self, context: &mut PrivateContext) -> Note {\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n\n    unconstrained fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/state_vars/immutable_singleton"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "60": {
        "source": "fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/utils"
      },
      "61": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/private_call_stack_item"
      },
      "62": {
        "source": "use crate::{\n    abi,\n    abi::{\n        PublicCircuitPublicInputs,\n        FunctionData,\n    },\n};\nuse crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__CALL_STACK_ITEM,\n};\n\n// oracles\nuse crate::oracle::{\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n};\n\nstruct PublicCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PublicCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PublicCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}\n\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/public_call_stack_item"
      },
      "65": {
        "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: Field,\n    _function_selector: Field,\n    _args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained fn call_private_function_internal(\n    contract_address: Field,\n    function_selector: Field,\n    args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n    )\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/call_private_function"
      },
      "73": {
        "source": "use crate::types::point::Point;\nuse dep::std::hash;\nuse crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n\n#[oracle(getPublicKey)]\nfn get_public_key_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_internal(address: Field) -> [Field; 3] {\n  get_public_key_oracle(address)\n}\n\nfn get_public_key(address: Field) -> Point {\n  let result = get_public_key_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = hash::pedersen_with_separator([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_public_key"
      },
      "74": {
        "source": "use crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(_owner: Point) -> Field {}\n\nunconstrained fn get_secret_key(owner: Point) -> Field {\n    get_secret_key_oracle(owner)\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_secret_key"
      },
      "76": {
        "source": "\n// contract_address + \n// args_hash +\n// crate::abi::FUNCTION_DATA_SIZE +\n// crate::abi::CALL_CONTEXT_SIZE +\n// = 2 + 4 + 6\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE: Field = 12;\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: Field, \n    _function_selector: Field, \n    _args_hash: Field,\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {}\n\nunconstrained fn enqueue_public_function_call_internal(\n    contract_address: Field, \n    function_selector: Field,\n    args_hash: Field\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {\n    enqueue_public_function_call_oracle(\n        contract_address, \n        function_selector, \n        args_hash,\n    )\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/enqueue_public_function_call"
      },
      "78": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _storage_slot: Field,\n    _nullifier: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn notify_nullified_note<N>(\n    storage_slot: Field,\n    nullifier: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(storage_slot, nullifier, preimage, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialise the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialise the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_some.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let header = NoteHeader { contract_address, nonce, storage_slot };\n            let is_some = fields[read_offset + 1] as bool;\n            if is_some {\n                let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n                let mut note = deserialise(preimage);\n                set_header(&mut note, header);\n                placeholder_opt_notes[i] = Option::some(note);\n            }\n        };\n    };\n    placeholder_opt_notes\n}\n\nunconstrained fn is_nullifier_emitted(nullifier: Field) -> bool {\n    // TODO\n    nullifier == 0\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/notes"
      },
      "80": {
        "source": "use crate::types::point::Point;\nuse crate::constants_gen::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: Field,\n    _storage_slot: Field,\n    _encryption_pub_key: Point,\n    _preimage: [Field; N],\n)  -> Field {}\n\nunconstrained fn emit_encrypted_log<N>(\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    preimage: [Field; N],\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(\n        contract_address,\n        storage_slot,\n        encryption_pub_key,\n        preimage,\n    ), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_message: T)  -> Field {}\n\nunconstrained fn emit_unencrypted_log<T>(message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(message), 0]\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/logs"
      },
      "81": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      },
      "84": {
        "source": "use dep::std::hash::pedersen;\nuse dep::aztec::note::note_interface::NoteInterface;\nuse dep::aztec::note::note_header::NoteHeader;\nuse dep::aztec::note::utils::compute_unique_siloed_note_hash;\nuse dep::aztec::oracle::get_secret_key::get_secret_key;\nuse dep::aztec::oracle::get_public_key::get_public_key;\n\nglobal ECDSA_PUBLIC_KEY_NOTE_LEN: Field = 5;\n\n// Stores an ECDSA public key composed of two 32-byte elements\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\nstruct EcdsaPublicKeyNote {\n    x: [u8; 32],\n    y: [u8; 32],\n    owner: Field, // We store the owner address only to get the secret key to compute the nullifier\n    header: NoteHeader,\n}\n\nimpl EcdsaPublicKeyNote {\n    fn new(x: [u8; 32], y: [u8; 32], owner: Field) -> Self {\n        EcdsaPublicKeyNote {\n            x,\n            y,\n            owner,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // Serialise the note as 5 fields where:\n    // [0] = x[0..31] (upper bound excluded)\n    // [1] = x[31]\n    // [2] = y[0..31]\n    // [3] = y[31]\n    // [4] = owner\n    fn serialise(self) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n\n        for i in 1..32 {\n          let bytex: Field = self.x[31 - i] as Field;\n          x = x + (bytex * mul);\n          let bytey: Field = self.y[31 - i] as Field;\n          y = y + (bytey * mul);\n          mul *= 256;\n        }\n\n        let last_x = self.x[31] as Field;\n        let last_y = self.y[31] as Field;\n        \n        let res: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] = [x, last_x, y, last_y, self.owner];\n        res\n    }\n\n    fn compute_nullifier(self) -> Field {\n        let unique_siloed_note_hash = compute_unique_siloed_note_hash(EcdsaPublicKeyNoteInterface, self);\n        let owner_nullifying_public_key = get_public_key(self.owner);\n        let secret = get_secret_key(owner_nullifying_public_key);\n        dep::std::hash::pedersen([\n            unique_siloed_note_hash,\n            secret,\n        ])[0]\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n}\n\nfn deserialise(preimage: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> EcdsaPublicKeyNote {\n    let mut x: [u8; 32] = [0;32];\n    let mut y: [u8; 32] = [0;32];\n\n    let part_x = preimage[0].to_be_bytes(32);\n    for i in 0..31 { x[i] = part_x[i + 1]; }\n    x[31] = preimage[1].to_be_bytes(32)[31];\n\n    let part_y = preimage[2].to_be_bytes(32);\n    for i in 0..31 { y[i] = part_y[i + 1]; }\n    y[31] = preimage[3].to_be_bytes(32)[31];\n\n    EcdsaPublicKeyNote {\n        x,\n        y,\n        owner: preimage[4],\n        header: NoteHeader::empty(),\n    }\n}\n\nfn serialise(note: EcdsaPublicKeyNote) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n    note.serialise()\n}\n\nfn compute_note_hash(note: EcdsaPublicKeyNote) -> Field {\n    dep::std::hash::pedersen(note.serialise())[0]\n}\n\nfn compute_nullifier(note: EcdsaPublicKeyNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: EcdsaPublicKeyNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut EcdsaPublicKeyNote, header: NoteHeader) {\n    note.set_header(header);\n}\n\nglobal EcdsaPublicKeyNoteInterface = NoteInterface {\n    deserialise,\n    serialise,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n};\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-contracts/src/contracts/ecdsa_account_contract/src/ecdsa_public_key_note"
      }
    }
  }
}
