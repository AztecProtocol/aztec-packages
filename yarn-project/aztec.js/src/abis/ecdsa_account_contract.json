{
  "name": "EcdsaAccount",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 5,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+3dTW8kSX7f8Xp+yKxiPbFYfH5uNslmdxfZ3dNPszO5D9pdabU7awl+AxZmBQN+EIwVbB3kWR8Nw4AvNnz0ZQ8+2Fed/Br0HnyxT4Z98kHCQpPF/C9/HYxidw0zp769igSIioysyv8nIotVmZERUd1SqVQuXS/Vr/9qpduLbU+yx+n9lstyfvuaFumsfCTOao7O1FYvFXv8awXUa97G+kdgbHwExuZHYGyV8v3/MaN9lra//ou+/ou//uuUbpa/Xb/Zbv9zVXmNvb4ieVWnDtqy3ZaGpJN8yvWikX+9T+uZvySPWt6VrCzNfONeah3VSjf13JRjYNu78pjmtfK1XDWk7Dnt81m6zyjffT5P9xkX8J7q5LvPTxpyzHLa50srd0nem2mclXzjXJZL7y6JpC2WWqogSw1kqYMsDZClCbK0QJY2yBKBLDHI0gFZuiBLecmWthhKkmfbW5LXk7Q99rN0JHkDp5xp3jBLdyRvlKW7kreapfWceZyl9dx6LUvrOfokS9clT89FLc/2o+Wx/fQlz/YzkDz7PhhKnn0ujyTP6m1V8qzexpJn9bYmeVZvWp6/lO32XK2jiWc/ltb3mMVOssfp/ZbZe0zjJLJusSIxrAEsXZClA7LEIEsEsrRBlhbI0gRZGiBLHWSpgSxVkKXiWPQ8YyJ5Fee1zcydcxvFizSWti2aX5dE0gWew07TffZy3me6j774rax6Tmzbe1K2fr6O2ftjpfRundp6X+KG8ucaN5S/FMr/97n8oQ06tEF/U0togw5t0ItYQht0aINexNIDWejt4dqmbecL2qZtbcXatnxXG7S2N9v3n+0j/Q76Zet2vIonXt/jKrouNU4i6xZL2337AEsPZOmCLB2QJQZZIpClDbK0QJYmyNIAWeogSw1kqYIsFccS2ghCG8E3tYQ2gtBGsIgltBGENoJFLKQ2gqK/uxexDEAWetuJ9qNz20TS79L/Lm0ddg9e2zqy4Tbv9APcyNLaD3BT9ml5W1m6IXnbWbrpsWofAOvrty551tdvQ/Ksr9+m5Fm/gS3Jsz4H2x6LHkN7TZI9Tu+3zI6hxklk3WJpm802wDIAWfogSw9k6YIsHZAlBlkikKUNsrRAlibI0gBZ6iBLDWSpgiwVj2UzX8uVnseVxKRLImk9D9twzKlvvYC62nAstm6xYjGsFGa5mvU3cmMXUOartlPmdLnrmOg5tJ1jb4hvJ1/f7JhMHIutWyytq2Fhlutj4sYuoMxXbafM6XLXMbH46et2s/REfHv5+mbHZNex2LrF0roaFWiJPbELiHPVdsqcLncdE4ufvm4/S++K7yDneihLHNuvrVssravVAi2xJ3YBca60bm2565hY/PR1h1l6X3xHOddDWeLYfm3dYmldjQu0xJ7YBcS5ajtlTpe7jonFT193nKUPxfcg53ooSxzbr61bLK2rtQIt8ZzYtug9xOMC6qHk1IMtxx5LFWSpgSx1kKUBsjRBlhbI0gZZIpAlBlk6IEsXZFkBWXogSx9kGYAsQ5BlBLKsgixjkGUNZJmALOsgywbIsgmybIEs2yDLDsiyC7LsgSz7IMsByHIIshyBLOUlW+b1U7Pt2lfL2tW0n9dJltY+Yg+z9K7knWbpfck7y9KHkneepXWuvUeStseLLK1z7VU8ZbO2tgeSV8vSJ5JnbU8PJc/agE4lz9piziTPrOeSZ1a1m9Xsacw/7t0uk74n7PVJ9ji93zJ7T2icRNYtlvZ7uwBYjkCWQ5DlAGTZB1n2QJZdkGUHZNkGWbZAlk2QZQNkWQdZJiDLGsgyBllWQZYRyDIEWQYgSx9k6YEsKyBLF2TpgCwxyBKBLG2QpQWyNEGWBshSB1lqIEsVZKk4lki26xgMa4vbkDxrs5tInrXt7UqetQHuS561FVr7j7bhVqReiuhjqUsiaV8/xyrIUgNZ6iBLA2RpgiwtkKUNskQgSwyydECWLsiyArL0QJY+yDIAWYYgywhkWQVZxiBLkeN4FrVMQJZ1kGUDZNkEWbZAlm2QZQdk2QVZ9kCWfZDlAGQ5BFmOQJYTkOUhyHIKspyBLOcgyyOQ5QJkKS/ZMq+/sG3XuSetH672gX2cpbWv7JMsrX1qn2Zp7Xs7zdLaR/cyS2tf3orHbO3i2jfYrI8lr56ln0ietdc+lTxrN51KnrVfmind1697t/0Vj3/qKacea4ud2PNzONYaJ5F1i6X9gKcAywXI8ghkOQdZzkCWU5DlIchyArIcgSyHIMsByLIPsuyBLLsgyw7Isg2ybIEsmyDLBsiyDrJMQJY1kGUMsqyCLCOQZQiyDECWPsjSA1lWQJYuyNIBWWKQJQJZ2iBLC2RpgiwNkKUOstRAlirIUnEs8/rYF+HTJZH0U4+lCrLUQJY6yNIAWZogSwtkaYMsEcgSgywdkKULsqyALD2QpQ+yDECWIcgyAllWQZYxyLIGskxAlnWQZQNk2QRZtkCWbZBlB2TZBVn2QJZ9kOUAZDkEWY5AlhOQ5SHIcgqynIEs5yDLI5DlAmQpui18EcslyFJesmXe2AO9h2B51n//UvIqnv1ZW749P23D/lX/9r4rnn0/9Ri0jh47ZZneb5nVkcZJZP2x1EHZ8S3TcgmyTEGWC5DlEchyDrKcgSynIMtDkOUEZDkCWQ5BlgOQZR9k2QNZdkGWHZBlG2TZAlk2QZYNkGUdZJmALGsgyxhkWQVZRiDLEGQZgCx9kKUHsqyALF2QpQOyxCBLBLK0QZYWyNIEWRogSx1kqYEsVZDFvdcwbyxDET5dEkk/9liqIEsNZKmDLA2QpQmytECWNsgSgSwxyNIBWbogywrI0gNZ+iDLAGQZgiwjkGUVZBmDLGsgywRkWQdZNkCWTZBlC2TZBll2QJZdkGUPZNkHWQ5AlkOQ5QhkOQFZHoIspyDLGchyDrI8AlkuQJYnIEvR7fKLWKYgyyXIUl6yZd4YD9vekjz7LQf9rYaKZ3/ubz+kbft/1b+974pn3489Bq2jIn6DQ+Mksm6xdIzHY4DlEmSZgixPQZYnIMsFyPIIZDkHWc5AllOQ5SHIcgKyHIEshyDLAciyD7LsgSy7IMsOyLINsmyBLJsgywbIsg6yTECWNZBlDLKsgiwjkGUIsgxAlj7IYv2UCJYVkKULsnRAlhhkiUCWNsjSAlmaIEsDZKmDLDWQpQqyuPdg5o19WfZvqVdBlhrIUgdZGiBLE2RpgSxtkCUCWWKQpQOydEGWFZClB7L0QZYByDIEWUYgyyrIMgZZ1kCWCciyDrJsgCybIMsWyLINsuyALLsgyx7Isg+yHIAshyDLEchyDLKcgCwPQZZTkOUMZDkHWR6BLBcgS9Ht8otYnoAsT0GWKchyCbKUl2yZNyZIt9vjVZY+lryKZ39278eeX//676/7t/dd8ez7gcegdfTMKcv0fsusjjROIusWS8cEPQBYLkGWKcjyFGR5ArI8BlkuQJZHIMs5yHIGspyCLA9BlhOQ5RhkOQJZDkGWA5BlH2TZA1l2QZYdkGUbZNkCWTZBlg2QZR1kmYAsayDLGGRZBVlGIMsQZBmALH2QpQeyrIAsXZClA7LEIEsEsrRBlhbI0gRZGiBLHWSpgSxVkMW9NxXJ9i3Je56lNyTvRZaeSN4nWXpX8l5m6X3Je5Wlrf1n3hit16X860WXRNKvPZYqyFIDWeogSwNkaYIsLZClDbJEIEsMsnRAli7IsgKy9ECWPsgyAFmGIMsIZFkFWcYgyxrIMgFZ1kGWDZBlE2TZAlm2QZYdkGUXZNkDWfZBlgOQ5RBkOQJZjkGWByDLCcjyEGQ5BVnOQJZzkOURyHIBsjwGWZ6ALE9BlinIcgmyXIEsz0CW5yDLC5DlE5DlJcjyCmQpL9kybwyoba9L3pss/Uzy3mbp55L3aZZ+IXnfydKfSN5nWfql5H2epV9JXsVjtvvXbyTP7iO/lTzzfyp5dl/1O5Jn9zc/kzy7z2imdF+/7t32Vzz+zzzl1GNtsZPscXq/ZXasNU4i6xZLx7J+BrC8AllegiyfgCwvQJbnIMszkOUKZLkEWaYgy1OQ5QnI8hhkuQBZHoEs5yDLGchyCrI8BFlOQJYHIMsxyHIEshyCLAcgyz7Isgey7IIsOyDLNsiyBbJsgiwbIMs6yDIBWdZAljHIsgqyjECWIcgyAFn6IEsPZFkBWbogSwdkiUGWCGRpgywtkKUJsjRAljrIUgNZqiBLxWP5NF/Lc+0DUBKTLomkPxXL23wts9tCbySWuSxOLNu1j96bfB2z4/PWKb+tq+9DrccfkfXqI7J+vmSr9rPRPisVx9zMjI18jVfaj8aWu/53G2K070WdV6FVQB02HYutW6xYDNXiLC9iT+xoTj2084091T5Ltu/0O+/ftG5ixjmXN93nSs7lSI+nXQuky1dSLh2zXkTcrhM3duKWS+/Os/CVWO21VXnOv2/dHId/m6X1GlD71/WcWPo/btuapXevZ/X/si9pq6+a5A0lXXFeo20HOs7b2lmS7HF6v+VF23Gky12fJTrOe5yvZXa8dYxyIjE07iTfuJcat5z9WQzLr0r6v9jBlOeli70HzKxtdPo8TQ+d18SyfbXgMo/Fkci6xUrfq/9RyrrqcevnuW3XORJWc3an+xiJo+XY2lIO/Wxf+xbrb03qpO7UVwGW2XecG7uouh+/p+4tz57nft/V8jVdad9jW+76/NK5rfI9L7uafd9/k/Oy9LGZq2U6LeBcanad1ha/ldXssWzXOaFyPq+68/xS538K5c81bih/KZQ/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5Q/lD+UP5T/2y9/W/KqS7bEYiiuv+XVNC753wc5l/mq7ZQ5Xe7q56GWfPt7Xvc5iRaw6O9AdXK1FNfnRPuAWlk7Uh7brv9z3Xwdl24f2KR0u59pKH8ofyh/rnFD+Uuh/KH8ofyh/KH8ofyh/KH8ofyh/KH8ofyh/KH8ofyh/KH8ofyh/KH8ofyh/KH8ofyh/KH8yyl/W/KaS7ZoX5CoMMt1nxPf+yDnMs/eBytS5ooTU+frLW5OruvyuoY0Ti/XONfHWJdE0hZLLVWQpQay1EGWBsjSBFlaIEsbZIlAlhhk6YAsXZBlBWQpL9nSLvl/R9q2dySvn6XvmucyzbPvWHt++t3yv/o3222Ou4q8xubqq0qezRdX8xiGHutI8mxuwVXP/rTOc54nc1bnGieRdYulv+e8CrCsgCxdkKUDssQgSwSytEGWFsjSBFkaIEsdZKmBLFWQpeKx5N1Ooucctu/0ePxZdBMz33mrL3+R7nM953LonNTp8pWUa13qr4i4Eyfu2ImbPkfnM/5KrPbaqjznondzHP5Vdhz09w617WYz3/LM5iy2375MF3sPWhz9DcgtcXxb7WZbuca5+9rAYs1rN1u2pQay1EGWBsjSBFlaIEsbZIlAlhhk6YAsXZBlBWTpgSx9kGUAsgxBlhHIsgqyjEGWNZBlArKsgywbIMsmyFJesmXefRzbviF521nadx9H92fXfPZ89z7Obpav93H2srTex9nP0jWPYddj3ZO8nSy979mf1rm9Jskep/dbZnWucRJZt1h6H2cfYNkEWTZAlnWQZQKyrIEsY5BlFWQZgSxDkGUAsvRBlh7IsgKydEGWDsgSgywRyNIGWVogSxNkaYAsdZClBrJUQZaKx7Kbr2V2X9xi2n7da90i+haUnf0nEkOvye05F9kHf7cgT7qPw9LNYtf2YzkeB1n6sMB6Sfd5lOs+r+dS1bKlS9lZTyR9JOV7kKvl+v12IvtPJIbGfZhv3EuNW87+LIblVyX9uTSWPbxJ/vba3Mzp++LY8zxNHzqviWX7ccFlfiCORNYtVvrZ+1zKeuxxj8Vt2+1/IX1v2XHTPhfHBZTlqPRuWY4cs87HfFiY5brPixu7gDJfpfvQ41dxYkbieCCOb6uPT86fDXe2G+v/ji1VkKUGstRBlgbI0gRZWiBLG2SJQJYYZOmALF2QZQVk6YEsfZBlALIMQZYRyLIKsoxBljWQZQKyrIMsGyDLJsiyBbJsgyw7IMsuyLIHsuyDLAcgyyHIUmA78cKWY5ClvGTLvL6Vbjt7mmft3b6+lbo/a2uz59dL7/atPM3yK/KasyytfSvPs3TNYzj1WM8kz9qszz370zq31yTZ4/R+y6zONU4i6xZL+1aeAyzHIMsRyHIIshyALPsgyx7Isguy7IAs2yDLFsiyCbJsgCzrIMsEZFkDWcYgyyrIMgJZhiDLAGTpgyw9kGUFZOmCLB2QJQZZIpClDbK0QJYmyNIAWeogSw1kqYIsFY+liLnyLKbOlfescxOziH7bj3MuR1qPj0o3y1dSrsdSf0XEvXDijp246XNOxfCVWO21VXlOXebKe5sdh0j2p33znuZbnmezfZRuFnsPWpzU8cRiiePb6kc7zTXO3fcILNa8frTLttRAljrI0gBZmiBLC2RpgywRyBKDLB2QpQuyrIAsPZClD7IMQJYhyDICWVZBljHIsgayTECWdZBlA2TZBFm2QJZtkGUHZNkFWfZAln2Q5QBkOQRZjkCWY5DlAchyArI8BFlOQZYzkOUcZHkEslyALI9Blicgy1OQpbxky7yxFLb9ieRdZmnfWArdn91vsee7YymeZfkVec3zLK1jKV5k6ZrH8MxjfS55V1n6hWd/Wuf2msTKkUOda5xE1i1WJIYXAMtTkOUJyPIYZLkAWR6BLOcgyxnIcgqyPARZTkCWByDLMchyBLIcgiwHIMs+yLIHsuyCLDsgyzbIsgWybIIsGyDLOsgyAVnWQJYxyLIKsoxAliHIMgBZ+iBLD2RZAVm6IEsHZIlBlghkaYMsLZClCbI0QJY6yFIDWaogS8VjeZavZTYezGLaft37TEWMqSs7+08kht4Ps+f80+wLscjfiHlZulnsvtpYjscnWfplgfWS7vNVrvu8/o0YLVu63HV/9JWU702uluv321vZfyIxNO6n+ca91Ljl7M9iWH5V0r+yEzB5XrrYfTEzp++L157nafql85pYtr8uuMxvxJHIusVKP3v/XMr62uMei9u22/9C+t6y46Zjx14XUJZXpXfL8soxx2J4WZjleqynGzuSvKrkvfbUzdtcPdPZx6W+3+x746043OM+b7xqEe9BXRJJ+yxVkKUGstRBlgbI0gRZWiBLG2SJQJYYZOmALF2QZQVk6YEsfZBlALIMQZYRyLIKsoxBljWQZQKyrIMsGyDLJsiyBbJsgyw7IMsuyLIHsuyDLAcgyyHIcgSyHIMsD0CWE5DlIchyCrKcgSznIMsjkOUCZHkMsjwBWZ6CLFOQ5RJkuQJZnoEsz0GWFyDLJyDLS5Cl6P4Pi1iK7pewiOUNyPIWZCkv2eKbPyG9T70+uNn+eZZfkdckWVrnO/hultb5DizO55L3HceT5n2Wpb/r2Z/WUeK8dnq/ZVZHGieRdYuh8x18F2B5C7K8AVlegyyvQJaXIMsnIMsLkOU5yPIMZLkCWS5BlinI8hRkeQKyPAZZLkCWRyDLOchyBrKcgiwPQZYTkOUByHIMshyBLIcgywHIsg+y7IEsuyDLDsiyDbJsgSybIMsGyLIOskxAljWQZQyyrIIsI5BlCLIMQJY+yNIDWVZAli7I0gFZYpAlAlnaIEsLZGmCLA2QpQ6y1ECWKshScSzad+GV5Fn/hNeS970s/Ubyvp+ltf/ED7L0dyTv97L0Z5JXcXz6WxPaP8KO5fckz95r35c8+1/4geTZ/6rFT9cjZ72UvXbT8Uzvt1yqJV2sPVvHXn0v35izuWi+LzHT/Z449VeWtL0Xf+DUZ1We081OqLqONV2szdVen9bt587z0hg/zLWc1/P/qMPKVXLKbssPxfLjXC3Xdf77sv9EYmjcP8g37qXGLWd/FsPyq5LetRNjeV662P+CmdNj+CPP8zSdOK+JZfuPCi7zjx3Hjx1f+nkxkrL+yHl+upyJ27Z/Lu4iPgt+KA73s6AtDv1Myvm9Oqs/tz5sXY9l04mbv+V6ziE3dlF1/6P31L3l2fPS99Cz7CIlEl+1YOfvi3PkONOYP8k35lQ/M2y/di1vscqSts83c/6B1Is957nzffFT2b/9W9rr07r9Q+d5aYyf5VrO6+8LdVi5Sk7ZbfmZWH6eq+W6zv+B7D+RGBr3j/KNe6lx7fvCYlh+VdK/J5+hf3ST/O3/gpnTY/iF53ma/qnzmli2f1FwmX8ujkTWLVb6v/5GyvqFxz0St23/Q3EX8VnwM3G4nwVtcehnUs7v1Vn9feHUn63rsaw69ZW/5fr7wo1dVN1/8Z66tzx7Xvoe+rPopj5sqYgzztl51+dXXLptqYIsNZClDrI0QJYmyNICWdogSwSylJdsmffbp7a9Inl2/0HH69j5qo7Xsfs3dcnT+dMsz86Zm5Jn9+dakjeUtD3ad0kkeRVP2czakTyzdiXPrPq7rmbtSZ5Z+5Jn1oHkmVXtZjV7GvNwcLtM+p6w1yfZ4/R+y+w9oXESWbdYOlZpBLBEIEsbZGmBLE2QpQGy1EGWGshSBVkqjqWZeaJ8PbPhWfb5UZO4Fqcq26P+zfP+a++mjjr5mmbD12KPSb/rbft/kzaqeddr3Xx9d57DWKx512vLttRAljrI0gBZmiBLC2RpgywRyBKDLB2Qpbxky7zrWNuu16x2jafXrHaNp9esOs+25dk1nl6z2rmEXrNWPD4z6DWmGfQa0wx6jWkGvcY0w1DsPx3ctlY81oGnTHoMLXaSPU7vt8yOocZJZN1i6XXnAGDpgCwxyBKBLG2QpQWyNEGWBshSB1lqIEsVZKk4Fv0utu+vtO5a/ZvtPWc/6fa/zFbmXauuFFA+XRJJW6x516rLttRAljrI0gBZmiBLC2RpgywRyBKDLB2QpQey9EGWAcgyBFnKS7bMa9uw7e+7H6/3my1PfxPK8mwstbZt2FhvX9uG+syg7R3u/SZt21iVPDOMJc8Ma2L/d4Pb1orHOvaUSY+hxU6yx+n9ltkx1DiJrFssbdsYAyxDkGUAsvRBlh7I0gFZYpAlAlnaIEsLZGmCLA2QpQ6y1ECWKshScSza1mXnO9rWped2ek+p4uzb+rjU8y3XlZ73laR8uiSS1raeRr6WqZWzJPVUkjg6Zk/bBZv5OmbHuuGU39bV96HW6pKt89pTcz5+d14bNTyWKshSA1kK/B9b2FJesmXetbRt1+vmivPatB7bw5vt7meH7kevoZuesrcKKLvGSWTdYuk1aBNgqYMsNZClCrJUPJZ2vpapxSpJjJLEiRyTbYscr/7PRuIO5znhPOebWAs4Vs8L+F++0u8YW+56L+q9u5z/l686mUW/Ry2W1q2+D3Me9zb7f+jcFPfWeau22+i4sI5st7yK87zweRI+T76ptYBj9Sx8nlwvH/vnSS1P8+V0qvfa9P5g05On79t0uetY63WNHXet+5zHTM3mfdF+DEnp3XM7y895XNSlxi1nfxYjljq09N/0b55rz0uP6W+knmqyv67U3W+c19hz2pLW/dhr3bQdx0icej/W9tV6j69RKqYPv57jJ7Ku96z/T//GkPfnmtZpreS/5img7FN9T9h72D0uRfUtsLj2HrYYOr7vt/3c7UasPM9sJTHr9Zj2AfD9XxZRpkjKlMj6iuTPe47+v/jKGMlj7HneXfUSl/z9R+6Ko68puk+dlj2RdR0P8xu5j2BG7Tein8WWZ279bnCvw7WPiM7PUHPKbt+HlXzLP/1Y9qnf2752Rc3ztT9auu6p94an3pvyqO95PX7uvB86L3pN8tx5P7QPg77v75r3Q88lihgPLh9xs/3ausWKS7fnEcnfcj0vlxtb66FaWOwPrwd37pRl1EOtsNgfXg/ufDFFWN5XD3VAPZihtcR6aADqwW2fXkY9NAH1YIboW66HZmn+Pegi7pOUnLqwpSV1YUsVZKmBLHWQpQGyFH2PbxFL0fen32eZd2/ebWfS+dW0Hcs+h7St0Mqn58N6PmN59t3uu4ZRn8azRz0HtjyLp9c6Fk/bCC1eV5zD4W1rxWP1tTXqMSxiPkGNk5Rut4lpH4MOwNIEWRogSx1kqYEsVZDFvVegn2fafuher4bzow+zhPOjcH60iCWcHzHOj/756LY1nB99M0s4PwrnR9PfkfOjeec8Rfh0SSQdeyzhNyT8lvAbEn4L6Tckiv4/X8TSBVmKPo94n2XeueCHXB+m/3f/W86h7Lys4tmPr7+9lj3n/n539u/Q8QBlx7dMSxdk6YAsTZClAbLUQZYayFIFWSoeS87X/LN+xdo3zD5zdayTmbSfnabtseI8z/pRVXM2/46Pffhtf3O9fihJPZpTvyubzjY9Htq/qog+rQX8jzwroB/38wLOk14U0O/7kwL6/76cd10a5h+9WcL8o2H+0UUsYf7RMP/oIhbS/KNdkKW8ZMu8dgx3TITOe6TnvTpvuOUNnHKmedZ3UO8J2byU2lZi8yPp+Z3NvaT3tnTuJcubZGm9l7aepfVe2kaW9t1L882pqeW2ePrbIO6c9novTfuOur/Rp/cOdT5Oq1+dc8rqd03yrH4nkmf1uy55Vr9W7tT7/6T9yZ6rdb7h2Y+l9T1rsZPscXq/Zfae1TiJrFssbX9aB1i6IEsHZIlBlghkaYMsLZClCbI0QJY6yFIDWaogS8WxzGtzKMKnSyLpicdSBVlqIEsdZGmALE2QpQWytEGWCGSJQZYOyNIFWYr+vlzEsgGyFH1d+z7LvLYY2+67v6VtHv9wfLPd2gkqnv1oG8Kap+zjAsqucZLS7d8K0Wv6NYBlA2RZB1m6IEsHZIlBlghkaYMsLZClCbI0QJY6yFIDWaogS8Vjyfn3Oa70vk9JTLokktbfUxvla5n1ExtKLHNZnFi26/lsEfOCjJzy27r6PtQ6WbJ1XhtZzsfvznPvkcdSBVlqIEsdZGmALE2QpQWytEGWCGSJQZYOyNIFWQo8n1jYMgZZ1kCWCciyDrJsgCzlJVvmtanadu1jVXFem57v/DNpU7Xz1opnP9rPa+gp+6CAsmucRNYtlrapDgGWDZBlHWSZgCxrIMsYZFkFWbogSwdkiUGWCGRpgywtkKUJsjRAljrIUgNZqiBLxWPp52uZtXvb2Id0sXNdHfNhJh0j0XO8em5t22w8bs5jZ690TEVJ6lGXRNLaRpXzmNupjtHQdrkifyvJ9mvrOjeTjmsvyhJ7YhcQ56rtlDld7jrOainiOOtv0FicZfyGjNZ/kWMRY0/sAuJctZ0yp8tdx1ktvZzLrOPdtK2yiO+AvlM+W9exdWboFWiJPbGLrlvbd/rd/x9GNzHz/u2TAu6hT937nl9JubQdt4i4q07coRO37BzDr8Rqr63Kc/7H6OY4/Gc5Dmu52i9/ke5jIna3f4G2BWhfyYmnXouwbYit6rFZW9KG2Nzxk+nzNrO0fg9vZWn93tjJtQzTF6lnu/Tuctdn6I5YdvO1zM4p9ySWuXalHmz7pjj28nXMPmN3nfLbuvo+1Dr5iKxbH5F14yOy1pZsbUvetuRVHLNdexXxWWkxtC+ZnsvsS9p1RVKWffHvO+VMn3eQpfWz9DBL6/nikcSy/RzK9mNJHzivSWM/cOKk9XaSpZPscXq/ZXZsH4gjkXWLpddvxwVaYk/sot4rFmfee+WhpO17114Tic+e15b0iTzvVOrQ8s6ytL5XzrPHiuznTLY/kvSp85o09oUTJ623x1k6yR6n91tm75ULcSSy/ljix465CEvsiR1Jnl4jPckz9uX1eYTFrEjMJ3I8nnoc0zwd2fGwOLZfW5/K8eg69VSEJfbELuJareSU2b1u02s5e557LRfmRVxoeVHkvIjz+uGG+fFuljA/XpgfbxFLmB8vzI+3iCXMjxfmx0uX982PV/H4ip6nLn3dvxzfLpOea1hsnaPPjDVPmdQ19PgHnnJaWt8TeZ/blp04iaxbLO1XWeT9pg+1dEGWDsgSgywRyNIGWVogSxNkaYAsdZClBrJUQRb3vGDeNX0RPl0SSfc8lirIUgNZ6iBLA2RpgiwtkKUNskQgSwyydECWLshS9PflIpYi+7QtahmCLCOQpejr/fdZ5rUB2XZtB7F2DW0Hsb512g5ifdb0twp0bLXlWb8i/a0C61OmbU/a98werf+Utj25/c20b5i2PVkfMF/bk9aLlVPbc6yc+psGVk4db2vl1PkIrZzaz8+do1x/I0HLbeXclDwr55bkWTm1j4yV08qdev+1tHnZc/VY73j2Y2l9z1rsJHuc3m+ZvWc1TiLrFkvbqLYBlhHIMgRZBiDLCsjSBVk6IEsMskQgSxtkaYEsTZClAbLUQZYayFIFWSqOZV6bZhE+XRJJb3ksVZClBrLUQZYGyNIEWVogSxtkiUCWGGTpgCxdkGUFZBmALEOQZQSyFH1+tYhlB2Qput3sfZZ5bb22XfvJWTvjjuRVPPuz80N7fnpe9Nf92/uuePa95TFoHW04ZZneb5nVkcZJZN1iadviFsCyA7JsgywjkGUIsgxAlhWQpQuydECWGGSJQJY2yNICWZogSwNkqYMsNZClCrL4zl9tu95XrzivvWscac5jfe88j7dY864plmGZd01RdepK69W2pf8z/3PtZnvd85qGJ56+3vK0bdh9rdZRzuOoZ3WkcRJZt1iRY1i2peJY0u8XOyf50y9/+cdf/sm/+PKXP/nyL/S4uscmXaqS1v4/Tec188ZmF/Ce/V0fK39V5Fh57Y+kx67txNL+SE3PPrXvlv7f2qM5dB9hnP77LWGcfhinv4gljNMP4/QXsYRx+mGcfrqEcfphnP6iljBOP4zTX8QSxumHcfqLWMI4/TBO/y6fLomkwzj9D7eEcfphnP4iljBOP4zTX8QSxumHcfqLWMI4/TBOP13+Po/T/0+Tm+1hnP79LGGcfhinv4gljNMP4/QXsYRx+mGc/iKWME4/jNO/y6dLImnf2LIwTt9vCeP0/ZYwTt9vCeP0/ZYwTt9vCeP0/ZYwTt9vCeP0/ZYwTv/d9kFfW69tH0nefcbp/1UYp5+bJYzT91vCOH2/JYzT91vCOH2/JYzT91vCOH2/JYzT91vCOH2/JYzTX7wsuiSS/l0cp/9/12+2+8YYu+OP9Xla9iLGvGucRNZ94+9rAEvFY8l5nPg03Yd9B5RK794fMIeZtC24lXOdpPtoexwtcWi/InNE+Tqu0n347pdE8mjxta2zk6/jWdtxpMtd/7/a1tnN1zJ7j6xILHN1Zd22Fz3eu+uU3x1Ptoi16DHYeVqLHhf9PmsB76tfFNBH8krHXtryIf0mU0s/X8szm4PDjqvt361bPf8o4vN9eFPcd45numgbgz7P0jXZrt/3tn1zclOmeedUo3zLdOd5jMWad8972ZYayFIHWRogi34vLNvSAlnaIEsEssQgSwdk6YIsKyBLD2TpgywDkGUIspSXbJnXJqRzrliejaPxzfem+7NzslXZx/+XtiMbe6NtRzb2xjdeaexxrXleq3Vpr0myx+n9llldapxE1i2WtjGtASxDkGUAsvRBlh7IsgKydEGWDsgSgywRyNIGWVogSxNkaYAsdZClBrJUQZaKY9FzRx3TbWO09Ry04uxPz0t1LHuYc/j9ljDncJhzeBFLmHM4zDm8iCXMORzmHE6XMOdwmHN4UUuYczjMObyIJcw5HOYcXsQS5hwOcw7f5dMlkXSYc/jDLWHO4TDn8CKWMOdwmHN4EUuYczjMObyIJcw5/OFzDmv7hrVraLuQ3qexR73HY3lrTtn1vo62C9ncu8T5gNN9/bp321/x+CeecuqxtthJ9ji93zI71honkXWLpW07E4BlBLIMQZYByLICsnRBlg7IEoMsEcjSBllaIEsTZGmALHWQpQayVEGWimOZ1xZYhE+XRNJrHksVZKmBLHWQpQGyNEGWFsjSBlkikCUGWTogSxdkWQFZBiDLEGQZgSxFn18tYlkHWYpuN3ufZV4bqW3XPmfWzqi/IVbx7M/OD/X32X7Vv73vimffax6D1tGqU5bp/ZY7+/NbrHljI5dlWQdZJiDLCGQZgiwDkGUFZOmCLB2QJQZZIpClDbK0QJYmyNIAWeogSw1kqYIsvvNX39wdFee1zcxdy9f9TM+fS+LXJZG0xU8/D+w75E+//OXP//wf/ZN//Cc/+fIvyrIP22/Vs189F687z9Py65yr8+bSvev12uei6tmnW9bc3hAtKXQlC17Lgjey4C2Jq1D7Ukwr+O8ADXjahaVNBAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "signing_pub_key_x",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "signing_pub_key_y",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
<<<<<<< HEAD
  ]
=======
  ],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "0": {
        "source": "mod storage;\nmod ecdsa_public_key_note;\n\n// Account contract that uses ECDSA signatures for authentication on the same curve as Ethereum.\n// The signing key is stored in an immutable private note and should be different from the signing key.\ncontract EcdsaAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::log::emit_encrypted_log;\n    use dep::aztec::oracle::get_public_key::get_public_key;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    use dep::aztec::constants_gen::MAX_NOTE_FIELDS_LENGTH;\n    use dep::aztec::note::{\n        note_header::{NoteHeader},\n        utils as note_utils,\n    };\n\n    use crate::storage::Storage;\n    use crate::ecdsa_public_key_note::EcdsaPublicKeyNote;\n    use crate::ecdsa_public_key_note::EcdsaPublicKeyNoteInterface;\n    use crate::ecdsa_public_key_note::ECDSA_PUBLIC_KEY_NOTE_LEN;\n\n    // All calls made by this account will be routed through this entrypoint\n    fn entrypoint(  \n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        signature: pub [u8;64],\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        \n        // Initialise context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64\n        let mut args: BoundedVec<Field, 77> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in signature { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Load public key from storage\n        let storage = Storage::init();\n        let public_key = storage.public_key.get_note(&mut context);\n\n        // Verify payload signature using Ethereum's signing scheme\n        // Note that noir expects the hash of the message/challenge as input to the ECDSA verification.\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n        let hashed_message: [u8; 32] = std::hash::sha256(message_bytes);\n        let verification = std::ecdsa_secp256k1::verify_signature(public_key.x, public_key.y, signature, hashed_message);\n        assert(verification == true);\n\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Creates a new account out of an ECDSA public key to use for signature verification\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n        signing_pub_key_x: pub [u8;32],\n        signing_pub_key_y: pub [u8;32],\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        let storage = Storage::init();\n        \n        let mut args: BoundedVec<Field, 64> = BoundedVec::new(0);\n        for byte in signing_pub_key_x { args.push(byte as Field); }\n        for byte in signing_pub_key_y { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n        \n        let this = context.this_address();\n        let mut pub_key_note = EcdsaPublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\n        storage.public_key.initialise(&mut context, &mut pub_key_note);\n        \n        emit_encrypted_log(\n            &mut context,\n            this,\n            storage.public_key.storage_slot,\n            get_public_key(this),\n            pub_key_note.serialise(),\n        );\n\n        context.finish()\n    }\n\n    // Computes note hash and nullifier.\n    // Note 1: Needs to be defined by every contract producing logs.\n    // Note 2: Having it in all the contracts gives us the ability to compute the note hash and nullifier differently for different kind of notes.\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> [Field; 4] {\n        assert(storage_slot == 1);\n        let note_header = NoteHeader { contract_address, nonce, storage_slot };\n        note_utils::compute_note_hash_and_nullifier(EcdsaPublicKeyNoteInterface, note_header, preimage)\n    }\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-contracts/src/contracts/ecdsa_account_contract/src/main"
      },
      "3": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\nfn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\nfn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\nfn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\nfn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\nfn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\nfn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\nfn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "33": {
        "source": "use crate::context::PrivateContext;\nuse crate::oracle;\nuse crate::types::point::Point;\n\nfn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\nfn emit_unencrypted_log<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let _ = oracle::logs::emit_unencrypted_log(log);\n    context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/log"
      },
      "39": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\nfn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // 0 nonce implies \"transient\" nullifier (must nullify a commitment in this TX).\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.nonce == 0) {\n        // TODO(suyash): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(storage_slot, nullifier, preimage, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/note/lifecycle"
      },
      "40": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort},\n    note_interface::NoteInterface,\n    note_header::NoteHeader,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n    utils::compute_unique_siloed_note_hash,\n    utils::compute_inner_note_hash,\n    utils::compute_siloed_note_hash,\n};\nuse crate::messaging::get_commitment_getter_data::make_commitment_getter_data;\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn ensure_note_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    let saved_note = get_note_internal(storage_slot, note_interface);\n\n    // Only copy over the header to the original note to make sure the preimage is the same.\n    let get_header = note_interface.get_header;\n    let set_header = note_interface.set_header;\n    let note_header = get_header(saved_note);\n    set_header(note, note_header);\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, *note);\n    context.push_read_request(note_hash_for_read_request);\n}\n\n// Ensure a note's hash exists in the tree without retrieving the entire\n// notes via the oracle.\n// Modifies the note by populating it with header info.\nfn ensure_note_hash_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    // Initialize header of note. Must be done before computing note hashes as it initializes the:\n    // - storage slot (used in inner note hash)\n    // - the contract address (used in siloed note hash)\n    // - and the nonce (used in the unique siloed note hash)\n    let set_header = note_interface.set_header;\n    let note_header = NoteHeader {\n        contract_address: (*context).this_address(),\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n        // real nonce (once public kernel applies nonces).\n        nonce: 0,\n        storage_slot\n    };\n    set_header(note, note_header);\n\n    // Get a note from oracle and early out if it doesn't exist.\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let raw_oracle_ret = oracle::get_commitment::get_commitment(inner_note_hash);\n    let deserialized_oracle_ret = make_commitment_getter_data(raw_oracle_ret, 0);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // unique_siloed_note_hash once public kernel applies nonces\n    let saved_siloed_note_hash = deserialized_oracle_ret.message;\n\n    assert(saved_siloed_note_hash != 0); // TODO(dbanks12): necessary?\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    // Ensure that the note hash retrieved from oracle matches the one computed from note.\n    let computed_siloed_note_hash = compute_siloed_note_hash(note_interface, *note);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // compute_note_hash_for_read_or_nullify once public kernel applies nonces\n    assert(computed_siloed_note_hash == saved_siloed_note_hash);\n\n    context.push_read_request(computed_siloed_note_hash);\n}\n\nfn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\nfn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        let mut note_hash_for_read_request = 0;\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            check_note_header(*context, storage_slot, note_interface, note);\n            note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n        };\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n        // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n        context.push_read_request(note_hash_for_read_request);\n    };\n\n    // TODO(#1660)\n    // Move it back to get_notes_internal and only make read request for selected notes.\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/note/note_getter"
      },
      "42": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\nfn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\nfn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/note/note_hash"
      },
      "46": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nfn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\nfn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\nfn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    if (header.nonce == 0) {\n        // when nonce is zero, that means we are reading a pending note (doesn't have a nonce yet),\n        // so we just read the inner_note_hash (kernel will silo by contract address)\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\nfn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    let mut note = deserialise(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/note/utils"
      },
      "48": {
        "source": "use dep::std::hash::pedersen_with_separator;\nuse crate::context::PrivateContext;\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle;\nuse crate::constants_gen::{\n    GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n    EMPTY_NULLIFIED_COMMITMENT,\n};\n\nstruct ImmutableSingleton<Note, N> {\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    fn new(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Self {\n        ImmutableSingleton { storage_slot, note_interface }\n    }\n\n    unconstrained fn is_initialised(self) -> bool {\n        let nullifier = self.compute_initialisation_nullifier();\n        oracle::notes::is_nullifier_emitted(nullifier)\n    }\n\n    fn initialise(self, context: &mut PrivateContext, note: &mut Note) {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialisation_nullifier();\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n\n    fn compute_initialisation_nullifier(self) -> Field {\n        pedersen_with_separator([self.storage_slot], GENERATOR_INDEX__INITIALISATION_NULLIFIER)[0]\n    }\n    \n    fn get_note(self, context: &mut PrivateContext) -> Note {\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n\n    unconstrained fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/state_vars/immutable_singleton"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "70": {
        "source": "use crate::types::point::Point;\nuse dep::std::hash;\nuse crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n\n#[oracle(getPublicKey)]\nfn get_public_key_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_internal(address: Field) -> [Field; 3] {\n  get_public_key_oracle(address)\n}\n\nfn get_public_key(address: Field) -> Point {\n  let result = get_public_key_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = hash::pedersen_with_separator([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_public_key"
      },
      "78": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      }
    }
  }
>>>>>>> feat: initial uniswap skeleton
}
