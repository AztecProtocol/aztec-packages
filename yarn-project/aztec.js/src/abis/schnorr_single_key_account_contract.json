{
  "name": "SchnorrSingleKeyAccount",
  "functions": [
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/9Xc12/aUBzFcUKTdO/svfewsQ02XWm6994roYHu3f7/5SggRXnN4eF7JQv8Yp2PAPuO3+VfLper5LZbW/3I14/2xvvmeceu887G+52teb7WeI2CYhxXS4VqGIWbQSGrpEkQJ5ViGqZhkiZbhTSKqmmclrJKVgqyMI6qYS3Jolqw3Xp2XCvYY2tlzl5Izj5Izn5IzgFIzkFIziFIzmFIzhFIzlFIzjFIznFIzglIzklIzilIzmlIzhlIzllIzjlIznlIzgVIzkVIziVIzmVIzhVIzlVIzgCSM4TkLEByRpCcMSRnAslZhOQsQXKmkJwZJGe5RTnzu3IGe2thm9F8BmLOG81nIeZ9RvM5iLndaD4PMXcYzRcg5k6jeQ1i7jGaL0LMvUbzOsTcZzRfgpj7jebLEPOA0XwFYh40mq9CzENG8zWIedhovg4xjxjNNyDmUaP5JsQ8ZjTfgpjHjebbEPOE0XwHYp40mu9CzFNG8z2Iedpovg8xzxjNDyDmWaP5IcQ8ZzQ/gpjnjebHEPOC0fwEYl40mp9CzEtG8zOIedlofg4xrxjNLyDmVaP5JcQcGM2vIObQaH4NMReM5jcQc2Q0v4WYY6P5HcScGM0bEHPRaN6EmEtGcwViTo3m9xBzZjRvQcxlo7kKMe83mmsQ8wGj+QPEfNBo/ggxHzKaP0HMh43mzxDzEaP5C8R81Gj+CjEfM5q/QczHjebvEPMJo/kHxHzSaP4JMZ8ymn9BzKeN5t8Qc5fR/Adi7jaa/7bA3N14bf5fn/ZGaa+Q9s5oL4nGhRonadygfrT6lepnqd+h57CeS7pP676l37G+112N65Yb19ZeOO0N014p7R1q7qXRXov1+qFafNWmq1Zbtcuq5VVtq2o9VfuoWkDVxqlWTLVTqiVSbY1qTVR7oVoErc1rrVprt1rL1Nqe1rq09qO1EK0NaK5cc8eaS92oH5pr09yT5mI0N6GxusauGstpbKO+vvq+6guqb6S+gp6depbo3qp7jX57+i7qs/kPVgMtpSBRAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "owner",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "partial_address",
          "type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "0": {
        "source": "// Account contract that uses Schnorr signatures for authentication. The signing key is the same as the\n// encryption key, and as such is not stored in the contract but part of the address preimage, so it can\n// be verified by passing in the partial address.\ncontract SchnorrSingleKeyAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::private_call_stack_item::PrivateCallStackItem;\n    use dep::aztec::public_call_stack_item::PublicCallStackItem;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    fn entrypoint(\n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        owner: pub [u8;64], // pubkey x and y coordinates concatenated\n        signature: pub [u8;64], // schnorr signature of the payload hash\n        partial_address: pub Field,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Initialize context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64 + 64 + 1\n        let mut args: BoundedVec<Field, 142> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in owner { args.push(byte as Field); }\n        for byte in signature { args.push(byte as Field); }\n        args.push(partial_address);\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Verify payload signature\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n\n        // Convert owner pubkey into fields\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n        for i in 0..32 {\n          let bytex: Field = owner[31 - i] as Field;\n          x = x + (bytex * mul);\n          let bytey: Field = owner[63 - i] as Field;\n          y = y + (bytey * mul);\n          mul *= 256;\n        }\n        \n        // Verify signature of the payload hash\n        // TODO: Find out why this signature verification never fails\n        let verification = std::schnorr::verify_signature(x, y, signature, message_bytes);\n        assert(verification == true);\n\n        // Verify public key against address\n        let reproduced_address = dep::std::hash::pedersen_with_separator([x, y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n        assert(reproduced_address == context.this_address());\n\n        // Execute calls\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Constructs the contract\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Return private circuit public inputs. All private functions need to return this as it is part of the input of the private kernel.\n        PrivateContext::new(inputs, 0).finish()\n    }\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-contracts/src/contracts/schnorr_single_key_account_contract/src/main"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, msg: Field) {\n        self.new_l2_to_l1_msgs.push(msg);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "61": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/private_call_stack_item"
      },
      "62": {
        "source": "use crate::{\n    abi,\n    abi::{\n        PublicCircuitPublicInputs,\n        FunctionData,\n    },\n};\nuse crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__CALL_STACK_ITEM,\n};\n\n// oracles\nuse crate::oracle::{\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n};\n\nstruct PublicCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PublicCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PublicCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}\n\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/public_call_stack_item"
      },
      "65": {
        "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: Field,\n    _function_selector: Field,\n    _args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained fn call_private_function_internal(\n    contract_address: Field,\n    function_selector: Field,\n    args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n    )\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/call_private_function"
      },
      "76": {
        "source": "\n// contract_address + \n// args_hash +\n// crate::abi::FUNCTION_DATA_SIZE +\n// crate::abi::CALL_CONTEXT_SIZE +\n// = 2 + 4 + 6\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE: Field = 12;\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: Field, \n    _function_selector: Field, \n    _args_hash: Field,\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {}\n\nunconstrained fn enqueue_public_function_call_internal(\n    contract_address: Field, \n    function_selector: Field,\n    args_hash: Field\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {\n    enqueue_public_function_call_oracle(\n        contract_address, \n        function_selector, \n        args_hash,\n    )\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/enqueue_public_function_call"
      },
      "81": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      }
    }
  }
}
