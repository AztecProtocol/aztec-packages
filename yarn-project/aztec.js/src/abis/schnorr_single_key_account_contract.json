{
  "name": "SchnorrSingleKeyAccount",
  "functions": [
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/9Xc12/aUBzFcUKTdO/svfewsQ02XWm6994roYHu3f7/5SggRXnN4eF7JQv8Yp2PAPuO3+VfLper5LZbW/3I14/2xvvmeceu887G+52teb7WeI2CYhxXS4VqGIWbQSGrpEkQJ5ViGqZhkiZbhTSKqmmclrJKVgqyMI6qYS3Jolqw3Xp2XCvYY2tlzl5Izj5Izn5IzgFIzkFIziFIzmFIzhFIzlFIzjFIznFIzglIzklIzilIzmlIzhlIzllIzjlIznlIzgVIzkVIziVIzmVIzhVIzlVIzgCSM4TkLEByRpCcMSRnAslZhOQsQXKmkJwZJGe5RTnzu3IGe2thm9F8BmLOG81nIeZ9RvM5iLndaD4PMXcYzRcg5k6jeQ1i7jGaL0LMvUbzOsTcZzRfgpj7jebLEPOA0XwFYh40mq9CzENG8zWIedhovg4xjxjNNyDmUaP5JsQ8ZjTfgpjHjebbEPOE0XwHYp40mu9CzFNG8z2Iedpovg8xzxjNDyDmWaP5IcQ8ZzQ/gpjnjebHEPOC0fwEYl40mp9CzEtG8zOIedlofg4xrxjNLyDmVaP5JcQcGM2vIObQaH4NMReM5jcQc2Q0v4WYY6P5HcScGM0bEHPRaN6EmEtGcwViTo3m9xBzZjRvQcxlo7kKMe83mmsQ8wGj+QPEfNBo/ggxHzKaP0HMh43mzxDzEaP5C8R81Gj+CjEfM5q/QczHjebvEPMJo/kHxHzSaP4JMZ8ymn9BzKeN5t8Qc5fR/Adi7jaa/7bA3N14bf5fn/ZGaa+Q9s5oL4nGhRonadygfrT6lepnqd+h57CeS7pP676l37G+112N65Yb19ZeOO0N014p7R1q7qXRXov1+qFafNWmq1Zbtcuq5VVtq2o9VfuoWkDVxqlWTLVTqiVSbY1qTVR7oVoErc1rrVprt1rL1Nqe1rq09qO1EK0NaK5cc8eaS92oH5pr09yT5mI0N6GxusauGstpbKO+vvq+6guqb6S+gp6depbo3qp7jX57+i7qs/kPVgMtpSBRAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "owner",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "partial_address",
          "type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "0": {
        "source": "// Account contract that uses Schnorr signatures for authentication. The signing key is the same as the\n// encryption key, and as such is not stored in the contract but part of the address preimage, so it can\n// be verified by passing in the partial address.\ncontract SchnorrSingleKeyAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::private_call_stack_item::PrivateCallStackItem;\n    use dep::aztec::public_call_stack_item::PublicCallStackItem;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    fn entrypoint(\n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        owner: pub [u8;64], // pubkey x and y coordinates concatenated\n        signature: pub [u8;64], // schnorr signature of the payload hash\n        partial_address: pub Field,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Initialize context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64 + 64 + 1\n        let mut args: BoundedVec<Field, 142> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in owner { args.push(byte as Field); }\n        for byte in signature { args.push(byte as Field); }\n        args.push(partial_address);\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Verify payload signature\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n\n        // Convert owner pubkey into fields\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n        for i in 0..32 {\n          let bytex: Field = owner[31 - i] as Field;\n          x = x + (bytex * mul);\n          let bytey: Field = owner[63 - i] as Field;\n          y = y + (bytey * mul);\n          mul *= 256;\n        }\n        \n        // Verify signature of the payload hash\n        // TODO: Find out why this signature verification never fails\n        let verification = std::schnorr::verify_signature(x, y, signature, message_bytes);\n        assert(verification == true);\n\n        // Verify public key against address\n        let reproduced_address = dep::std::hash::pedersen_with_separator([x, y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n        assert(reproduced_address == context.this_address());\n\n        // Execute calls\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Constructs the contract\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Return private circuit public inputs. All private functions need to return this as it is part of the input of the private kernel.\n        PrivateContext::new(inputs, 0).finish()\n    }\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-contracts/src/contracts/schnorr_single_key_account_contract/src/main"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "61": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/private_call_stack_item"
      },
      "78": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/mnt/user-data/alvaro/aztec-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      }
    }
  }
}
