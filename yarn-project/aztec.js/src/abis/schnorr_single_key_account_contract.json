{
  "name": "SchnorrSingleKeyAccount",
  "functions": [
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/9Xc12/aUBzFcUKTdO/svfewsQ02XWm6994roYHu3f7/5SggRXnN4eF7JQv8Yp2PAPuO3+VfLper5LZbW/3I14/2xvvmeceu887G+52teb7WeI2CYhxXS4VqGIWbQSGrpEkQJ5ViGqZhkiZbhTSKqmmclrJKVgqyMI6qYS3Jolqw3Xp2XCvYY2tlzl5Izj5Izn5IzgFIzkFIziFIzmFIzhFIzlFIzjFIznFIzglIzklIzilIzmlIzhlIzllIzjlIznlIzgVIzkVIziVIzmVIzhVIzlVIzgCSM4TkLEByRpCcMSRnAslZhOQsQXKmkJwZJGe5RTnzu3IGe2thm9F8BmLOG81nIeZ9RvM5iLndaD4PMXcYzRcg5k6jeQ1i7jGaL0LMvUbzOsTcZzRfgpj7jebLEPOA0XwFYh40mq9CzENG8zWIedhovg4xjxjNNyDmUaP5JsQ8ZjTfgpjHjebbEPOE0XwHYp40mu9CzFNG8z2Iedpovg8xzxjNDyDmWaP5IcQ8ZzQ/gpjnjebHEPOC0fwEYl40mp9CzEtG8zOIedlofg4xrxjNLyDmVaP5JcQcGM2vIObQaH4NMReM5jcQc2Q0v4WYY6P5HcScGM0bEHPRaN6EmEtGcwViTo3m9xBzZjRvQcxlo7kKMe83mmsQ8wGj+QPEfNBo/ggxHzKaP0HMh43mzxDzEaP5C8R81Gj+CjEfM5q/QczHjebvEPMJo/kHxHzSaP4JMZ8ymn9BzKeN5t8Qc5fR/Adi7jaa/7bA3N14bf5fn/ZGaa+Q9s5oL4nGhRonadygfrT6lepnqd+h57CeS7pP676l37G+112N65Yb19ZeOO0N014p7R1q7qXRXov1+qFafNWmq1Zbtcuq5VVtq2o9VfuoWkDVxqlWTLVTqiVSbY1qTVR7oVoErc1rrVprt1rL1Nqe1rq09qO1EK0NaK5cc8eaS92oH5pr09yT5mI0N6GxusauGstpbKO+vvq+6guqb6S+gp6depbo3qp7jX57+i7qs/kPVgMtpSBRAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "owner",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "partial_address",
          "type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
<<<<<<< HEAD
  ]
=======
  ],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "0": {
        "source": "// Account contract that uses Schnorr signatures for authentication. The signing key is the same as the\n// encryption key, and as such is not stored in the contract but part of the address preimage, so it can\n// be verified by passing in the partial address.\ncontract SchnorrSingleKeyAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::private_call_stack_item::PrivateCallStackItem;\n    use dep::aztec::public_call_stack_item::PublicCallStackItem;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    fn entrypoint(\n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        owner: pub [u8;64], // pubkey x and y coordinates concatenated\n        signature: pub [u8;64], // schnorr signature of the payload hash\n        partial_address: pub Field,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Initialize context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64 + 64 + 1\n        let mut args: BoundedVec<Field, 142> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in owner { args.push(byte as Field); }\n        for byte in signature { args.push(byte as Field); }\n        args.push(partial_address);\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Verify payload signature\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n\n        // Convert owner pubkey into fields\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n        for i in 0..32 {\n          let bytex: Field = owner[31 - i] as Field;\n          x = x + (bytex * mul);\n          let bytey: Field = owner[63 - i] as Field;\n          y = y + (bytey * mul);\n          mul *= 256;\n        }\n        \n        // Verify signature of the payload hash\n        // TODO: Find out why this signature verification never fails\n        let verification = std::schnorr::verify_signature(x, y, signature, message_bytes);\n        assert(verification == true);\n\n        // Verify public key against address\n        let reproduced_address = dep::std::hash::pedersen_with_separator([x, y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n        assert(reproduced_address == context.this_address());\n\n        // Execute calls\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Constructs the contract\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Return private circuit public inputs. All private functions need to return this as it is part of the input of the private kernel.\n        PrivateContext::new(inputs, 0).finish()\n    }\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-contracts/src/contracts/schnorr_single_key_account_contract/src/main"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "61": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/private_call_stack_item"
      },
      "78": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      }
    }
  }
>>>>>>> feat: initial uniswap skeleton
}
