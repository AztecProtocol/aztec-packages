import {
  ARTIFACT_FUNCTION_TREE_MAX_HEIGHT,
  MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,
  computeArtifactFunctionTree,
  computeArtifactFunctionTreeRoot,
  computeArtifactMetadataHash,
  computeFunctionArtifactHash,
  computePrivateFunctionsTree,
  getContractClassFromArtifact,
} from '@aztec/circuits.js';
import { ContractArtifact, FunctionSelector, FunctionType, bufferAsFields } from '@aztec/foundation/abi';
import { padArrayEnd } from '@aztec/foundation/collection';
import { Fr } from '@aztec/foundation/fields';

import { ContractFunctionInteraction } from '../contract/contract_function_interaction.js';
import { Wallet } from '../wallet/index.js';
import { getRegistererContract } from './protocol_contracts.js';

/**
 * Sets up a call to broadcast a private function's bytecode via the ClassRegisterer contract.
 * Note that this is not required for users to call the function, but is rather a convenience to make
 * this code publicly available so dapps or wallets do not need to redistribute it.
 * @param wallet - Wallet to send the transaction.
 * @param artifact - Contract artifact that contains the function to be broadcast.
 * @param selector - Selector of the function to be broadcast.
 * @returns A ContractFunctionInteraction object that can be used to send the transaction.
 */
export function broadcastPrivateFunction(
  wallet: Wallet,
  artifact: ContractArtifact,
  selector: FunctionSelector,
): ContractFunctionInteraction {
  const contractClass = getContractClassFromArtifact(artifact);
  const privateFunction = contractClass.privateFunctions.find(fn => fn.selector.equals(selector));
  if (!privateFunction) {
    throw new Error(`Private function with selector ${selector.toString()} not found`);
  }
  const privateFunctionArtifact = artifact.functions.find(fn =>
    FunctionSelector.fromNameAndParameters(fn).equals(selector),
  )!;

  // TODO(@spalladino): The following is computing the unconstrained root hash twice.
  // Feels like we need a nicer API for returning a hash along with all its preimages,
  // since it's common to provide all hash preimages to a function that verifies them.
  const artifactMetadataHash = computeArtifactMetadataHash(artifact);
  const unconstrainedArtifactFunctionTreeRoot = computeArtifactFunctionTreeRoot(artifact, FunctionType.OPEN);

  // We need two sibling paths because private function information is split across two trees:
  // The "private function tree" captures the selectors and verification keys, and is used in the kernel circuit for verifying the proof generated by the app circuit.
  // The "artifact tree" captures function bytecode and metadata, and is used by the pxe to check that its executing the code it's supposed to be executing, but it never goes into circuits.
  const privateFunctionTreePath = computePrivateFunctionsTree(contractClass.privateFunctions).getSiblingPath(0);
  const artifactFunctionTreePath = computeArtifactFunctionTree(artifact, FunctionType.SECRET)!.getSiblingPath(0);

  const vkHash = privateFunction.vkHash;
  const metadataHash = computeFunctionArtifactHash(privateFunctionArtifact);
  const bytecode = bufferAsFields(
    Buffer.from(privateFunctionArtifact.bytecode, 'hex'),
    MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,
  );

  const registerer = getRegistererContract(wallet);
  return registerer.methods.broadcast_private_function(
    contractClass.id,
    Fr.fromBufferReduce(artifactMetadataHash),
    Fr.fromBufferReduce(unconstrainedArtifactFunctionTreeRoot),
    privateFunctionTreePath.map(Fr.fromBufferReduce),
    padArrayEnd(artifactFunctionTreePath.map(Fr.fromBufferReduce), Fr.ZERO, ARTIFACT_FUNCTION_TREE_MAX_HEIGHT),
    // eslint-disable-next-line camelcase
    { selector, metadata_hash: Fr.fromBufferReduce(metadataHash), bytecode, vk_hash: vkHash },
  );
}

/**
 * Sets up a call to broadcast an unconstrained function's bytecode via the ClassRegisterer contract.
 * Note that this is not required for users to call the function, but is rather a convenience to make
 * this code publicly available so dapps or wallets do not need to redistribute it.
 * @param wallet - Wallet to send the transaction.
 * @param artifact - Contract artifact that contains the function to be broadcast.
 * @param selector - Selector of the function to be broadcast.
 * @returns A ContractFunctionInteraction object that can be used to send the transaction.
 */
export function broadcastUnconstrainedFunction(
  wallet: Wallet,
  artifact: ContractArtifact,
  selector: FunctionSelector,
): ContractFunctionInteraction {
  const functionArtifactIndex = artifact.functions.findIndex(
    fn => fn.functionType === FunctionType.UNCONSTRAINED && FunctionSelector.fromNameAndParameters(fn).equals(selector),
  );
  if (functionArtifactIndex < 0) {
    throw new Error(`Unconstrained function with selector ${selector.toString()} not found`);
  }
  const functionArtifact = artifact.functions[functionArtifactIndex];

  // TODO(@spalladino): Same comment as above on computing duplicated hashes.
  const artifactMetadataHash = computeArtifactMetadataHash(artifact);
  const privateArtifactFunctionTreeRoot = computeArtifactFunctionTreeRoot(artifact, FunctionType.SECRET);
  const functionTreePath = computeArtifactFunctionTree(artifact, FunctionType.UNCONSTRAINED)!.getSiblingPath(
    functionArtifactIndex,
  );

  const contractClassId = getContractClassFromArtifact(artifact).id;
  const metadataHash = computeFunctionArtifactHash(functionArtifact);
  const bytecode = bufferAsFields(
    Buffer.from(functionArtifact.bytecode, 'hex'),
    MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,
  );

  const registerer = getRegistererContract(wallet);
  return registerer.methods.broadcast_unconstrained_function(
    contractClassId,
    Fr.fromBufferReduce(artifactMetadataHash),
    Fr.fromBufferReduce(privateArtifactFunctionTreeRoot),
    padArrayEnd(functionTreePath.map(Fr.fromBufferReduce), Fr.ZERO, ARTIFACT_FUNCTION_TREE_MAX_HEIGHT),
    // eslint-disable-next-line camelcase
    { selector, metadata_hash: Fr.fromBufferReduce(metadataHash), bytecode },
  );
}
