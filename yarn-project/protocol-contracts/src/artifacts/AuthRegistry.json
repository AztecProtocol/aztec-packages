{"transpiled":true,"noir_version":"0.30.0+48d9df4ff227c08a6e66f21c0286bc6349151671","name":"AuthRegistry","functions":[{"name":"_set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2ZW0/jRhTHJ4Fw2wKJcUhMLiQQEyD3bGJKU/q4Up/71peql223Ui9SL6raj9hP1TlnZvyPcerVWVELVWvJsX38/825zDjxgZ7aUmpvR+mtpeymr/bUER+KtH+i3Jk+ob1wpArOZHQl2llXMvu6jk0h3aTRi3ym7WortAOrbT7TkSij26YoQjuc2r3QH+WlcoFW6GPvmD73S+SeB97X+0GP0lGR3g9Dl84LxUbaDunDaCiAD3q401OFV/p4ZMQvrPg4LBqjOgZ2bDSH5pTR32F2aJlREpSBloGWLfoTzA6tMEqCCtAK0IpFv4bZoR6jJPCAekA9i/4Gs0NPGCXBCdAToCcW/R5mh/qMksAH6gP1LfozzA6tMkqCKtAq0Ko5ppFyNqK9dWB26CmjJDgFegr01KJfwOzQGqMkqAGtAa1Z9FeYHVpnlAR1oHWgdYu+htmhAaMkCIAGQIN0eYJ4HoXIaTaiA/wSZoeeMUqCM6BnQM/S3s7iJ0OIeNmIDvANzA5tMEqCBtAG0EbaWyNekxmI9vYLzA5tMkqCJtAm0GbaWzN+eDIQ7e0vmB3aYpQELaAtoK20t1a8oDIQ7e0bmB3aZpQEbaBtoO20t3b8vAmRihwJ5Eg5l1z8Jw9Mz88PMDv0nFESnAM9B3pu0T9hdmiHURJ0gHaAdtKBduJyZCDa21cwO7TLKAm6QLtAu2lv3XjZCpGqHKnIkUCOtHNB3qFirVyKfCJHynLEy6VijVxyebZr7DwboY9CE2/ndwwqvJK7d3ASqtC9p+sRtxW2C3Z1kXR1aeCuOXV36PX/Eq/24Q6fhlZ0pb+TiO0XeIg+mWjnMANz5XIkph86WQ/ezI2iMao+Iuqr2BkhYYe6oLWwHgUcFWy2d0ZDIx7EtdlHbQ6Sncse0tNVLankxpXixowLdmGG2bfDdDdV0k7agQ3uYBNSykYSIblkDlfba5p985vwOF7aLk28VJVL09S5IpV67E6FJT6WbHl7xsnHer+OK3aFil0nK9ZHeNd6wM/08caIr6z4lpO8oTNgt0ZzbU7pmEY8OeLLkYYcCbIRXYbvYHbogFESDIAOgA7S3gbxF6cQqcqRmhxpyxFfjnhPnr6enynMDh0ySoIh0CHQYdrbMPYmRMpyxJcjXi65BHKknQvylorpVfAHzA4dMUqCEdAR0FHa2yh+SoVIKxvRAY5hduiYURKMgY6BjtPexvHUCpEbOeLJEV+ONORIIEdu5Ug9l3mpyZF2LvPi5ZLLWyqmn5sfYXbohFESTIBOgE7S3ibx39OESE2OeHKk+lwDC+RI4zlUTC+cb2F26JRREkyBToFO096mcU5CxJcjYzlSzUZ0GWYwO3TGKAlmQGdAZ2lvs/inKgOhbqT4KfqOBwYVmg3XXcy4V3EdyCzZxc7Z1Tzp6qWBZ+bU3aHG5iWalqXpYpdWFNku9s50sdRTU38ZcZivzJXLkZi70MkW8GZuFI3RtaBW55wRsuzoQVdrYT0KmLtYyvYBjd88rk0JtZkne7Jeb/3OltGa6nBU3Y1TMreuNyI72Qjim8WN6dwOMjNt59y2nd2S63J5NneQ/mLTtC+Sqa3N3AIriUTL+JVlCfnSaBa26BsRT474cqQhRwI5citH6nKkKkdqcqSdy7x4uaQ/yMVL+X9UsSCXBZPPGhvm8lS25Mgol6l8/538/jv5v579Wi4VG8uR41xy8Z7rgvFyecQaz7Vik1xy8XNZye+Q/vTJf5Kobdh6g77hgUGVbAmUVZt2cWFGXG8XI3YVJV09bs7QmNyh6bg37eK9FX1k28WVaRdXZKKdw3xtrlyOxKxCJ/sQ3syNojGqFSJaqdgZIfcdff35WliPAuZ2kbJ9MP/z21WJ/ytGcZl2UaYo2V7t9NbvbNlBonh2uhtnJ7JRRLiDXi76115ueV2wDug4vySk/jft/wAulotePisAAA==","debug_symbols":"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"},{"name":"is_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83Z6W7bRhAH8JUsKq5ikaIuU6dFS7R123HkokCafMwL9AGK3mjRA+iBoq/Yp+rO7PGXzILGFAURArRWw/nt7C6lmOss1JlS54HSx0TZo6YjKlR1/VKl851yLd2gsxKqigtldJGUaem4OsssUDVu6QoquNY/LjJlejivPdKFGvW1UBVCLwLqk2qrF/qsL2hg6qDPRuYGpuuc2WaDfpgcYh8tcEV3+F6/vjTJ5zb5IquaoLoAuzA5DdNk+gfCjjaZUkITtAnatPRnhB0NmVJCCBqChpZ+hbCjEVNKiEAj0MjS3xF2tMWUElqgLdCWpd8j7GjMlBJi0Bg0tvQXhB1tM6WENmgbtG1e86RZTHS1GcKOdphSQge0A9rJV+v4uRUQXe03hB3tMqWELmgXtGvp5wg72mNKCT3QHmjP0l8RdrTPlBL6oH3QvqXfIOzoJVNKuAS9BL209AeEHU2YUkICmoAm+ZVNfDUhCeUkkpNuMdHL8AXCjg6YUsIAdAA6sPRHhB0dMqWEIegQdJgf6H8mbTkJ5SSRk2Ypc4lLGdgz90V/Cv5C2NERU0oYgY5AR/lqI78MBURX+xJhR8dMKWEMOgYd56uN/bdWSNpyEspJIieDUsgzK6bvz9cIOzphSgkT0AnoJF9t4hdbSDpyEslJUkqVlpyEpcxlUAoZFpPUPI375+VHhgoPye6pmB/uM/fkrHusKRxTLjU9LXVl8MQ03RV6IL/Cw3Za52Zqk67tw/y8wl3MKUQnD/OleefmSLF55tJmqGYuVE1QzTGiufLFiKQzCh8N68mAP67Y2T6aHJ5jdrTJcZOYnu4l6pjedKECdXrwXeDNEVeyN6Rmu2nwuCfmnwHXob0NUzuc6b+RoJicDMlN5upN7SinZu7M0/HSMTPjpeWcBdxs2LfBgsupa7P7CuwNS02RT+kz41dsjhXLTldsgeFlusPP9OuNSZ7b5Fue5A21wG5NTmaa9JonkZzEctKTk6SY6GX4DmFHl0wpYQm6BF3mqy39rxwhactJR04GchLLSfS/T1/fn3uEHV0xpYQV6Ap0la+28tWEpCknsZxEpcwlkZNBKeSZFdOfgj8RdnTNlBLWoGvQdb7a2n9LhWRcTPQA9wg7umFKCRvQDegmX23jb62Q3MhJJCexnPTkJJGTWznpl3JfOnIyKOW+RKXM5ZkV09+bnxB2dMuUEragW9BtvtrW/+1XSDpyEslJ+0MdWCInvQ9hxfQH51uEHd0xpYQd6A50l6+283MSklhONnLSLiZ6GV4h7OieKSXsQfeg+3y1vf9VVUBoR1d9g33HW4YKmw23u9j7zUdmejzexd5xqbvTUvcG703TXaGNzT02LQ9mF/tgk17bXezB7GJpb/maTh7mJ+admyOZQ+bSXqGauVA1QXXAiA7KFyPyMNOd7o6G9WTAvIul2b5FF3d+bQKszd3pniy9rdp9Hm/sclvL1F5Nj7qt+00nryLP970fhD3OTFlO22f2dqpG6PeVwTs7Mj7x/4UmZPKomZomD4RJw55HhEP+zxYpt3hYc2omf9P5D3fVp4nDHAAA","debug_symbols":"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"},{"name":"set_authorized_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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N7AgwLYbWBBg2w1c/42NSlPPVgG239oLAgy9iV+PZOjd+noklbflPE7Z5ZovHunjgGKq8vaRprlHUmm/+dYjqf42iUr7zcbHz74fv/h+fPH9+NX34zffj999P/7w/fjT9eNP32/d6futO32/dafvt65K783Gx/f91p2+37rT91t3+n7rTtdvXXm4fuvKw/VbVx6u37rycP3WlYfrt648XL915eH6rSsP129debh+68rD91s3+X7rJt9v3eT7rZt8v3V1unn2Pb7vt27y/dZNvt+6yfdbN/l+62bfb93s+62bfb91s++3rk43z77H9/3Wzb7futn3Wzf7futm32/d4vutW3y/dYvvt27x/dbVaUba9/i+37rF91u3+H7rFt9v3eL7rSu+37ri+60rvt+64vutq9NLte/xfb91xfdbV3y/dcX3W1d8v3Wr77du9f3Wrb7futX3W1enl2rf4/t+61bfb93q+61bfb91q++3bvP91m2+37rN91u3+X7r6nRL7Xt832/d5vut23y/dZvvt27z/dbtvt+63fdbt/t+63bfb12dvqd9j+/7rdt9v3W777du9/3W7b7fur67qcR3N5X47qYS391U4rubSnx3U4nvbirx3U0lvrupxHc3lfjuphLf3VTiu5tKfHdTie9uKvHdTSW+u6nEdzeV+O6mEt/dVNV3N1X13U1VfXdTVd/dVPXh+q1bfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1X13U1VfXdTVd/dVNV3N1Xz3U3VfHdTNd/dVM13N1V7uH7rNt/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfHdTNd/dVM13N1Xz3U3VfXdTdd/dVN13N1X33U3VH67fut13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTdd/dVN13N1X33U3VfXdTDd/dVMN3N9Xw3U01fHdTjYfrt+7w3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVMN3N9Xw3U01fHdTDd/dVNN3N9X03U01fXdTTd/dVPPh+q07fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9X03U01fXdTTd/dVNN3N9XzOV2/dv/+nM6f3/WL9/mcrt+8z+d0/ep9Pqfrd+/zOV2/fJ/P6frt+3xO16/f53M6f//6rql6Pr/z96/voqrn8zt///quqno+v/P3r++yqufzO3//+q6rej6/8/ev78Kq5/M7f//6rqx6Pr/z96/v0qrn8zt///qurXo+v/P3r+/iqufzO3//+q6uej6/8/ev7/Kq5/M7f//6rq96Pr/z96/vAqvn8zt///qusHo+v/P3r+8Sq+fDOX//+q6xej6c8/ev7yKr58M5f//6rrJ6Ppzz96/vMqvnwzl///qus3o+v/P3r+9Cq+fzO3//+q60ej6/8/ev71Kr5/M7f//6rrV6Pr/z96/vYqvn8zt///qutno+v/P3r+9yq+fzO3//+q63ej6/8/ev74Kr5/M7f//6rrh6Pr/z96/vkqvn8zt///quuXo+v/P3r++iq+fzO3//+q66ej6/8/ev77Kr5/M7f//6rrt6Pr/z96/vwqvn8zt///quvHo+v/P3r+/Sq+fzO3//+q69ej6/8/ev7+Kr5/M7f//6rr56Pr/z96/v8qvn8zt///quv3o+v+/3b3Lef5Wc918l5/1XyXn/1fPpnD+/7/dvct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3XyXn/VfJef9Vct5/lZz3X2Xn/VfZef9Vdt5/lZ33X+WH7/dvdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfZef9Vdt5/lZ33X2Xn/VfFef9Vcd5/VZz3XxXn/Vfl4fv9W5z3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef9Vcd5/VZz3XxXn/VfFef+VOO+/Euf9V+K8/0qc91/Jw/f7V5z3X4nz/itx3n8lzvuvxHn/lTjvvxLn/VfivP9KnPdfifP+K3HefyXO+6/Eef+VOO+/Euf9V+K8/0qc91+J8/4rcd5/Jc77r8R5/5U4778S5/1X4rz/Spz3X4nz/itx3n8lzvuvxHn/lTjvvxLn/VfivP9KnPdfifP+K3HefyXO+6/Eef+VOO+/Euf9V+K8/0qc91+J8/4rcd5/Jc77r8R5/5U4778S5/1X4rz/Spz3X4nz/itx3n8lzvuvxHn/lTjvvxLn/VfivP9KnPdfifP+K3HefyXO+6/Eef+VOO+/Euf9V+K8/0qc91+J8/4rcd5/Jc77r8R5/5U4778S5/1X4rz/Spz3X4nz/itx3n8lzvuvxHn/lTjvvxLn/VfivP9KnPdfifP+K3HefyXO+6/Eef+VOO+/Euf9V+K8/0qc91+J8/4rcd5/Jc77r8R5/5U4778S5/1X1Xn/VXXef1Wd919V5/1X9eH7/Vud919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXXef1Wd919V5/1X1Xn/VXPef9Wc91815/1XzXn/VXv4fv825/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wc91815/1XzXn/VXPef9Wd91915/1X3Xn/VXfef9Ufvt+/3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd91915/1X3Xn/VXfef9Wd918N5/1Xw3n/1XDefzWc91+Nh+/373DefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1Xw3n/1XDefzWc918N5/1X03n/1XTefzWd919N5/1X8+H7/Tud919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03n/1XTefzWd919N5/1X03f/VX747r96Pr/r9+/z+V2/f5/P7/r9+3x+1+/f5/O7fv8+n9/1+/f5/K7fv8/nd/3+fT6/8/ev7/6r5/M7f//67r96Pr/z96/v/qvn8zt///ruv3o+v/P3r+/+q+fzO3//+u6/ej6/8/ev7/6r5/M7f//67r96Pr/z96/v/qvn8zt///ruv3o+v/P3r+/+q+e/4Pz967v/6vkvOH//+u6/ev4Lzt+/vvuvnv+C8/ev7/6r57/g/P3ru//q+fzO37+++6+ez+/8/eu7/+r5/M7fv777r57P7/z967v/6vn8zt+/vvuvns/v/P3ru//q+fzO37+++6+ez+/8/eu7/+r5/M7fv777r57P7/z967v/6vn8zt+/vvuvns/v/P3ru//q+fzO37+++6+ez+/8/eu7/+r5/M7fv777r57P7/z967v/6vn8zt+/vvuvns/v/P3ru//q+fzO37+++6+ez+/8/eu7/+r5/M7fv777r57P7/z967v/6vn8zt+/vvuvns/v/P3ru//q+fzO37+++6+ez+/8/eu7/+r5/M7fv777r57P7/z967v/6vn8zt+/vvuvns/v+/2bnPdfJef9V8l5/1Vy3n/1fDrnz+/7/Zuc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1XyXn/VXLef5Wc918l5/1X2Xn/VXbef5Wd919l5/1X+eH7/Zud919l5/1X2Xn/VXbef5Wd919l5/1X2Xn/VXbef5Wd919l5/1X2Xn/VXbef5Wd919l5/1X2Xn/VXbef5Wd919l5/1X2Xn/VXbef5Wd919l5/1X2Xn/VXbef5Vt9y9Vyb++tsrJ85v+/F94ftOfP7WO1/O3/v75TX/+LDy/6c+fhec3/fmz8Pym/f/189vu/1l4ftOf/y21X1/bSn7//KY//xee37T/X3h+cf78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eSnjrcfaaqG8lPHGY221UF7KeNuxtlooL2W86VhbLZSXqlBeyniHtbJa4x3W2mqhvFSD8lLG+8m11QqUWigvZbyfXFstlJcy3k+urRbKSxnvJ9dWC+WljPeTa6uF8lLG+8m11UJ5KeNd5tpqobwUVO95huo9z1C95xmq9zxD9Z5nqN7zDNV7nqF6zzNU73mG6j3PUL3nGar3PEP1nmeo3vMM1XueoXrPM1TveYbqPc9QvecZqvc8Q/WeZ6je8wLVe16ges8LVO95geo9Lw+BUovkpQpU73mB6j0vUL3nBar3vED1nheo3vMC1XteoHrPC1TveYHqPS9QvecFqve8QPWeF6je8wLVe16ges8LVO95geo9L1C95wWq97xA9Z4XqN7zAtV7XqB6zwtU73mB6j0vUL3nBar3vED1nheo3vMC1XteoHrPC1TveYHqPS9QvecFqve8QPWeF6je8wLVe16ges8LVO95geo9L1C95wWq97xA9Z4XqN7zAtV7XqB6zwtU73mB6j0vUL3nBar3vED1nheo3vMC1XteoHrPC1TveYHqPS9QvecFqve8QPWeF6je8wLVe16ges8LVO95geo9L1C95wWq97xA9Z4XqN7zAtV7XqB6zwtU73mB6j0vUL3nBar3vED1nheo3vMC1XteoHrPC1TveYHqPS9QvecFqve8QPWeF6je8wLVe16ges8LVO95geo9L1C95wWq97xA9Z4XqN5zgeo9F6jec4HqPReo3nN5CJRaJC8lUL3nAtV7LlC95wLVey5QvecC1XsuUL3nAtV7LlC95wLVey5QvecC1XsuUL3nAtV7LlC95wLVey5QvecC1XsuUL3nAtV7LlC95wLVey5QvecC1XsuUL3nAtV7LlC95wLVey5QvecC1XsuUL3nAtV7LlC95wLVey5QvecC1XsuUL3nAtV7LlC95wLVey5QvecC1XsuUL3nAtV7LlC95wLVey5QvecC1XsukdqiZ8+vL+7lvdpAb6BrtZEahecYry+e/b3aQJ9SC2oDfUotqBUotYES34LaQIlvQW2k9+212kjv22u1gRLftdpIjcILaqG8VKRG4QW1br3UoUDcK7DteXqeLwUj96vU/Zjt9dQpfXrqVj/02nY9+npt+x59vbadj75e295HXa/xDmB9vbb9j75e2w5IX69tD6SvV8D0gvkr433A+nrB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"},{"name":"is_consumable","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+2aWW/iVhTHLwSYmVKMYwiENRBw2CEsyUSaZh771Lc+VOpL1V2VukhdVPUr9lP1nnOXP2Dk0R1Nr6LRWHK4Pv7/7lmuMT5yhuJMiOcFIbeO0FteWkQgpPF5lvbXwozkgPZMIDLGFNNJotRI2sVZrAGR49EZzcmjnPxTuJZ/SrFQcz3P39GJPM06FJmMOqCPnJ742ZBCFDu5F2MT4gvBRtqK9EdpCPtoiDNywk/l58dK/EKLS3FWGUUJWElpimrI6F8wGzRglAQB0ABooNFfYTZomVESlIGWgZY1+i3MBg0ZJUEINAQaavRPmA16zigJzoGeAz3X6E8wGzRilAQR0AhopNHfYDZohVESVIBWgFbUZxIJ0hHprQezQauMkqAKtAq0mvRWtbmlINLbHzAb9IJRElwAvQB6odGvYDZojVES1IDWgNaSgdbs0jsikTsSuCNVd6SUjsjK/QKzQeuMkqAOtA60rtGvYTboJaMkuAR6CfRSo9/AbNAGoyRoAG0AbWj0Z5gN2mSUBE2gTaBNjX4Ps0FbjJKgBbQFtJWsbMt+AxyRsjtSd0cCL7lEXgJrpCNySf+B2aBtRknQBtoG2k56a9syOCKX7kjTS2Bld6TujjS8IG+omLwKvoPZoB1GSdAB2gHaSXrr2GI7IlV3JHRH6l68nLsjZS+5NLwgrXSkr57H7XPyHYMCD8fmaZgf72PzxCxnzAlsXXbVPXR1peCOGpoz9CB+hYfsfoGHfS261g/xgwxPMSAT7RxmUR2ZHMk2iI2sB2/qRFYZxQARDYR1Rki/R+a9sI4Cvs/obO+UhnO0tcmhNt3DHuIZ0usOqR062GiWDrdH7EkvSE5PU+S4O+o2YCbUy9DV4XRPIfl05CAkk8zVq9yeJqdW5jhe2noqXipnL8/Doj7MD9mduFZdV14vWF85+YSuGVuxASoWH1ZsiPBiOeHn8vNGiQdaPOIkb2gEbKQ0sRrSZxIJ3ZEoHZEB/g6zQceMkmAMdAx0nPQ2tneOFER6+xFmg04YJcEE6AToJOltYn96HJGKO1J1RxruSOSOhO88fbk+tzAbdMooCaZAp0CnSW9T680RCdyRyB0JveRSd0caXpA3VExeBX/DbNAZoySYAZ0BnSW9zey31BFppyMywCXMBp0zSoI50DnQedLb3C6tI3LjjoTuSOSOjNyRujsydkeaXtal6o40vKxL6CWXt6hYzR0pecklfKoXTOjlKzZ6ChWTN9ofYDboglESLIAugC6S3hY2J0ckckdq7kglHZFlWMNs0CWjJFgCXQJdJr0t7U9UCkIdXfYV+o5HBgWaDdNdLG3zEasZ97vYFbtaHbq6VfBSDc0Zamxu0bRsVBe70aKt7mJ3qoul3nJLO4f5oI5MjsTsYiNbw5s6kVVGsUNEO2GdEbLpyUkXe2EdBcxdLGX7iMZvZWuTR21Whz1Zf7h/5kxpVXU4quLJJVlp1yeRQjqC+Ja2MV3pSZaq7VzptrOg2s2CbjeLSH99atnXh6ntrdwaVxKJNvZRZQP5RmnWuugnkdAdidyRkTtSd0fG7kjTHam4I1V3pOFlXUIv6U+8eAneo4rVvVwwfq6xqZdvZdsdmXlZyg/35A/35P979ateKlZzR0pecgmf6gUTevmKjZ5qxeZecom8XMlvkf7inf8kUR929iX6hkcGxWFLILRatYtrNeN+u7hlV9tDV8fNGRqTHZqOe9Uu3mvRS90uPqh2kRrEl7RzmF+oI5MjMQ+xkd3BmzqRVUbxgIgehHVGyH1PHn+2F9ZRwNwurlW7ePwqkFsu9SqQ970Kn3plzNWDZjsy7XVGHLyr1L3iVp/d7k1bsG8xsXD0OmzNYerNvNDucvtn4l8FtmMsvtaR8Y5/QVWmwL7Q3KohB8LISu97CJtic3LLIwKyAxpe/kv7f2Q7N08WKwAA","debug_symbols":"1d3RapVXEMXxd8m1lD2zZ/bM9lVKKWlrS0BiqbFQxHfvseaYigdyVonN+V8V9TtmcF0sXfn49f3VL69+evfbjze3v755e/Xy+/dXr9/8fH138+b28KP3V+M7m//87Nvfr28//sTbu+s/7q5ejhdXr25/Ofz3w4urX29ev7p6OS0//PDi4wdC/UCqH1jqB0r9QKsf2OIHfKgfMPUDrn5ATdrVpF1N2tWkXU3a1aRdTXqqSU816akmPdWkp5r0VJOeatJTTXqqSU816VCTDjXpUJMONelQkw416VCTDjXpUJMONelUk0416VSTTjXpVJNONelUk0416VSTTjXppSa91KSXmvRSk15q0ktNeqlJLzXppSa91KRLTbrUpEtNutSkS0261KRLTbrUpEtNutSkW0261aRbTbrVpFtNutWkW0261aRbTbrVpLea9FaT3mrSW016q0lvNemtJr3VpLea9FaTtjHkT5j8CZc/Ia8nQ55PhryfDHlAGfKCMuQJZciZm5y5yZmbnLm+mOmTmb6Z6aOZvprps5m8m5k8nJm8nJk8nZm8nZk8npm8npk8n5m8n5k8oJm8oJk8oZm8oZk8opm8opk8o5m8o5k8pJm8pJk8pZm8pZk8ppm8ppk8p1no3w2RM5cXNZMnNZM3NZNHNZNXNZNnNZN3NZOHNZOXNZOnNZO3NZPHNZPXNZPnNZP3NZMHNpMXNpMnNpM3NpNHNlv69z3lzOWdzeShzeSlzeSpzeStzeSxzeS1zeS5zeS9zUr/ZrecuTy5mby5mTy6mby6mTy7mby7mTy8mby8mTy9WetvOMiZy+ubyfObyfubyQOcyQucyROcyRucySOcySucbf21Fv29FvnFFnmHc3mHc3mHc3mHc3mHc3mHc3mHc3mHc3mHc9NfZpIzl3c4l3c4l3c4l3c4l3c4l3c4l3c4199f019g+w9vsMmZ6++w6S+x6W+x6a+x6e+x6S+yyTucyzucyzucT/21RTlzeYdzeYdzeYdzeYdzeYdzeYdzeYdzeYdzeYfz0N9VlTOXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdziXdzhf+lvpcubyDufyDufyDuend7iosPsPRbV/8bkXXz29Z98/vLs/P3v41sqJZw8D//2zh3+Kfn728Je2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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b227aQBCG18RJTJ24YGMMgQQIyUXvDA2nO16mfe3eV+orVM2YnTJsp2hRx1tWYqWIsb2e/5t/D1jICdSuRe9/gY6v9eeN+rNhn63+LP+tzQRzlXVyBp5wNjzhvPKEMxTkDBhO+Ax1DOsO1tytOlyPv9tWqChTlELBBLoi19URwIMboUU6oBfHUuDrcnNDklNwpcFDfQ0/ASfW1yhYrIus+pBzWGiDnEOdK3IOd0bUibQpwvUuoj2yXN73CQA1NHUu5I5JTK8NiXVhTTVey9f4VsuYlLtVjGNyrXPfkmP0Cj0U/OaYUe1A/zWJptJjhPGA9MV+6EeDjDG0e7Wf180j94XGfQnpc8PUPxau/9bgMecsjEFLx204xj2BsH0g9W1l2ErIG8vnndExCHVu5I9JTYm43/M15L9Th838VhqTOCE89+I85ayeOndj95Gwy+RdvIFXLcOrO8OrhPShDK0a/AuILubG4xajLefFcg3abQsv2gxP27EXbUZb0IsNaKcWXqQMT+rYi5TRlvNi9Rm0MwsvMoYnc+xFxmjLeTGvni06Fl50GJ6OYy86jLbgGqnmRW7hRc7w5I69yBltQS++gnbXwosuw9N17EWX0Rb04gtoFxZeFAxP4diLgtEW3Dur54uehRc9hqfn2Iseoy3oxRy0+xZe9BmevmMv+oy24BqptB8svHhgeB4ce4F6pzJ3PGQuPGTOzoA5MmIZ7WW1fw4svBgwPAPHXtDfck5hzs+AOTJiGe3lArSHFl4MGZ6hYy9Q71Tm1EPmzEPmrofMuYfMhYfM5zCfIyOW0V5Ve+ijhRePDM+jYy9Q71Tm1EPmgYfM2RkwR0Yso72qfpt7svDiieF5cuwF6p3K3POQuX0GzJERy2ivlqA9svBixPCMHHuBeqcy9z1kLjxkHnjInHnI3PWQOfeQ+bIG3TCnZ8AM773gOzA/auWZb2KDBz1TBqMyGGMSJ4QR+26V3PsqiVE7ak3E/diNjzlf8HhSq/Z8DXmn8jVVz/IvOhe+wzdlanrVcSDs5wvJGxAdPB+S+Dvpi/3QD1y3yA7vXD3r+PXIfSPjvoT0eWbqHwvXPzV4pgYzjMk3wlHH3LKZ1y21X8ufCE8N++AbfScXm82+Q/cYQZ5ZTXWW9B2+n0p2TU8Mr5qGVwnpQ/fo/7VvXpgvzH9jps8TTXKO8uC5hlEL/f+GCcnxC57ToyHuNQAA","debug_symbols":"ndpRattAGIXRveg5FN/fGs0oWymlOIlTDMEJsVMoJnuv3dIF9LxpJN237+kwl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLjT9vT2+74+3F6bx7P0/321530/74dHvqn3fT8+Flf31O+/x2dxutMNpuZBQZlYy2Mppl1GS0yKjLSIrYShGzFDFLEbMUMUsRsxQxSxGzFDFLEbMUMUsRTYpoUkSTIpoU0aSIJkU0KaJJEU2KaFLEIkUsUsQiRSxSxCJFLFLEIkUsUsQiRSxSRJciuhTRpYguRXQpoksRXYroUkSXIroUMaSIIUUMKWJIEUOKGFLEkCKGFDGkiCFFrFLEKkWsUsQqRaxSxCpFrFLEKkWsUsQqRWSzoVVoVbTa0mqmVaPVQqtOq0EraiPURqiNUBuhNkJthNoItRFqI9RGqI2iNoraKGqjqI2iNoraKGqjqA0CzZBohkgzZJoh1AypZog1Q64Zgs2QbIZoM2SbIdwM6WaIN0O+GQLOkHCGiDNknCHkDClniDlDzhmCzpB0hqgzZJ0h7AxpZ4g7Q94ZAs+QeIbIM2SeIfQMqWeIPUPuGYLPkHyG6DNknyH8DOlniD9D/hkC0JCAhgg0ZKAhBA0paIhBQw4agtCQhIYoNGShIQwNaWiIQ0MeGgLRkIiGSDRkoiEUDaloiEVDLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5adtGTXLTIRYtctMhFi1y0yEWLXLT+20Wvp5+798Pu4WV/u9t7+/hxfPx31fd6PP96+/vl+u9v"},{"name":"unconstrained_is_consumable","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"set_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"reject","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/83X2Y7TMBQGYKcb7XSmM9MmTZtuaZqllArBBUgIhiskHoAnQGK5YZFYxDvyVPgc++RvCWTkm2oipXGPz+djO1ONnKqmUt2W0tdC2Ut/66qB6uhHg+6XSlq6Qbc3UJ6ETB4N0uS8prkP8ziUUSeN3uCWjisTo8RWZqlqJ/pj8ETJpK7po5MqGbKXySzvKQ7S1aMPk0PjdlP0pKqtji/KOONZqzNzN81oPEw/a9iOPgbsm5yeadKzSjr15GhKspjz562DHBrvvDpfui7MfC/obptS9qveGiqnLtv8pK5L2kFT5IW+h+WOXWHHhsc7do3pDfWAb/RzZJKvbLLPixxRC8w3OUPTZPoDYaEBU0oIQAPQwNKvCAsdM6WEMegYdGzpN4SFhkwpIQQNQUNL3yIsdMKUEiagE9CJpR8RFjplSglT0Cno1NL3CAuNmFJCBBqBRpbGCAudMaWEGegMdGbpd4SFzplSwhx0Djq39BPCQhdMKWEBugBdmGeVBO7EdydRPdFreoSw0CVTSliCLkGX1WrLsloN0dW+ICx0xZQSVqAr0FW12qrcQUfiu5PInYTuZH4ScsuO6ffzC2GhMVNKiEFj0LhaLS5/xTVEV3uHsNA1U0pYg65B15Y+RFhowpQSEtAENKlONClfsSMZuRPfnQTuZOxOQncycSfTk7yXmTuZn+S9+CdZyy07pn83nxEWumFKCRvQDejG0p8IC02ZUkIKmoKm1Ymm5docie9Oors6sdCdjO/Cjum/gg8IC82YUkIGmoFm1WpZuSZHEriTxJ1E9URvw2OEheZMKSEHzUHzarW8/JdVQ6jbe43zzA1DhUOMnFoom+sbm6qWwlVwqeK41Nbg3DSlhw5MWxyGdh1u7mzSA716snuPh9hTiG6e5ivzTdZIZp9J2n1UMx0NE1R7zGivymJEdrEOPzuY1l8TfurZ1d6Yw2FblQdljxcty29jm4rjY98gPexp2kGK8u10/vl2CjuLAj04Yxb/PWPmW88W4PPxhsjkN91/AGbVK/CEEAAA","debug_symbols":"1dzLSlthGIXhe8lYyr/W9x+9lVJK6qEEJIrGQhHvvbHNTioG4kDa/c6MfkkWGeTFyfO0uLz69vj962p9ffuwOP/8tLi5vVhuVrfr7aOnRfqk/Pu3D3fL9csvHjbL+83iXM75bHG1vnz5sebns8X16uZqcR4qz2dvrot67K6LhvbXI44c15zq7rhmvzr+cvYyqBwfZB8GlRODRvTd8eh9f6vsI7cqaXrhcbi1j20fxZpeuPTDCsfYja/k8Y08vpPHD/B4J/J4k8cHeXwmjydHyuRImRwpkyNlcqSCHKkQeTy5sPEBhVWq039HktOJ+dP4dOJVW5mWt/r3R5J3wwt1eKUOb9ThnTp8QIfnRB0u6nBTh1MDlDN1OLWcmVrOTC1nppYzU8tZqOUs1HIWajkLtZyFWs5CLWehlrNQy1mo5SzUclZqOSu1nJVazkotZ6WWs1LLWanlrNRyVmo5K7WcjVrORi1no5azUcvZqOVs1HI2ajkbtZyNWs5GLWenlrNTy9mp5ezUcnZqOTu1nJ1azk4tZ6eWs1PLOajlHNRyDmo5B7Wcg1rOQS3noJZzUMs5qOUc1HIqUdOpRG2nEjWeStR6KlHzqUTt5/ZNscupBVWiJlQJ21BhGypsQ4VtqLANFbahwjZU2IYK21BhGypsQ41tqLENNbahxjb0Ixyf/7Qc21BjG2psQ41tqLENDWxDA9vQwDYUi/UosA3FOkPCQkPCSkPCUkPCWkPCYkPCakPCckPCekPCgkPCikPCkkPCmkPCokPCqkPCskPCukPCwkPCykPC0kPC2kPC4kPC6kPC8kPC+kPCAkTCCkTCEkTCGkTCIkTCKkTCMkTCOkTCQkTCSkTCUkTCWkTCYkTCakTCckTCekTCgkTCikTCkkTCmkTCokTCqkTCskTCukTCwkTCykTC0kTC2kTC4kTC6kTC8kTC+kTCAkXCCkXCEkXCGkXCIkXCKkXCMkXCOkXGOkXGOkXGOkXGOkVO1IYa6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQF1ikKrFMUWKcosE5RJGpDA+sUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2ieIdT1Map5Tnl6To7Xr3L2+sY06Lt0/a3jjQt6h+xKPafZW6nFtUyza+jHm49pkVjbove4QX960Wa3SLPblHMblGe3aIyu0V1dova7BbN7js7ZvednWf3nZ3n9J29ffRjeb9afru5etg+4+WPj+uLzep2vXu4+Xn35y/b218="},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2Zy27aQBSGBwikTQhJSmwM5mLABgImCYt20ZbuKnXfVZeV0mbTi9SL+o59qs45M+PfjinRVK2FqiANHp/5vzmXMSFHhKIixIOqkK+e0C9590A0RE1eyjReCDOTExqlhigZk9Lt0WDdnhppHZsiWqTdyzyTdlGJ9MZCrVbId6Q3EbWRfDt+LEx4p/S2H1K8vPlBZOKV21b09IDelIY8PAyxEoqqyL5ol0OOXxyqUdFB0jb1qKwX6tiwrjQHakrXPLK/HcmEZJI5eraX0tB+R/l46dVQ8TZoVHla17eyNOROnFT5SlGcUAWVk+dyNJOKnaJizWzFHiG8ptzwtbyeKfGpFjuc5BnNgDlK01RTRr/BbFCXURK4QF2grkY/w2zQFqMkaAFtAW1p9AvMBvUYJYEH1APqafQtzAZtM0qCNtA20LZGb2A2aIdREnSAdoB2NPoOZoP6jJLAB+oD9TUawGzQLqMk6ALtAu1q9CvMBu0xSoIe0B7QnkY/wGzQPqMk6APtA+2rax5x7RHHHvG3IzKnK5gNOmCUBAOgA6CDvLdB4m0LIr19gtmgAaMkCIAGQIO8tyCpoCXi2CO+PeLZI71CkDsqJs/nB8wGHTJKgiHQIdBh3tsw+RRvQaS3a5gNOmKUBCOgI6AjjV7AbNAxoyQYAx0DHecDHSdHbImc2SOOPeLaIy17xLNH2vZIp5Bz6dojvULOxSkklzsqJj83H2E2aMgoCUKgIdBQo99hNmjEKAkioBHQKB9olORmiTj2iL+rgXn2SGsXKiafgvcwG3TCKAkmQCdAJ3lvkyQnS8S1R8b2iL8dkWVYwWzQKaMkmAKdAp3mvU2Tr6wtCH0Zll6hn1kzKNDEmK6F1HwMig3FnsBrxq5mWVfnCp6qqVmhhukczdCixtOFFsUye2KXJd5iSSYaHOZLdWdyJGYZGdkc3tRCWRnFEhEtReKMkEUgzU9TYd0K+ElJZ7tGQzlLarOP2syyvd5xmF6pKK2qDkdV33gkM+16I1LdjiC+adLwzvQmU9XO0i21s1XVxtKG1MbWkf5807HPs6mlTm6OJ4lEi+RflwXkC6WZ66JvRBx7xLVHWvaIZ4+07ZGOPeLbI117pFfIuTiFpN8vxMvgP6qYV8gDU8wzFhTyqRzaI6NCjvL+b/L93+R/ffrdQio2tkfCQnJxdvWBcQr5iLV2tWJRIbm4hTzJf5D+5K9/JdGXXPkGfcOaQZFtCYRWq3ZxrnZMt4sxu4qzrm43Z2hMlmg6LlW7eKlFV7pdXKl2kfpm+snhisO8VncmR2JWkZFdwJtaKCujWCGilUicEXIZyE3fpMK6FTC3i5TtWv2WSKOK3eKkTDWUKc62V/UwvVLRm8TJ6VQ3nk6so4ixgl4u/m0vt5iVtAO6zsaEeD9p/AKfECQnvR4AAA==","debug_symbols":"1dzRahxXFobRd9G1GWrvs/epOn6VYRiUxBkERg6xMhBM3j1yorZiIugLkaTWnVp9uvqnBfWpb9anm+/effPT//57d//9h483b//96eb9h29vH+4+3D8++nSz/Sv6t99+/OH2/vMvPj7c/vhw8/ao483Nu/vvHn+axy9vbr6/e//u5u2I/uXNn852HOPpcMeKL6fXeOHwrG0+HZ6VXx3+z5vPc+aLc3L7MmddmbPGZfo6nqdH5Qtnoy/XjfV8NvOl5aszLhfuo59Pj/U0fXenH+70xU7PzZ0e7vThTi93ervT3SSlm6R0k5RukoabpOEmaaQ73a3peHVNY5uXbz4RuV0Zf7nudu371LrsntvXH8jvs6c5ezdnH+bsRc6uzZwd5uw0Zw9ztpmbanO2WckyK1lmJcusZJuVbLOSbVayzUq2Wck2K9lmJdusZJuVbLOS06zkNCs5zUpOs5LTrOQ0KznNSk6zktOs5DQruZuV3M1K7mYld7OSu1nJ3azkblZyNyu5m5XczUoeZiUPs5KHWcnDrORhVvIwK3mYlTzMSh5mJQ+zksus5DIrucxKLrOSy6zkMiu5zEous5LLrOQyKxmbmcnYzE7GZoYyNrOUsZmpjM1s5eOborvNWsZm5jI2tJeB9jLQXgbay0B7GWgvA+1loL0MtJeB9jLQXibay0R7mWgvE+3l6xWcf2g32stEe5loLxPtZaK9HGgvB9rLgfZyoL1EnZsYaC9RoCdQoSdQoidQoydQpCdQpSdQpidQpydQqCdQqSdQqidQqydQrCdQrSdQridQrydQsCdQsSdQsidQsydQtCdQtSdQtidQtydQuCdQuSdQuidQuydQvCdQvSdQvidQvydQwCdQwSdQwidQwydQxCdQxSdQxidQxydQyCdQySdQyidQyydQzCdQzSdQzidQzydQ0CdQ0SdQ0idQ0ydQ1CdQ1SdQ1idQ1ydQ2CdQ2SdQ2idQ2ydQ3CdQ3SdQ3idQ3ydR3ydR3ydR3ydR3yc3s5eJ+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j6J+j4D9X0G6vsM1PcZqO8zNrOXA/V9Bur7DNT3GajvM1DfZ6C+z0B9n4H6PgP1fQbq+wzU9xmo7zNQ32egvs9AfZ+B+j4D9X0G6vsM1PcZqO8zUN9noL7PQH2fcdX3OeaVd1jjeDq7juPK6ujLdWM9n80cL1238zJ99dHPp8e6bF/u9qvOz5m3B7w94e0D3l7w9oa3T3j7Dm+Huzrgrhbc1YK7WnBX69Vd/Wv+d9/7Mnyff/xE6rK70N2N7p7o7h3dfaC7l7m7N3R3oLsT3Y328qoNdNbdaC8b7WWjvWy0l432cqK9nGgvJ9rLifbyqg101t1oLyfay4n2cqK9nGgvd7SXO9rLHe3ljvbyqg101t1oL3e0lzvayx3t5Y728kB7eaC9PNBeHmgvr9pAZ92N9vJAe3mgvTzQXh5oLxfay4X2cqG9XGgvr9pAZ92N9nKhvVxoLxfay2X2sjazl7WZvazN7GVtZi9rM3tZm9nL2sxe1mb2sjazl7WhvQy0l4H2MtBeBtrLqzbQWXejvQy0l4H2MtBeBtrLRHuZaC8T7WWivbxqA511N9rLRHuZaC8T7WWivRxoLwfay4H2cqC9fL0B9A/tRns50F4OtJcD7eVAe1loLwvtZaG9RH2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fQn2fRn2fRn2fRn2fRn2f3sxeNur7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7NOr7TNT3majvM1HfZ6K+z9zMXk7U95mo7zNR32eivs9EfZ+J+j4T9X0m6vtM1PeZqO8zr/k+axvXdtdWl92V46v3+PPpsS57Hl/25WyO7bJnvn7P+PI51n5tz+zL+Lme/0KR67JnP9me42R71rn2XHNx/vY9cbI9ebI942R76mR7+mR7TnZ/zpPdn/Nk9+c8z/358dH/b3+8u/3m/buPj6/4/ORP998+3H24f3r48PMPvz/zePZX"},{"name":"consume","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"1dzdjlzXcYbhe+GxEKyqWvWnWwmCQLblgIBAGRYdIBB079lKuqc5UDPdqAw9+z2L7L05H0alfhUO/fz64S8//ukf//HvHz/99edfPnz/r79++OnnP//w+ePPn46/+vXD+hex//lPf/nbD59+/w9++fzD3z9/+F6q+7sPP376y/F/tu3fvvvw148//fjhexP/7bs/PN1Wl4e76uVZ2XrnWfH18gvfnlW1e7+uq1x/YS+/PW3927999/v4TR7v5PFBHp/k8QUer4s8XsjjlTyeHCklR0rJkVJypJQcKUVHqsHjjVxYe4PCygq7Pi26Hsy/jl8PftX06/KML78l+zLcqMM3dbhThwd1eFKHF3V4Q4fvRR1ODdBW6nBqOTe1nJtazk0t56aWc1PLuanldGo5nVpOp5bTqeV0ajmdWk6nltOp5XRqOZ1azqCWM6jlDGo5g1rOoJYzqOUMajmDWs6gljOo5UxqOZNazqSWM6nlTGo5k1rOpJYzqeVMajmTWs6ilrOo5SxqOYtazqKWs6jlLGo5i1rOopazqOVsajmbWs6mlrOp5WxqOZtazqaWs6nlbGo5m1pOWdR0yqK2UxY1nrKo9ZRFzacsaj+PL4pdTi2oLGpCZWEbKtiGCrahgm2oYBv6FkDOOy3HNlSwDRVsQwXbUME2VLENVWxDFdtQxTb0Lfyed1qObahiG6rYhiq2oYptqGEbiqV6xLANxSpDgmWGBOsMCRYaEqw0JFhqSLDWkGCxIcFqQ4LlhgTrDQkWHBKsOCRYckiw5pBg0SHBqkOCZYcE6w4JFh4SrDwkWHpIsPaQYPEhwepDguWHBOsPCRYgEqxAJFiCSLAGkWARIsEqRIJliATrEAkWIhKsRCRYikiwFpFgMSLBakSC5YgE6xEJFiQSrEgkWJJIsCaRYFEiwapEgmWJBOsSCRYmEqxMJFiaSLA2kWBxIsHqRILliQTrEwkWKBKsUCRYokiwRpFgkSLBKkWCZYoE6xQp1ilSrFOkWKdIsU6RLmpDFesUKdYpUqxTpFinSLFOkWKdIsU6RYp1ihTrFCnWKVKsU6RYp0ixTpFinSLFOkWKdYoU6xQp1ilSrFOkWKdIsU6RYp0ixTpFinWKFOsUKdYpUqxTpFinSLFOkWKdIsU6RYp1ihTrFCnWKVKsU6RYp0ixTpFinSLFOkWKdYoU6xQp1ilSrFOkWKdIsU6RYp0ixTpFinWKFOsUKdYpUqxTpFinSLFOkWKdIsU6RYp1ihTrFCnWKVKsU6RYp0ixTpFinSLFOkWKdYoU6xQp1ilSrFOkWKdIsU6RYp0ixTpFinWKFOsUKdYpUqxTpFinSLFOkWKdIsU6RYp1ihTrFCnWKVKsU6RYp0ixTpFinSLFOkWKdYoU6xQp1ilSrFOkWKdIsU6RYp0ixTpFhnWKDOsUGdYpMqxTZIvaUMM6RYZ1igzrFBnWKTKsU2RYp8iwTpFhnSLDOkWGdYoM6xQZ1ikyrFNkWKfIsE6RYZ0iwzpFhnWKDOsUGdYpsiecoi2Plovdlsd+9VX++LRVXB7emrdnte88q3Vdf3x8v3r2sj7Q6xO9vtDrm7z+Cbvo/7X+8lXkn/JV9C2+Su6Xr9Lx4O+E2/WX9n377qqt6yI73aJ9ukV+ukVxukV5ukX1jos87izacrpFerpFX/lnrfRlkferRZf3YvheDt+r4Xs9e+9rcsLD92T4ng7fs+F7e/je8F58eC8+vBcf3osP7yWG9xLDe4nhvcTwXmJ4LzG8lxjeSwzvJYb3EsN7yeG95PBecngvObyXHN5LDu8lh/eSw3vJ4b3k8F5qeC81vJca3ksN76WG91LDe6nhvdTwXmp4LzW8lx7eSw/vpYf30sN76eG99PBeengvPbyXHt5Lz+5lrzV8T4bv6fA9G763h+/58L0YvpfD92r43vBeZHgvMrwXGd6LDO9Fhvciw3uR4b3I8F5keC8yvBcd3osO70WH96LDe9HhvejwXnR4Lzq8Fx3eiw7vxYb3cv/nCrr0+ttguvbr9+78npnU9ecKLn37/bi2Ow/H8VF/eTiOa/3y4csivb/o5SeyuurR7/m5rbwuMskHi9LruijT7yyy+4var4uOHxI/XBT7ZVHag0Wl158pR1ncWXT/n56ul79rsuPBouNfta7f0eNT/7bf5c7D7Xr9KVh73b5Han2d5OebFOeblOebVOeb1Keb9BVd/10nyfkm6fkm2fkmne/Te5/v03uf79N7n+/Te5/v03uf79Pbz/fp7ef79PbzfXr7+T69/Xyf3n6+T28/36e3n+/T+/5P3fX2J1ZUxR9Marv+f69dX/6p4nt/Ull8vfx2wBd/Jklttr7J6+//CQTMekGvV/R6Q6939PpAr0/0enStAl2rRNcq0bVKdK0SXav7fy4Os/4NWvtt/reI3tfpsV5/Ty7LA7s8scsLu7ypy2thlwt2uWKXG3b5xi7HNrSwDS1sQwvb0MI2tLENbWxDG9vQxja0sQ1tbEMb29DGNrSxDW1qQ31RG+qL2lBf1Ib6ojbUF7WhvqgN9UVtqC9qQ31RG+oL21DBNlSwDRVsQwXbUME2VLANFWxDBdtQwTZUsA1VbEMV21DFNlSxDVVsQxXbUMU2VLENVWxDFdtQwzbUsA01bEMN21DDNtSwDTVsQw3bUMM21LAN3diGbmxDN7ahG9vQjW3oxjZ0Yxu6sQ3d2IZubEMd21DHNtSxDXVsQx3bUMc21LENdWxDHdtQxzY0sA0NbEMD29DANjSwDQ1sQwPb0MA2NLANDWxDE9vQxDY0sQ1NbEPfwip6p+XYhmKdIsc6RY51ihzrFDnWKXKsU+RYp8ixTpFjnSLHOkWOdYoc6xQ51ilyrFPkWKfIsU6RY50ixzpFjnWKHOsUOdYpcqxT5FinyLFOUWCdosA6RYF1igLrFMWiNjSwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsU5RYpyixTlFinaLEOkW5qA1NrFOUWKcosU5RYp2ixDpFiXWKEusUJdYpSqxTlFinKLFOUWKdosQ6RYl1ihLrFCXWKUqsU5RYpyixTlFinaLEOkWJdYoS6xQl1ilKrFOUWKcosU5RYp2ixDpFiXWKEusUJdYpSqxTlFinKLFOUWKdosQ6RYl1ihLrFCXWKUqsU5RYpyifcIpMH3yNtro83FUPdotfl0vfnj2+yL1f1/U6vr1u3z+1vq4v9Pomr3/CLDrzekGvV/R6Q6/f6PWOXh/o9ejWOrq1jm5toFsb6NbGG7T22/y7/fEvMZcnM778nuzrcsMu39jljl0e2OWJXV7Y5U1dngu7XLDLsQ1NbEOfMI7Ouhzb0MQ2NLENTWxDE9vQwja0sA0tbEML29AnjKOzLsc2tLANLWxDC9vQwja0sQ1tbEMb29DGNvQJ4+isy7ENbWxDG9vQxja0qQ2tRW1oLWpDa1EbWova0FrUhtaiNrQWtaG1qA2tRW1oLWxDBdtQwTZUsA0VbEOfMI7OuhzbUME2VLANFWxDBdtQxTZUsQ1VbEMV29AnjKOzLsc2VLENVWxDFdtQxTbUsA01bEMN21DDNvQJ4+isy7ENNWxDDdtQwzbUsA3d2IZubEM3tqEb29AnjKOzLsc2dGMburEN3diGbmxDHdtQxzbUsQ11bEPfwjF6p+XYhjq2oY5tqGMb6tiGBrahgW0o1ikqrFNUWKeosE5RYZ2iwjpFhXWKCusUFdYpKqxTVFinqLBOUWGdosI6RYV1igrrFBXWKSqsU1RYp6iwTlFhnaLCOkWFdYoK6xQV1ikqrFNUWKeosE5RYZ2iwjpFhXWKCusUFdYpKqxTVFinqLBOUWGdosI6RY11ihrrFDXWKWqsU9SL2tDGOkWNdYoa6xQ11ilqrFPUWKeosU5RY52ixjpFjXWKGusUNdYpaqxT1FinqLFOUWOdosY6RY11ihrrFDXWKWqsU9RYp6ixTlFjnaLGOkWNdYoa6xQ11ilqrFPUWKeosU5RY52ixjpFjXWKGusUNdYpaqxT1FinqLFOUWOdosY6RY11ihrrFDXWKWqsU9RYp6ixTlFjnaLGOkWNdYoa6xQ11ilqrFPUWKeosU5RY52ixjpFjXWKGusUNdYpaqxT1FinqLFOUWOdosY6RY11ihrrFDXWKWqsU9RYp6ixTlFjnaLGOkWNdYoa6xQ11ilqrFPUWKeosU5RY52ixjpFjXWKGusUNdYpaqxT1FinqLFOUWOdosY6RY11ihrrFDXWKWqsU9RYp6ixTpEsLFR0TKdW9JhOzegxndrRYzo1pMd0akmP6dSUHtOpLT2mU2N6TOfWFEsWHdO5NcWiRcd0bk2xbNExnVtTLFx0TOfWFEsXHdO5NcXiRcd0bk2xfNExnVtTLGB0TOfWFEsYHdO5NcUiRsd0bk2xjNExnVtTLGR0TOfW9BnKqB9NF7tNj/3qy/zxaau4PLw1b89q33lW6zrfpF49e53v7PnBnp/s+cWe3992/uXLPAMSvcWXkbf4Mi9Pi3Q8+Jvh1peHfd++wWrrZZKeb5Kdb9I+3yQ/36Q436R8x0ke9yb5Ot8kOd+k+//Eqa+XSW2vJl1f9OmLMX0xpy/W9MUevvgV8OCJF2X6ok5ftOmL08uJ6eXE9HJiejkxvZyYXk5OLyenl5PTy8np5eT0cnJ6OTm9nJxeTk4vJ6eXU9PLqenl1PRyano5Nb2cml5OTS+nppdT08up6eX09HJ6ejk9vZyeXk5PL6enl9PTy+np5fT0cnp4ObLW9EWZvqjTF2364p6+6NMXY/piTl+s6YvTy5Hp5cj0cmR6OTK9HJlejkwvR6aXI9PLkenlyPRydHo5Or0cnV6OTi9Hp5ej08vR6eXo9HJ0ejk6vRybXo5NL8eml2PTy7Hp5dj0cr7ycydb19+lV9v7t//7N7Xa6vJw15c/Wrz340p5WST9xe9Fqt37dV2vP/hoL789bf0yP9nziz2/0fO/8vMszHxhz1f2fGPP3+z5zp7Pru5mV3ezq7vZ1XV2df0Nqvtt/oSf93V7rNfflOt05U437vTNne7c6cGdntzpxZ3e2OmxuNO5NQ1uTYNb0+DWNLg1DW5Ng1vT4NY0uDVNbk2TW9Pk1jS5NU1uTZNb0+TWNLk1TW5Nk1vT4ta0uDUtbk2LW9Pi1rS4NS1uTYtb0+LWtLg1bW5Nm1vT5ta0uTVtbk2bW9Pm1rS5NW1uTRtbU13YmurC1lQXtqa6sDXVha2pLmxNdWFrqgtbU13Ymuri1lS4NRVuTYVbU+HWVLg1FW5NhVtT4dZUuDUVbk2VW1Pl1lS5NVVuTZVbU+XWVLk1VW5NlVtT5dbUuDU1bk2NW1Pj1tS4NTVuTY1bU+PW1Lg1NW5NN7emm1vTza3p5tb0LZyk95rOrenm1nRza7q5Nd3cmjq3plwLSbkWknItJOVaSMq1kJRrISnXQlKuhaRcC0m5FpJyLSTlWkjKtZCUayEp10JSroWkXAtJuRaSci0k5VpIyrWQlGshKddCUq6FpFwLSbkWknItJOVaSMq1kJRrISnXQlKuhaRcC0m5FpJyLSTlWkjKtZCUayEp10JSroWkXAtJuRaSci0k5VpIyrWQlGshKddCUq6FpFwLybgWknEtJONaSMa1kGxha2pcC8m4FpJxLSTjWkjGtZCMayEZ10IyroVkXAvJuBaScS0k41pIxrWQjGshGddCMq6FZFwLybgWknEtJONaSMa1kIxrIRnXQjKuhWRcC8m4FpJxLSTjWkjGtZCMayEZ10IyroVkXAvJuBaScS0k41pIxrWQjGshGddCMq6FZFwLybgWknEtJONaSMa1kIxrIRnXQjKuhWRcC8m4FpJxLSTjWkjGtZCMayEZ10IyroVkXAvJuBaScS0k41pIxrWQjGshGddCMq6FZFwLybgWknEtJONaSMa1kIxrIRnXQjKuhWRcC8m4FpJxLSTjWkjGtZCMayEZ10IyroVkXAvJuBaScS0k41pIxrWQjGshGddCMq6FZFwLybgWknEtJONaSMa1kIxrIRnXQtpcC2lzLaTNtZA210LaC1vTzbWQNtdC2lwLaXMtpM21kDbXQtpcC2lzLaTNtZA210LaXAtpcy2kzbWQNtdC2lwLaXMtpM21kDbXQtpPWEghD75IW10e7qoHw8Wv06Vvz6ravV/X9bq+vfz2tPXL/M2e7+z5wZ6f7PnFnt/o+U84SaeeL+z5yp7Pru4TbtKp57Ora+zqGru69gbV/Tb/rp9+3Z7x5Tdlv0xv7PS9uNOFO1250407fXOnO3d6cKcndzq3pptbU+fW1Lk1dW5NnVvTJxyl007n1tS5NXVuTZ1bU+fWNLg1DW5Ng1vT4Nb0CUfptNO5NQ1uTYNb0+DWNLg1TW5Nk1vT5NY0uTV9wlE67XRuTZNb0+TWNLk1TW5Ni1vT4ta0uDUtbk2fcJROO51b0+LWtLg1LW5Ni1vT5ta0uTVtbk2bW9MnHKXTTufWtLk1bW5Nm1vTxtbUF7amvrA19YWtqS9sTX1ha+oLW1Nf2Jr6wtbUF7amvrg1FW5NhVtT4dZUuDV9wlE67XRuTYVbU+HWVLg1FW5NlVtT5dZUuTVVbk3fwlB6r+ncmiq3psqtqXJrqtyaGremxq2pcWtq3Jq+hY30XtO5NTVuTY1bU66F5FwLybkWknMtJOdaSM61kJxrITnXQnKuheRcC8m5FpJzLSTnWkjOtZCcayE510JyroXkXAvJuRaScy0k51pIzrWQnGshOddCcq6F5FwLybkWknMtJOdaSM61kJxrITnXQnKuheRcC8m5FpJzLSTnWkjOtZCcayE510JyroXkXAvJuRaScy0k51pIzrWQnGshOddCcq6F5FwLybkWknMtJOdaSM61kJxrITnXQnKuheRcC8m5FpJzLSTnWkjOtZCCayEF10IKroUUXAspFramwbWQgmshBddCCq6FFFwLKbgWUnAtpOBaSMG1kIJrIQXXQgquhRRcCym4FlJwLaTgWkjBtZCCayEF10IKroUUXAspuBZScC2k4FpIwbWQgmshBddCCq6FFFwLKbgWUnAtpOBaSMG1kIJrIQXXQgquhRRcCym4FlJwLaTgWkjBtZCCayEF10IKroUUXAspuBZScC2k4FpIwbWQgmshBddCCq6FFFwLKbgWUnAtpOBaSMG1kIJrIQXXQgquhRRcCym4FlJwLaTgWkjBtZCCayEF10IKroUUXAspuBZScC2k4FpIwbWQgmshBddCCq6FFFwLKbgWUnAtpOBaSMG1kIJrIQXXQgquhRRcCym4FlJwLaTgWkjBtZCCayEF10IKroUUXAspuBZScC2k5FpIybWQkmshJddCyoWtaXItpORaSMm1kJJrISXXQsonLKTcj6Zve5m+0159mT8+Hb4vDx//2np7Vvtlkpxvkp5vkp1v0j7fJD/fpDjfpDzfpDrfpD7dJD3fp7ee79Nbz/fprWf69D7+6j9/+PvHH/7004+/HG/8/l/+49OfP3/8+dPlLz//19/+9785nv1v"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"reject_all","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"approved_actions","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"reject","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_parameters"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::is_consumable_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_consumable_abi"}]}},"file_map":{"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nunconstrained fn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"137":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"142":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        // This looks the same as the &mut PublicContext impl, but is actually very different. In public execution the\n        // storage read oracle gets transpiled to SLOAD opcodes, whereas in unconstrained execution the PXE returns\n        // historical data.\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n"},"163":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse dep::std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: 0 }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"165":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, nullifier_counter: u32, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, nullifier_counter, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    nullifier_counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.nullifier_counter == other.nullifier_counter)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            nullifier_counter: 0,\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.nullifier_counter as Field, self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            nullifier_counter: reader.read_u32(),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n        assert(\n            (self.nullifier_counter == 0) | (read_request.counter() < self.nullifier_counter), \"Read request counter must be less than the nullifier counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"166":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr","source":"use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        // WARNING: if updating, see comment in public_call_stack_item.ts's `PublicCallStackItem.hash()`\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs = PublicCircuitPublicInputs::empty();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector, note_hash::NoteHash,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x2751111aa213d9d21279da53531bf90c2da272cf3f959e2a2a1dfceb487bf102;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x1860d00d9602966e398c6d585216baba2ffa8c5eddda5faee041136665d8482a;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n"},"168":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    new_note_hashes: u32,\n    new_nullifiers: u32,\n    new_l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            new_note_hashes: validate_array(public_inputs.new_note_hashes),\n            new_nullifiers: validate_array(public_inputs.new_nullifiers),\n            new_l2_to_l1_msgs: validate_array(public_inputs.new_l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.new_note_hashes.len() {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..self.new_nullifiers.len() {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.new_l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x1970bf189adc837d1769f9f44a8b55c97d45690e7744859b71b647e808ee8622;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"171":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"174":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint\n};\n\nstruct KeyValidationRequest {\n    pk_m: GrumpkinPoint,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: GrumpkinPoint::zero(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: GrumpkinPoint::new(fields[0], fields[1]),\n            sk_app: fields[2],\n        }\n    }\n}\n\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"188":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"189":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    abis::{caller_context::CallerContext, side_effect::{Ordered, RangeOrdered, Scoped}},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.hash == other.hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"203":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x22786e4f971661d2e49095e6b038e5170bc47b795253916d5657c4bdd1df50bf;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"206":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"210":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    abis::{gas_settings::GasSettings, gas::Gas}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        let serialized: [Field; CALL_CONTEXT_LENGTH] = self.serialize();\n\n        for i in 0..CALL_CONTEXT_LENGTH {\n            assert(serialized[i] == 0);\n        }\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n        serialized.push(self.side_effect_counter as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n            side_effect_counter: reader.read() as u32,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n            side_effect_counter: 0,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn assert_is_zero() {\n    let context = CallContext::empty();\n    context.assert_is_zero();\n}\n\n#[test(should_fail)]\nfn not_zero_assert_is_zero() {\n    let mut context = CallContext::empty();\n    context.is_delegate_call = true;\n    context.assert_is_zero();\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"212":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, note_hash::NoteHash, nullifier::Nullifier, read_request::ReadRequest,\n    gas::Gas, global_variables::GlobalVariables, log_hash::LogHash\n},\n    address::AztecAddress,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH, MAX_UNENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize, Empty}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    l1_to_l2_msg_read_requests: [ReadRequest; MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    // Global variables injected into this circuit\n    global_variables: GlobalVariables,\n\n    prover_address: AztecAddress,\n\n    revert_code: u8,\n    \n    start_gas_left: Gas,\n    end_gas_left: Gas,\n    transaction_fee: Field,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.l1_to_l2_msg_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        for i in 0..MAX_UNENCRYPTED_LOGS_PER_CALL{\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n        fields.push(self.transaction_fee);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            l1_to_l2_msg_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            global_variables: reader.read_struct(GlobalVariables::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            revert_code: reader.read() as u8,\n            start_gas_left: reader.read_struct(Gas::deserialize),\n            end_gas_left: reader.read_struct(Gas::deserialize),\n            transaction_fee: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PublicCircuitPublicInputs {\n    fn empty() -> Self {\n        PublicCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0 as u32,\n            end_side_effect_counter: 0 as u32,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0 as u8,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PublicCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PublicCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x01681b19fb7fe21aa9c2cf9fb47520149f46edd679b2e7c2b2c4a279fd685125;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"214":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"22":{"path":"std/field.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"221":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"222":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"223":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"230":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.tx_tree_height);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    contract_class_id::ContractClassId, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{Hash, is_empty},\n    utils::{uint256::U256, field::field_from_bytes_32_trunc}\n};\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u32) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, first_nullifier: Field, index: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, index);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"242":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"248":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"260":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"280":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"281":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"315":{"path":"/usr/src/noir-projects/noir-contracts/contracts/auth_registry_contract/src/main.nr","source":"contract AuthRegistry {\n    use dep::aztec::{state_vars::{PublicMutable, Map}, protocol_types::address::AztecAddress};\n    use dep::authwit::auth::{IS_VALID_SELECTOR, compute_outer_authwit_hash, assert_current_call_valid_authwit};\n\n    #[aztec(storage)]\n    struct Storage {\n      reject_all: Map<AztecAddress, PublicMutable<bool>>,\n      // on_behalf_of => authwit hash => authorized\n      approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool>>>,\n    }\n\n    /**\n     * Updates the `authorized` value for `msg_sender` for `message_hash`.\n     *\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[aztec(public)]\n    fn set_authorized(message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Updates the `reject_all` value for `msg_sender`.\n     * \n     * When `reject_all` is `true` any `consume` on `msg_sender` will revert.\n     * \n     * @param reject True if all actions should be rejected, false otherwise\n     */\n    #[aztec(public)]\n    fn set_reject_all(reject: bool) {\n        storage.reject_all.at(context.msg_sender()).write(reject);\n    }\n\n    /**\n     * Consumes an `inner_hash` on behalf of `on_behalf_of` if the caller is authorized to do so.\n     * \n     * Will revert even if the caller is authorized if `reject_all` is set to true for `on_behalf_of`.\n     * This is to support \"mass-revoke\".\n     *\n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param inner_hash The inner_hash of the authwit\n     * @return `IS_VALID_SELECTOR` if the action was consumed, revert otherwise\n     */\n    #[aztec(public)]\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \"rejecting all\");\n\n        let message_hash = compute_outer_authwit_hash(\n            context.msg_sender(),\n            context.chain_id(),\n            context.version(),\n            inner_hash\n        );\n\n        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();\n\n        assert_eq(true, authorized, \"unauthorized\");\n        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\n\n        IS_VALID_SELECTOR\n    }\n\n    /**\n     * Updates a public authwit using a private authwit\n     * \n     * Useful for the case where you want someone else to insert a public authwit for you.\n     * For example, if Alice wants Bob to insert an authwit in public, such that they can execute\n     * a trade, Alice can create a private authwit, and Bob can call this function with it.\n     *\n     * @param approver The address of the approver (Alice in the example)\n     * @param message_hash The message hash to authorize\n     * @param authorize True if the message hash should be authorized, false otherwise\n     */\n    #[aztec(private)]\n    fn set_authorized_private(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        assert_current_call_valid_authwit(&mut context, approver);\n        AuthRegistry::at(context.this_address())._set_authorized(approver, message_hash, authorize).enqueue(&mut context);\n    }\n\n    /**\n     * Internal function to update the `authorized` value for `approver` for `messageHash`.\n     * Used along with `set_authorized_private` to update the public authwit.\n     * \n     * @param approver The address of the approver\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(approver).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Fetches the `reject_all` value for `on_behalf_of`.\n     * \n     * @param on_behalf_of The address to check\n     * @return True if all actions are rejected, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {\n        storage.reject_all.at(on_behalf_of).read()\n    }\n\n    /**\n     * Fetches the `authorized` value for `on_behalf_of` for `message_hash`.\n     * \n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param message_hash The message hash to check\n     * @return True if the caller is authorized to perform the action, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n\n    unconstrained fn unconstrained_is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> pub bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n}\n"},"51":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n// docs:start:assert_current_call_valid_authwit\n// Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_new_nullifier(nullifier, 0);\n}\n\n// docs:start:assert_current_call_valid_authwit_public\n// Assert that `on_behalf_of` have authorized the current call in a public context\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n// docs:start:compute_call_authwit_hash\n// Compute the message hash to be used by an authentication witness \npub fn compute_call_authwit_hash<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_outer_authwit_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_call_authwit_hash\n\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\npub fn compute_outer_authwit_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field\n) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"86":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::address::AztecAddress;\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = block_number_oracle();\n        let contract_address = contract_address_oracle();\n        let chain_id = chain_id_oracle();\n        let version = version_oracle();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n}\n\n#[oracle(getContractAddress)]\nunconstrained fn contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn version_oracle() -> Field {}\n"},"87":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"90":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_args(self) -> [Field];\n    fn get_original(self) -> fn[Env](T) -> P;\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message,\n    hash::{hash_args_array, ArgsHasher, compute_unencrypted_log_hash},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    note::note_interface::NoteInterface,\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{\n    emit_encrypted_note_log, emit_encrypted_event_log,\n    emit_contract_class_unencrypted_log_private_internal, emit_unencrypted_log_private_internal\n},\n    logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field,\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, grumpkin_point::GrumpkinPoint, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::{is_empty, Empty},\n    utils::arrays::find_index\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n    // --> might be a better approach to force devs to make a public function call that emits the log if needed then\n    // it would be less easy to accidentally leak information.\n    // If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\n    pub fn emit_unencrypted_log<T, N, M>(&mut self, log: T) where T: ToBytesForUnencryptedLog<N, M> {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_slice = log.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n        // call oracle\n        let _void = emit_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    pub fn emit_contract_class_unencrypted_log<N>(&mut self, log: [Field; N]) {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n    }\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, encrypted_log: [u8; M]) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, encrypted_log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, encrypted_log: [u8; M]) {\n        let counter = self.next_counter();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, encrypted_log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    */\n    pub fn emit_unencrypted_log_with_selector<T, N>(\n        &mut self,\n        event_selector: Field,\n        log: T\n    ) where T: Serialize<N> {\n        emit_unencrypted_log(event_selector, Serialize::serialize(log).as_slice());\n    }\n    // For compatibility with the selector-less API. We'll probably rename the above one.\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        self.emit_unencrypted_log_with_selector(/*event_selector=*/ 5, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(event_selector: Field, message: [Field]) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(event_selector: Field, message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}