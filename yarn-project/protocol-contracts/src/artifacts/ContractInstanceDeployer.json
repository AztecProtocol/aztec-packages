{"transpiled":true,"noir_version":"0.30.0+48d9df4ff227c08a6e66f21c0286bc6349151671","name":"ContractInstanceDeployer","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b227aQBCG18RJTJ24YGMMgQQIyUXvDA2nO16mfe3eV+orVM2YnTJsp2hRx1tWYqWIsb2e/5t/D1jICdSuRe9/gY6v9eeN+rNhn63+LP+tzQRzlXVyBp5wNjzhvPKEMxTkDBhO+Ax1DOsO1tytOlyPv9tWqChTlELBBLoi19URwIMboUU6oBfHUuDrcnNDklNwpcFDfQ0/ASfW1yhYrIus+pBzWGiDnEOdK3IOd0bUibQpwvUuoj2yXN73CQA1NHUu5I5JTK8NiXVhTTVey9f4VsuYlLtVjGNyrXPfkmP0Cj0U/OaYUe1A/zWJptJjhPGA9MV+6EeDjDG0e7Wf180j94XGfQnpc8PUPxau/9bgMecsjEFLx204xj2BsH0g9W1l2ErIG8vnndExCHVu5I9JTYm43/M15L9Th838VhqTOCE89+I85ayeOndj95Gwy+RdvIFXLcOrO8OrhPShDK0a/AuILubG4xajLefFcg3abQsv2gxP27EXbUZb0IsNaKcWXqQMT+rYi5TRlvNi9Rm0MwsvMoYnc+xFxmjLeTGvni06Fl50GJ6OYy86jLbgGqnmRW7hRc7w5I69yBltQS++gnbXwosuw9N17EWX0Rb04gtoFxZeFAxP4diLgtEW3Dur54uehRc9hqfn2Iseoy3oxRy0+xZe9BmevmMv+oy24BqptB8svHhgeB4ce4F6pzJ3PGQuPGTOzoA5MmIZ7WW1fw4svBgwPAPHXtDfck5hzs+AOTJiGe3lArSHFl4MGZ6hYy9Q71Tm1EPmzEPmrofMuYfMhYfM5zCfIyOW0V5Ve+ijhRePDM+jYy9Q71Tm1EPmgYfM2RkwR0Yso72qfpt7svDiieF5cuwF6p3K3POQuX0GzJERy2ivlqA9svBixPCMHHuBeqcy9z1kLjxkHnjInHnI3PWQOfeQ+bIG3TCnZ8AM773gOzA/auWZb2KDBz1TBqMyGGMSJ4QR+26V3PsqiVE7ak3E/diNjzlf8HhSq/Z8DXmn8jVVz/IvOhe+wzdlanrVcSDs5wvJGxAdPB+S+Dvpi/3QD1y3yA7vXD3r+PXIfSPjvoT0eWbqHwvXPzV4pgYzjMk3wlHH3LKZ1y21X8ufCE8N++AbfScXm82+Q/cYQZ5ZTXWW9B2+n0p2TU8Mr5qGVwnpQ/fo/7VvXpgvzH9jps8TTXKO8uC5hlEL/f+GCcnxC57ToyHuNQAA","debug_symbols":"ndpBattQGIXRvWhsiu9vSe/JWymlOIlTDMYOsVMoJnuv3dIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhu3X23A8P++uh/PpfroN6y/V/7y9vO1OjxeX6+79Omw3rVbD/vTyeGqfq+H1cNwP2+r989vqMVpgtFnLKDIqGW1kNMpoktEsoyYjKWIjRYxSxChFjFLEKEWMUsQoRYxSxChFjFLEKEVMUsQkRUxSxCRFTFLEJEVMUsQkRUxSxCRFzFLELEXMUsQsRcxSxCxFzFLELEXMUsQsRTQpokkRTYpoUkSTIpoU0aSIJkU0KaJJEV2K6FJElyK6FNGliC5FdCmiSxFdiuhSxCJFLFLEIkUsUsQiRSxSxCJFLFLEIkUsUkTWa1qFVkWrDa1GWk20mmnVaNVpRW2E2gi1EWoj1EaojVAboTZCbYTaCLVR1EZRG0VtFLVR1EZRG0VtFLVBoBkSzRBphkwzhJoh1QyxZsg1Q7AZks0QbYZsM4SbId0M8WbIN0PAGRLOEHGGjDOEnCHlDDFnyDlD0BmSzhB1hqwzhJ0h7QxxZ8g7Q+AZEs8QeYbMM4SeIfUMsWfIPUPwGZLPEH2G7DOEnyH9DPFnyD9DABoS0BCBhgw0hKAhBQ0xaMhBQxAaktAQhYYsNIShIQ0NcWjIQ0MgGhLREImGTDSEoiEVDbFoyEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFyy56kosWuWiRixa5aJGLFrlokYvWf7vo/fRz937YPR33j7u9j48fp+d/V33vx+uvt79f7v/+Bg=="},{"name":"deploy","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"initialization_hash","type":{"kind":"field"},"visibility":"private"},{"name":"public_keys_hash","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::public_keys_hash::PublicKeysHash"},"visibility":"private"},{"name":"universal_deploy","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3hjtxEGoXhe+nfEeoqf1V25VZWq9UAYTVSNEFkWGkV5d7pgWlPB76TFu5DgsX7a5XFPbEfecbvAYI/HL5/8+3P//3P/cMP794fXv/rw+Htu+/uHu/fPZx+9eFQ+q//3/sf7x6efvn+8e6nx8Pr46vDm4fvT//78dXhh/u3bw6v67J8fPWH4+rcpudD6zy39ehSenJ01DI/Hx11iStHj1bL89GjLS9fu07j479fHcq81xNfvuCJT8c4n/jUbz3xccuJxzT19VTmuh49ytPXrse/8GuX7Gsv/fyREe3K1y91OjOWk+jF0TU5us/t+eClXx47/XnyWvd76tPNp14uTr1cO/XS4vyNUeYoV46+dvKRnfyYzzdkOdZ+7ewjzpdaWrs8+5KdT49xPp/5WD85nz8ePcX5x9H09HuvXzn71ijz+QtHGe3zB59+tq0/XD69AbILPE5t5Vg+OfhJsCF4o2BH8EbBNBFKeflBUUa9Qtgjzr9Dj4vTGSU999qW9eTrMv/+SbT83U4ofaSXqKtqK+OTEzp9aEqf1aXVsX5ovnYVp2dRm1+eS3O/7Tqm8vc7peo4pdM3+csjsE6fP6V+nM43Uj+2l2/KUufsG3gpsX4HT+PK0WMp6zdaeTmPmj6Kp7H+2Dml2eXBTzATMDlMAJPDNGBymA5MDjMDk8MswOQwA5gUJo7A5DAFmByG8hUwlK+ACWByGMpXwFC+AobyFTCUr4ChfHOYRvkKGMpXwFC+AobyFTABTA5D+QoYylfAUL4ChvIVMJRvDtMpXwFD+QoYylfAUL4CJoDJYShfAUP5ChjKV8BQvgKG8s1hZspXwFC+AobyFTCUr4AJYHIYylfAUL4ChvIVMJSvgKF8c5iF8hUwlK+AoXwFDOUrYAKYHIbyFTCUr4ChfAUM5StgKN8cZlC+AobyFTCUr4ChfAVMAJPDUL4ChvIVMJSvgKF8BQzlm8OUI+mrZGhfJUP8KhnqV8kEMkKG/lUyBLCSoYCVDAmsZGhgIVNoYCVDAysZGljJ0MBKJpARMjSwkqGBlQwNrGRoYCVDAwuZSgMrGRpYydDASoYGVjKBjJChgZUMDaxkaGAlQwMrGRpYyEw0sJKhgZUMDaxkaGAlE8gIGRpYydDASoYGVjI0sJKhgYUML3uTMjSwkqGBlQwNrGQCGSFDAysZGljJ0MBKhgZWMjSwkOG1b1KGBlYyNLCSoYGVTCAjZGhgJUMDKxkaWMnQwEqGBhYyvABOytDASoYGVjI0sJIJZIQMDaxkaGAlQwMrGRpYydDAQoZXwUkZGljJ0MBKhgZWMoGMkKGBlQwNrGRoYCVDAysZGljI8FI4KUMDKxkaWMnQwEomkBEyNLCSoYGVDA2sZGhgJUMDCxleDydlaGAlQwMrGRpYyQQyQoYGVjI0sJKhgZUMDaxkaOBcpvKeOClDAysZGljJ0MBKJpARMjSwkqGBlQwNrGRoYCVDAwsZ3hMnZWhgJUMDKxkaWMkEMkKGBlYyNLCSoYGVDA2sZGhgIcN74qQMDaxkaGAlQwMrmUBGyNDASoYGVjI0sJKhgZUMDSxkeE+clKGBlQwNrGRoYCUTyAgZGljJ0MBKhgZWMjSwkqGBhQzviZMyNLCSoYGVDA2sZAIZIUMDKxkaWMnQwEqGBlYyNLCQ4T1xUoYGVjI0sJKhgZVMICNkaGAlQwMrGRpYydDASoYGFjK8J07K0MBKhgZWMjSwkglkhAwNrGRoYCVDAysZGljJ0MBChvfESRkaWMnQwEqGBlYygYyQoYGVDA2sZGhgJUMDKxkaWMjwnjgpQwMrGRpYydDASiaQETI0sJKhgZUMDaxkaGAlQwMLGd4TJ2VoYCVDAysZGljJBDJChgZWMjSwkqGBlQwNrGRo4Fxm4j1xUoYGVjI0sJKhgZVMICNkaGAlQwMrGRpYydDASoYGFjK8J07K0MBKhgZWMjSwkglkhAwNrGRoYCVDAysZGljJ0MBChvfESRkaWMnQwEqGBlYygYyQoYGVjKeBY1llammfl5nr+eA5Lq609B0rzigaFBcUDYoDxdsVTe+1+6crFhQNihVFg+KEokExUDQoNhQNimwXhyLbxaHIdnEosl0MisF2cSiyXRyKbBeHItvFoRgoGhTZLg5FtotDke3iUGS7OBTZLgbFxnZxKLJdHIpsF4ci28WhGCgaFNkuDkW2i0OR7eJQZLs4FNkuBsXOdnEosl0cimwXhyLbxaEYKBoU2S4ORbaLQ5Ht4lBkuzgU2S4GxZnt4lBkuzgU2S4ORbaLQzFQNCiyXRyKbBeHItvFoch2cSiyXQyKC9vFoch2cSiyXRyKbBeHYqBoUGS7OBTZLg5FtotDke3iUGS7GBQH28WhyHZxKLJdHIpsF4dioGhQZLs4FNkuDkW2i0OR7eJQZLvcrhhHtotDke3iUGS7OBTZLg7FQNGgyHZxKLJdHIpsF4ci28WhyHYxKBa2i0OR7eJQZLs4FNkuDsVA0aDIdnEosl0cimwXhyLbxaHIdjEoVraLQ5Ht4lBkuzgU2S4OxUDRoMh2cSiyXRyKbBeHItvFoch2MShObBeHItvFoch2cSiyXRyKgaJBke3iUGS7OBTZLg5FtotDke1iUAy2i0OR7eJQZLs4FNkuDsVA0aDIdnEosl0cimwXhyLbxaHIdjEoNraLQ5Ht4lBkuzgU2S4OxUDRoMh2cSiyXRyKbBeHItvFoch2MSh2totDke3iUGS7OBTZLg7FQNGgyHZxKLJdHIpsF4ci28WhyHYxKM5sF4ci28WhyHZxKLJdHIqBokGR7eJQZLs4FNkuDkW2i0OR7WJQXNguDkW2i0OR7eJQZLs4FANFgyLbxaHIdnEosl0cimwXhyLbxaA42C4ORbaLQ5Ht4lBkuzgUA0WDItvFoch2cSiyXRyKbBeHItvldsV2ZLs4FNkuDkW2i0OR7eJQDBQNimwXhyLbxaHIdnEosl0cimwXg2JhuzgU2S4ORbaLQ5Ht4lAMFA2KbBeHItvFoch2cSiyXRyKbBeDYmW7OBTZLg5FtotDke3iUAwUDYpsF4ci28WhyHZxKLJdHIpsF4PixHZxKLJdHIpsF4ci28WhGCgaFNkuDkW2i0OR7eJQZLs4FNkuBsVguzgU2S4ORbaLQ5Ht4lAMFA2KbBeHItvFoch2cSiyXRyKbBeDYmO7OBTZLg5FtotDke3iUAwUDYpsF4ci28WhyHZxKLJdHIpsF4NiZ7s4FNkuDkW2i0OR7eJQDBQNimwXhyLbxaHIdnEosl0cimwXg+LMdnEosl0cimwXhyLbxaEYKBoU2S4ORbaLQ5Ht4lBkuzgU2S4GxYXt4lBkuzgU2S4ORbaLQzFQNCiyXRyKbBeHItvFoch2cSiyXQyKg+3iUGS7OBTZLg5FtotDMVA0KLJdHIpsF4ci28WhyHZxKLJdblfsR7aLQ5Ht4lBkuzgU2S4OxUDRoMh2cSiyXRyKbBeHItvFoch2MSgWtotDke3iUGS7OBTZLg7FQNGgyHZxKLJdHIpsF4ci28WhyHYxKNYvv11GnZ8PHr1cUZza8XypU5vqF3QpuKQuFZfUZcIldQlcUpeGS+rScUldZlxSlwWX1GXgkrlM9G7uQu/mLvRu7kLv5i6BS+pC7+Yu9G7uQu/mLvRu7kLvpi5B7+Yu9G7uQu/mLvRu7hK4pC70bu5C7+Yu9G7uQu/mLvRu6tLo3dyF3s1d6N3chd7NXQKX1IXezV3o3dyF3s1d6N3chd5NXTq9m7vQu7kLvZu70Lu5S+CSutC7uQu9m7vQu7kLvZu7fPneLVOr69HztT/fdrrCeb3Y6eXPt9Vp/HoBX+ElsOYLKHu/gLr3C5j2fgGx9wtoe7+AvvcLmPd+AcveL2DvT+Jl70/iZe9P4mXvT+Jl70/ir/D6OvMF7P1JvOz9Sbzs/Um87P1JvOz9STz2/iQee38Sj70/icfen8Rf4WVM5gvY+5N47P1JPPb+JB57fxJ73nnT1r8RX6Ze6uUFnH6TOr7J//DavP5d9nn0i1Or50+VTZ+qmz41bfpUbPpU2/SpvulT86ZPLZs+NbZ8qm26N9qme6Ntujfapnujbbo32qZ7o226N9qme6Ntujfapnujb7o3+qZ7o2+6N/qme6Nvujfyf1VhbmP91Jx9qv/pT50eC9/k/+XsuhzP/3nLuoyLf+haTz/qT7/6391P93ffvn3z/vSZp7/488N3j/fvHp5/+fj/H3/7K6djfwE="}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"salt","type":{"kind":"field"}},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"public_keys_hash","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::public_keys_hash::PublicKeysHash"}},{"name":"universal_deploy","type":{"kind":"boolean"}}],"kind":"struct","path":"ContractInstanceDeployer::deploy_parameters"}}],"kind":"struct","path":"ContractInstanceDeployer::deploy_abi"}]}},"file_map":{"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: GrumpkinPoint,\n    _ivpk_m: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: GrumpkinPoint,\n    ivpk_m: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: GrumpkinPoint,\n    _ivpk_m: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: GrumpkinPoint,\n    ivpk_m: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _event_selector: Field, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, event_selector, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, event_selector: Field, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, event_selector, message, counter)\n}\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs_traits.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n// TODO: this is awful but since we can't have a fn that maps [Field; N] -> [u8; 480 + N * 32]\n// (where N is the note pre-image size and 480 + N * 32 is the encryption output size)\n// The fns for LensForEncryptedLog are never used, it's just to tell the compiler what the lens are\n\n// The to_bytes fn for ToBytesForUnencryptedLog is used to allow us to hash some generic T\n\n// I could have omitted N from the trait, but wanted to keep it strictly for field arrs\n// TODO(1139): Once we enc inside the circuit, we will no longer need the oracle to return\n// anything, so we can remove this trait\ntrait LensForEncryptedLog<N, M> {\n    // N = note preimage input in fields\n    // M = encryption output len in bytes (= 480 + N * 32)\n    fn output_fields(self: [Field; N]) -> [Field; N];\n    fn output_bytes(self: [Field; N]) -> [u8; M];\n}\n\nimpl LensForEncryptedLog<1, 512> for [Field; 1] {\n    fn output_fields(self) -> [Field; 1] {[self[0]; 1]}\n    fn output_bytes(self) -> [u8; 512] {[self[0] as u8; 512]}\n}\nimpl LensForEncryptedLog<2, 544> for [Field; 2] {\n    fn output_fields(self) -> [Field; 2] {[self[0]; 2]}\n    fn output_bytes(self) -> [u8; 544] {[self[0] as u8; 544]}\n}\nimpl LensForEncryptedLog<3, 576> for [Field; 3] {\n    fn output_fields(self) -> [Field; 3] {[self[0]; 3]}\n    fn output_bytes(self) -> [u8; 576] {[self[0] as u8; 576]}\n}\nimpl LensForEncryptedLog<4, 608> for [Field; 4] {\n    fn output_fields(self) -> [Field; 4] {[self[0]; 4]}\n    fn output_bytes(self) -> [u8; 608] {[self[0] as u8; 608]}\n}\nimpl LensForEncryptedLog<5, 640> for [Field; 5] {\n    fn output_fields(self) -> [Field; 5] {[self[0]; 5]}\n    fn output_bytes(self) -> [u8; 640] {[self[0] as u8; 640]}\n}\nimpl LensForEncryptedLog<6, 672> for [Field; 6] {\n    fn output_fields(self) -> [Field; 6] {[self[0]; 6]}\n    fn output_bytes(self) -> [u8; 672] {[self[0] as u8; 672]}\n}\n\ntrait LensForEncryptedEvent<N, M> {\n    // N = event preimage input in bytes\n    // M = encryption output len in bytes (= 480 + M)\n    fn output(self: [u8; N]) -> [u8; M];\n}\n\nimpl LensForEncryptedEvent<96, 512> for [u8; 96] {\n    fn output(self) -> [u8; 512] {[self[0] as u8; 512]}\n}\nimpl LensForEncryptedEvent<128, 544> for [u8; 128] {\n    fn output(self) -> [u8; 544] {[self[0] as u8; 544]}\n}\nimpl LensForEncryptedEvent<160, 576> for [u8; 160] {\n    fn output(self) -> [u8; 576] {[self[0] as u8; 576]}\n}\nimpl LensForEncryptedEvent<192, 608> for [u8; 192] {\n    fn output(self) -> [u8; 608] {[self[0] as u8; 608]}\n}\nimpl LensForEncryptedEvent<224, 640> for [u8; 224] {\n    fn output(self) -> [u8; 640] {[self[0] as u8; 640]}\n}\nimpl LensForEncryptedEvent<256, 672> for [u8; 256] {\n    fn output(self) -> [u8; 672] {[self[0] as u8; 672]}\n}\n\n// This trait defines the length of the inputs in bytes to\n// the unencrypted log hash fn, where the log can be any type T\n// as long as the ACVM can convert to fields.\ntrait ToBytesForUnencryptedLog<N, M> {\n    // N = preimage input in bytes (32 * num fields or chars)\n    // M = full log input in bytes ( = N + 40 = N + 32 for addr, + 4 for selector, + 4 for len)\n    fn to_be_bytes_arr(self) -> [u8; N];\n    fn output_bytes(self) -> [u8; M];\n}\n\nimpl ToBytesForUnencryptedLog<32, 72> for Field {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        self.to_be_bytes(32).as_array()\n    }\n    fn output_bytes(self) -> [u8; 72] {[self as u8; 72]}\n}\n\nimpl ToBytesForUnencryptedLog<32, 72> for AztecAddress {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        self.to_field().to_be_bytes(32).as_array()\n    }\n    fn output_bytes(self) -> [u8; 72] {[self.to_field() as u8; 72]}\n}\n\nfn arr_to_be_bytes_arr<N, L>(fields: [Field; L]) -> [u8; N] {\n    let mut bytes: [u8] = &[];\n    for i in 0..L {\n        // Note that bytes.append() results in bound error\n        let to_add = fields[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes = bytes.push_back(to_add[j]);\n        }\n    }\n    bytes.as_array()\n}\n\n// each character of a string is converted into a byte\n// then an ACVM field via the oracle => we recreate here\nfn str_to_be_bytes_arr<N, L>(string: str<L>) -> [u8; N] {\n    let chars_bytes = string.as_bytes();\n    let mut bytes: [u8] = &[];\n    for i in 0..L {\n        let to_add = (chars_bytes[i] as Field).to_be_bytes(32);\n        for j in 0..32 {\n            bytes = bytes.push_back(to_add[j]);\n        }\n    }\n    bytes.as_array()\n}\n\nimpl ToBytesForUnencryptedLog<32, 72> for [Field; 1] {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 72] {\n        [self[0] as u8; 72]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<64, 104> for [Field; 2] {\n    fn to_be_bytes_arr(self) -> [u8; 64] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 104] {\n        [self[0] as u8; 104]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<96, 136> for [Field; 3] {\n    fn to_be_bytes_arr(self) -> [u8; 96] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 136] {\n        [self[0] as u8; 136]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<128, 168> for [Field; 4] {\n    fn to_be_bytes_arr(self) -> [u8; 128] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 168] {\n        [self[0] as u8; 168]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<160, 200> for [Field; 5] {\n    fn to_be_bytes_arr(self) -> [u8; 160] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 200] {\n        [self[0] as u8; 200]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<192, 232> for [Field; 6] {\n    fn to_be_bytes_arr(self) -> [u8; 192] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 232] {\n        [self[0] as u8; 232]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<224, 264> for [Field; 7] {\n    fn to_be_bytes_arr(self) -> [u8; 224] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 264] {\n        [self[0] as u8; 264]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<256, 296> for [Field; 8] {\n    fn to_be_bytes_arr(self) -> [u8; 256] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 296] {\n        [self[0] as u8; 296]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<288, 328> for [Field; 9] {\n    fn to_be_bytes_arr(self) -> [u8; 288] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 328] {\n        [self[0] as u8; 328]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<320, 360> for [Field; 10] {\n    fn to_be_bytes_arr(self) -> [u8; 320] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 360] {\n        [self[0] as u8; 360]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<352, 392> for [Field; 11] {\n    fn to_be_bytes_arr(self) -> [u8; 352] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 392] {\n        [self[0] as u8; 392]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<384, 424> for [Field; 12] {\n    fn to_be_bytes_arr(self) -> [u8; 384] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 424] {\n        [self[0] as u8; 424]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<416, 456> for [Field; 13] {\n    fn to_be_bytes_arr(self) -> [u8; 416] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 456] {\n        [self[0] as u8; 456]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<448, 488> for [Field; 14] {\n    fn to_be_bytes_arr(self) -> [u8; 448] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 488] {\n        [self[0] as u8; 488]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<480, 520> for [Field; 15] {\n    fn to_be_bytes_arr(self) -> [u8; 480] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 520] {\n        [self[0] as u8; 520]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<512, 552> for [Field; 16] {\n    fn to_be_bytes_arr(self) -> [u8; 512] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 552] {\n        [self[0] as u8; 552]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<544, 584> for [Field; 17] {\n    fn to_be_bytes_arr(self) -> [u8; 544] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 584] {\n        [self[0] as u8; 584]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<576, 616> for [Field; 18] {\n    fn to_be_bytes_arr(self) -> [u8; 576] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 616] {\n        [self[0] as u8; 616]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<608, 648> for [Field; 19] {\n    fn to_be_bytes_arr(self) -> [u8; 608] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 648] {\n        [self[0] as u8; 648]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<640, 680> for [Field; 20] {\n    fn to_be_bytes_arr(self) -> [u8; 640] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 680] {\n        [self[0] as u8; 680]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<672, 712> for [Field; 21] {\n    fn to_be_bytes_arr(self) -> [u8; 672] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 712] {\n        [self[0] as u8; 712]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<704, 744> for [Field; 22] {\n    fn to_be_bytes_arr(self) -> [u8; 704] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 744] {\n        [self[0] as u8; 744]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<736, 776> for [Field; 23] {\n    fn to_be_bytes_arr(self) -> [u8; 736] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 776] {\n        [self[0] as u8; 776]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<768, 808> for [Field; 24] {\n    fn to_be_bytes_arr(self) -> [u8; 768] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 808] {\n        [self[0] as u8; 808]\n    }\n}\n\nimpl<N,M,L> ToBytesForUnencryptedLog<N, M> for str<L> where [Field; L]: ToBytesForUnencryptedLog<N,M> {\n    fn to_be_bytes_arr(self) -> [u8; N] {\n        str_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; M] {\n        [0; M]\n    }\n}\n"},"22":{"path":"std/field.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"232":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    contract_class_id::ContractClassId, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{Hash, is_empty},\n    utils::{uint256::U256, field::field_from_bytes_32_trunc}\n};\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u32) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, first_nullifier: Field, index: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, index);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"28":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"281":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"282":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"283":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"288":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"mod events;\n\ncontract ContractInstanceDeployer {\n    use dep::aztec::protocol_types::{\n        address::{AztecAddress, EthAddress, PublicKeysHash, PartialAddress},\n        contract_class_id::ContractClassId, constants::DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\n        traits::Serialize\n    };\n\n    use crate::events::{instance_deployed::ContractInstanceDeployed};\n\n    #[aztec(private)]\n    fn deploy(\n        salt: Field,\n        contract_class_id: ContractClassId,\n        initialization_hash: Field,\n        public_keys_hash: PublicKeysHash,\n        universal_deploy: bool\n    ) {\n        // TODO(@spalladino): assert nullifier_exists silo(contract_class_id, ContractClassRegisterer)\n\n        let deployer = if universal_deploy {\n            AztecAddress::zero()\n        } else {\n            context.msg_sender()\n        };\n\n        let partial_address = PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\n\n        let address = AztecAddress::compute(public_keys_hash, partial_address);\n\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\n        context.push_new_nullifier(address.to_field(), 0);\n\n        // Broadcast the event\n        let event = ContractInstanceDeployed { contract_class_id, address, public_keys_hash, initialization_hash, salt, deployer, version: 1 };\n        let event_payload = event.serialize();\n        dep::aztec::oracle::debug_log::debug_log_format(\"ContractInstanceDeployed: {}\", event_payload);\n        context.emit_unencrypted_log(event_payload);\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message,\n    hash::{hash_args_array, ArgsHasher, compute_unencrypted_log_hash},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    note::note_interface::NoteInterface,\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{\n    emit_encrypted_note_log, emit_encrypted_event_log,\n    emit_contract_class_unencrypted_log_private_internal, emit_unencrypted_log_private_internal\n},\n    logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field,\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, grumpkin_point::GrumpkinPoint, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::{is_empty, Empty},\n    utils::arrays::find_index\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n    // --> might be a better approach to force devs to make a public function call that emits the log if needed then\n    // it would be less easy to accidentally leak information.\n    // If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\n    pub fn emit_unencrypted_log<T, N, M>(&mut self, log: T) where T: ToBytesForUnencryptedLog<N, M> {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_slice = log.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n        // call oracle\n        let _void = emit_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    pub fn emit_contract_class_unencrypted_log<N>(&mut self, log: [Field; N]) {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n    }\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, encrypted_log: [u8; M]) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, encrypted_log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, encrypted_log: [u8; M]) {\n        let counter = self.next_counter();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, encrypted_log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}