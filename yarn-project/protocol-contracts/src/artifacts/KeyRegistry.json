{"transpiled":true,"noir_version":"0.30.0+48d9df4ff227c08a6e66f21c0286bc6349151671","name":"KeyRegistry","functions":[{"name":"register","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"partial_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::partial_address::PartialAddress"},"visibility":"private"},{"name":"keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"ivpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"ovpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"tpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}}],"kind":"struct","path":"aztec::keys::public_keys::PublicKeys"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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iNzpFJE7nSJyp1NE7nSKyJ1OEbnTKSJ3OkXkTqeI3OkUkTudInKnU0TudIrInU4RudMpInc6ReROp4jc6RSRO50icqdTRO50isidThG50ykidzpF5E6niNzpFJE7nSJyp1NE7nSKyJ1OEbnTKSJ3OkXkTqeI3OkUkTudInKnU0TudIrInU4RudMpInc6ReROp4jc6RSRO50icqdTRO50isidThG50ykidzpF5E6niNzpFJE7nSJyp1NE7nSKyJ1OEbnTKSJ3OkXkTqeI3OkUkTudInKnU0TudIrInU4RudMpInc6ReROp4jc6RSRO50icqdTRO50isidThG50ykidzpF5E6niNzpFJE7nSJyp1NE7nSKyJ1O8aDTKfn2gymWwWVqKF8vrqUMlu4aFVfvr/U+9H5vbKuot/v7/upQ2/Ir9PIPep1glu+wl++xlx+wlx+xl5+wl5+xl49tWxXattIGbVtpg7attEHbVtqgbSttgr18Bdd917CStoS8+Iy8+IK8+Aq8eLchL94hL94jLz4gL16QF4/ssA7ZYR2ywzpkh3XIDuuRHdYjO6xHdliP7LAe2WE9ssN6ZIf1yA7rkR3WIztsQHbYgOywAdlhA7LDBmSHDcgOG5AdNiA7bEB22IDssILssILssILssILssILssILssILssILssILssILssBHZYSOyw0Zkh43IDhuRHTYiO2xEdtiI7LAR2WEjssMmZIdNyA6bkB02ITtsQnbYhOywCdlhE7LDJmSHTcgOm5EdNiM7bEZ22IzssBnZYTOyw2Zkh83IDpuRHTYjO2xBdtiC7LAF2WELssMWZIctyA5bkB22IDtsQXbYguywFdlhK7LDVmSHrcgOW5EdtiI7bEV22IrssBXZYSuww+YN2GHzBuyweQN22LwBO2zegB02I3c6ZeROp4zc6ZSRO50ycqdTRu50ysidThm50ykjdzpl5E6njNzplJE7nTJyp1NG7nTKyJ1OGbnTKSN3OmXkTqeM3OmUkTudMnKnU0budMrInU4ZudMpI3c6ZeROp4zc6ZSRO50ycqdTRu50ysidThm50ykjdzpl5E6njNzplJE7nTJyp1NG7nTKyJ1OGbnTKSN3OmXkTqeM3OmUkTudMnKnU0budMrInU4ZudMpI3c6ZeROp4zc6ZSRO50ycqdTRu50ysidThm50ykjdzpl5E6n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yA4bkR02IjtsRHbYiOywEdlhI7LDJmSHTcgOm5AdNiE7bEJ22ITssAnZYROywyZkh03IDpuRHTYjO2xGdtiM7LAaLU/vWzyyw2Zkh83IDpuRHTYjO2xBdtiC7LAF2WGRO508cqeTR+508sidTh6508kjdzp55E4nj9zp5JE7nTxyp5NH7nTyyJ1OHrnTySN3OnnkTieP3OnkkTudAnKnU0DudArInU4BudMpbMAOG5A7nQJyp1NA7nQKyJ1OAbnTKSB3OgXkTqeA3OkUkDudAnKnU0DudArInU4BudMpIHc6BeROp4Dc6RSQO50CcqdTQO50CsidTgG50ykgdzoF5E6ngNzpFJA7nQJyp1NA7nQKyJ1OAbnTKSB3OgXkTqeA3OkUkDudAnKnU0DudArInU4BudMpIHc6BeROp4Dc6RSQO50CcqdTQO50CsidTgG50ykgdzoF5E6ngNzpFJA7nQJyp1NA7nQKyJ1OAbnTKSB3OgXkTqeA3OkUkDudAnKnU0DudArInU4BudMpIHc6BeROp4Dc6RSQO50CcqdTQO50CsidTgG50ykgdzoF5E6ngNzpFJA7nQJyp1NA7nQKyJ1OAbnTKSB3OgXkTqeA3OkUkDudAnKnU0DudArInU4BudMpIHc6BeROp4Dc6RSQO50CcqdTQO50CsidTgG50ykgdzoF5E4nQe50EuROJ0HudBLkTifZgB1WkDudBLnTSZA7nQS500mQO50EudNJkDudBLnTSZA7nQS500mQO50EudNJkDudBLnTSZA7nQS500mQO50EudNJkDudBLnTSZA7nQS500mQO50EudNJkDudBLnTSZA7nQS500mQO50EudNJkDudBLnTSZA7nQS500mQO50EudNJkDudBLnTSZA7nQS500mQO50EudNJkDudBLnTSZA7nQS500mQO50EudNJkDudBLnTSQ46ncqW9x8ssY4uU2rdX119+HaZn6++ZcF9UTd/z4NX+5jT/ruTS4NX19h+d40ltlf7UJvgZE1wtia4WBNcjQk+6LVaWLCzJthbExysCRZrgq0lrWQtaSVrSStZS1rJWtLKb0ha23YXXEaCt7L/6iDttSl1XhrKjkb8A0dfu0vewQRXvr125+LIpcvFk0uXSyCXLhchly6X+NlcXA2NS/w9l5LivoyS0qODpaY2mVKbTaktptRWS2rLh6dDZbUfnvmeUZu33axKdtJV++FJTlnth+czZbViSu1CWeqE2oWy1Am1C2WpnKSpzb6rdqEsdULtQllqrLYulKVOqF0pS43VrpSlxmpXylJjtbKQWvF3teGb2s6i5f5wmTy82gfX2KyUvLTZrJTTtNn8yaluv0x5zWXqKy4Tt+01l3GvuYx/zWXCay4jr7lMfM1l0msuk19zmfKay2i8C9w+sW+XyaOP9yWm/XdL2kbu4FP7/MpnP//oQHSbNcHOmmBvTXCwJlisCY7WBCdrgrM1wcWaYGtJy1tLWt5a0vLWkpa3lrT8G5KWpLtgGQl+z4OQ0Udy6XJJ5NLlksmly6WQS5dL/WwuT3wMU73sH1ZWHx8/rPS72rCZUutMqfWm1AZTasWU2g/PfE+p9fGuNnxT21mGL/tvlrDdJUpPYY67Y+Z6X7G/U/zwhAhC8cNzEwjFlVLW2yjKSuntfRRXSoVPUQy+NIohPVLc0awUIZXRrJQ3ldGIWTQpNjTZ9dCYTbKhPTgtoWw9NB++UfdONAtlzlD2B+OqbLE37clC2XCsNi6U4U6oXShrhVKa2se95Ae1C8WnE2oXSkSh5Kb28TOFB7UL7aacULuQOY/VpoXek2+/uakt0lW70HvyCbULvSdLDE1t7e6cp4Xek6Nvf9sY+39bWUlt+9vGlLpqF3pPPqF2oRkoet/U5m5Ozgu9J6et/W1TCF21C70nn1C70Hty2tqdnMR11S70npxy29bJ/fk2L7S/d0LtQjNQyi1dZNf9d6vxte2wtQajsIXRQ8WutMeEXXlQUEPnxam0x+BS3fLji/8uIGl8IfybANm+Cdgv415zGf+aywSNy+S9aCG4bVgx61373T5tnVsxaTwcHnz7h3f7RKerXeNZ6zOXSa+5TH7NZYrGZWq7YcK3hNi7YYpLrW7Db6O6DVfb53fuFlG+vfpLQoifJGFfVPrEReVPXJTGHXh/qDrIuEkmu/bBZ45u9AanfChB0niaCEqwxoM/WIKdNcHemuBgTbBYExytCU7WBGdrgq0Fj2gteERrwSNaCx7RWvCI1oJHtBY84uuDR2pb7ZLTSEKQnc5tu+xvv92XL9I23IqU4d5WalunLoXtgY1rbPKHs2kKwsPmXJdNag+7pPrwa/39PiiGtFY7WtNmSKszpNUb0hoMaRVDWqMhrZ+eszS1GspNyVBuSoZyUzaUm7Kh3JQN5aZsKDdpPDsKo9VQbsqGclM2lJuyodx0dLB3ejj3xQ20PntcV9v4FYn5by/eVD4623tdwc6aYG9NcLAmWKwJjtYEJ2uCszXBxZpga0mrWkta1VrSqtaSVrWWtOobktYzpzm/6XiFVBO5dLlkculyKeTS5VLJpcMlbxu5dLm4z+byRFVDSXFfRknp0dlTU+tNqQ2m1IoptdGU2g9Ph8pqPzzzPaM2tyKVkp101X54klNW++H5TFet+/DUpax2oSx1Qu1CWeqE2oWy1Am1spDadopCydl31S6UpU6oXShLnVC7UpYaq10pS43VrpSlhmr9SllqrHalLCX+rnb0VWUvad+y8/Lw6vtXlbNfKXlps1kpp2mzkT+XzX6Z+JrLpNdcJr/mMuU1l6kvuUzYXnMZ95rL+NdcJrzmMq95FwiveRcIGu8CT1aNp/3bApK2kTv41D6t87e3rMGrxw+Q5JCtCS7WBFdjgmWzJthZE+ytCQ7WBIs1wdGaYGvBQ6wFD7EWPKK14BGtBY9oLXjENwSPZ47eetdzrlHIpcslkkuXSyKXLpdMLl0u5bO5PHPkoZd25KGPveOjc6yW1KbNlFpnSq03pfbD06GyWllIrY93teGb2s4yfGntV2G7N2tJT+HNur5em+t9xf5O8cMTIgjFD89NIBRXSlnvo7hSensbxbxSKnyKYmgHBUsI6ZHijmalCKmMZqW8qYxmpXD6HJrUToUK2fXQiF000tA8nKv+gObDN+reiWahzBnKvugqW+xNe3mhbHhC7UIZbqy2LJS1QilN7eNe8oPaheLTCbULJaJQclP7+JnCg9qFdlNOqF3InE+oXeg9WVrPfZUiPbV1offkE2oXek+WGJra2t05rwu9J0ff/rYx9v+2Cw2e0be/bfx27sVd7ULvySfULjQDRe+b2tzLyWVb6D05be1vm0Loql3oPfmE2oXek9PW7uQkrqt2offklNu2Tt76/27FlNqFZqCUW7rIrvvvVuOb3WFrlU1hC6OHil1pjwm78qCghs6LU2mPwaW65ccX7wKqsgDZvgn4uozGd8bPXMa95jJe4zJ5b5YIbhs2CPt2ipn3aevdihoPhwff/uHdPtHpatd41vrMZeJrLpNec5mscZnabpjwLSH2bpjiUusX8duoX8TV9vmdq+n7q78kJPkkCfui4icuKn3iojTuwOdOacyuffCZoxu9wSmfxVE0nibCElyNCdZ4RgdLsLMm2FsTHKwJFmuCozXByZpga8EjWwsexVrwKNaCR7EWPIq14KFxKDaW4NcHj9S22iWnkYQgO52Q7o8t9LtzpW24FSnDva3Utk5dCtsDG9fYpA9n0xSEh825LpvUHnZJ9eHX+vt9kA1pLYa0Vjta62ZIqzOk1RvSGgxpFUNaPz1naWo1lJuqodxUDeWmaic31c1ObqqbndxUNzu5qW52clPdxJBWO7mpbnZyU93s5KZ6cNp1De3wrvqwOatzPlnb+BWJ+W+v3VSuBwderyv44MzrhQU7a4K9NcHBmmCxJjhaE5ysCc7WBFtLWs5a0vLWkpa3lrS8taTl35C0njm++k3HK1QfyaXLJZFLl0smly6XQi5dLpVcelzC9tlcnqhqKCnuyygpPTp7amqdKbXelNoPT1bKasWU2g9Ph8pqPzzzPaM2tyKVkp101X54klNW++H5TFnth6cuXbWyUJY6oXahLHVC7UJZ6oTahbJUbqcolJx9V62YUrtQljqhdqUsNVa7UpYaq10pS43VrpSlhmrjSllK/F3t6KvKXlKTKA+vvn9VucaVkpc2m5VymjabPznV7ZeR11wmvuYy6TWXya+5THnNZepLLpO211zGveYy/jWXec27QHrNu0DSeBd4smo87d8WkLSN3MGn9mmdz17hAZKUrAnO1gQXa4KrMcF5sybYWRPsrQkO1gSLNcHWgke2FjyyteCRrQWPYi14FGvBo7wheDxz9Na7nnMtgVy6XIRculwiuXS5JHLpcsmfzeWZIw+9tCMPfewdH11LMaW2WlJbN1NqnSm1H54OldV+eOZ7Sq2Pd7Xhm9rOMnxp7Vdhq+3V0lOY4+6Yud5X7O8UhRQVKH54bgKhuFLKeh/FldLb+yiulAqfohjaQcESQnqk+L/RyLatFCGV0ayUN5XRrBROn0OT2qlQIbseGrNJNrQnxSU8nKv+gObDN+reiWahzBnK/iRglS3+nPZuahfKhifULpThTqhdKGuFUprax73ku1q3UHw6oXahRBRKbmofP1N4UCum1C5kzifULvSeLK3nvkqRrtqF3pPHav1C78kSQ1NbfVftQu/J0be/bYz9v+1Cg2f07W8bv517cVe70HvyCbULzUDR+6Y2d3OyX+g9OW3tb5tC6KkNC70nn1C70Hty2tqdnMR11S70npxy29bJ/fk2LLS/d0KtrKS2pYvsuv9uNb7ZHbZW2RS2MHqo2JX2mLArDwpq6Lw4lfYYXKpbfnzxLqAoC5Dtm4D9MvUll9H4zviZyziNy+S9WSK4bdgg7NspZt6nrXcrajwcHnz7h3f7RKerXeNZ6zOXkddcJr7mMknjMrXdMOFbQuzdMMWl1i/it1G/iKvt8ztX0/dXf0mo4ZMk7IuST1xU/MRFadyBz53SmF374DNHN3qD0z2L4yY4WxNcrAmutgQ7jSdvsAQ7a4K9NcHBmmCxJjhaE2wseLjNWPBwm7Xg4awFD2cteDhrwcNZCx4azyY9KTi1rXbJaSQhyE4npPtjC/3uXGkbbkXKcG8rta1Tl8L2wMY1NvHD2TQF4WFzrssmtYddUn34tf5+HyRDWrMhrcWQ1mpHq98MaXWGtHpDWoMhrWJIq6Hc5A3lJm8oN3lDuckbyk3BUG4KhnJTMJSbgqHcpPHcKIxWQ7kpGMpNR6dd17a1uUkdaH32fLK28SsS899evKl8dOD1uoKrMcFHx16vK9hZE+ytCQ7WBIs1wdGa4GRNsLWkJdaSllhLWtFa0orWklZ8Q9J65vjq9xyvcOMi5NLlEsmlyyWRS5dLJpcul0IuXS71s7k8UdVQUtyXUVJ6dPb9G7AubabUOlNqPzxZKasNptSKKbUfnvmeUZtbkUrJTrpqPzzJKav98HymrPbDU5ey2oWy1FhtXihLnVC7UJY6oXahLJXbKQolZ99Vu1CWOqFWTKldKUuN1a6UpcZqV8pSY7UrZamx2pWylPi72tFXlb2k9lSkPLz64avKZaXkpc1mpZymzeZPTnX7ZcJrLiOvuUx8zWXSay6TX3OZ8prL1Jdcpm6vuYx7zWVe8y5QX/MuUDXeBZ6sGk/7twUkbSN38Kl9WuezV3iApEZrgpM1wdma4GJNcLUl2G+bNcHOmmBvTXCwJthY8PCbseDhN2PBw2/GgoffrAUPZy14uDcEj2eO3nrTc67eeXLpcgnk0uUi5NLlEsmlyyV9Npdnjjz00o489LF3fLR32ZTaYkpttaTWb6bUfng6VFb74ZnvKbU+3tWGb2o7y/CltV+F7S5Regpz3B0z1/uK/Z3ihydEEIofnptAKK6Ust5HcaX09j6KK6XCpyiGdlCwhJAeKe5oVoqQumjCSnlTGc1K4fQ5NKmdChWy66Exm2RDe1JcwsO56g9ohGiO0CyUOUPZnwSsssXetBcWyoYn1C6U4U6oXShrhVKa2se95Ae1C8WnsVpZKBGFkpvax88UHtQutJtyQu1C5nxC7ULvydJ67qsU6apd6D35hNqF3pMlhqa2dnfO40LvydG3v22M3b9tXGjwjL79beO3cy/uahd6Tz6hdqEZKHrf1OZuTo4LvSenrf1tUwhdtQu9J4/VpoXek9PW7uQkrqt2offklNu2Tu7Pt2mh/b0TaheagVJu6SK77r9bjW92h61VNoUtjB4qdqU9JuzKg4IaOi9OpT0Gl+qWH1+8C8jKAmT7JmC/THnNZepLLqPxnfGw5b1ZIrht2CDs2ylmt8/Jt86tGDQeDg++/cO7faLT0x40nrU+c5nwmsvIay4TNS5T2w0TviXE3g1TXGr9In4b9Yu42j6/czV9f/WXBO8/ScK+qPCJi5JPXJTGHfjcKY3ZtQ8+c3SjNzjlsziCxtNEWIKzNcHFmuBqTLDG8zRYgp01wd6a4GBNsFgTbC14BGvBI1gLHsFa8BBrwUOsBQ+xFjzk9cEjta12yWkkIUhbSLo/ttDvzpW24VakDPe2Uts6dSlsD2xcYyMfzqYpCA+bc102qT3skurDr/X3+yAa0poMac2GtBZDWqsdrXEzpNUZ0uoNaf30nKWpVQxpNZSboqHcFA3lpmgoN0VDuSkZyk3JUG5KhnJTMpSbNE68htFqKDf1T7sOWzsUPLiHx4h1zidrG78iMf/txZvK/QOvVxZcrAmuxgT3T75eWbCzJthbExysCRZrgqM1wdaSVraWtLK1pJWtJa1iLWmVNyStZ46vftPxCqEEculyEXLpconk0uWSyKXLJZNLl0v5bC5PVDWU1BZdUnp09vYN2FItqa2bKbUfnqyU1XpTaj88HSqrlXXU5lakUrKTrtoPT3LKaj88nymr/fDUpax2oSx1Qu1CWWqo9nZlU2oXylK5naJQcvZdtQtlqRNqF8pSJ9SKKbUrZamx2pWy1FjtSllqrHalLCX+rjZ8U9tZtKR9y87Lw6vvX1WWbaXkpczGrZTTtNn8yaluv4x/zWXCay4jr7lMfM1l0msuk19zmfKay9SXXMZvr7nMa94F/GveBbzGu8CTVeNp/7aApG3kDj61T+t89vMPkIgXa4KjNcHJmuBsTXCxJrgaExw2a4KdNcHemmCxJtha8AjWgkewFjyCteARrAUPeUPweOborTc95yriyKXLxZNLl0sgly4XIZcul/jZXJ458tBLO/LQx97x0SLJlNpsSm0xpbZaUhs/PB0qq/3wzPeUWh/vasM3tZ1l+NLar8J2b9aSnsIcd8fM9b5if6f44QkRhKKQogLFlVLW+yiulN7eR3GlVPgUxdAOCv7jpLNHijualSKkMpqV8qYumrRSOH0OTWqnQoXsemjMJtnQnhT/oyyoh+bDN+reiUbWQRPKvugqW+xNe2mhbHhC7UIZ7oTahbJWKKWpfdxLflC7UHw6oXahRBRKbmofP1O4q80L7aacULuQOZ9Qu9B7srSe+ypFumoXek8+oXah92SJoamt3Z3zvNB7cvTtbxtj929bFho8o29/2/jt3Iu72oXek0+olZXU+qY2d3NyWeg9OW3tb5tC6Kpd6D35hNqF3pPT1u7kJK6nti70npxy29bJ/fm2LrS/d0LtQjNQyi1dZNf7dxs1vtkdtlbZFLYweqjYlfaYsCsPCmrovDiV9hhcqlt+fPEuICkLkO2bgP0y+TWXKa+5TNW4TN7aq7dhg7Bvp5h5n7berajxcHjw7R/e7ROdrnaNZ63PXMa/5jLhNZcRjcvUdsOEbwmxd8MUl1q/iN9G/SKuts/vXE3fX/0lIbpPkrAvyn/iosInLkrjDnzulMbs2gefObrRG5zyWRxR42kiLMHJmuBsTXCxJrgaE6zxlAyWYGdNsLcmOFgTbC14JGvBI1kLHsla8EjWgke2FjyyteCRXx88Uttql5xGEoLsdEK6P7bQ786VtuFWbp94f9vu6OxtpbZ16lLYHti4xiZ8OJumIDxsznXZpPawS6oPv9bf7wMxpDUa0poMac2GtBZDWqsdrWUzpNUZ0vrpOUtTq6HcpPGsIYxWQ7mpGMpNxVBuKoZyUzGUm6qh3FQN5aZqKDdVQ7lJ47xrGK393OTaF1luF8sDrc+eT9Y2fv8orfnbizeVDw68Xlhwtia4WBNcbQlOB4dfLyzYWRPsrQkO1gSLNcHGklbajCWttBlLWmkzlrTSZi1puTckrWeOr37T8QrJeXLpcgnk0uUi5NLlEsmlyyWRS5dL/mwuT1Q1lNT2k0tKj86emtpiSm21pNZ/eLJSVutMqf3wdKis9sMz3zNqcytSKdlJV62YUvvh+UxZ7YenLmW1C2WpE2oXylIn1C6UpcZqw0JZKrdTFErOvqt2oSx1Qu1CWeqE2pWy1FitmFK7UpYaq10pS43VrpSlxN/Vjr6q7G/7NvtvlodX37+qnMJKyUubzUo5TZmN/Mmpbr+Me81l/GsuE15zGXnNZeJrLpNec5n8msuU11ymvuQy8TXvAvE17wJR413gyarxtH9b4I+nDAev9ql9WuezV3iAJAZrgsWa4GhNcLImOFsTXKwJrsYEp82aYGdNsLXgkawFj2QteCRrwSNZCx7JWvBIbwgezxy99a7nXPNGLl0ujly6XDy5dLkEculykc/m8syRh17akYc+9o6PTjmaUptMqc2m1BZTaj88HeqqLR+e+Z5S6+NdbfimtrMMX1r7Vdhqe7X0FOa4O2au9xX7O8UPT4ggFD88N4FQFFJUoLhSensfxZVS4VMUQzsoWEJIjxR3NCtFSGU0K+VNZTQrhdPn0KR2KlTIroOmmk2yoT0pLuHhXPUHNB++UfdONAtlzlD2JwGrbLE37dWFsuEJtQtluBNqF8paoZSm9nEv+UHtQvHphNqFElEoual9/Eyhqc3bQrspJ9QuZM4n1C70niyt575Kka7ahd6TT6hd6D1ZYmhqq++qXeg9Ofr2t42x/7ddaPCMbdE1fjv3oql1C70nn1C70AwUvW9qc+yqXeg9OW3tb5tC6Kpd6D35hNqF3pPT1u7kJK6rdqH35JTbtk7uzrfZL7S/d0LtQjNQyi1dZNf9d6vxze6wtcqmsIXRQ8WutMeEXXlQUEPnxbdPJPZffdtmzo8v3gVEZQGyfROwXya95jL5NZcpGpfJW3v1NmwQ9u0UM+/T1rsVNR4OD779w7t9otPVrvGs9ZnLuNdcxr/mMkHjMrXdMOFbQuzdMMWl1i/it1G/iKvt8ztX0/dXf0ko2ydJ2BflPnFR/hMXpXEHPndKY3btg88c3egNTvksjqzxNBGW4GhNcLImOFsTXKwJrsYEazz7giXYWRPsrQkWa4KtBY9qLXhUa8GjWgse1VjwKJux4FG21weP1Lbab7uTIwlBdjoh3R9b6HfnSttwK1KGe1upbZ26FLYHNq6x8R/OpikID5tzXTapPeyS6sOv9ff7IBjSKoa0RkNakyGt2ZDWYkhrtaPVbYa0fnrO0tRqKDc5Q7lJ4/xtGK2GcpMzlJucodzkDOUmZyg3eUO5yRvKTd5QbvKGctPRadfty4Xhjw3Z32t99nyytvErEvPfXrypfHTg9bqCkzXB2ZrgYk1wNSb46PzrdQU7a4K9NcHBmmCxJtha0grWklawlrSCtaQV3pC0njm++k3HKxRx5NLl4smlyyWQS5eLkEuXSySXLpf02VyeqGooKe7LKCk9OntqarMptcWU2g9PVrpq42ZK7YenQ2W1H575nlGbW5FKyU66aj88ySmrFVNqPzx1KatdKEudULtQljqhdqEsdULtQlkqt1MUSs6+pzYtlKVOqF0oS51Qu1KWGqtdKUuN1YoptStlqbHalbKU+Lva0VeVvaR9y87Lw6sfvqqcVkpe2mxWymnabP7kVPd1mby95jLuNZfxr7lMeM1l5DWXia+5THrNZfJrLlNec5nXvAuU17wLFI13gSerxtP+uyVtI3fwqX1a57NXeICkeGuCgzXBYk1wtCY4WROcrQku1gRXY4LrZk2wteBRrQWPai14VGvBo1oLHtVa8KhvCB7PHL31rudcayWXDpe6beTS5eLIpcvFk0uXS/hsLs8ceeilHXnoY+/46LqJKbXRlNpkSm02pfbD06Gy2g/PfE+p9fGuNnxT21mGL639Kmx3idJTmOPumLneV+wbRffhCRGE4ofnJhCKK6Ws91EUUlSguFIqfIpiaAcFSwjpkeKOZqUIqYxmpbypjGalcPocmtROhQrZ9dCYTbKhPSku4eFc9Tsa/+Ebde9Es1DmDGV/ErDKFnvTnl8oG55QK6bULpS1QilN7eNe8oPaheLTCbULJaLQFl2/faZwVxsW2k05oXYhcz6hdqH3ZGk991WKdNUu9J58Qu1C78kSQ1NbuzvnYaH35Ojb3zbG/t92ocEztjM1avx27kVTKwu9J59Qu9AMFL1vanM3J8tC78lpa3/bFEJX7ULvySfULvSenLZ2JydxXbULvSen3LZ1cn++lYX298Zq40IzUMotXWTX/Xer8c3usLXKprCF0UPFrrTHhF15UFBD58WptMfgUt3y44t3AaIsQLZvAvbLxNdcJr3mMlnjMnlvlghuGzYI+3aKmfdp692KGg+HB9/+4d0+0elq13jWeniZuGk8unzmMu41l/Eal6nthgnfEmLvhikutX4Rv436RVxtn9+5mr6/epdQP0nC16Lc9omLcp+4KI078LlTGrNrH3zm6EZvcLpncdwEB2uCxZrgaE1wsiY4WxNcrAmuxgT7zZpgZ02wteCh8bQKlmBrwcNbCx7eWvDw1oKHtxY8wuuDR2pb7ZLTSEKQnU5I98cW+t250jbcipTh3lZqW6cuhe2BjWts3IezaQrCw+Zcl01qD7uk+vBr/f0+8Ia0BkNaxZDWaEhrMqQ1G9JaDGmtdrTKp+csTa2GcpMYyk1iKDdpnKkNo9VQbhJDuUkM5SYxlJvEUG6KhnJTNJSboqHcdHDatZf9K9AhbG6g9dnzydrGr0jMf3vxpvLBgdcLC47WBCdrgrM1wcWa4GpM8MER2AsLdtYEe2uCrSWtZC1pJWtJK1lLWsla0kpvSFrPHF/9nuMV4pY3culyceTS5eLJpcslkEuXi5BLl0v8bC5PVDWUFPdllJQenb19AzYnU2qzKbUfnqyU1VZLasuHp0NltR+e+Z5Rm1uRSslOumo/PMkpq/3wfKasVkypXShLnVC7UJY6oXahLHVC7UJZKrdTFErOvqt2oSw1VlsXylIn1K6UpcZqV8pSY7UrZamxWjGldqUsJf6udvRVZS9p37Lz8vDqh68q15WSlzablXKaNps/OdXtl6mvuIzbttdcxr3mMv41lwmvuYy85jLxNZdJr7lMfs1lymsu85p3AafxLvBk1Xjavy0gaRu5g0/t0zqf/fwDJM45a4K9NcHBmmCxJjhaE5ysCc7WBBdrgqsxwd5a8PDWgoe3Fjy8teDhrQUPby14+DcEj2eO3nrTc67OF3Lpcqnk0uMSNnLpcnHk0uXiP5vLM0ceemlHHvrYOT76pjaYUium1EZTapMptR+eDpXVfnjme0qtj3e14ZvazjJ8ae1XYbs3a0lPYY67Y+Z6X7G/U/zwhIhBUT48N4FQXCllvY/iSuntfRTFKsXQDgqWENIjxR3NShFSGc1KeVMZzUrh9Dk0qZ0KFbLroTGbZEN7UlzCw7nqdzTxwzfq3olmocwZyr7oKlvsTXtxoWx4Qu1CGe6EWllJbWlqH/eSH9QuFJ9OqF0oEYXWaF6/fabwoHah3ZSx2rSQOZ9Qu9B7srSe+ypFumoXek8+oXah92SJoamt3Z3ztNB7cvTtbxtj/2+70OAZffvbxm/nXjS1eaH35BNqF5qBovdNbe7m5LzQe3La2t82hdBVu9B78gm1C70np63dyUlcV+1C78kpt22d3J9v80L7eyfULjQDpdzSRXa9f7de45vdYWuVTWELo4eKXWmPCbvyoKCGzotTaY/BpbrlxxfvAoKyANm+CdgvI6+5THzNZZLGZfLeLBHcNmwQ9u0UM+/T1rsVNR4OD779w7t9otPVrvGs9ZnL1JdcRuNJ4DOXcRqXqe2GCd8SYu+GKS61fhG/jfpFXG2f37mavr96l1A+ScK+qPqBi5LtExelcQc+d0pjdu2Dzxzd6A1O+SwOr/E0EZbgYE2wWBMcrQlO1gRna4KLNcHVmGCNR3iwBFsLHtFa8NB4YAVLsLXgEa0Fj2gteERrwSO+PnikttUuOY0kBNnphHR/bKHfnSttw61IGe5tpbZ16lLYHtjs3bk+bR/OpikID5tzXTapPeyS6sOvbd9l98kZ0uoNaQ2GtIohrdGQ1mRIazaktRjS+uk5S1FrNpSbsqHclA3lpmwoN2k8QQqj1VBuyoZyUzaUm7Kh3JQN5aZiKDcVQ7mpf/6z38q+tendQzlGX6uT9jSze/xK0w1kb+M3NY41b/d90z82fnt7rE1rKQ+/uQfR5f0Xi6vx9y8O3ren1bx/XHMjI1bJyP3Z0OR6ZDLJHJApJHNAppJMn0z//GOSuZFxJHNAxpPMARmzeWZIRkjmgEwkmQMyiWQOyDADH5FhBj4iYzYD13ZahX/YhmhkwmY2Aw/JmM3AQzJmM/CQjNkMPCQjJHNAxmwGHpIxm4GHZMxm4CEZsxl4SMZqBr5l3P0Xh4dinjsZZzUDj8lYzcBjMlYz8JiM1Qw8JiMkc0DGbAYu92chau6RMZuBh2TMZuAhGbMZeEjG7D7wiIw3uw88JGN2H3hIxuw+8JCM2X3gIRkhmQMyzMBHZJiBj8gwAx+RYQY+IsMMfEAmMAMfkWEGPiLDDHxEhhn4iIyQzAEZZuAjMszAR2SYgY/IMAMfkWEGPiAjzMBHZJiBj8gwAx+RYQY+IiMkc0CGGfiIDDPwERlm4CMyzMBHZJiBD8hEZuAjMszAR2SYgY/IMAMfkRGSOSDDDHxEhknviAyT3hEZJr0DMolJ74gMk94RGaOu7e/HfvsafI+MUdc+QcboztUJMkbzzAkyRvPMCTJG88yYTDaaZ06QMZpnTpAxunN1gozRnasTZIRkDsgwAx+RMZuBU25kSu2RMZuBh2TMZuAhGbMZeESmmM3AQzJmM/CQjNkMHF0jk6RHxmwGHpIRkjkgYzYDD8mYzcBDMmYz8JCM2Qw8JGM2A4/IWD3Z6gQZsxl4SIYZ+IgMM/ARGSGZAzLMwEdkmIGPyDADH5FhBj4iwwzcJyNWT7Y6QYYZ+IgMM/ARGWbgIzJCMgdkmIGPyDADH5FhBj4iwwx8RIYZ+ICM1ZOtTpBhBj4iwwx8RIYZ+IiMkMwBGWbgIzLMwEdkmIGPyDADH5FhBj4gY/VkqxNkmIGPyDADH5FhBj4iIyRzQIYZ+IgMM/ARGWbgAzJWTynyRcKusHwn0xHo3Y7j9p+1h9Fq+FHGaDUpKWO0GquUMQoxamC0GtiUMVpNd8oYrUZBZYxW906VMVrdaNXFaPWcqScx3gX62MXIKUYFI6cYFYycYlQwCjFqYOQUo4KRU8wZjEEaRgk9jJxiVDByilHByClGA6PVk8K0MXKKUcHIKUYFI6cYFYxCjBoYOcWoYOQUo4KRU4wKRk4xKhg5xWhgtHoKnjZGTjEqGDnFqGDkFKOCUYhRAyOnGBWMnGJUMHKKUcHIKUYFI6cYDYxmz75UxsgpRgUjpxgVjJxiVDAKMWpg5BSjgpFTjApGTjEqGDnFqGDkFKOB0ezppcoYOcWoYOQUo4KRU4wKRiFGDYzMjWOMNe6vrTH3IDI1KkBkZpyHaPasT1WIzIsKEJkWFSAyKypAFEKch8jdbgWI3OtWgMiJRQEiJxYFiJxYpiFGsyezqkLkxKIAkROLAkROLAoQhRDHELPfV1xiDyInFgWInFgUIHJiUYDIiUUBIieWeYhmz9FVhciJRQEiJxYFiJxYFCAKIc5D5MRyAmLZf7HbHld8p8iRRYMiZxYNihxaNChyalGgaPboY12KnFueCTpHFDm4zMdFs6cvq0IUQpyHyMFFASLnFgWIHFsUIHJqUYDIoWUeIo8314DIkUUBIicWBYicWBQgCiHOQ+TEogCRE4sCRE4sChA5sShA5MQyD5FHmWtA5MSiAJETiwJETiwKEIUQ5yFyYlGAyIlFASInFgWInFgUIHJimYfIY8s1IHJiUYDIiUUBIicWBYhCiPMQObEoQOTEogCRE4sCRE4sChA5scxD5BHlGhA5sShA5MSiAJETiwJEIcR5iJxYFCByYlGAyIllHiIPgT4BMZddX65bDyJz4hhi2crXa4svPYjMiQoQmRMVINKdFSDSnRUgcj9RASL3E+ch8phdDYjMiQoQmRMVIDInKkAUQpyHyP1EBYicWBQgcmJRgMiJ5QTEtoiSevuJPKFYAyLDtgJEhm0FiAzbChCFEOchMmwrQGTYVoDIsK0AkWFbASI/HpiGmHhCsQZETiwKEDmxKEDkxKIAUQhxHiInFgWInFgUIHJiUYDIiUUBIieWeYg8oVgDIicWBYicWBQgcmJRgCiEOA+RE4sCRE4sChA5sShA5MSiAJETyzxEHk6sAZETiwJETiwKEDmxKEAUQpyHyIlFASInFgWInFgUIHJiUYDIiWUeIo8m1oDIsK0AkWFbAaIQ4jxEhm0FiAzbChDXiTgh+51LyCF0xC505ugJseu4XcgpNbFZemLXcaUTYtdxjxNi13mXPyF2na2PE2LX2aI4IXYlnx2JXeikvBNi1/kw8YTYdfYhToi1lKAWOsnthFhLCWqhk9FOiLUUKhY6JGssdqHDrE6ItRQqFjoc6oRYS6FiocOWToi1FCoWOrzohFhL2zJppQQV/V3s4GMV54Psa/bS21FPK8UtVTILHSClTWalIKdLZqXUp0tmpYioS0ZI5oDMSuFTl8xKSVWXzEqxVpcMM/ARGWbgAzILHY6lTYYZ+IgMM/ARGWbgIzJCMgdkmIGPyDADH5FhBj4iwwx8RIYZ+IDMQmdWaZNhBj4iwwx8RIYZ+IiMkMwBGWbgIzJWM3BI+ypcqL5HxmoGHpOxmoGDxDuZzr+mvNAxNc+RSW7/3uXtP6VHxmqeGZOxmmfGZIRkDshYzTMplkbmj3X+JGM1z4zJWM0zYzJW88yYjNU9vXSfm24fR3bILHQyxXNkSth/sSsx98gY9Sa/5f3Ff4jtkTHqTSfIGPWmE2SMetMJMka9aUxmoTZ8bTJG92dOkDGaZ06QMbo/c4KMkMwBGWbgIzLMwEdkmIGPyDADH5FhBj4gs1C/ujYZZuAjMszAR2SYgY/ICMkckGEGPiLDDHxEhhn4iAwz8BEZZuADMksV++uSYQY+IsMMfESGGfiIjJDMARmrGdj5u0KfemSsZuAxGasZeEzGagYek7GagYdkljp0Q5eM1Qw8JmM1A4/JWM3AYzJCMgdkmIGPyDADH5FhBj4iwwx8QGapw0FUv6uy1EkiumTMfvd2SEaMksmlfSeuuN6e3lIHmuiSsfrd2zEZq9+9HZOx+t3bMRmr370dkjF7rsqYjNUMPCZjNQOPyVjNwGMyQjIHZJiBj8gwAx+RYQY+IsMMfESGGfiAjNlzVcZkmIGPyDADH5FhBj4iIyRzQIYZ+IgMM/ARGWbgIzLMwEdkmIEPyJg9V2VMhhn4iAwz8BEZqxl42Ghq9lyVMRmrGXhMxmoGHpOxmoHHZKxm4DEZqxl4RKZsVjPwmIzVDDwmw+76IzLMwEdkhGQOyDADH5FhBj4iwwx8RIYZ+IgMM/ABGbNn8cT2nTgXJQ1+8+337b9ZNulhtBp+lDEKMWpgtBqrlDFazWDKGK0GNmWMVtOdMkarUVAXo9VzsrQxWt1oVcbIKUYFI6cYFYxCjBoYOcWoYGTgGWPMZdeX69aBaPVIJF2InKfHEGsM+4q7G7ZWj/lQhWj1dIfnILaG9toraC9WD4LQhcjJRQEi5xYFiEKI8xA5syhAZE5UgMicqACRn7koQOQGxDxEq2dx6ELkxKIAkRPLGKLbQnvxVnrbslaPA9HGKMSogZFziwpGTi4qGDm7qGDk9KKCkfOLBsbECUYFI2cYFYycYlQwcopRwSjEqIGRU4wKRk4xKhg5xahg5BSjgpFTjAZGs+cnKWPkFKOCkVOMCkZOMScwuobj9p+ph1GIUQMjpxgVjJxiVDByilHByClGBSOnGA2MZk/AUsbIKUYFI+O3CkYhRg2MjN8qGBm/VTAyfqtgZPxWwcj4rYHR7OFbyhgZv1Uw8kMEFYycYlQwCjFqYOQUo4KRU4wKRk4xKhg5xahg5BSjgLGaPfDpKYzetRd7V3sYhRg1MNJizmAM0jBK6GGkxahgpMVoYHTcKFPByI0yFYzcKFPByNyoglGIUQMjN8pUMHKjTAUjpxgVjJxiVDByitHAyLOydDByivkV407G7GCStrbm3L1nzM4aQzJCMgdkzE4EQzJmQ/6QjNncPiRjNooPyZhN1yMydk9bG5Ixm4GHZJiBj8gwAx+REZI5IMMMfESGGfiIDDPwERlm4CMyzMAHZOweUTokwwx8RIYZ+IgMM/ARGSGZAzLMwEdkmIGPyDADH5FhBj4iwwx8QMbuoZdDMszAR2SsZuDkwr7m5KRHxmoGHpMRkjkgYzUDj8lYzcBjMlYz8JiM1Qw8JmM1Aw/JmD02cUzGagYek2EGPiLDDHxERkjmgIzRpOedvyv0ve8dWD3h7gQZo0nvBBmjSW9MxurRcifIGE16J8gYTXonyBhNeifICMkckDG623mCDDPwERlm4CMyzMBHZJiBD8hYPZjsBBlm4CMyzMBHZJiBj8gIyRyQYQY+IsMMfESGGfiIDDPwERlm4AMyNo612sWaCG+7WBN5bBcrlsSaSE27WLZrapxYwWNoFDCmbWO7pgpGtmuqYOQZASoYeUaACkYhRg2MPCNABSPPCFDByDMCVDByijmD8S7Qxy5GTjEaGHnSmQ5GTjEqGDnFqGDkFKOCUYhx+vyUG0ZOMSoYOcWoYOQUo4KRU4wKRk4xGhh50pkORk4xKhg5xahg5BSjglGIUQMjpxgVjJxiVDByilHByClGBSOnGA2Mdo+f08XIKUYFI6cYFYycYlQwCjFqYOQUo4KRU4wKRk4xKhg5xahg5BSjgdHuAYK6GDnFqGDkFKOCkVOMCkYhRg2MnGJUMHKKUcHIKUYFI6cYFYycYjQw2j0CUhcjpxgVjJxiVDAyN44x1rifS1Nj7kFkalSAyMyoAJGJUQEi8+I8RLOHJapCZFZUgMikqACRu90KEIUQ5yFyYlGAyIlFASInFgWInFgUIHJimYdo9dBPXYicWBQgcmI5ATHvv7iW2IPIiUUBohDiPEROLAoQObEoQOTEogCRE4sCRE4s8xCtHtGqC5ETiwJETiwKEDmxnIBY9hW77XHFd4pCigoUObNoUOTQokGRU4sGRY4tGhQ5tzwTdA4oVg4u83HRxuHEfzZEDi4KEDm4KEAUQpyHyLFFASKnFgWIHFoUIHJmUYDIkWUaouPR5hoQObEoQOTEogCRE4sCRCHEeYicWBQgcmJRgMiJRQEiJxYFiJxY5iHyGHMNiJxYFCByYlGAyIlFAaIQ4jxETiwKEDmxKEDkxKIAkROLAkROLPMQeWS5BkROLAoQObEoQOTEogBRCHEeIicWBYicWBQgcmJRgMiJRQEiJ5Z5iDyeXAMiJxYFiJxYFCByYlGAKIQ4D5ETiwJE5sQxxFx2fbluPYjMiWOIZStfry2+dCDyAGgNiMyJChDpzgoQ6c4KELmfqACR+4kKEJkTFSAyJ85D5BG7GhCZExUgcj9RASL3ExUgCiHOQ+TEogCRE8sJiG0RJfX2E3lCsQZEhu15iDyhWAMiw7YCRIZtBYgM2woQhRDnITJsK0Bk2FaAyI8HFCByYlGAyIllHiJPKNaAyIlFASInFgWInFgUIAohzkPkxKIAkROLAkROLAoQObEoQOTEMg+RJxRrQOTEogCRE4sCRE4sChCFEOchcmJRgMiJRQEiJxYFiJxYFCByYpmHyKOJNSByYlGAyIlFASInFgWIQojzEDmxKEDkxKIAkROLAkROLNMQPU/V1YDIsK0AkWFbASLDtgJEIcR5iP2I47bcILoygBjjTqXkO8IkryQoLu+/WG4TxAC399v+i72XHpZiEou0u9An18FycMqjeSyeWHpYArH0sAix9LBEYulhScTSw2IztwyxMLd0sVRi6WA5OEfQPBam3C4WptwuFpspt7qGpaYeFiGWHhabKXeIxWbKHWKxmXKHWGym3CEWmyl3hCXYTLlDLDZT7hCLzZQ7xGIy5YatfU4UXOhhEWLpYTGZcsdYTKbcMRaTKXeMxWTKHWOxmXLL/YmFmjtYxGbKHWKxmXKHWGym3CEWm3u5QyxCLD0sNvdyh1hs7uUOsdjcyx1isbmXO8TClNvDEplyu1iYcrtYmHK7WJhyu1iEWHpYmHK7WJhyu1iYcrtYmHK7WJhye1gSU24XC1NuFwtTbhcLU24XixBLDwtTbhcLU24XC1NuFwtTbhcLU24PS2bK7WJhyu1iYcrtYmHK7WIRYulhYcrtYmHK7WJhyu1iYcrtYmHK7WEpjHNdLIxzXSyMc10sQiw9LIxzXSwWDdpXX3Z5NfgeFosGPcZSLW5DncBiMbecwGIxt5zAYjG3nMAixNLDYjG3nMBicRvqBBaL21AnsDDldrEw5XawhM1myk1NXi21h8Vmyh1isZlyh1hsptwhFiGWHhabKXeIxWbKja5hSdLDYjPlDrHYTLlDLDZT7giLs5lyh1hsptwhFpspd4jFZsodYhFi6WGxmXKHWJhyu1iYcrtYmHK7WJhye1hMHtt0AgtTbhcLU24XC1NuF4sQSw8LU24XC1NuFwtTbhcLU24XC1NuD4vJY5tOYGHK7WJhyu1iYcrtYhFi6WFhyu1iYcrtYmHK7WJhyu1iYcrtYTF5bNMJLEy5XSxMuV0sTLldLEIsPSxMuV0sTLldLEy5XSxMuV0sTLk9LCaPbTqBhSm3i0UsYikSdnnlO5afL3bexa8X3/6z9y0bk6f2aDM0mYiUGZqMT8oMTWYtZYYmg5kuQ5PHEmkzNBn5lBma3AVVZmhyy1SZoZDhiKGkxjB2GXJOmWfIOWWeIeeUeYacU+YZck6ZZmjyYKknGQZpDCX0GHJOmWfIOWWeIeeUeYZChtMMOafMM+ScMs+Qc8o8Q84p8ww5p0wzLJxT5hlyTplnyDllniHnlHmGQobTDDmnzDPknDLPkHPKPEPOKfMMOadMM7R5QqIyQ84p8ww5p8wz5Jwyz1DIcJoh55R5hpxT5hlyTplnyDllniHnlFmGYvOMS2WGnFPmGXJOmWfIOWWeoZDhNEPOKfMMOafMM+ScMs+Qc8o0Q5tHST7DsMb9tTXmHkGmw1mCzIazBIUEJwkyF84SZCqcJchMOEuQiXCWIPetJwnaPM1TlSBnklmCnElmCXImmSUoJDhJkDPJLEHOJLMEOZPMEuRMMiKY/b7iEnsEOZNMErR59qoqQc4kswQ5k8wS5EwyS1BIcJIgZ5JZgpxJZglyJpklyJlkliBnkhHBsv9itz2uuCG0eVSuLkJOJdMIOZZMI+RcMo1QiHAWISeT05nmCCFHk8lYaPN0YVWCHE1mCXI0mSRo83hjVYIcTGYJci6ZJcixZJagkOAkQQ4lswQ5k8wS5EwyS5AzySxBziSTBHlY9zRBziSzBDmTzBLkTDJLUEhwkiBnklmCnElmCXImmSXImWSWIGeSSYI8mHuaIGeSWYKcSWYJciaZJSgkOEmQM8ksQc4kswQ5k8wS5EwyS5AzySRBHsI9TZAzySxBziSzBDmTzBIUEpwkyJlkliBnklmCnElmCXImmSXImWSSIA/cnibImWSWoJDg71+cS/p6ba5bjyDz4IBg2cquzpceQebBWYLMg3MEIw+VnSZIL54lyP3BWYLcH5wlKCQ4SZB5cJYg8+AsQebBWYLcH5wlyP3BSYKOM8ksQc4kswQ5k4wItkWUtPUICglOEmSiniXIRD1LkIl6liAT9SxBJupJgjyEd5ogE/UsQSbqWYLc5Z8lKCQ4SZAzySxBziSzBDmTzBLkTDJLkDPJJEEewjtNkDPJLEHOJLMEOZPMEhQSnCTImWSWIGeSWYKcSWYJciaZJciZZJIgz+CdJsiZZJYgZ5JZgpxJZgkKCU4S5EwyS5AzySxBziSzBDmTzBLkTDJJkKfvThPkTDJLkDPJLEHOJLMEhQQnCTJRzxJkop4lyEQ9S5CJepIgz46dJrhImgnZ71BCDqGnVMwoXcTbQk6pKc3SU7qIB51QuohXjJWucvbeCaWL7GacULrIrsMJpcv46VDpMn46VLrIJ4AnlC6yr3BCqZmMtMrZZSeUmslIq5wFdkKpmYy0ytlaJ5SayUirnFV1QqmZjLTK2U8nlJrJSKucpXRCqZmMtMrZRCeUmslI1UxGqmYy0irnN51QaiYjrXIe0gmlZjJSNZORqpWMlFY5M+qEUisZKa1yBtMJpVYyUtrEjFIrySGtcsLNCaVWkkNa5cSYsdJVTnY5odRMcljlpJQTSs0kh1XObjmh1MruSlrlLJSQo78rHTz17nyQrxc7L6GHZZlApYtlmfSli2WZqKaKZZXzRbSxLBMCdbEskxh1sSwTL3WxCLH0sCwTXHWxMOV2sTDldrEw5XaxMOX2sKxyYoU2FqbcLham3C4WptwuFiGWHham3C4WptwuFqbcLham3C4WptwellXOQNDGwpTbxcKU28XClNvFIhaxhLSvwoXqe1hMptwxFpMpN0i8Y+n+IzKZW5Lb++tu/9l7vmWVnnRtLCZzyxiLydwyxmIyt6RYGpbieliEWHpYTOaWMRaTuWWMxeTuXLrPRKn0Uu4qbdTPYSlh/8WuxNzDYtGJ/Jb3F/utxB4Wi050AotFJzqBxaITncBi0YlOYLH4OdEJLBb3W8ZY1mlc18Vicb/lBBaL+y0nsDDldrEIsfSwMOV2sTDldrEw5XaxMOV2sTDl9rCs05mvi4Upt4uFKbeLhSm3i0WIpYeFKbeLhSm3i4Upt4uFKbeLhSm3h2WdUw90sTDldrEw5XaxmEy5zscmz6ceFiGWHhaTKXeMxWTKHWMxmXLHWEym3DEWkyl3hCWvc26FLhaTKXeMxWTKHWNhyu1iEWLpYWHK7WJhyu1isfnN1sE3RPI6p2boYrH5zdYhFpPfbM2lffusuNjDYvKbrWMsQiw9LCa/2TrGYvKbrWMsJr/ZOsZisndujMVkyh1isXmGyBiLyZQ7xsKU28XClNvFIsTSw8KU28XClNvFwpTbxcKU28XClNvDYvMMkTEWptwuFqbcLham3C4WIZYeFqbcLham3C4WptwuFqbcLham3B4Wm2eIjLGYTLmjqs9s8wyRMRaTKXeMRYilh8Vkyh1jMZlyx1hMptwxFpMpd4zFZModYrF54swYC1NuFwtTbhcLU24XixBLDwtTbhcLU24XC1NuD4vNE2di+/aZi5IGv/n2+/bfLJv0GJoMOcoMTSYiZYYm45MyQyHDaYYmg5kyQ5MpTpmhycinzNDkLqgyQ5NbproMTZ4wpc2Qc8o8Q84p8ww5p8wzZLYZMMwlfb02161HkMlmkqDJMyueIlhj2Ffc3X01ebyFLkH+Kx4RbF3ltVdVnk0eg6BK0OSJCboEOZnMEuRcMkuQU8ksQSHBSYLMg7ME+bnJLEHuLMwS5EwyS5AzyRzBYvJ8i6cIui20F29Fegw5lcwz5Fwyz5CTyTxDIcNphpxO5hlyPplnyAllniFnlHmGnFKmGdo8z0aZIeeUeYacU+YZck6ZZyhkOM2Qc8o8Q84p8ww5p8wz5Jwyz5BzyjRDmycSKTPknDJi6Ep7sSupx5BzyjxDzinzDIUMpxlyTplnyDllniHnlHmGnFPmGXJOmWZo8/AkZYbM2PMMmbHnGQoZTjNkxp5nyIw9z5AZe54hM/Y8Q2bsaYY2T7RSZsg5ZZ4h55R5hpxT5hkKGU4z5Jwyz5BzyjxDzinTDG0eevQUQ+/ai72rPYbMNvMM6SlDhkEaQwk9hvSUeYb0lHmG3PuaZ8i9r2mGPC9KgSHz4TxD5sN5htz7mmcoZDjNkHPKPEPOKfMMOafMM+ScMs+Qc0pvW9XoEVBpa1hy724xeqrTEIvNAWGIxWbmH2IRYulhsZnMh1hshu0hFpv5eYjFZiQeYrGZckdYClNuFwtTbhcLU24XC1NuF4sQSw8LU24XC1NuFwtTbhcLU24XC1NuD4vRIzOHWJhyu1iYcrtYmHK7WIRYeliYcrtYmHK7WJhyu1iYcrtYmHI7WKrNQxiTCzuW5KSHxWTKHWMxmXLHWEym3DEWIZYeFpMpd4zFZModYzGZcsdYTKbcMRaTKXeIxeYRfmMsTLldLEy5XSxiEIt37Zn/23+mHhaLce4EFotx7gQWi3HuBBaLce4EFotxbozF5ElnJ7BYjHMnsFiMcyewWNy0PIFFiKWHhSm3i4Upt4uFKbeLhSm3i4Upt4clMOV2sTDldrEw5XaxMOV2sQix9LAw5XaxMOV2sTDldrGsH+e+lBo4ZWlXun7o2pWun6N2petHo10pmydnT2qoPHVFgSGbJ+cZsnlymmFkQ/48QzbkzzNkQ/48QzbkzzMUMpxmyIb8eYacU4YMJTWGscuQc8o8Q84p8ww5p0wz5EleCgw5p8wz5Jwye2JI5UleCgyFDKcZck6ZZ8g5ZZ4h55R5hpxT5hlyTplmaPTYL12GnFPmGXJOmWfIOWWeoZDhNEPOKfMMOafMM+ScMs+Qc8o8Q84p0wyNHtymy5BzyjxDzinzDDmnzDMUMpxmyDllniHnlHmGnFPmGXJOmWfIOWWaodGj93QZck6ZZ8g5ZZ4h55R5hkKG0ww5p8wz5Jwyz5BzyjxDzinzDDmnTDLMm83DE5UZMh8OGNa4H8xSY+4RFBKcJMhsOEuQyXCWIHPhLEGmwlmCzISTBG0eNKhKkPvWswS5az1LkDPJLEEhwUmCnElmCXImmSXImWSWIGeSWYKcSSYJmjwt8zmCef/FtcQeQc4kswQ5k8wS5EwyS1BIcJIgZ5JZgpxJZglyJpklyJlkliBnkkmCJs821SXImWREsOwrdtvjiu8IOZRMI+RUMo1QiHAWIeeSaYQcTKYRcjI5nWmOEHI0mY2FHE0mCRo41PfPJsjRZJYgJ5NZghxMZgkKCU4S5FgyS5BTySxBDiWzBDmTzBLkTDJJkAd2TxPkTDJLkDPJLEHOJLMEhQQnCXImmSXImWSWIGeSWYKcSWYJciaZJMjDuacJciaZJciZZJYgZ5JZgkKCkwQ5k8wS5EwyS5AzySxBziSzBDmTTBLkQdzTBDmTzBLkTDJLkDPJLEEhwUmCnElmCXImmSXImWSWIGeSWYKcSSYJ8tDtaYKcSWYJciaZJciZZJYg8+CAYC7p67W5bj2CzIMDgmUruzpfegSZB2cJMg9OEuShstME6cWzBIUEJwlyf3CWIPPgLEHmwVmCzIOzBJkH5wg6HiI7TZD7g7MEOZPMEuRMMktQSHBAsC2ipK1HkIl6liAT9SxBJupZgkzUkwR5CO80QSbqWYJM1LMEmahnCQoJThLkLv8sQc4kswQ5k8wS5EwyS5AzySRBHsI7TZAzySxBziSzBDmTzBIUEpwkyJlkliBnklmCnElmCXImmSXImWSSIA/hnSbImWSWIGeSWYKcSWYJCglOEuRMMkuQM8ksQc4kswQ5k8wS5EwySZCn704T5EwyS5AzySxBziSzBIUEJwlyJpklyJlkliAT9SxBJupJgjw7dpogE/UsQSbqywRv/8v/+0//81/+6b/86z//++0H/vj//a+//tf/+Jd/++vX//of/9//+Pv/5/ba/x8="},{"name":"rotate_npk_m","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"new_npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b227aQBCG18RJTJ24YGMMgQQIyUXvDA2nO16mfe3eV+orVM2YnTJsp2hRx1tWYqWIsb2e/5t/D1jICdSuRe9/gY6v9eeN+rNhn63+LP+tzQRzlXVyBp5wNjzhvPKEMxTkDBhO+Ax1DOsO1tytOlyPv9tWqChTlELBBLoi19URwIMboUU6oBfHUuDrcnNDklNwpcFDfQ0/ASfW1yhYrIus+pBzWGiDnEOdK3IOd0bUibQpwvUuoj2yXN73CQA1NHUu5I5JTK8NiXVhTTVey9f4VsuYlLtVjGNyrXPfkmP0Cj0U/OaYUe1A/zWJptJjhPGA9MV+6EeDjDG0e7Wf180j94XGfQnpc8PUPxau/9bgMecsjEFLx204xj2BsH0g9W1l2ErIG8vnndExCHVu5I9JTYm43/M15L9Th838VhqTOCE89+I85ayeOndj95Gwy+RdvIFXLcOrO8OrhPShDK0a/AuILubG4xajLefFcg3abQsv2gxP27EXbUZb0IsNaKcWXqQMT+rYi5TRlvNi9Rm0MwsvMoYnc+xFxmjLeTGvni06Fl50GJ6OYy86jLbgGqnmRW7hRc7w5I69yBltQS++gnbXwosuw9N17EWX0Rb04gtoFxZeFAxP4diLgtEW3Dur54uehRc9hqfn2Iseoy3oxRy0+xZe9BmevmMv+oy24BqptB8svHhgeB4ce4F6pzJ3PGQuPGTOzoA5MmIZ7WW1fw4svBgwPAPHXtDfck5hzs+AOTJiGe3lArSHFl4MGZ6hYy9Q71Tm1EPmzEPmrofMuYfMhYfM5zCfIyOW0V5Ve+ijhRePDM+jYy9Q71Tm1EPmgYfM2RkwR0Yso72qfpt7svDiieF5cuwF6p3K3POQuX0GzJERy2ivlqA9svBixPCMHHuBeqcy9z1kLjxkHnjInHnI3PWQOfeQ+bIG3TCnZ8AM773gOzA/auWZb2KDBz1TBqMyGGMSJ4QR+26V3PsqiVE7ak3E/diNjzlf8HhSq/Z8DXmn8jVVz/IvOhe+wzdlanrVcSDs5wvJGxAdPB+S+Dvpi/3QD1y3yA7vXD3r+PXIfSPjvoT0eWbqHwvXPzV4pgYzjMk3wlHH3LKZ1y21X8ufCE8N++AbfScXm82+Q/cYQZ5ZTXWW9B2+n0p2TU8Mr5qGVwnpQ/fo/7VvXpgvzH9jps8TTXKO8uC5hlEL/f+GCcnxC57ToyHuNQAA","debug_symbols":"ndpRattAGIXRveg5FN/fMxopWymlOIlTDMEJsVMoJnuv3dIF9LxpJN237+kwl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLLX/ent52x9uL03n3fp7ut6Pupv3x6fY0Pu+m58PL/vrc2+e3u9tohdF2I6PIqGS0lVGTUZfRLKMhIyliK0U0KaJJEU2KaFJEkyKaFNGkiCZFNCmiSRFdiuhSRJciuhTRpYguRXQpoksRXYroUsQsRcxSxCxFzFLELEXMUsQsRcxSxCxFzFLEkCKGFDGkiCFFDCliSBFDihhSxJAihhSxSBGLFLFIEYsUsUgRixSxSBGLFLFIEYsUsUoRqxSxShGrFLFKEasUsUoRqxSxShGrFJHNhlahVdFqS6tGq06rmVaDVgutqI1QG6E2Qm2E2gi1EWoj1EaojVAboTaK2ihqo6iNojaK2ihqo6iNojYINEOiGSLNkGmGUDOkmiHWDLlmCDZDshmizZBthnAzpJsh3gz5Zgg4Q8IZIs6QcYaQM6ScIeYMOWcIOkPSGaLOkHWGsDOknSHuDHlnCDxD4hkiz5B5htAzpJ4h9gy5Zwg+Q/IZos+QfYbwM6SfIf4M+WcIQEMCGiLQkIGGEDSkoCEGDTloCEJDEhqi0JCFhjA0pKEhDg15aAhEQyIaItGQiYZQNKSiIRYNuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlo2UVPctEiFy1y0SIXLXLRIhctctH6bxe9nn7u3g+7h5f97W7v7ePH8fHfVd/r8fzr7e+X67+/AQ=="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"npk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"npk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"ivpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"ivpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"ovpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"ovpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"tpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"tpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"partial_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::partial_address::PartialAddress"}},{"name":"keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"ivpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"ovpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"tpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}}],"kind":"struct","path":"aztec::keys::public_keys::PublicKeys"}}],"kind":"struct","path":"KeyRegistry::register_parameters"}}],"kind":"struct","path":"KeyRegistry::register_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"new_npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"KeyRegistry::rotate_npk_m_parameters"}}],"kind":"struct","path":"KeyRegistry::rotate_npk_m_abi"}]}},"file_map":{"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nunconstrained fn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n"},"142":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"152":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse dep::std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n"},"156":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse dep::std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{hash::pedersen_hash, traits::FromField};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::public_storage;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we \n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the \n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling \n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need. \n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and \n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write_value_change(value_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write_delay_change(delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        public_storage::read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        public_storage::read(self.get_delay_change_storage_slot())\n    }\n\n    fn write_value_change(self, value_change: ScheduledValueChange<T>) {\n        public_storage::write(self.get_value_change_storage_slot(), value_change);\n    }\n\n    fn write_delay_change(self, delay_change: ScheduledDelayChange<INITIAL_DELAY>) {\n        public_storage::write(self.get_delay_change_storage_slot(), delay_change);\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(*self.context);\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes. \n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20 \n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is \n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the \n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(\n        self,\n        context: PrivateContext\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField {\n        let header = context.get_header();\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let value_change_slot = self.get_value_change_storage_slot();\n        let mut raw_value_change_fields = [0; 3];\n        for i in 0..3 {\n            raw_value_change_fields[i] = header.public_storage_historical_read(\n                value_change_slot + i as Field,\n                context.this_address()\n            );\n        }\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let delay_change_slot = self.get_delay_change_storage_slot();\n        let raw_delay_change_fields = [header.public_storage_historical_read(delay_change_slot, context.this_address())];\n\n        let value_change = ScheduledValueChange::deserialize(raw_value_change_fields);\n        let delay_change = ScheduledDelayChange::deserialize(raw_delay_change_fields);\n\n        let historical_block_number = context.historical_header.global_variables.block_number as u32;\n\n        (value_change, delay_change, historical_block_number)\n    }\n}\n"},"188":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"22":{"path":"std/field.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"223":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"230":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"231":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use dep::std::cmp::Eq;\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    contract_class_id::ContractClassId, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{Hash, is_empty},\n    utils::{uint256::U256, field::field_from_bytes_32_trunc}\n};\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u32) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, first_nullifier: Field, index: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, index);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"267":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"28":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"281":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"354":{"path":"/usr/src/noir-projects/noir-contracts/contracts/key_registry_contract/src/main.nr","source":"contract KeyRegistry {\n    use dep::authwit::auth::assert_current_call_valid_authwit_public;\n\n    use dep::aztec::{\n        keys::PublicKeys, state_vars::{SharedMutable, Map},\n        protocol_types::{grumpkin_point::GrumpkinPoint, address::{AztecAddress, PartialAddress}}\n    };\n\n    global KEY_ROTATION_DELAY = 5;\n\n    #[aztec(storage)]\n  struct Storage {\n    // The following stores a hash of individual master public keys\n    // If you change slots of vars below, you must update the slots in `SharedMutablePrivateGetter` in aztec-nr/keys.\n    // We store x and y coordinates in individual shared mutables as shared mutable currently supports only 1 field\n    npk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    npk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n\n    ivpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    ivpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    \n    ovpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    ovpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    \n    tpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    tpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n  }\n\n    #[aztec(public)]\n  fn rotate_npk_m(address: AztecAddress, new_npk_m: GrumpkinPoint, nonce: Field) {\n        // TODO: (#6137)\n        if (!address.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, address);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let npk_m_x_registry = storage.npk_m_x_registry.at(address);\n        let npk_m_y_registry = storage.npk_m_y_registry.at(address);\n        npk_m_x_registry.schedule_value_change(new_npk_m.x);\n        npk_m_y_registry.schedule_value_change(new_npk_m.y);\n    }\n\n    #[aztec(public)]\n  fn register(address: AztecAddress, partial_address: PartialAddress, keys: PublicKeys) {\n        let computed_address = AztecAddress::compute(keys.hash(), partial_address);\n\n        assert(computed_address.eq(address), \"Computed address does not match supplied address\");\n\n        let npk_m_x_registry = storage.npk_m_x_registry.at(address);\n        let npk_m_y_registry = storage.npk_m_y_registry.at(address);\n        let ivpk_m_x_registry = storage.ivpk_m_x_registry.at(address);\n        let ivpk_m_y_registry = storage.ivpk_m_y_registry.at(address);\n        let ovpk_m_x_registry = storage.ovpk_m_x_registry.at(address);\n        let ovpk_m_y_registry = storage.ovpk_m_y_registry.at(address);\n        let tpk_m_x_registry = storage.tpk_m_x_registry.at(address);\n        let tpk_m_y_registry = storage.tpk_m_y_registry.at(address);\n\n        npk_m_x_registry.schedule_value_change(keys.npk_m.x);\n        npk_m_y_registry.schedule_value_change(keys.npk_m.y);\n        ivpk_m_x_registry.schedule_value_change(keys.ivpk_m.x);\n        ivpk_m_y_registry.schedule_value_change(keys.ivpk_m.y);\n        ovpk_m_x_registry.schedule_value_change(keys.ovpk_m.x);\n        ovpk_m_y_registry.schedule_value_change(keys.ovpk_m.y);\n        tpk_m_x_registry.schedule_value_change(keys.tpk_m.x);\n        tpk_m_y_registry.schedule_value_change(keys.tpk_m.y);\n    }\n}\n"},"44":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not() {\n        let num = U128::from_u64s_le(0, 0);\n        let not_num = num.not();\n\n        let max_u64: Field = pow64 - 1;\n        assert_eq(not_num.hi, max_u64);\n        assert_eq(not_num.lo, max_u64);\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"51":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n// docs:start:assert_current_call_valid_authwit\n// Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_new_nullifier(nullifier, 0);\n}\n\n// docs:start:assert_current_call_valid_authwit_public\n// Assert that `on_behalf_of` have authorized the current call in a public context\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n// docs:start:compute_call_authwit_hash\n// Compute the message hash to be used by an authentication witness \npub fn compute_call_authwit_hash<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_outer_authwit_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_call_authwit_hash\n\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\npub fn compute_outer_authwit_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field\n) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    grumpkin_point::GrumpkinPoint, traits::{Deserialize, Serialize}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 8;\n\nstruct PublicKeys {\n    npk_m: GrumpkinPoint,\n    ivpk_m: GrumpkinPoint,\n    ovpk_m: GrumpkinPoint,\n    tpk_m: GrumpkinPoint,\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            poseidon2_hash(\n                [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH\n        ]\n            )\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> GrumpkinPoint {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.tpk_m.x,\n            self.tpk_m.y,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: GrumpkinPoint { x: serialized[0], y: serialized[1] },\n            ivpk_m: GrumpkinPoint { x: serialized[2], y: serialized[3] },\n            ovpk_m: GrumpkinPoint { x: serialized[4], y: serialized[5] },\n            tpk_m: GrumpkinPoint { x: serialized[6], y: serialized[7] },\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: GrumpkinPoint { x: 1, y: 2 },\n        ivpk_m: GrumpkinPoint { x: 3, y: 4 },\n        ovpk_m: GrumpkinPoint { x: 5, y: 6 },\n        tpk_m: GrumpkinPoint { x: 7, y: 8 }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x2406c1c88b7afc13052335bb9af43fd35034b5ba0a9caab76eda2833cf8ec717;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: GrumpkinPoint { x: 1, y: 2 },\n        ivpk_m: GrumpkinPoint { x: 3, y: 4 },\n        ovpk_m: GrumpkinPoint { x: 5, y: 6 },\n        tpk_m: GrumpkinPoint { x: 7, y: 8 }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/public_storage.nr","source":"use dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::oracle::storage::{storage_read, storage_write};\n\npub fn read<T, N>(storage_slot: Field) -> T where T: Deserialize<N> {\n    T::deserialize(storage_read(storage_slot))\n}\n\npub fn write<T, N>(storage_slot: Field, value: T) where T: Serialize<N> {\n    storage_write(storage_slot, value.serialize());\n}\n\n// Ideally we'd do the following, but we cannot because of https://github.com/noir-lang/noir/issues/4633\n// pub fn read_historical<T, N>(\n//     storage_slot: Field,\n//     context: PrivateContext\n// ) -> T where T: Deserialize<N> {\n//     let mut fields = [0; N];\n//     for i in 0..N {\n//         fields[i] = public_storage_historical_read(\n//                 context,\n//                 storage_slot + i as Field,\n//                 context.this_address()\n//             );\n//     }\n//     T::deserialize(fields)\n// }\n\nmod tests {\n    use dep::std::test::OracleMock;\n    use dep::protocol_types::traits::{Deserialize, Serialize};\n    use crate::public_storage;\n\n    struct TestStruct {\n        a: Field,\n        b: Field,\n    }\n\n    impl Deserialize<2> for TestStruct {\n        fn deserialize(fields: [Field; 2]) -> TestStruct {\n            TestStruct { a: fields[0], b: fields[1] }\n        }\n    }\n\n    impl Serialize<2> for TestStruct {\n        fn serialize(self) -> [Field; 2] {\n            [self.a, self.b]\n        }\n    }\n\n    #[test]\n    fn test_read() {\n        let slot = 7;\n        let written = TestStruct { a: 13, b: 42 };\n\n        OracleMock::mock(\"storageRead\").with_params((slot, 2)).returns(written.serialize());\n\n        let read: TestStruct = public_storage::read(slot);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n\n    #[test]\n    fn test_write() {\n        let slot = 7;\n        let to_write = TestStruct { a: 13, b: 42 };\n\n        let mock = OracleMock::mock(\"storageWrite\").returns([0; 2]); // The return value is unused\n\n        public_storage::write(slot, to_write);\n        assert_eq(mock.get_last_params(), (slot, to_write.serialize()));\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    */\n    pub fn emit_unencrypted_log_with_selector<T, N>(\n        &mut self,\n        event_selector: Field,\n        log: T\n    ) where T: Serialize<N> {\n        emit_unencrypted_log(event_selector, Serialize::serialize(log).as_slice());\n    }\n    // For compatibility with the selector-less API. We'll probably rename the above one.\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        self.emit_unencrypted_log_with_selector(/*event_selector=*/ 5, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(event_selector: Field, message: [Field]) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(event_selector: Field, message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}