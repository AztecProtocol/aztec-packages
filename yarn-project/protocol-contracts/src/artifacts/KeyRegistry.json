{"transpiled":true,"noir_version":"0.30.0+69d3505aae6ab262912d841822f4f3a67dd1dce6","name":"KeyRegistry","functions":[{"name":"register","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"param_witnesses":{"address":[{"end":4,"start":3}],"inputs":[{"end":3,"start":0}],"keys":[{"end":13,"start":5}],"partial_address":[{"end":5,"start":4}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"partial_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::partial_address::PartialAddress"},"visibility":"private"},{"name":"keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"ivpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"ovpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"tpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}}],"kind":"struct","path":"aztec::keys::public_keys::PublicKeys"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"7b3tjjS5cqR5L+e3sAiSzi/dymKx0MxoFgKEo8FIs8BAOPc+2VIlq6pfj2Zm0DsrjW6/1JKiKmhPxZtmzsw0/vtf/ts//pf/9f/9v//01//+L//6l7//v//9L//8L//1H/7tn/7lr7f/7d//cvxf8fiP/+u//o9/+Otv/4d//bd/+J//9pe/P/7uL//41/92+59/+7u//Pd/+ud//Mvfp3T87f/5u99+IDz7A/HZH0jP/oA8+wP52R8oz/5AffYH2rM/0J/8gfTsXzo9+5dO6l86hqN+/EwMoX37sb/75eqc+8fFrcq4tmXl0l5K+7i21xjGxbE05eok91Wk9rmIqF5astyvLTX+8cXlSB/XlkO+XvqfSBKR/B6JEMnvkWQi+T2SQiS/R1KJ5PdIGpH8Hkknkt8hkYNIfo8kEMnvkTC9/oKE6fUXJOIRSbr/3pLzr0hcptc/RuIyvf4xEpfp9Y+RuEyvf4zEZXr9QyTZZVT7YyQuo9ofI3EZ1f4YiRDJ75Ewqv2ChFHtFySMar8gYVT7BQmj2u+RFJcbjX+MhOn1FyRMr78gYXr9BYkQye+RML3+goTp9RckTK+/IGF6/QUJ0+vvkVSm11+QML3+goTp9RckTK+/IBEi+T0SptdfkDC9/oKE6fUXJEyvvyBhev09ksb0+gsSptdfkDC9/oKE6fUXJEIkv0fC9PoLEka1X5Awqv2ChFHt90g6o9ovSBjVfkHCqPYLEka1X5AIkfweCaPaL0i40fgLEqbXX5Awvf6ChOn190jCsX98/RC6fyj9ELp/1PwQun+A/BAqXoTuH/Y+hO4f4T6E7h/MPoTuH7c+hO4fov5TaPCSjIKXZBS8JKPgJRkF8SLUSzIKXpJR8JKMgpdkFLwko+glGUUvySh6SUbRSzKKXpJR9JKMopdkFL0ko+glGUUvySh5SUbJSzJycAzIh1AvycjBkR0fQr0kIwfHa3wI9ZKMHByF8SHUSzJycGzFh1AvycjBERMfQr0kIwfHQXwI9ZKMHBzd8CHUSzJycMzCh1AvySh7SUYOzn74EOolGTk4p+FDqHgR6iUZOTgp4UOol2Tk4FSDD6FekpGDEwg+hHpJRvv0wPchtB7K1yr3aXefCd3kVVdCvS9CQs+XL/6gsslLtC2VXTq5jals8uJvTGWTGdqYyiYDtzEVIRWFyiYRxJjKJnO/MZVNNgmMqTDbalSYbRUquzR2G1NhttWoMNtqVJhtNSpCKgoVZluNCrOtRoXZVqPCbKtRYbZVqOxScW5MhdlWo8Jsq1FhttWoiEMqMeZ0lxdrUqh4zLZzKh6zbYwpflIRhYrHvBKl3y+O+Th+oRJ36bQ2puIxr8ypeMwrcyoe88qcipCKQsVlXplScZlXplQ87sXNqXjci5tTYbZVqOzSSm5MhdlWo8Jsq1ERUlGoMMVpVJjiNCounbnJ2KFsRf744pTqWIUcv27cxV0qtH8SoUvPt0XoMiDYInS5U2aLUIhwFaHL9GaL0GXUs0XocnfPFqHLrUBbhJxOVhHuUmP/kwg5nSwj5HSyjJChZoKwtvJxbe3KVtcujes/BnCX8uQ/D2Afn3zsuSoAhQDXAPKf8AxgvX/KtLesAORMsgiQE8kawF0qkn8OIKeRRYCcRRYBMgcuAhQCXAPI90gWAXIzYREgJ5FFgJxEFgFyEpkADEfKHxeHoylbqruUkv8kQk4jywg5jywj5ESyjFCIcBUhp5JlhJxLlhFyMllGyNlkGSGnk1WELo/YMEbI6WQZIaeTZYScTpYRChGuIuR0soyQ08kyQk4nywg5nSwj5HSyitDlISnPIQxtIAytKAg5nSwj5HSyjJDTyTJCIcJVhJxOlhFyOllGyOlkGSGnk1WELs9oMUbIaL2MkNF6GSGj9TJCIcJVhIzWywgZrZcRMlovI2S0XkbIjf9FhMnniUy2CDmdLCPkdLKMkNPJMkIhwlWEnE6WEXI6WUXo8yiepxDGMBDG0BWEDDXLCGknU4RJBkJJCkLayTJC2skyQm52LSPkZtcyQm52rSLk2U7rCJkLlxFys2sZITe7lhEKEa4i5HSyjJDTyTJCTifLCDmdLCPkdLKKkGc7rSPkdLKMkNPJMkJOJ6JQEVJRqHCG0KhwLNCoMOlrVBjeNSrM4woVYcTWqDA1a1QYhDUqzLYaFSEVhQqzrUaF2VajwmyrUWG2Vaj4PPKvx/sqYk9RoeLSmadUXL7a9hwGFfVfkMtX2ykVl6+2UyoudxJmVHweNjal4nInYUrFZ16ZUfGZV2ZUhFQUKi53EqZUmG01Kh6zbfos+L79p/JlRJeHYM2peMy2Uyouj6qaU/GYbedUPGbbORWP2XZORUhFoeIx286peMy2cyrMthoVZluNCrOtQsXlKT1zKkxxGhWmOI2KkIpChSlOo+IyxX3W06XQm0LFZYqbUnGZ4qZUXKa4GRWXZ+rMqbjMtlMqLrPtlIpLZ47xuP/iGJX3Dl0eazGjIi7PCEixfVLpVaHi8tV2SsXlq+2UisudhCkVIRWFisudhCkVn3llRsVnXplRcbmTMKXicidhRsXlURFzKsy2GhWX2fbLL05Fo+Iy206pCKkoVFxm2ykVl9l2SsVltk11/OLbfKxQcZniZlRcHuwwp+IyxU2p+ExxMyo+U9yMipCKQsVniptR8ZniZlSY4jQqLncop1SYbRUqLo8FmFNhttWoMNtqVJhtNSpCKgoVZluNCrOtRoXZVqPCbKtRYbZVqLjs459TYbbVqDDbalSYbTUqQioKFWZbjQqzrUaF2VajwmyrUWG2VahkZluNCrOtRoXZVqPCbKtREVJRqDDbalSYbTUqzLYaFWZbjQqzrULF5ekncyrMthoVZluNCrOtRkVUKscos4khlQmVcNvR+7g65PzlJsdLwaSS5X5tqfGPLy7H/cTDomLJxKJhKcSiYanEomFpxKJh6cSiYDk5A8U9lkAsGpZILBqWRCwaFiEWDQtTrorFa8pN999bclaweE25EyxeU+4Ei9eU+8dYmteUO8HiNeVOsHhNuRMsXlPuBIsQi4bFa8qdYGHKVbEw5apYmHJVLEy5GpbOlKtiYcpVsTDlqliYclUsQiwaFqZcFQtTroqFKVfFwpSrYmHKVbDkgylXxcKUq2JhylWxMOWqWIRYNCxMuSoWplwVC1OuioUpV8XClKthCUy5KhamXBULU66KhSlXxSLEomFhylWxMM6pWBjnVCyMcxqWyDinYmGcU7EwzqlYGOdULEIsGhbGORULNy1VLEy5KhamXBULU66GJblIuR9aXUTXD60u8uiHVhch80OrONLqIg5+aHWR8T60ughuH1pdpLEPrS4i1n9qFUe5SRzlJnGUm8RRbhJHuUkc5SZxlJvEUW4SR7lJHOWm7Cg3ZUe5KTvKTdlRbsqOclN2lJuyo9yUHeWm7Cg3ZUe5qTjKTcVRbiqOclNxlJt8HBfzodVRbvJxsMuHVke5yccRLB9aHeUmH4elfGh1lJt8HGvyodVRbvJxAMmHVke5ycdRIR9aHeUmH4d6fGh1lJt8HL/xodVRbvJxUMaHVke5yceRFh9aHeUmH4dPfGh1lJt8HBPxodVRbvJxoMOHVke5aasy/T601kP5TuhWDfkzrfu8Dkuo/eNaCT1fvvgDzD4v2qZgykZl5sZg9rEDYzD7zNzGYPYZ0I3BCMHoYPaJJsZg9tknMAazz6aCMRgm3xMwTL46mI0Kzo3BMPmegGHyPQHD5HsCRghGB8PkewKGyfcEDJPvCRgm3xMwTL46mI264I3BMPmegGHyPQHD5HsCRnyCiTGnu8JYkwLGafKdg3GafGNM8ROMKGCc5pgo/X5xzMfxK5iN2r6NwTjNMXMwTnPMHIzTHDMHIwSjg/GaY6ZgvOaYKRinO3hzME538OZgmHx1MBv1tRuDYfI9AcPkewJGCEYHw4B3AoYB7wSMV7tuMrY2W5E/vjilOlYhh7Ldt1Gn+E9S9BoEbCl6TQ22FL1urtlSFFI0oOg11dlS9BoBbSl63RC0peh199CWImcXA4ob9fr/JEXOLhYUObtYUGTSmVOs7a6vdmVfbKPm+R9juFFr9J/HsI+PWPZcFYZChssM+W/5AYb1/onW3pTPhm/UsvxzDDmvLDPcqBX65xhyVllnyEllnSHz4TpDIcNlhnx/ZZ0h9xzWGXJOWWfIOWWdIeeUOcNwpDuOcDRlF3ajHvafpMhZxYIipxULipxXLCgKKRpQ5MxiQZFTiwVFzi0WFDm5WFDk7LJOsXo9YcSYImcXC4qcXSwocnaxoCikaECRs4sFRc4uFhQ5u1hQ5OxiQZGziwFFr2fEPEcxDBy3/ywKRc4uFhQ5u1hQ5OxiQVFI0YAiZxcLipxdLChydrGgyNnFgKLX82mMKTJ1W1Bk6ragyNRtQVFI0YAiU7cFRaZuC4pM3RYUmbotKPIdAwOKbs+ksqXI2cWCImcXC4qcXSwoCikaUOTsYkGRs4sBRbdnED1FMYZBMYauUGTSsaBId3mEYpJBUZJCke5iQZHuYkGRO2MWFLkzZkGRO2MGFHmulQlF5kULitwZs6DInTELikKKBhQ5u1hQ5OxiQZGziwVFzi4WFDm7GFDkuVYmFDm7WFDk7GJBkbPL7yl+gBGC0cFwwjgBw6HhBAzngBMwjPYnYJjWdTCVAfwEDDP1CRjG5BMwTL4nYIRgdDBMvidgmHxPwDD5noBh8tXBuD0Dscf7KmJPUQHj1a6nYLy++PYcBhj1n5LXF98pGK8vvlMwXrcdZmDcnrs2BeN122EKxm2OmYFxm2NmYIRgdDBetx2mYJh8T8A4Tb7ps8f89p/K9yO9ngc2B+M0+c7ANK+nds3BOE2+czBOk+8cjNPkOwcjBKODcZp852CcJt85GCbfEzBMvidgmHx1MF5PK5qDYcA7AcOAdwJGCEYHw4B3AsZrwPts20uhNwWM14A3BeM14E3BeA14MzBejxeag/GafKdgvCbfKRivdh3jcf/FMYoCxqtdz8B4PR8hxfYJplcFjNcX3ykYry++UzBetx2mYIRgdDBetx2mYNzmmBkYtzlmBsbrtsMUjNdthxkYr+dlzMEw+Z6A8Zp8v/ziVDQwXpPvFIwQjA7Ga/KdgvGafKdgvCbfVMcvlkPZwfN6GsYUjNcDLuZgvAa8KRi3AW8Gxm3Am4ERgtHBuA14MzBuA94MDAPeCRivW5tTMEy+OhivxyPMwTD5noBh8j0Bw+R7AkYIRgfD5HsChsn3BAyT7wkYJt8TMEy+Ohiv5xLMwTD5noBh8j0Bw+R7AkYIRgfD5HsChsn3BAyT7wkYJt8TMEy+OpjG5HsChsn3BAyT7wkYJt8TMEIwOhgm3xMwTL4nYJh8T8Aw+Z6AYfLVwXg9FGYOhsn3BAyT7wkYJt8TMKKCCVkGmBa/gfn4uXzx58rFn6sXf65d/Ll+6ef6yXEG858LF38uXvy5dPHn5OLP5Ys/Vy7+XL34c+3iz118XsLF5yVcfF7CxeclXHxewsXnJVx8XsLF5yVcfF7CxeclXHxe4sXnJV58XuLF5yVefF7ixeclXnxe4sXnJV58XuLF5yVefF7SxeclXXxe0sXnJV18XtLF5yVdfF7SxeclXXxe0sXnJV18XuTi8yIXnxe5+LzIxedFLj4vcvF5kYvPi1x8XuTi8yIXn5d88XnJF5+XfPF5yRefl3zxeckXn5d88XnJF5+XfPF5yRefl3LxeSkXn5dy8XkpF5+XcvF5KRefl3LxeSkXn5dy8XkpF5+XevF5qRefl3rxeakXn5d68XmpF5+XevF5qRefl3rxeakXn5d28XlpF5+XdvF5aRefl3bxeWkXn5d28XlpF5+XdvF5aRefl37xeekXn5d+8XnpF5+Xi/u7/eL+br+4v9sv7u/2i/u7/eL+bjgubvDefjBc/cF49QfT1R+Uqz+Yr/5gufqD9eoPtqs/ePXJCVefnHD1yQlXn5xw9ckJV5+ccPXJCVefnHD1yQlXn5xw9cmJV5+cePXJiVefnHj1yYlXn5x49cmJV5+cePXJiVefnHj1yUlXn5x09clJV5+cdPXJSVefnHT1yUlXn5x09clJV5+cdPXJkatPjlx9cuTqkyNXnxy5+uTI1SdHrj45cvXJkatPjlx9cvLVJydffXLy1ScnX31y8tUnJ199cvLVJydffXLy1ScnX31yytUnp1x9csrVJ6dcfXLK1SenXH1yytUnp1x9csrVJ6dcfXLq1SenXn1y6tUnp159curVJ6defXLq1SenXn1y6tUnp159ctrVJ6ddfXLa1SenXX1y2tUnp119ctrVJ6ddfXLa1SenXX1y+tUnp199cvrVJ6dffXL61SenX31y+tUnp199cvrVJ+fqHnK4uoccru4hh6t7yOHqHvJtfrj6g/nqD5arP1iv/mC7+oNXn5yre8jh6h5yuLqHHK7uIYere8jh6h5yuLqHHK7uIYere8jh6h5yuLqHHK7uIYere8jh6h5yuLqHHK7uIYere8jh6h5yuLqHHK7uIYere8jh6h5yuLqHHK7uIYeTPeRY7l+1iunI335Q+cZXGl/4+vIdrts/PO27ZPl+Itu3484lar83y/3iXr5+h6u0sfyMvfyCvfyKvfyGvfwOvfyTt0tglh+xl5+wl49tW4JtW4JtW4JtW4JtW4JtWydv8sIsH9t1s4Hr/vYe5n1N/7HoPxRwX9Ex+a3x9l7sfQ23d3O+/NY6Fp+QFy/Ii8/Iiy/Ii6/Ii2/Ii+/Aiy8H8uID8uKRHbYgO2xBdtiC7LAF2WELssMWZIctyA5bkR22IjtsRXbYiuywFdlhK7LDVmSHrcgOW5EdtiI7bEN22IbssA3ZYRuywzZkh23IDtuQHbYhO2xDdtiG7LAd2WE7ssN2ZIftyA7bkR22IztsR3bYjuywHdlhO7DDxgPYYeMB7LDxAHbYeAA7bDyAHTYewA4bD2CHjQeww8YD2GHjgeywAdlhA7LDBmSHDcgOG5AdNiA7bEB22IDssAHZYQOyw0Zkh43IDhuRHTYiO2xEdtiI7LAR2WEjssNGZIeNyA6bkB02ITtsQnbYhOywFsVJP7d4ZIdNyA6bkB02ITtsQnZYQXZYQXZYQXZYQXZYi46nn1s8ssMKssMKssMKssMKssNmZIfNyA6L3OkUkTudInKnU0TudIrInU4RudMpInc6ReROp4jc6RSRO50icqdTRO50isidThG50ykidzpF5E6niNzpFJE7nSJyp1NE7nSKyJ1OEbnTKSJ3OkXkTqeI3OkUkTudInKnU0TudIrInU4RudMpInc6ReROp4jc6RSRO50icqdTRO50isidThG50ykidzpF5E6niNzpFJE7nSJyp1NE7nSKyJ1OEbnTKSJ3OkXkTqeE3OmUkDudEnKnU0LudEoHsMMm5E6nhNzplJA7nRJyp1NC7nRKyJ1OCbnTKSF3OiXkTqeE3OmUkDudEnKnU0LudErInU4JudMpIXc6JeROp4Tc6ZSQO50ScqdTQu50SsidTgm50ykhdzol5E6nhNzplJA7nRJyp1NC7nRKyJ1OCbnTKSF3OiXkTqeE3OmUkDudEnKnU0LudErInU4JudMpIXc6JeROp4Tc6ZSQO50ScqdTQu50SsidTgm50ykhdzol5E6nhNzplJA7nRJyp1NC7nRKyJ1OCbnTKSF3OiXkTqeE3OmUkDudEnKnU0LudErInU4JudMpIXc6JeROp4Tc6ZSQO50ScqdTQu50SsidTgm50ykhdzol5E6nhNzplJA7nRJyp1NC7nRKyJ1OCbnTKSF3OiXkTqeE3OmUkDudEnKnU0LudErInU4JudMpIXc6JeROp4Tc6ZSQO50ScqdTQu50SsidTgm500mQO50EudNJkDudBLnTSQ5ghxXkTidB7nQS5E4nQe50EuROJ0HudBLkTidB7nQS5E4nQe50EuROJ0HudBLkTidB7nQS5E4nQe50EuROJ0HudBLkTidB7nQS5E4nQe50EuROJ0HudBLkTidB7nQS5E4nOel0SqmNxVeZ3KaPi3trk6WHfF986J/XRona781yv7iX43MVsbSx/IS9fMFefsZefsFefsVefode/klJEszyA/bysW1LsG1LsG1LsG1LsG1LsG3rpDQJZvkGrvtjw0o+kBcfkBcfkRefkBcvyIvPyIsvyIuvyItvyItHdtiC7LAF2WELssMWZIctyA5bkB22IDtsQXbYguywBdlhK7LDVmSHrcgOW5EdtiI7bEV22IrssBXZYSuyw1Zkh23IDtuQHbYhO2xDdtiG7LAN2WEbssM2ZIdtyA7bkB22IztsR3bYjuywHdlhO7LDdmSH7cgO25EdtiM7bAd22HwAO2w+gB02H8AOmw9gh80HsMPmA9hh8wHssPkAdth8ADtsPpAdNiA7bEB22IDssAHZYQOywwZkhw3IDhuQHTYgO2xAdtiI7LAR2WEjssNGZIeNyA4bkR02IjtsRHbYiOywEdlhE7LDJmSHTcgOm5Ad1qIy6ecWj+ywCdlhE7LDJmSHTcgOK8gOK8gOK8gOK8gOa9Hu9HOLR3ZYQXZYQXZYQXZY5E6njNzplJE7nTJyp1NG7nTKyJ1OGbnTKSN3OmXkTqeM3OmUkTudMnKnU0budMrInU4ZudMpI3c6ZeROp4zc6ZSRO50ycqdTRu50ysidThm50ykjdzpl5E6njNzplJE7nTJyp1NG7nTKyJ1OGbnTKSN3OmXkTqeM3OmUkTudMnKnU0budMrInU4ZudMpI3c6ZeROp4zc6ZSRO50ycqdTRu50ysidThm50ykjdzpl5E6njNzplJE7nQpyp1NB7nQqyJ1OBbnTqRzADluQO50KcqdTQe50KsidTgW506kgdzoV5E6ngtzpVJA7nQpyp1NB7nQqyJ1OBbnTqSB3OhXkTqeC3OlUkDudCnKnU0HudCrInU4FudOpIHc6FeROp4Lc6VSQO50KcqdTQe50KsidTgW506kgdzoV5E6ngtzpVJA7nQpyp1NB7nQqyJ1OBbnTqSB3OhXkTqeC3OlUkDudCnKnU0HudCrInU4FudOpIHc6FeROp4Lc6VSQO50KcqdTQe50KsidTgW506kgdzoV5E6ngtzpVJA7nQpyp1NB7nQqyJ1OBbnTqSB3OhXkTqeC3OlUkDudCnKnU0HudCrInU4FudOpIHc6FeROp4Lc6VSQO50KcqdTQe50KsidTgW506kgdzoV5E6ngtzpVJA7nQpyp1NB7nQqyJ1OBbnTqSB3OhXkTqeC3OlUkDudCnKnU0HudCrInU4FudOpIHc6FeROp4rc6VSRO50qcqdTRe50qgeww1bkTqeK3OlUkTudKnKnU0XudKrInU4VudOpInc6VeROp4rc6VSRO50qcqdTRe50qsidThW506kidzrVk04nOcbiRfLkNn0o7a1Nlh7yffGhf14bJWq/N8v94l6OT4SxtLH8iL38hL18wV5+xl5+wV5+w15+h17+SU0SzPKxbSth21bCtq2EbVsJ27YStm2dlCbBLN/AdX9sWEkdePFyIC8+IC8+Ii8+IS9ekBefkRdfkBdfkReP7LCC7LAZ2WEzssNmZIfNyA6bkR02IztsRnbYjOywGdlhM7LDFmSHLcgOW5AdtiA7bEF22ILssAXZYQuywxZkhy3IDluRHbYiO2xFdtiK7LAV2WErssNWZIetyA5bkR22IjtsQ3bYhuywDdlhG7LDNmSHbcgO25AdtiE7bEN22IbssB3ZYTuyw3Zkh+3IDtuRHbYjO2xHdtiO7LAd2WE7sMO2A9hh2wHssO0Adth2ADtsO4Adth3ADtsOYIdtB7DDtgPYYduB7LAB2WEDssMGZIcNyA4bkB02IDtsQHbYgOywAdlhA7LDRmSHjcgOG5EdNiI7rEVh0s8tHtlhI7LDRmSHjcgOG5EdNiE7bEJ22ITssAnZYS26nX5u8cgOm5AdNiE7LHKnU0PudGrInU4NudOpIXc6NeROp4bc6dSQO50acqdTQ+50asidTg2506khdzo15E6nhtzp1JA7nRpyp1ND7nRqyJ1ODbnTqSF3OjXkTqeG3OnUkDudGnKnU0PudGrInU4NudOpIXc6NeROp4bc6dSQO50acqdTQ+50asidTg2506khdzo15E6nhtzp1JA7nRpyp1ND7nRqyJ1ODbnTqSF3OjXkTqeG3OnUkDudGnKnU0PudGrInU4NudOpIXc6NeROp4bc6dSQO50acqdTQ+50asidTg2506khdzo15E6njtzp1JE7nTpyp1NH7nTqB7DDduROp47c6dSRO506cqdTR+506sidTh2506kjdzp15E6njtzp1JE7nTpyp1NH7nTqyJ1OHbnTqSN3OnXkTqeO3OnUkTudOnKnU0fudOrInU4dudOpI3c6deROp47c6dSRO506cqdTR+506sidTh2506kjdzp15E6njtzp1JE7nTpyp1NH7nTqyJ1OHbnTqSN3OnXkTqeO3OnUkTudOnKnU0fudOrInU4dudOpI3c6deROp47c6dSRO506cqdTR+506sidTh2506kjdzp15E6njtzp1JE7nTpyp1NH7nTqyJ1OHbnTqSN3OnXkTqeO3OnUkTudOnKnU0fudOrInU4dudOpI3c6deROp47c6dSRO506cqdTR+506sidTh2506kjdzp15E6njtzp1JE7nTpyp1NH7nTqyJ1OHbnTqSN3OnXkTqeO3OnUkTudOnKnU0fudOrInU4duNMpHsCdTrfF4zrsbfG4DntbPK7D3haP67C3xeM67G3xuA57Wzyuw94Wj+uwt8UjO+xZp1Pt9x/MoUxu09Nd6W0zYrL0kO+Lvw3/49ooUfu9We4X93LI59WljeUH7OVH7OUn7OUL9vIz9vIr9vIb9vI79PIjtm1FbNuK2LYVsW0rYttWxLats9IklOUbuO6PDSuxIS++Ay8+HciLD8iLj8iLT8iLF+TFZ+TFF+TFIztsQnbYhOywguywguywguywguywguywguywguywguywguywguywGdlhM7LDZmSHzcgOm5EdNiM7bEZ22IzssBnZYTOywxZkhy3IDluQHbYgO2xBdtiC7LAF2WELssMWZIctyA5bkR22IjtsRXbYiuywFdlhK7LDVmSHrcgOW5EdtiI7bEN22IbssA3ZYRuywzZkh23IDtuQHbYhO2xDdtiG7LAd2WE7ssN2ZIftyA7bkR22IztsR3bYjuywHdlhO7DDhgPYYcMB7LDhAHbYcAA7bDiAHTYcwA4bDmCHDQeww4YD2GHDgeywAdlhA7LDBmSHDcgOa1GX9HOLR3bYgOywAdlhA7LDBmSHjcgOG5EdNiI7bER2WItmp59bPLLDRmSHRe50CsidTgG50ykgdzoF5E6ngNzpFJA7nQJyp1NA7nQKyJ1OAbnTKSB3OgXkTqeA3OkUkDudAnKnU0DudArInU4BudMpIHc6BeROp4Dc6RSQO50CcqdTQO50CsidTgG50ykgdzoF5E6ngNzpFJA7nQJyp1NA7nQKyJ1OAbnTKSB3OgXkTqeA3OkUkDudAnKnU0DudArInU4BudMpIHc6BeROp4Dc6RSQO50CcqdTQO50CsidTgG50ykgdzoF5E6ngNzpFJA7nQJyp1NA7nQKyJ1OAbnTKSB3OgXkTqeA3OkUkDudAnKnU0DudArInU4BudMpIHc6BeROp4Dc6RSQO50CcqdTQO50isidThG50ykidzpF5E6neAA7bETudIrInU4RudMpInc6ReROp4jc6RSRO50icqdTRO50isidThG50ykidzpF5E6niNzpFJE7nSJyp1NE7nSKyJ1OEbnTKSJ3OkXkTqeI3OkUkTudInKnU0TudIrInU4RudMpInc6ReROp4jc6RSRO50icqdTRO50isidThG50ykidzpF5E6niNzpFJE7nSJyp1NE7nSKyJ1OEbnTKSJ3OkXkTqeI3OkUkTudInKnU0TudIrInU4RudMpInc6ReROp4jc6RSRO50icqdTRO50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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"param_witnesses":{"compute_nullifier":[{"end":5,"start":4}],"contract_address":[{"end":1,"start":0}],"nonce":[{"end":2,"start":1}],"note_type_id":[{"end":4,"start":3}],"serialized_note":[],"storage_slot":[{"end":3,"start":2}]},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[5,6,7,8]},"bytecode":"H4sIAAAAAAAA/+2b227aQBCG18RJTJ24YGMMgQQIyUXvDA2nO16mfe3eV+orVM2YnTJsp2hRx1tWYqWIsb2e/5t/D1jICdSuRe9/gY6v9eeN+rNhn63+LP+tzQRzlXVyBp5wNjzhvPKEMxTkDBhO+Ax1DOsO1tytOlyPv9tWqChTlELBBLoi19URwIMboUU6oBfHUuDrcnNDklNwpcFDfQ0/ASfW1yhYrIus+pBzWGiDnEOdK3IOd0bUibQpwvUuoj2yXN73CQA1NHUu5I5JTK8NiXVhTTVey9f4VsuYlLtVjGNyrXPfkmP0Cj0U/OaYUe1A/zWJptJjhPGA9MV+6EeDjDG0e7Wf180j94XGfQnpc8PUPxau/9bgMecsjEFLx204xj2BsH0g9W1l2ErIG8vnndExCHVu5I9JTYm43/M15L9Th838VhqTOCE89+I85ayeOndj95Gwy+RdvIFXLcOrO8OrhPShDK0a/AuILubG4xajLefFcg3abQsv2gxP27EXbUZb0IsNaKcWXqQMT+rYi5TRlvNi9Rm0MwsvMoYnc+xFxmjLeTGvni06Fl50GJ6OYy86jLbgGqnmRW7hRc7w5I69yBltQS++gnbXwosuw9N17EWX0Rb04gtoFxZeFAxP4diLgtEW3Dur54uehRc9hqfn2Iseoy3oxRy0+xZe9BmevmMv+oy24BqptB8svHhgeB4ce4F6pzJ3PGQuPGTOzoA5MmIZ7WW1fw4svBgwPAPHXtDfck5hzs+AOTJiGe3lArSHFl4MGZ6hYy9Q71Tm1EPmzEPmrofMuYfMhYfM5zCfIyOW0V5Ve+ijhRePDM+jYy9Q71Tm1EPmgYfM2RkwR0Yso72qfpt7svDiieF5cuwF6p3K3POQuX0GzJERy2ivlqA9svBixPCMHHuBeqcy9z1kLjxkHnjInHnI3PWQOfeQ+bIG3TCnZ8AM773gOzA/auWZb2KDBz1TBqMyGGMSJ4QR+26V3PsqiVE7ak3E/diNjzlf8HhSq/Z8DXmn8jVVz/IvOhe+wzdlanrVcSDs5wvJGxAdPB+S+Dvpi/3QD1y3yA7vXD3r+PXIfSPjvoT0eWbqHwvXPzV4pgYzjMk3wlHH3LKZ1y21X8ufCE8N++AbfScXm82+Q/cYQZ5ZTXWW9B2+n0p2TU8Mr5qGVwnpQ/fo/7VvXpgvzH9jps8TTXKO8uC5hlEL/f+GCcnxC57ToyHuNQAA","debug_symbols":"ndpLahtBGIXRvfTYBN2/H1XtrYQQZFsOAiEZSw4E4b1HSsgCcmZd3X1n3+hQ1+Fl9/Tx4/v++Ho6D49fr8Ph9Ly97E/H2+k6bL5U//P2/LY93l+cL9v3y/A4tnoYdseX+1P7fBhe94fd7XncfH57uI9WGI0bGUVGJaNRRpOMZhktMmoykiJGKWKSIiYpYpIiJilikiImKWKSIiYpYpIiJililiJmKWKWImYpYpYiZililiJmKWKWImYpYpEiFilikSIWKWKRIhYpYpEiFilikSIWKaJJEU2KaFJEkyKaFNGkiCZFNCmiSRFNiuhSRJciuhTRpYguRXQpoksRXYroUkSXIlYpYpUiVililSJWKWKVIlYpYpUiVililSKy2dAqtCpajbSaaDXTaqFVo1WnFbURaiPURqiNUBuhNkJthNoItRFqI9RGURtFbRS1UdRGURtFbRS1UdQGgWZINEOkGTLNEGqGVDPEmiHXDMFmSDZDtBmyzRBuhnQzxJsh3wwBZ0g4Q8QZMs4QcoaUM8ScIecMQWdIOkPUGbLOEHaGtDPEnSHvDIFnSDxD5BkyzxB6htQzxJ4h9wzBZ0g+Q/QZss8Qfob0M8SfIf8MAWhIQEMEGjLQEIKGFDTEoCEHDUFoSEJDFBqy0BCGhjQ0xKEhDw2BaEhEQyQaMtEQioZUNMSiIRctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLbvoSS5a5KJFLlrkokUuWuSiRS5a/+2it9PP7ft++3TY3e/23j9+HJ//XfW9HS+/3v5+uf37Gw=="},{"name":"rotate_npk_m","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"param_witnesses":{"address":[{"end":4,"start":3}],"inputs":[{"end":3,"start":0}],"new_npk_m":[{"end":6,"start":4}],"nonce":[{"end":7,"start":6}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"new_npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"npk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"1"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY, Context>, Context>"}}],"kind":"struct"}},{"name":"npk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"2"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY, Context>, Context>"}}],"kind":"struct"}},{"name":"ivpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"3"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY, Context>, Context>"}}],"kind":"struct"}},{"name":"ivpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"4"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY, Context>, Context>"}}],"kind":"struct"}},{"name":"ovpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"5"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY, Context>, Context>"}}],"kind":"struct"}},{"name":"ovpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"6"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY, Context>, Context>"}}],"kind":"struct"}},{"name":"tpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"7"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY, Context>, Context>"}}],"kind":"struct"}},{"name":"tpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"8"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY, Context>, Context>"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"new_npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"KeyRegistry::rotate_npk_m_parameters"}}],"kind":"struct","path":"KeyRegistry::rotate_npk_m_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"partial_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::partial_address::PartialAddress"}},{"name":"keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"ivpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"ovpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"tpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}}],"kind":"struct","path":"aztec::keys::public_keys::PublicKeys"}}],"kind":"struct","path":"KeyRegistry::register_parameters"}}],"kind":"struct","path":"KeyRegistry::register_abi"}]}},"file_map":{"109":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n"},"118":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/public_storage.nr","source":"use dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::oracle::storage::{storage_read, storage_write};\n\npub fn read<T, N>(storage_slot: Field) -> T where T: Deserialize<N> {\n    T::deserialize(storage_read(storage_slot))\n}\n\npub fn write<T, N>(storage_slot: Field, value: T) where T: Serialize<N> {\n    storage_write(storage_slot, value.serialize());\n}\n\n// Ideally we'd do the following, but we cannot because of https://github.com/noir-lang/noir/issues/4633\n// pub fn read_historical<T, N>(\n//     storage_slot: Field,\n//     context: PrivateContext\n// ) -> T where T: Deserialize<N> {\n//     let mut fields = [0; N];\n//     for i in 0..N {\n//         fields[i] = public_storage_historical_read(\n//                 context,\n//                 storage_slot + i as Field,\n//                 context.this_address()\n//             );\n//     }\n//     T::deserialize(fields)\n// }\n\nmod tests {\n    use dep::std::test::OracleMock;\n    use dep::protocol_types::traits::{Deserialize, Serialize};\n    use crate::public_storage;\n\n    struct TestStruct {\n        a: Field,\n        b: Field,\n    }\n\n    impl Deserialize<2> for TestStruct {\n        fn deserialize(fields: [Field; 2]) -> TestStruct {\n            TestStruct { a: fields[0], b: fields[1] }\n        }\n    }\n\n    impl Serialize<2> for TestStruct {\n        fn serialize(self) -> [Field; 2] {\n            [self.a, self.b]\n        }\n    }\n\n    #[test]\n    fn test_read() {\n        let slot = 7;\n        let written = TestStruct { a: 13, b: 42 };\n\n        OracleMock::mock(\"storageRead\").with_params((slot, 2)).returns(written.serialize());\n\n        let read: TestStruct = public_storage::read(slot);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n\n    #[test]\n    fn test_write() {\n        let slot = 7;\n        let to_write = TestStruct { a: 13, b: 42 };\n\n        let mock = OracleMock::mock(\"storageWrite\").returns([0; 2]); // The return value is unused\n\n        public_storage::write(slot, to_write);\n        assert_eq(mock.get_last_params(), (slot, to_write.serialize()));\n    }\n}\n"},"120":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"123":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse dep::std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n"},"125":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse dep::std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n"},"127":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{hash::pedersen_hash, traits::FromField};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::public_storage;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we \n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the \n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling \n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need. \n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and \n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write_value_change(value_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write_delay_change(delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        public_storage::read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        public_storage::read(self.get_delay_change_storage_slot())\n    }\n\n    fn write_value_change(self, value_change: ScheduledValueChange<T>) {\n        public_storage::write(self.get_value_change_storage_slot(), value_change);\n    }\n\n    fn write_delay_change(self, delay_change: ScheduledDelayChange<INITIAL_DELAY>) {\n        public_storage::write(self.get_delay_change_storage_slot(), delay_change);\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(*self.context);\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes. \n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20 \n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is \n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the \n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(\n        self,\n        context: PrivateContext\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField {\n        let header = context.get_header();\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let value_change_slot = self.get_value_change_storage_slot();\n        let mut raw_value_change_fields = [0; 3];\n        for i in 0..3 {\n            raw_value_change_fields[i] = header.public_storage_historical_read(\n                value_change_slot + i as Field,\n                context.this_address()\n            );\n        }\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let delay_change_slot = self.get_delay_change_storage_slot();\n        let raw_delay_change_fields = [header.public_storage_historical_read(delay_change_slot, context.this_address())];\n\n        let value_change = ScheduledValueChange::deserialize(raw_value_change_fields);\n        let delay_change = ScheduledDelayChange::deserialize(raw_delay_change_fields);\n\n        let historical_block_number = context.historical_header.global_variables.block_number as u32;\n\n        (value_change, delay_change, historical_block_number)\n    }\n}\n"},"164":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"205":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"22":{"path":"std/field.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"242":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"256":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"257":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"268":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    contract_class_id::ContractClassId, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{Hash, is_empty},\n    utils::{uint256::U256, field::field_from_bytes_32_trunc}\n};\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u32) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\nfn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_siloed_note_hash(address: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, first_nullifier: Field, index: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, index);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"271":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use dep::std::cmp::Eq;\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize"},"28":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"330":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-contracts/contracts/key_registry_contract/src/main.nr","source":"contract KeyRegistry {\n    use dep::authwit::auth::assert_current_call_valid_authwit_public;\n\n    use dep::aztec::{\n        keys::PublicKeys, state_vars::{SharedMutable, Map},\n        protocol_types::{grumpkin_point::GrumpkinPoint, address::{AztecAddress, PartialAddress}}\n    };\n\n    global KEY_ROTATION_DELAY = 5;\n\n    #[aztec(storage)]\n  struct Storage {\n    // The following stores a hash of individual master public keys\n    // If you change slots of vars below, you must update the slots in `SharedMutablePrivateGetter` in aztec-nr/keys.\n    // We store x and y coordinates in individual shared mutables as shared mutable currently supports only 1 field\n    npk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    npk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n\n    ivpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    ivpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    \n    ovpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    ovpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    \n    tpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    tpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n  }\n\n    #[aztec(public)]\n  fn rotate_npk_m(address: AztecAddress, new_npk_m: GrumpkinPoint, nonce: Field) {\n        // TODO: (#6137)\n        if (!address.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, address);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let npk_m_x_registry = storage.npk_m_x_registry.at(address);\n        let npk_m_y_registry = storage.npk_m_y_registry.at(address);\n        npk_m_x_registry.schedule_value_change(new_npk_m.x);\n        npk_m_y_registry.schedule_value_change(new_npk_m.y);\n    }\n\n    #[aztec(public)]\n  fn register(address: AztecAddress, partial_address: PartialAddress, keys: PublicKeys) {\n        let computed_address = AztecAddress::compute(keys.hash(), partial_address);\n\n        assert(computed_address.eq(address), \"Computed address does not match supplied address\");\n\n        let npk_m_x_registry = storage.npk_m_x_registry.at(address);\n        let npk_m_y_registry = storage.npk_m_y_registry.at(address);\n        let ivpk_m_x_registry = storage.ivpk_m_x_registry.at(address);\n        let ivpk_m_y_registry = storage.ivpk_m_y_registry.at(address);\n        let ovpk_m_x_registry = storage.ovpk_m_x_registry.at(address);\n        let ovpk_m_y_registry = storage.ovpk_m_y_registry.at(address);\n        let tpk_m_x_registry = storage.tpk_m_x_registry.at(address);\n        let tpk_m_y_registry = storage.tpk_m_y_registry.at(address);\n\n        npk_m_x_registry.schedule_value_change(keys.npk_m.x);\n        npk_m_y_registry.schedule_value_change(keys.npk_m.y);\n        ivpk_m_x_registry.schedule_value_change(keys.ivpk_m.x);\n        ivpk_m_y_registry.schedule_value_change(keys.ivpk_m.y);\n        ovpk_m_x_registry.schedule_value_change(keys.ovpk_m.x);\n        ovpk_m_y_registry.schedule_value_change(keys.ovpk_m.y);\n        tpk_m_x_registry.schedule_value_change(keys.tpk_m.x);\n        tpk_m_y_registry.schedule_value_change(keys.tpk_m.y);\n    }\n}\n"},"44":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not() {\n        let num = U128::from_u64s_le(0, 0);\n        let not_num = num.not();\n\n        let max_u64: Field = pow64 - 1;\n        assert_eq(not_num.hi, max_u64);\n        assert_eq(not_num.lo, max_u64);\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"56":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER}, hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n// docs:start:assert_current_call_valid_authwit\n// Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let function_selector = FunctionSelector::from_signature(\"spend_private_authwit(Field)\");\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    let result: Field = context.call_private_function(on_behalf_of, function_selector, [inner_hash]).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n// docs:end:assert_current_call_valid_authwit\n\n// docs:start:assert_current_call_valid_authwit_public\n// Assert that `on_behalf_of` have authorized the current call in a public context\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let function_selector = FunctionSelector::from_signature(\"spend_public_authwit(Field)\");\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    let result: Field = context.call_public_function(\n        on_behalf_of,\n        function_selector,\n        [inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n// docs:start:compute_call_authwit_hash\n// Compute the message hash to be used by an authentication witness \npub fn compute_call_authwit_hash<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_outer_authwit_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_call_authwit_hash\n\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\npub fn compute_outer_authwit_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field\n) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n"},"67":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    */\n    pub fn emit_unencrypted_log_with_selector<T, N>(\n        &mut self,\n        event_selector: Field,\n        log: T\n    ) where T: Serialize<N> {\n        emit_unencrypted_log(event_selector, Serialize::serialize(log).as_slice());\n    }\n    // For compatibility with the selector-less API. We'll probably rename the above one.\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        self.emit_unencrypted_log_with_selector(/*event_selector=*/ 5, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(event_selector: Field, message: [Field]) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nfn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nfn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nfn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nfn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nfn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nfn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nfn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nfn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nfn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nfn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nfn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nfn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nfn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nfn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nfn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nfn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nfn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nfn emit_unencrypted_log_opcode(event_selector: Field, message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nfn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nfn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nfn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nfn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"},"85":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    grumpkin_point::GrumpkinPoint, traits::{Deserialize, Serialize}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 8;\n\nstruct PublicKeys {\n    npk_m: GrumpkinPoint,\n    ivpk_m: GrumpkinPoint,\n    ovpk_m: GrumpkinPoint,\n    tpk_m: GrumpkinPoint,\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            poseidon2_hash(\n                [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH\n        ]\n            )\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> GrumpkinPoint {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.tpk_m.x,\n            self.tpk_m.y,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: GrumpkinPoint { x: serialized[0], y: serialized[1] },\n            ivpk_m: GrumpkinPoint { x: serialized[2], y: serialized[3] },\n            ovpk_m: GrumpkinPoint { x: serialized[4], y: serialized[5] },\n            tpk_m: GrumpkinPoint { x: serialized[6], y: serialized[7] },\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: GrumpkinPoint { x: 1, y: 2 },\n        ivpk_m: GrumpkinPoint { x: 3, y: 4 },\n        ovpk_m: GrumpkinPoint { x: 5, y: 6 },\n        tpk_m: GrumpkinPoint { x: 7, y: 8 }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x1936abe4f6a920d16a9f6917f10a679507687e2cd935dd1f1cdcb1e908c027f3;\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: GrumpkinPoint { x: 1, y: 2 },\n        ivpk_m: GrumpkinPoint { x: 3, y: 4 },\n        ovpk_m: GrumpkinPoint { x: 5, y: 6 },\n        tpk_m: GrumpkinPoint { x: 7, y: 8 }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"}}}