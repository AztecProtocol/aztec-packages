{"transpiled":true,"noir_version":"0.30.0+69d3505aae6ab262912d841822f4f3a67dd1dce6","name":"GasToken","functions":[{"name":"mint_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":5,"start":4}],"inputs":[{"end":3,"start":0}],"to":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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"},{"name":"_increase_public_balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":5,"start":4}],"inputs":[{"end":3,"start":0}],"to":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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"},{"name":"deploy","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"param_witnesses":{"artifact_hash":[{"end":40,"start":39}],"inputs":[{"end":39,"start":0}],"portal_address":[{"end":43,"start":42}],"private_functions_root":[{"end":41,"start":40}],"public_bytecode_commitment":[{"end":42,"start":41}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"artifact_hash","type":{"kind":"field"},"visibility":"private"},{"name":"private_functions_root","type":{"kind":"field"},"visibility":"private"},{"name":"public_bytecode_commitment","type":{"kind":"field"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"},"return_witnesses":[43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499]},"bytecode":"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","debug_symbols":"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0mm+dCLVvw/RSKfZePrs+vTF9enF9emr69M316fvrk8/XJ9+ej79dP2sna6ftdP1s3a6ftZq5NJsPL3rZ+10/aydrp+10/Wzdnp+1srh+Vkrh+dnrRyen7VyeH7WyuH5WSuH52etHJ6ftXJ4ftbK4flZK4frZ21y/axNrp+1yfWzNrl+1qpk5+w7vetnbXL9rE2un7XJ9bM2uX7WZtfP2uz6WZtdP2uz62etSnbOvtO7ftZm18/a7PpZm10/a7PrZ21x/awtrp+1xfWztrh+1qrkFu07vetnbXH9rC2un7XF9bO2uH7Wiutnrbh+1orrZ624ftaqZEbtO73rZ624ftaK62etuH7WiutnbXX9rK2un7XV9bO2un7WqmRG7Tu962dtdf2sra6ftdX1s7a6ftY218/a5vpZ21w/a5vrZ61K7tO+07t+1jbXz9rm+lnbXD9rm+tnbXf9rO2un7Xd9bO2u37WqmQx7Tu962dtd/2s7a6ftd31s7a7fta6zo0S17lR4jo3SlznRonr3ChxnRslrnOjxHVulLjOjRLXuVHiOjdKXOdGievcKHGdGyWuc6PEdW6UuM6NEte5UeI6N0pc50ZV17lR1XVuVHWdG1Vd50bVw/OztrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo6jo3qrrOjaquc6Oq69yo5jo3qrnOjWquc6Oa69yodnh+1jbXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1VznRjXXuVHNdW5Uc50b1V3nRnXXuVHddW5Ud50b1Q/Pz9ruOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo7rr3KjuOjequ86N6q5zo4br3KjhOjdquM6NGq5zo8bh+Vk7XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btRwnRs1XOdGDde5UcN1btR0nRs1XedGTde5UdN1btQ8PD9rp+vcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo2arnOjpuvcqOk6N2q6zo1Kh+vgqMfxPT9tH8f3/Lh9HN/z8/ZxfM8P3MfxPT9xH8f3/Mh9HN/zM/dxfM8P3cfxfT91XUdIPY7v+6nrOkTqcXzfT13XMVKP4/t+6roOknoc3/dT13WU1OP4vp+6rsOkHofz/dR1HSf1OJzvp67rQKnH4Xw/dV1HSj0O5/up6zpU6nE4309d17FSj+P7fuq6DpZ6HN/3U9d1tNTj+L6fuq7DpR7H9/3UdR0v9Ti+76eu64Cpx/F9P3VdR0w9ju/7qes6ZOpxfN9PXdcxU4/j+37qug6aehzf91PXddTU4/i+n7quw6Yex/f91HUdN/U4vu+nruvAqcfxfT91XUdOPY7v+6nrOnTqcXzfT13XsVOP4/t+6roOnnoc3/dT13X01OP4vp+6rsOnHsf3/dR1HT/1OL7vp67rAKrH8X0/dV1HUD2O7/up6zqE6nF8309d1zFUj+P7fuq6DqJ6HN/3U9d1FNXj+L6fuq7DqB7H9/3UdR1H9Ti+76eu60Cqx/F9P3VdR1I9ju/7qes6lOpxfN9PXdexVI/j+37qug6mehzf91PXdTTV4/iun7rJdzZV8p1NlXxnUyXf2VTpcP3UTb6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+c6mSr6zqZLvbKrkO5sq+86myr6zqbLvbKrsO5sqH66futl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTZd/ZVNl3NlX2nU2VfWdTFd/ZVMV3NlXxnU1VfGdTlcP1U7f4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9squI7m6r4zqYqvrOpiu9sKvGdTSW+s6nEdzaV+M6mksP1U1d8Z1OJ72wq8Z1NJb6zqcR3NpX4zqYS39lU4jubSnxnU4nvbCrxnU0lvrOpxHc2lfjOphLf2VTiO5tKfGdTie9sKvGdTSW+s6nEdzaV+M6mEt/ZVOI7m0p8Z1OJ72wq8Z1NJb6zqcR3NpX4zqYS39lU4jubSnxnU4nvbCrxnU0lvrOpxHc2lfjOphLf2VTiO5tKfGdTie9sKvGdTSW+s6nEdzaV+M6mEt/ZVOI7m0p8Z1OJ72wq8Z1NJb6zqcR3NpX4zqYS39lU4jubSnxnU4nvbCrxnU0lvrOpxHc2lfjOphLf2VTiO5tKfGdTie9sKvGdTSW+s6nEdzaV+M6mEt/ZVOI7m0p8Z1OJ72wq8Z1NJb6zqcR3NpX4zqYS39lU4jubSnxnU4nvbCrxnU0lvrOpxHc2lfjOphLf2VTiO5tKfGdTie9sKvGdTSW+s6nEdzaV+M6mEt/ZVNV3NlX1nU1VfWdTVd/ZVPVw/dStvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r6zqaqvrOpqu9squo7m6r5zqZqvrOpmu9squY7m6odrp+6zXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1M139lUzXc2VfOdTdV8Z1N139lU3Xc2VfedTdV9Z1P1w/VTt/vOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq7jubqvvOpuq+s6m672yq4TubavjOphq+s6mG72yqcbh+6g7f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNXxnUw3f2VTDdzbV8J1NNX1nU03f2VTTdzbV9J1NNQ/XT93pO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmr6zqabvbKrpO5tq+s6mmq6zqfLhOpvqcXzPT93H8T0/dR/H9/zUfRzf81P3cXzPT93H8T0/dR/H9/zUfRzf81P3cXzfT13X2VSP4/t+6rrOpnoc3/dT13U21eP4vp+6rrOpHsf3/dR1nU31OL7vp67rbKrH8X0/dV1nUz2O7/up6zqb6nF8309d19lUj+P7fuq6zqZ6HN/3U9d1NtXj+L6fuq6zqR7H9/3UdZ1N9Ti+76eu62yqx/F9P3VdZ1M9ju/7qes6m+pxfN9PXdfZVI/j+37qus6mehzf91PXdTbV4/i+n7qus6kex/f91HWdTfU4vu+nrutsqsfxfT91XWdTPY7v+6nrOpvqcXzfT13X2VSP4/t+6rrOpnoc3/dT13U21eP4vp+6rrOpHsf3/dR1nU31OL7vp67rbKrH8X0/dV1nUz2O7/up6zqb6nF8309d19lUj+P7fuq6zqZ6HN/3U9d1NtXj+L6fuq6zqR7H9/3UdZ1N9Ti+76eu62yqx/F9P3VdZ1M9ju/7qes6m+pxfN9PXdfZVI/j+37qus6mehzf91PXdTbV4/i+n7qus6kex/f91HWdTfU4vuunbvKdTZV8Z1Ml39lUyXc2VTpcP3WT72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpkq+s6mS72yq5DubKvnOpsq+s6my72yq7DubKvvOpsqH66du9p1NlX1nU2Xf2VTZdzZV9p1NlX1nU2Xf2VTZdzZV9p1NlX1nU2Xf2VTZdzZV9p1NlX1nU2Xf2VTZdzZV9p1NlX1nU2Xf2VTZdzZV9p1NlX1nU2Xf2VTZdzZVNp2OVCX/+myVi+NbvvcXjm/55ql1PI/f+uvjW755Fo5v+eZZOL7lm2fh+Jb1/v3xTefzLBzf8r3fUvv12Vby6+NbvvcXjm9Z7y8cX3wf3/JTd+H4lp+6C8e3/NRdOL7lp+7C8S0/de+PbzqfZ+H4vp+6pvN5Fo7v+6lrOp9n4fi+n7qm83kWju/7qWs6n2fh+D/+1L0c/P39s6PP9Pzw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njeo3PMGlXveoHLPG1TueYPKPW9QuecNKve8QeWeN6jc8waVe96gcs8bVO55g8o9b1C55w0q97xB5Z43qNzzBpV73qByzxtU7nmDyj1vULnnDSr3vEHlnjeo3PMGlXveoHLPG1TueYPKPW9QuecNKve8QeWeN6jc8waVe94iZWOn4zg+jj1vvvhXDpJzGWeJQz7O0ec//cpHfZ45H7N+fOX2Et6Y51fON1+5Sv712Srlde8DqQ/2/mu9j5Sbzt5/sfeBlCl7/8XeB9Lp7P0Xex/ItbD3X+y9sPewvQ/kaNn7L/Y+0O9K2Psv9j7Qb47Y+y/2nnM93N5zrhe19+P5heunr/u595F2+LD3X+w953q4vedcD7f3nOtF7X3/6H173Xth72F7z7kebu8518PtPed6uL3nXA+395zrRe19fR65ttd/pxtpnyR7/8Xec66H23vO9XB7z7kebu+FvYftPed6uL3nXA+395zr4faecz3c3nOuB9v7SLvN2fsv9p5zPdzec66H23vO9XB7L+w9bO8518PtPed6uL3nXA+395zr4faecz3Y3k/O9XB7z7kebu8518PtPed6uL0X9h6295zr4faecz3c3nOuh9t7zvVwe8+5Hmrv+8G5Hm7vOdfD7T3neri951wPt/fC3sP2nnM93N5zrofbe871YHuf6O+39v5RSTp7n5pm7+/2ZvREf4/be/p73N7T3+P2Xth72N7T3+P2nv4et/f097i959/t4Paef7cD2/vMuR5u7znXi9r7u92IPXOuh9t7zvVwey/sPWzvOdeL2vu7HWk9c66H23vO9XB7z7kebu8514PtfeFcD7f3nOtF7f3t3+kWzvVwe8+5Hm7vhb2H7T3neri951wPt/ec6+H2nnM93N5zrgfbe+FcD7f3nOvh9p5zPdzec66H23th72F7z7kebu8518PtPed6uL3nXA+395zrwfa+cq6H23vO9XB7z7kebu8518PtvbD3sL3nXA+395zr4faecz3c3nOuh9t7zvVge98418PtPed6uL3nXA+395zr4fZe2HvY3nOuh9t7zvVwe8+5Hm7vOdfD7T3nerC97/T3+r1X3W7R6cKtd0jYIeMdoqO13iH6Tusdoju03iF6OOsdotMy3qHBv3Ow3iH+NYL1DnGmYL1DnCns7dDtjrMh7JDxDnGmYL1DnClY7xBnCns7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X53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VBZ5/dYHnX13g+VcXeP7V9cC+fy/w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/usDzry7w/KsLPP/qAs+/MvD8KwPPvzLw/CsDz7+yB/b9a+D5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBp5/ZeD5Vwaef2Xg+VcGnn9l4PlXBTz/qoDnXxXw/KsCnn9VHtj3bwHPvyrg+VcFPP+qgOdfFfD8qwKef1XA868KeP5VAc+/KuD5VwU8/6qA518V8PyrAp5/VcDzrwp4/lUBz78q4PlXBTz/qoDnXxXw/KsCnn9VwPOvCnj+VQHPvyrg+VcFPP+qgOdfFfD8qwKef1XA868KeP5VAc+/KuD5VwU8/6qA518V8PyrAp5/VcDzrwp4/lUBz78q4PlXBTz/qoDnXxXw/KsCnn9VwPOvCnj+VQHPvyrg+VcFPP+qgOdfFfD8qwKef1XA868KeP5VAc+/KuD5VwU8/6qA518V8PyrAp5/VcDzrwp4/lUBz78q4PlXBTz/qoDnXxXw/KsCnn9VwPOvCnj+VQHPvyrg+VcFPP+qgOdfFfD8qwKef1XA868KeP5VAc+/KuD5VwU8/6qA518V8PyrAp5/VcDzrwp4/lUBz78q4PlXBTz/qoDnXxXw/KsCnn9VwPOvKnj+VQXPv6rg+VcVPP+qPrDv3wqef1XB868qeP5VBc+/quD5VxU8/6qC519V8PyrCp5/VcHzryp4/lUFz7+q4PlXFTz/qoLnX1Xw/KsKnn9VwfOvKnj+VQXPv6rg+VcVPP+qgudfVfD8qwqef1XB868qeP5VBc+/quD5VxU8/6qC519V8PyrCp5/VcHzryp4/lUFz7+q4PlXFTz/qoLnX1Xw/KsKnn9VwfOvKnj+VQXPv6rg+VcVPP+qgudfVfD8qwqef1XB868qeP5VBc+/quD5VxU8/6qC519V8PyrCp5/VcHzryp4/lUFz7+q4PlXFTz/qoLnX1Xw/KsKnn9VwfOvKnj+VQXPv6rg+VcVPP+qgudfVfD8qwqef1XB868qeP5VBc+/quD5VxU8/6qC519V8PyrCp5/VcHzryp4/lUFz7+q4PlXFTz/qoLnX1Xw/KsKnn9VwfOvKnj+VQXPv6rg+VcVPP+qgudfNfD8qwaef9XA868aeP5Ve2Dfvw08/6qB51818PyrBp5/1cDzrxp4/lUDz79q4PlXDTz/qoHnXzXw/KsGnn/VwPOvGnj+VQPPv2rg+VcNPP+qgedfNfD8qwaef9XA868aeP5VA8+/auD5Vw08/6qB51818PyrBp5/1cDzrxp4/lUDz79q4PlXDTz/qoHnXzXw/KsGnn/VwPOvGnj+VQPPv2rg+VcNPP+qgedfNfD8qwaef9XA868aeP5VA8+/auD5Vw08/6qB51818PyrBp5/1cDzrxp4/lUDz79q4PlXDTz/qoHnXzXw/KsGnn/VwPOvGnj+VQPPv2rg+VcNPP+qgedfNfD8qwaef9XA868aeP5VA8+/auD5Vw08/6qB51818PyrBp5/1cDzrxp4/lUDz79q4PlXDTz/qoHnXzXw/KsGnn/VwPOvGnj+VQPPv2rg+VcNPP+qgedfNfD8qwaef9XA868aeP5VA8+/6uD5Vx08/6qD51918Pyr/sC+fzt4/lUHz7/q4PlXHTz/qoPnX3Xw/KsOnn/VwfOvOnj+VQfPv+rg+VcdPP+qg+dfdfD8qw6ef9XB8686eP5VB8+/6uD5Vx08/6qD51918PyrDp5/1cHzrzp4/lUHz7/q4PlXHTz/qoPnX3Xw/KsOnn/VwfOvOnj+VQfPv+rg+VcdPP+qg+dfdfD8qw6ef9XB8686eP5VB8+/6uD5Vx08/6qD51918PyrDp5/1cHzrzp4/lUHz7/q4PlXHTz/qoPnX3Xw/KsOnn/VwfOvOnj+VQfPv+rg+VcdPP+qg+dfdfD8qw6ef9XB8686eP5VB8+/6uD5Vx08/6qD51918PyrDp5/1cHzrzp4/lUHz7/q4PlXHTz/qoPnX3Xw/KsOnn/VwfOvOnj+VQfPv+rg+VcdPP+qg+dfdfD8qw6ef9XB8686eP5VB8+/6uD5Vx08/6qD51918PyrDp5/NcDzrwZ4/tUAz78a4PlX44F9/w7w/KsBnn81wPOvBnj+1QDPvxrg+VcDPP9qgOdfDfD8qwGefzXA868GeP7VAM+/GuD5VwM8/2qA518N8PyrAZ5/NcDzrwZ4/tUAz78a4PlXAzz/aoDnXw3w/KsBnn81wPOvBnj+1QDPvxrg+VcDPP9qgOdfDfD8qwGefzXA868GeP7VAM+/GuD5VwM8/2qA518N8PyrAZ5/NcDzrwZ4/tUAz78a4PlXAzz/aoDnXw3w/KsBnn81wPOvBnj+1QDPvxrg+VcDPP9qgOdfDfD8qwGefzXA868GeP7VAM+/GuD5VwM8/2qA518N8PyrAZ5/NcDzrwZ4/tUAz78a4PlXAzz/aoDnXw3w/KsBnn81wPOvBnj+1QDPvxrg+VcDPP9qgOdfDfD8qwGefzXA868GeP7VAM+/GuD5VwM8/2qA518N8PyrAZ5/NcDzrwZ4/tUAz78a4PlXAzv/6nxg5189zw99/z7PD33/Ps8Pff8+zw99/z7PD33/Ps8Pff8+zw99/z7PD33/Ps8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc8Pfv9i5189zw9+/2LnXz3PD37/YudfPc+Pff8e4PlXB3j+1QGef3WA518dD+z79wDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrAzz/6gDPvzrA868O8PyrEzz/6gTPvzrB869O8Pyr84F9/57g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX53g+VcneP7VCZ5/dYLnX52h85eK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Psjy2wdZfvsgy28fZPntgyu//Xpw5bc/66XSV896qfTVs14qffWs18jqpdJXz3qp9NWzXip99ayXSl896yXTV1z57c96yfQVV377s14yfcWV3/6sl0xfceW3P+sl01dc+e3Pesn0FVd++7NeMn3Fld/+rJdMX3Hltz/rJdNXXPntz3rJ9BVXfvuzXjJ9xZXf/qyXTF9x5bc/6yXTV1z57c96yfQVV377s14yfcWV3/6sl0xfceW3P+sl01dc+e3Pesn0FVd++7NeMn3Fld/+rJdMX3Hltz/rJdNXXPntz3rJ9BVXfvuzXjJ9xZXf/qyXTF9x5bc/6yXTV1z57c96yfQVV377s14yfcWV3/6sl0xfceW3P+sl01dc+e3Pesn0FVd++7NeMn3Fld/+rJdMX3Hltz/rJdNXXPntz3rJ9BVXfvuzXjJ9xZXf/qyXTF9x5bc/6yXTV1z57c96yfQVV377s14yfcWV3/6sl0xfceW3P+sl01dc+e3Pesn0FVd++7NeMn3Fld/+rJdMX3Hltz/rJdNXXPntz3q59NVBlt9+kOW3H2T57QdZfvvxMLJ6ufTVQZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e0HWX77QZbffpDltx9k+e1Honzv0c7Xi9uv7/xVbaJ075Vq8zybR/968X/+899Wm+fJvFJtnufySrV5nsor1ebxvCvV5nG8K9Umum8/V5so7Xml2jxed6XaPE53pVoqLZUo5XmlWlQt9a4AVR+9KwiteYq9nPSoo3/y3eV1jOe0aPIvLrTmca82tObxrjZ2ArN7taE1j3u1oTWPe7WhNY97tUZVbWjN415taH3kXi2VloqduOxeLZWWip227F4tlZaKnbTsXi2VloqdsuxeLZWWip2w7F4tlZaKna7sXi2TljpjJyu7V8ukpc7Yqcru1TJpqfNhVNUyaakzdpqye7VMWuqMnaTsXi2VloqdouxeLZWWip2g7F4tlZaKnZ7sXi2VloqdnOxeLZWWip2a7F4tlZaKnZjsXi2VloqdluxeLZWWip2U7F4tlZaKnZLsXi2VloqdkOxeLZWWip2O7F4tlZaKnYzsXi2VloqdiuxeLZWWip2I7F4tlZaKnYbsXi2VloqdhOxeLZWWip2C7F4tlZaKnYDsXi2VloqdfuxeLZWWip187F4tlZaKnXrsXi2VloqdeOxeLZWWip127F4tlZaKnXTsXi2VlipUWip2hrV3tbEzrN2rpdJSlUpLxc4nd6/WqKql0lKx88ndq6XSUrHzyd2rpdJSsfPJ3aul0lKx88ndq6XSUrHzyd2rpdJSsbPM3aul0lJUuecnVe75SZV7flLlnp9UuecnVe75SZV7flLlnp9UuecnVe75SZV7flLlnp9UuecnVe75SZV7flLlnp9UuecnVe75SZV7flLlnp9UuecnVe75RZV7flHlnl9UuecXVe759TCqapm01EWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z5fVLnnF1Xu+UWVe35R5Z4bVe65UeWeG1XuuVHlntvDqKpl0lJGlXtuVLnnRpV7blS550aVe25UuedGlXtuVLnnRpV7blS550aVe25UuedGlXtuVLnnRpV7blS550aVe25UuedGlXtuVLnnRpV7blS550aVe25UuedGlXtuVLnnRpV7blS550aVe25UuedGlXtuVLnnRpV7blS550aVe25UuedGlXtuVLnnRpV7blS550aVe25UuedGlXtuVLnnRpV7blS550aVe25UueeWKC16tPP14nZNqs1zAy1UmyhRePT+evF//vPfVpvnKbVSbZ6n1Eq1RlVtHse3Um0ex7dSbaL7dqHaRPftQrV5HN9CtYkShVeqpdJSiRKFV6pF1VLvCgy+gtCap53jVUE/2yfX/Rj1derj+HaO1r/VG1r13FBvaN1zQ72hlc8N9YbWPv71xs4AvqHe0PrnhnpDK6Ab6g2tgW6o18jqJdNXsfOAb6iXTF/FzgS+oV4yfRU7F/iGesn0Vexs4BvqJdNXsfOBb6iXTF/Fzgi+oV4yfRU7J/iGern0VYmdFXxDvVz6qsTOC76hXi59VR5GVi+Xviqxc4NvqJdLX5XY2cE31Eumr2LnB99QL5m+ip0hfEO9ZPoqdo7wDfWS6avYWcI31Eumr2LnCd9QL5m+ip0pfEO9ZPoqdq7wDfWS6avY2cI31Eumr2LnC99QL5m+ip0xfEO9ZPoqds7wDfWS6avYWcM31Eumr2LnDd9QL5m+ip05fEO9ZPoqdu7wDfWS6avY2cM31Eumr2LnD99QL5m+ip1BfEO9ZPoqdg7xDfWS6avYWcQ31Eumr2LnEd9QL5m+ip1JfEO9ZPqqGFm9ZPqqkOmr2DnbN9RLpq8Kmb6qZPoqdpb6DfWS6avYeeo31Gtk9ZLpq9ip6jfUS6avYier31Avmb6Kna5+Q71k+ip2wvoN9ZLpq9iJ7DfUS6avyPLbC1l+eyHLby9k+e2FLL+9kOW3F7L89kKW317I8tsLWX57IctvL2T57YUsv72Q5bcXsvz2QpbfXsjy2wtZfnshy28vZPnthSy/vZDltxey/PZClt9eyfLbK1l+eyXLb69k+e31YWT1cumrSpbfXsny2ytZfnsly2+vZPntlSy/vZLlt1ey/PZKlt9eyfLbK1l+eyXLb69k+e2VLL+9kuW3V7L89kqW317J8tsrWX57TZTv/Xz168Xt13d+V5vn9l2oNlH28+j99eLRJtXmeTKvVJvnubxSbZ6n8kq1eTzvSrV5HO9KtYnu24VqE923C9Xm8boL1SZKel6plkpLJUp5XqkWVUu9KzD4CkJrnl7a1z+iUj/5bju/fLdd5f3ej+NbvaFVzw31htY9N9QbWvncUG9o7eNfb+wc5hvqDa1/bqg3tAK6od7QGuiGeo2sXjJ9FTuH+YZ6yfRV7BzmG+ol01exc5hvqJdMX8XOYb6hXjJ9FTuH+YZ6yfRV7BzmG+ol01exc5hvqJdMX8XOYb6hXjJ9FTuH+YZ6yfRV7BzmG+ol01exc5hvqJdMX8XOYb6hXjJ9FTuH+YZ6yfRV7BzmG+ol01exc5hvqJdMX8XOYb6hXjJ9FTuH+YZ6yfRV7BzmG+ol01exc5hvqJdMX8XOYb6hXjJ9FTuH+YZ6yfRV7BzmG+rl0lctdg7zDfVy6asWO4f5hnq59FV7GFm9XPqqxc5hvqFeLn3VYucw31Avmb6KncN8Q71k+ip2DvMN9ZLpq9g5zDfUS6avYucw31Avmb6KncN8Q71k+ip2DvMN9ZLpq9g5zDfUS6avYucw31Avmb46yfRV7JztG+ol01cnmb66yPRV7Cz1G+ol01ex89RvqNfI6iXTV7FT1W+ol0xfxU5Wv6FeMn0VO139hnrJ9FXshPUb6iXTV7ET2W+ol0xfkeW3N7L89kaW397I8tsbWX57I8tvb2T57Y0sv72R5bc3svz2Rpbf3sjy2xtZfnsjy29vZPntjSy/vZHltzey/PZGlt/eyPLbG1l+eyPLb29k+e2NLL+9keW3N7L89kaW397I8tsbWX57I8tvb2T57Y0sv72R5bc3svz2Rpbf3sjy2xtZfnsjy29vZPntjSy/vZHltzey/PZGlt/eyPLbG1l+eyPLb29k+e2NLL+9keW3N7L89kaW397I8tsbWX57I8tv72T57Z0sv72T5bd3svz2/jCyern0VSfLb+9k+e2dLL+9k+W3d7L89k6W397J8ts7WX57J8tv72T57Z0sv72T5bd3svz2Tpbf3sny2ztZfnsny2/vZPntnSy/vZPlt3ey/PZOlt/eyfLbO1l+eyfLb+9k+e2dLL+9k+W3d7L89k6W397J8ts7WX57J8tv72T57Z0sv72T5bd3svz2Tpbf3sny2ztZfnsny2/vZPntnSy/vZPlt3ey/PZOlt/eyfLbO1l+eyfLb+9k+e2dLL+9k+W3d7L89p4o33u08/Xi9us7v6vNc/uuVJvn2Tx6/3pxm1Sb58m8Um2e5/JKtXmeyivV5vG8C9UmSnxeqTbRfbtQbaL7dqHaPF53pVqjqpZKSyVKeV6pFlVLvStA1UfvCkJrnvH1zsfjOI9Pxrt8vbrY7//JxY5h9i83tOrxLze07PEvN7Tu8S/XuMoNrXz8yw0tffzLDa19/MsNLZT8y+VSVbHDl/3L5VJVsaOX/cvlUlWxg5f9y+VSVbFjl/3L5VJVsUOX/culUlUjduSyf7lUqmrEDlz2L5dKVY2HcZVLpapG7LBl/3KpVNWIHbXsXy6XqoodtOxfLpeqih2z7F8ul6qKHbLsXy6XqoodsexfLpeqih2w7F8ul6qKHa/sXy6XqoodruxfLpeqih2t7F8ul6qKHazsXy6Xqoodq+xfLpeqih2q7F8ul6qKHansXy6XqoodqOxfLpeqih2n7F8ul6qKHabsXy6XqoodpexfLpeqih2k7F8ul6qKHaPsXy6XqoodouxfLpeqih2h7F8ul6qKHaDsXy6Xqoodn+xfLpeqih2e7F8ul6qKHZ3sXy6XqoodnOxfLpeqqlyqKnYqtn+5XKqqcqmqalzlcqmq2LHn/uVyqarYwef+5XKpqtjR5/7lcqmq2OHn/uVyqarY8ef+5XKpqtgB6P7lcqmq2HHp/uVyqSqubPXBla0+uLLVB1e2+uDKVh9c2eqDK1t9cGWrD65s9cGVrT64stUHV7b64MpWH1zZ6oMrW31wZasPrmz1QZWtbo9M6dsfd5Y/y010766Um+jJ/HHT5rPcRE/mlXITPZlXyk30ZF4pN5HfXSk3kd9dKDdTPvNKuZnu3YVyE/ndlXIT+d2Vco2rXC5VhZvP/C4BVim9S4isfp7nrsf7IOf54V/d/L3f9UaWPzfUGzpJ+Y56IwugO+qNrIDuqDeyBLqjXiOrN7IIuqPeyCrojnojS6Y76iXTV6EjlW+oN3Sm8h31kumr0KnKd9RLpq9C5yrfUS+ZvgqdrHxHvWT6KnS28h31kumr0OnKd9RLpq9C5yvfUS+ZvgqdsHxHvWT6KnTG8h31kumr0CnLd9RLpq9C5yzfUS+ZvgqdtHxHvWT6KnTW8h31kumr0GnLd9RLpq9C5y3fUS+ZvgqduHxHvWT6KnTm8h31kumr0KnLd9RLpq9C5y7fUS+ZvgqdvHxHvWT6KnT28h31kumr0OnLd9RLpq9C5y/fUS+ZvgqdwHxHvWT6KnQG8x31kumr0CnMd9RLpq9C5zDfUS+ZvgqdxHxHvWT6KnQW8x31kumr0GnMd9RLpq9C5zHfUS+ZvgqdyHxHvWT6KnQm8x31kumr0KnMd9RLpq8Gmb4aXPrqCJ27fUe9XPrq+S5k9Wa6j4q9ktWLzerNdB8t1Bs6r/jH9ZZXCmipbVJvpufVSr2Znlcr9Wbygyv1Glm9mfzgSr2Z7t961H9eXa9zUm+m+3el3kx+cKXeTH5wod5Uecgr9WbSVyv1ZtJXK/Vm0lcr9RpZvZn01Uq9ZPoqVR7ySr24+updA65m+qoheG7xWb8f5PHh393C3DR4brF/vbF10M/qPc+vg1iZ1BtbB/nXa2T1xtZB/vXG1kH+9cbWQf71xtZBP6y3lNdB2jGpN7Zmcq83eG6xf72Z9NVKvan01UK9qfTVQr1GVm8qfbVQb2x9dR3X10HsvD7U+3Q/r8HLUyh/m7xc17eKYyusOyqOrbHuqDi2yrqh4uD5xXdUHFtp3VFxbK11R8Wx1dYdFRtdxbEV1x0V02mu4GnGd1RMp7mCJxrfUHHwTOM7KqbTXMFzje+omE5zBc82vqNiOs0VPN/4jorpNFfwjOM7KqbTXMFzju+omE5zBc86vqNiOs0VPO/4jorpNFfwzOM7KqbTXMFzj++omE5zBc8+vqNiOs0VPP/4jorpNFfwDOQ7KqbTXMFzkO+omE5zBc9CvqNiOs0VPA/5jorpNFfwzNyfVTzaK9NttMlvMYNn5vrXm+k5PforE2qMSSZU8ExV73rP4Jmq/vVmekKv1JvJE6/Um8kRr9Sb6v5dqDfV/btQbyYvvFJvJie8Ui+XvjofZPoqeAb0n+p914Crmd41xNZBVu1dQ2sf/t19zgw6g2c1+9drZPXG1kE/q/dzxsoZPKvZv97YOsi/3tg6yL/e2DrIvd7gWc3+9cbWTP71ZtJXnzNHzuBZzf71Glm9qfTVQr2p9NVCvan01UK9qfTVQr1A+qrb72cWwXOd12oA0kHTGmJrm3K+51/lqv/7bCF4/rJ/vZao3gWtHjx/2b/e2NrGv97Y2sa/3tjaxr/e2NrGvd7g+cs/rPezdg2ev+xfbyZ9tVJvJn21Uq+R1ZtKXy3Um0pfLdQLpK9s8n2I4HnKazUA6aBZDcEzj0svXwep49P3oXqxx+vNS/n2v7RWv1UcXN3cUHFwfXNDxcEVzg0VG13FwVXODRUH1zk3VBxc6dxQcXBddEPFwVWUf8XBM4/vqJhOcwXPPL6jYjrNFTzz+I6K6TRX8MzjOyqm01zBM4/vqJhOcwXPPL6jYjrNFTzz+I6K6TRX8MzjOyqm01zBM4/vqJhOcwXPPL6jYjrNFTzz+I6K6TRX8MzjOyqm01zBM4/vqJhOcwXPPL6jYjrNFTzz+I6K6TRX8MzjOyqm01yDTnMNOs0VPNf6jorpNNeg01yDTnMFzy+/o2I2zXUFzzC/o2I2zXUFzzG/o2I2zXU9jK5iNs11Bc8zv6NiNs11Bc80v6NiOs0VPNf8jorpNFfwzPQ7KqbTXMFz0++omE5zBc9Ov6NiOs0VPD/9jorpNFfwDPU7KqbTXMFz1O+omE5zBc9Sv6NiOs0VPE/9jorpNFfwTPU7KqbTXMEz2O+omE5zRc93v6FiOs0VPeP9horpNFf0nPcbKqbTXNGz3m+omE5zRc97v6FiOs0VPfP9horpNFf03PcbKqbTXNGz32+omE5zRc+Kv6FiOs1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQX3Q59BddDv1Fl0N/0eXQG10OvdHl0BtdDr3R5dDbw+gqZtNcRpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfRGl0NvdDn0RpdDb3Q59EaXQ290OfSFLoe+0OXQF7oc+kKXQ18eRlcxm+YqdDn0hS6HvtDl0Be6HPpCl0Nf6HLoC10OfaHLoS90OfSFLoe+0OXQF7oc+kKXQ1/ocugLXQ59ocuhL3Q59IUuh77Q5dAXuhz6QpdDX+hy6EuqjPLRzn9ePdqv7/2uN9NtvFJvpuf06P1V73/+89/Wm+kpvVJvpmf0Sr2ZntAr9WbyxCv1ZnLEC/WmyqteqTfV/btQbyYvvFJvJie8Uq+R1Uumr4Azqt814Gqmdw2xdVC7Hl8H6fbp391/wmX/efl/Ut5+78yD50jfUHHwHOk7Ko6thu6oOLYeuqPi2IrojoqNruLYquiOimProjsqjq2i7qiYTnMFz5G+oeLgOdJ3VEynuYLnSN9RMZ3mCp4jfUfFdJoreI70HRXTaa7gOdJ3VEynuYLnSN9RMZ3mCp4jfUfFdJoreI70HRXTaa7gOdJ3VEynuYLnSN9RMZ3mCp4jfUfFdJoreI70HRXTaa7gOdJ3VEynuYLnSN9RMZ3mCp4jfUfFdJoreI70HRXTaa7gOdJ3VEynuYLnSN9RMZ3mCp4jfUfFdJoreI70HRWzaa4aPEf6jorZNFcNniN9R8Vsmqs+jK5iNs1Vg+dI31Exm+aqwXOk76iYTnMFz5G+o2I6zRU8R/qOiuk0V/Ac6TsqptNcwXOk76iYTnMFz5G+o2I6zRU8R/qOiuk0V/Ac6TsqptNcwXOk76iYTnMFz5G+o2I6zXXSaa6TTnMFzwq/o2I6zXXRaa6LTnMFzwz/WcWfM/Br8Mxw93qDZ0r/sN6PGa01eKa0f72ZntEr9WZ6Qq/Ua2T1ZnLEK/Wmun8X6k11/y7Um8kLr9SbyQkv1Jsqp3qlXjJ9BZxR/a4BVzO9a7DQNfR+fh1ktPHh391xja+SrzF+78yD50jfUXFsLXRHxbHV0B0Vx9ZDd1QcWxHdUHHwHOk7Ko6tiu6oOLYuuqPi2CrqjoqNrmI6zRU8R/qOiuk0V/Ac6TsqptNcwXOk76iYTnMFz5G+o2I6zRU8R/qOiuk0V/Ac6TsqptNcwXOk76iYTnMFz5G+o2I6zRU8R/qOiuk0V/Ac6TsqptNcwXOk76iYTnMFz5G+o2I6zRU8R/qOiuk0V/Ac6TsqptNcwXOk76iYTnMFz5G+o2I6zRU8R/qOitk0VwueI31HxWyaqwXPkb6jYjbN1R5GVzGb5mrBc6TvqJhNc7XgOdJ3VEynuYLnSN9RMZ3mCp4jfUfFdJoreI70HRXTaa7gOdJ3VEynuYLnSN9RMZ3mCp4jfUfFdJoreI70HRXTaa7gGcM/q/hzxl8LnjDsXm/w7Nkf1vsxg6YFT571rzfTM3ql3kxP6JV6jazeTI54pd5U9+9Cvanu34V6M3nhlXozOeGFeoNnRvvXS6avgmdG/6nedw24muldg0Wu4XgcXzUcj3J8+HdXzvHPq8tVvr33N18eO9v5hnpD66Af1tv6+Hrv88N7z8/xZhNaM21mE1pfbWYTWovtZRM7i3ozm9AabzOb0HpwM5vQOnMzGxObKZtMWtebjXTxnI108ZyNdPGcjXTxlE3sPPLNbKSL52yki+dspIvnbExspmyki+dspIvnbKSL52yki+dspIunbGJnxm9mI108ZyNdPGcjXTxnY2IzZSNdPGcjXTxnI108ZyNdPGcjXTxlEzvXfzMb6eI5G+niORvp4jkbE5spG+niORvp4jkb6eI5G+niORvp4imb2LsXNrORLp6zkS6es5EunrMxsZmykS6es5EunrORLp6zkS6es5EunrHpsfdjbGYjXTxnI108ZyNdPGdjYjNlI108ZyNdPGcjXTxnI108ZyNdPGUTe4fJZjbSxXM20sVzNtLFczYmNlM20sVzNtLFczbSxXM20sVzNtLFUzax98xsZiNdPGcjXTxnI108Z2NiM2UjXTxnI108ZyNdPGcjXTxnI108ZRN7r9dmNtLFczbSxXM20sVzNiY2UzbSxXM20sVzNtLFczbSxXM20sVTNrH3sW1mI108ZyNdPGcjXTxnY2IzZSNdPGcjXTxnI108ZyNdPGcjXTxlo313f2AjXTxnI108ZyNdPGdjYjNlI108ZyNdPGcjXTxnI108ZUO7m6vY652Lzdiw3uErbFifxaX0F5vaJmxYn8UrbFifxStsWGcUC2xodyytsGGdUaywYdU39aj/vLZe54QNq75ZYWNiM2XDOqNYYcOqi1fYsOriFTasuniFDasuXmBDu2NphQ2rLl5hI108ZyNdPGdjYjNlI108ZyNdPGcjXTxnI108ZyNdPGWTa8fST9671tdQ9Pn/jverz/MbnVTK2J1OKm3sTieVOnanY6LzBzqpFPJP3rs9XlfW0dqvdH7zudb5ugvLVb69c/1GMpWe3koylfreSjKVVt9KMpWy30hy5NoptZUkrWdwJ0nrL9xJ0noRd5Imkk4k5XG8SMrjeJGUx/EiKY/jRVIex4lkrv1gW0nK43iRlMfxIimP40XSRNKJpDyOF0l5HC+S0pNLJB9fJI/+e5K59mptJam72+l/3bl2L20lqbvbi6Tubi+Smk96kdR88r9JvulII/6BTq69Ue50eGeD4+ubnf2a0eGd963Q4fUBK3RMdP5Ah1evr9Dh1eArdGh1de9fbz2s/0LnX+nqXDuntpKk1eDeJHPts9pKklbbu5Ok9QHuJGk9gztJE0knkrRexJ0krW9xJymP40VSHseLpDyOE8lcu8m2kpTH8SIpj+NFUh7Hi6SJpBNJeRwvkvI4XiTlcbxIyuN4kZTHcSJZ5XG8SMrjeJGUx/EiKY/jRdJE0omkPI4XSXkcJ5K5NjzeR/Lzrw5z7YPcSlI3jtf/unXjeJHUjeNFUlM1L5KaqnmR1FTtv0l+0cm17dCdjnTfn+jQTrRGfb34fDyOCR3aKdUSHROdP9Ch1fZLdGj1+hIdWg2+RIdVV5+P6/iiM+wXOr/R1dVeurp/e+3j8Y0kq652J0m7WdGfJKte9yfJqu39SbL6AH+SJpJOJFn9hT9JVi/iT5LVt/iTlMfxIimP40KyPGi3RvqTlMfxIimP40VSHseLpImkE0l5HC+S8jheJOVxvEjK43iRlMdxIkm7NdKfpDyOF0l5HC+S8jheJE0knUjK43iRlMfxIimP40VSHseLpDyOE0naTab+JOVxvEjK43iRlMfxImki6URSHseLpDyOF0l5HC+S8jheJOVxnEjSbu31JymP40VSHseLpDyOF0mpoCWSn1LRniSlgpxI0u6d/CHJT7lJT5K6cbxI6sbxImki6URSUzUvkpqq/TfJNx1pxD/Rke77Ex3aidZxfJ36sAkd2j2Oa3RofcASHVptv0SHVq8v0THR+QMdWl199PJ1ahu/0PlX00XaXYf+JGk1uDtJWr3uTpJX2zuTpN116E+S1zN4k+T1F94keb2IN0kTSSeS8jheJOVxvEjK43iRlMfxIimP40SSdpOpP0l5HC+S8jheJOVxvEiaSDqRlMfxIimP40VSHseLpDyOF0l5HCeStJt4/UnK43iRlMfxIimP40XSRNKJpDyOF0l5HC+S8jheJOVxvEjK4ziR5N107E5SHseLpDyOF0l5HC+SJpJOJOVxvEjK43iRlMfxIimP40VSHseH5MG76didpInkCsmPqWgH7y5Ud5K6cZZIfsxNOnj3TnqT5N076U5SUzUvkpqqeZHUVO2/Sb7pmOj8gY5035/o0E60ztpfp76ejuv3dGinVEt0aH3AEh1abb9Ch3eH4hIdWg2+RIdWV1/nm47VCR1arbxEx0TnD3RotfISHVqtvESHVisv0aHVytd4vfVp1n+h87tZ0Pm7WdD3T8R4d/x5k+Td8edOklavu5Pk1fbeJHl9gDdJE0knkrz+4kck398Lam1CkteLeJPk9S3eJOVxvEjK4ziRNHkcL5LyOF4k5XF+SHL27WjerbLuJE0knUjSehzrXyTL9elbf/1xfL3zN5LHd5K0HsedJK3HcSdJ63HcSdJ6HG+SvFtw3UnSepyfkbSXCuqlTUjSehx3krQex52kiaQTSXkcL5LyOF4k5XGWSLbXl9X6OCYk5XG8SMrjOJHk3fDrTlIex4ukPI4XSXkcL5Imkgskx/EqcZx1QlIex4ukPI4XSXkcL5LyOF4k5XGcSPJu+HUnSetxSn28Tl0fxweSx/NC+TpI/fbdF/vOktbl3MCS1ufcwNLE0o0lrdf5GcvzeH0McZy9/cLyv1+9kGvHuxd4M3daH7WZO63r2syd1qPt5c67z3gzd/m/PdzlFfdwl6/cw93EfQt3+dU93OVX93CXX93DXX51D3f51S3ceXdTb+Yuv7qHu/zqHu7yq3u4m7hv4S6/uoe7/Ooe7tLvN3D/uJn15N27vJm79MyO58z5MHHfwl16Zg936Zk93DV/38Nd8/f/lfubpTS5G0vebfM3sNTse4nl9aivg1w2Y6l5th9LeTo/liaWbizlvfxYyk/5sZRHWmPZXrbnsPL4heVvXt3si3y3bye57Bt5uaRd5OWpNpE/5cB2kZdf20Ve7m4XeXnBXeRN5DeRl8/cRV6udBd5edhd5OVhd5GXh91E/pKH3UVeHnYXeXnYXeTlYXeRN5HfRF4edhd5edhd5OVhd5GXh91FXh52E3mTh91FXh52F3l52F3k5WF3kTeR30ReHnYXeXnYXeTlYXeRl4fdRV4edhP5Ig+7i7w87C7y8rC7yMvD7iJvIr+JvFSlP/mFXLIiTbmFe9XtegP3z3lBVXfrHu66Wfdw12x4D3dNhvdw11z4f+X+ZilN7sdSOnuJZTleNR6l9Y/Pg/N3z4PHN+5Nk9s93DW33cNdvnIPd/nKPdxN3Ldwl6/cw12+8gbu9RVCXFqbcJev3MNdHnQPd/nVLdy7/Ooe7vKre7jLr+7hLr96K/duE+4m7lu4y6/u4S6/usT9+ZLXQeq3c0y+UVfsa2tOKd+e8N+/UdflWHeRl2fdRV6udRP5Id+6i7yc6y7y8q53kC/jrUDPCXm5113kTeQ3kZeD3UVeHnYXeXnYXeTlYW8gb+PxRb7/qir/1XRtyO/G79L1kDdG6JJ89A1dqu396u/kv90110M+ehd5+ehd5E3kN5GXj95FXj56F3n56F3k5aPvIN+/EoXqGBPy8sabyB/yu7vIy8PuIi8Pu4u8POwu8ibym8jLw95B/vji145f9fy/migf8rsIXZI3RuiSfPQNXeqPr8/QfjnJL3eNfPQm8qd89C7y8tG7yMtH7yIvH72LvIn8JvLy0XeQP8oX+W/8fiUvb7yLvPzuLvLysLvIy8NuIn/Jw+4iLw+7i7w87A3k/7BF7F9NlC/5XYQumboE0CVaH12vr1M/P7j/2KXj65eX1b7VWPtv/wW8rpqzHb+c482d1kVv5k7roTdzp3XQm7nT+mc37l8sjdYR38CS1uPewJLWtd7AktZb3sDSxNKNpXyaH0t5Lz+W8lNrLMfXQdqj/MLyN+co/Z8Xt/FtbnN+wy47tQW73JQ/9vP8emsrv3exRc5rD3e5tD3c5ej2cJf728PdxH0Ld7nKG7h/nsoXOdA93OVWl7i3s39xt+N/tk1FbnULdrlVf+wLt2qVW93DXW51D3e51T3c5Vb3cDdx38JdbvUG7p9dU5Vb3cNdbnWNe/36nLr1T9+Z/GybqtzqFuxyq/7YF27VJre6h7vc6h7ucqt7uMut7uFu4r6Fu9zqDdw/u6Ymt7qHu9zqEvf++CLSz8f/bJua3OoW7HKr/tgXbtUut7qHu9zqHu5yq3u4y63u4W7ivoW73OoN3D+7pi63uoe73OrPubdfuL9ZyoL6sZSvdGM55BXXWDb7Ytnb//d/HY0MWcUt2OUU/bEvKOchp7iHu4n7Fu5yinu4yynu4S6nuIe7XOUN3D9PRoYc6A7u9pBbXeNejjf3/oH7uF5fchn120b2R/03FssecrbhWyQXHL5FMszhW2RqUfQWyYaHb5Ece/gWydyHb5HmAOFbpJFB9BYdmi6Eb5GmC0stGvZ1kFHKhxYtYNfEYAt2TQH8sX/+WMUOE/ct3OXX93CXCd/DXc56D3fZ5T3c5YFv4P75Y/NTxnYPd7nVPdxlV/dwl19d494fr1c/Pv5Q70+vfpM3kd9EXp7Vn3zr4+sc54dzzM/87pH8bfweyQvH75F8c/weyWOH79ElPx6/R/Lu8Xsknx+/R5oJxO+RqUfhe6Q5Q/weac4Qv0eaM8TvkeYM8XukOUP4HpnmDPF7pDlD/B5pzhC/R5ozxO+RqUfhe6Q5Q/weac4Qv0eaM8TvkeYM8XukOUP4HhXNGeL3SHOG+D3SnCF+jzRniN8j+aO9PSpfPyx6flA06ZH8UfgeVem6zT36iogptU16JF0Xv0fSdfF7JF0Xv0emHoXvkT4/it8j+aO9PapH/ee19TonPZI/it8jfX4Uv0f6/Ch8j5rmDPF7pDlD/B5pzhC/R5ozxO+RqUfhe6Q5Q/weac4Qv0eaM8TvkeYM8XukOcMNPfrBOd5htr9m2dZ3j7rmDPF7pDlD/B5pzhC/R5ozxO+RqUfhe6Q5Q/weac6wuUfl9drRHpMeac4Qv0eaM8TvkeYM4Xs0NGeI3yPNGeL3SHOG+D3SnOFv9ujN3cR9C3fNA/Zwl8ffw12+fQ93efE93OWvd3AvDw7P/K6Xw3++6+Xwcu96OXzRu14jq5fDB7zr5dDf73qD696vVx/P/xsf6j3K6yBHsUm9wfWme73Bdd6P6vXNTytHcC22lU1w3baVTXCNt5VNcD24lY2JzZRNcJ25lU1wTbqVTSb96s0mk9b1ZiNdPGVzShfP2UgXz9lIF8/ZSBfP2ZjYTNlIF8/ZSBfP2UgXz9lIF8/ZSBdP2VzSxXM20sVzNtLFczbSxXM2JjZTNtLFczbSxXM20sVzNtLFczbSxVM2Jl08ZyNdPGcjXTxnI108Z2NiM2UjXTxnI108ZyNdPGcjXTxnI108ZVOki+dspIvnbKSL52yki+dsTGymbKSL52yki+dspIvnbKSL52yki6dsqnTxnI108ZyNdPGcjXTxnI2JzZSNdPGcDau+KV9Z9M/PoSZsWPXNApvo+2nvY1P6i01tEzas99QKG9Z7aoUN6z21woZ1frPChnV+s8KGVd983nNZou+53Mkm+n7JrWxY5zcrbFh18QobVl28wsbEZsqGVRevsGHVxStsWHXxChvp4jkb6eIpm+j70LaykS6es5EunrORLp6zMbGZspEunrNJpYt/8t6lfMXnPz9ReL/6P+np/11jKa8S2zEhmUpFbyWZSnNvJZlKoW8kWaPvatpC8k0nlaJ3p5NK07vTSaXq3emY6PyBTipl705H2v5PdKTX/0SHVoPX82Wwj2rnL3T+jcOuubZu7SSZa0fXbSTP86tEKxOStHrdnSSttncnSesD3EmaSDqRpPUX7iRpvYg7SVrf8jOSn2e6uXaibSXJ63Fq+SLZ+v/ucXLtW9tKktfj/ITkwo2Ta5fbVpK8HsebpImkE0lej+NNktfjeJPk9TjeJHk9zo9IfvY4ubbh7SSZa3feVpLyOF4kaT1Oe7ys9NHK4wPJo7xKPP7zn/+WJK3HcSdpIrlA0jfprebaJghDndY7baVO67O2Uqf1ZFup0/q3ndRz7YOEoU7rC7dSl4fcQV1+cwd1E/UN1OVNd1CXN91BXd50B3V50x3U5U03UM+1kxWGurzpDurypjuoy5vuoG6ivoG6vOkO6vKmO6jLm+6gLm+6g7q86QbqufYiw1CXN91BXd50B3V50x3UTdQ3UJc33UFd3nQHdXnTHdTlTXdQlzfdQL3Jm+6gLm+6g7q86Q7q8qY7qJuob6Aub7qDurzpDurypjuoy5vuoC5vuoF6lzfdQV3edAd1edMd1KXXvakXey2kKjajLr2+g7o0jDv10l/Ua/s99SENs4O6NMwO6tIwO6hrvr6Duon6BurS697UF7avDOn1HdQ1X99BXfP1HdTlTf8+9faQN91BXd50B3V50x3U5U13UDdR30Bd3nQHdXnTHdTlTXdQlzfdQV3edAP1Q950B3V50x3U5U13UJc3XaL+g3c+z+vx5vF+9VF/duZ3j0w9Ct8j+d74PZJLjt8jeeq/2aM3d7nqPdzlq7dwP+Ws93CXt97DXe56D3f56z3cTdy3cJcP3sNd3nYPd/lVf+79i/t11F+4/+Yc1u11jnJ9f/W3qcIpd4vQJXnhvV3yzRVolzx2rn7Ku+fqp2YCufqpWUOufpr6maqfmo3k6qdmLrn6qVlOrn5q6pOrn5oPpeqnaT6Uq5+aD+Xqp+ZDufqp+VCufpr6maqfmg/l6qfmQ7n6qflQrn5qPpSrn5oPpepn0XwoVz81H8rVT82HcvVT86Fc/TT1M1U/NR/K1U/Nh3L1U/OhVP2s8p84/fy8+7FV+c9c/TT1E6efH/eatSp9m6uf0re5+il9m6uf+vwzVz/1+Weqfjb5T5x+LmStN/nPXP3U55+5+qnPP3P109TPVP3UfChXPzUfytVPzYdy9VPzoVz91HwoVT+75kO5+qn5UK5+aj6Uq5+aD23u50/ObF+kj/KYJI53U0eTdVQzomwd1ZQoW0c1J8rWUU2KsnVUs6JkHR2aFoF29Nurf+2o5kXZOqqJUbaOamYE1NFylK+Ofu/LLx01dTRZRzUzytZRzYyydVQzo2wd1cwoW0c1M8rV0f7QzAi0o1eZdFQzo2wd1cwoW0c1M4ra0XePTD0K3yPNddx7dB39q0f/ebc/9uiwbu+nXZ087TSrQeiS5i97u+Sbbdkfmr7k6qdmL6n6eWjykqufmrvk6qemLrn6qZlLrn6a+pmqn5rl5Oqnpj65+qn5UK5+aj6Uq5+aD6Xq56n5UK5+aj6Uq5+aD+Xqp+ZDufpp6meqfmo+lKufmg/l6qfmQ7n6qflQrn5qPpSqn5fmQ7n6qflQrn5qPpSrn5oP5eqnqZ+p+qn5UK5+yn/i9LPY+c9ri836Kf+Zqp8mfQvUz4+7yLtJ3+bqp6mfqfopfZurn/r8M1c/9flnrn7Kf+L08/Nuv27yn6n6WfT5Z65+6vPPXP3UfChXPzUfytVPUz9T9VPzoVz91HwoVz81H8rVT82HcvVT86FU/ayaD+Xqp+ZDm/v5kzMv7KvuVROibB3VjChbR00dTdZRzYmydVSTomwd1awoW0c1LQLt6LdX/9pRzYuSdbRpYpSto5oZAXV0ZV9108woW0c1M8rWUVNHk3VUM6NsHdXMKFtHNTPK1lHNjEA7epVJRzUzStbRrplRto5qZhS1o+8eaQoUv0ea6/j3qNSvHo36oUfjfH3/crTj22vrtx6ZehS+R5q97O2Rc65l1+QlVz81d8nVT01dcvVTM5dU/RyauOTqp+Ytufqp2UyufmqOk6ufpn6m6qfmQ7n6qflQrn5qPpSrn5oP5eqn5kOZ+jkemg/l6qfmQ7n6qflQrn5qPpSrn6Z+puqn5kO5+qn5UK5+aj6Uq5+aD+Xqp+ZDqfp5aD6Uq5+aD+Xqp+ZDufqp+VCufsp/4vSz2PnPa4vN+in/maqfp/QtUD8/7iEfp/Rtrn5K3+bqp/Rtrn6a+pmqn/r8M1c/5T9x+vl5r9845T9z9VOff+bqpz7/TNXPS/OhXP3UfChXPzUfytVPzYdy9dPUz1T91HwoVz81H8rVT82HcvVT86HN/fzBO4+v75uMUr69b/3WT82HUvXTNB/K1U/Nh3L1U/OhXP3UfChXP039TNVPzYeA+llerx3tMemn5kO5+qn5UK5+aj6Uq5+aD6XqZ9F8KFc/NR/K1U/Nh6L2890jzXzi98jUI/ceja8d03YcH3p0nvV6v/r85dXvLmk6g9AlzVx2d+ndpDJ53mmOEr9Hmo3E75HmHeF7VDXDiN8jzSXi90izhs09KuX14nZMeqRZQ/wemXoUvkeaNMTvkeYM8XukOUP8HmnOEL9HmjOE71HTnCF+jzRniN8jzRni90hzhvg9MvXof+rRm6SmAV4k5dm9SMpZe5GU//UiKZfqRLLLS3qRlOPzIilf5kVS7smLpImkE0l5HC+S8jj/TfJNh9e3tPOLTm8f/p09T2JfB7ls8i+N17n4s+T1Lu4sB6978WfJ61/8WfI6GH+WvB7Gn6WJpRtLXh/jz5LXyfizlO/xYynf48dSvseJZX085Hv8WMr3+LGU7/FjKd/jx9LE0o2lfI8fS/keP5byPX4s5Xv8WMr3uLE85Hv8WMr3+LGU7/FjKd/jx9LE0o2lfI8fS/keP5byPX4s5Xv8WMr3uLE85Xv8WMr3+LGU7/FjKd/jx9LE0o2lfI8fS/keP5byPX4s5Xv8WMr3uLG85Hv8WMr3+LGU7/FjKd/jx9LE0o2lfI8fS/keP5byPX4s5Xv8WMr3uLE0+R4/lvI9fizle/xYyvf4sTSxdGMp3+PHUr7Hj6V8jx9L+R4/lvI9biyLfI8fS/keP5byPX4s5Xv8WJpYurGU7/FjKd/jx1K+x4+lfI8fS/keN5ZVvsePpXyPH0v5Hj+W8j1+LE0s3VjK9/ixlO/xYynf48dSvsePpXyPG8sm3+PHUr7Hj6V8jx9L+R4/liaWbizle/xYyvf4sZTv8WMp3+PHUr7HjWWX7/FjKd/jx1K+x4+lfI8fSxNLN5byPX4s5Xv8WMr3+LGU7/FjKd/jxnLI9/ixlO/xYynf48dSvsePpYmlG0v5Hj+W8j1+LOV7/FjK9/ixlO/xYnk85Hv8WMr3+LGU7/FjKd/jx9LE0o2lfI8fS/keP5byPX4s5Xv8WMr3uLE85Hv8WMr3+LGU7/FjKd/jx9LE0o2lfI8fS/keP5byPX4s5Xv8WMr3uLE85Xv8WMr3+LGU7/FjKd/jx9LE0o2lfI8fS/keP5byPX4s5Xv8WMr3uLG85Hv8WMr3+LGU7/FjKd/jx9LE0o2lfI8fS/keP5byPX4s5Xv8WMr3uLE0+R4/lvI9fiw5fM+7Xg5v8q7XyOrl0Pjvejl0+LteDq38rpdDz77r5dCcX/WS7LN/18uh3d71kukrkt3t73oNtt53Dbia6V0Drg5614Crbd414OqVdw24GuSrBuB90e8acLXCuwbc+/9dA+6d/q4hwT0NvIf3XUOCexp47+y7hgT3NPCe1a8agPebvmtIcE8D7/N815DgngbeX/muIcE9Dbyv8V1D7Hv6+Tn2u4ZSf6nhX36aG3yb4R0Vx9YAN1QcfDPgHRXH1hd3VBxbjdxRcWztckfFRldxbF10R8WxVdQdFdNpruCb1O6omE5zBd9KdkfFdJor+IavOyqm01zBt2XdUTGd5gq+eeqOiuk0V/AtTndUzKa5zuAbke6omE1zncG3C91RMZvmOh9GVzGb5jqDb725o2I2zXUG3yBzR8V0miv4NpY7KqbTXME3m9xRMZ3mCr4l5I6K6TRX8I0bd1RMp7mCb6+4o2I6zRV8E8QdFdNpruBbFe6omE5zBd9QcEfFdJoreNr/HRXTaa7gyfl3VEynuYKn0N9RMZ3mCp7ofkfFdJoreDr6HRXTaa7gSeN3VEynuYKndt9RMZ3mCp6AfUfFdJoreJr0HRXTaa7gidJ3VEynuYKnSt9RMZ3mCp4sfUfFdJoreLr0HRXTaa7gCdN3VEynuYKnTN9RMZ3mCp5gfUfFdJoreDr2HRXTaa7gydt3VEynuYKnet9RMZ3mCp4YfkfFdJoreBr5HRXTaa7gSed3VEynuYKnqN9RMZ3mCp7QfkfFdJorePr7HRXTaa7gyfJ3VEynuehy6E+6HPqTLof+pMuhP+ly6E+6HPqTLof+pMuhP+ly6E+6HPqTLof+pMuhP+ly6E+6HPqTLof+pMuhP+ly6E+6HPqTLof+pMuhP+ly6E+6HPqLLof+osuhv+hy6C+6HPrrYXQVs2muiy6H/qLLob/ocugvuhz6iy6H/qLLob/ocugvuhz6iy6H/qLLob/ocugvuhz6iy6H/qLLob/ocuivQDn07zPFUUXvM8XRLe8zWcAzxbn732eKczu/zxTn/nyfKc4N9z5TnDvo60yBkrPfZwr4HA+UPv0+U8DneKAE5/eZAj7HA6Ugv88U8DkeKEn4faaAz/FAabzvMwV8jgdKtH2fKeBzPFAq7PtMAZ/jgZJV32cK+BwPlE76PlPA53ighM/3mQI+xwOlZL7PFPA5Hihp8n2me5/j779T/9LfaX/p7/S/9HfG3/k7Nyfrvf/O8Zf+zvmX/s71l/6O/aW/85eeB/UvPQ/qX3oe1L/0PKh/6XnQ/tLzoP2l50H7S8+D9peeB+0vPQ/aX3oetL/0PGh/6XnQ/tLzoP2l50H/S8+D/peeB/0vPQ/6X3oe9L/0POh/6XnQ/9LzoP+l50H/S8+D/peeB+MvPQ/GX3oejL/0PBh/6Xkw/tLzYPyl58H4S8+D8ZeeB+MvPQ/G33kemMcvOc9mX3+nj1/+zr/7Fpp5/NryhlOdIU91hTyVhTxVCXmqGvJULeSpeshTjYinOkI+24+Qz/Yj5LP9CPlsP0I+24+Qz/Yj5LP9CPlsP0I+24+Qz/Yz5LP9DPlsP0M+28+Qz/Yz5LP9DPlsP0M+28+Qz/Yz5LP9DPlsv0I+26+Qz/Yr5LP9Cvlsv0I+26+Qz/Yr5LP9Cvlsv0I+26+Qz3YL+Wy3kM92C/lst5DPdgv5bLeQz3YL+Wy3kM92C/lst5DP9hLy2V5CPttLyGd7CflsLyGf7SXks72EfLaXkM/2EvLZXkI+22vIZ3sN+WyvIZ/tNeSzvYZ8tteQz/Ya8tleQz7ba8hnew35bG8hn+0t5LO9hXy2t5DP9hby2d5CPttbyGd7C/lsbyGf7S3ks72HfLb3kM/2HvLZ3kM+23vIZ3sP+WzvIZ/tPeSzvYd8tveQz/YR8tk+Qj7bR8hn+wj5bB8hn+0j5LN9hHy2j5DP9hHy2T4iPttLyN+llpC/Sy0hf5daQv4utTwiPttLyN+llpC/Sy0hf5daQv4utYT8XWoJ+bvUEvJ3qSXk71JLyN+llpC/Sy0hf5daQv4utYT8XWoJ+bvUEvJ3qSXk71JLyN+llpC/Sy0hf5daQv4utYT8XWoJ+bvUEvJ3qSXk71JLyN+llpC/Sy0hf5daQv4utYT8XWoJ+bvUEvJ3qSXk71JLyN+llpC/Sy0hf5daQv4utYT8XWoJ+bvUEvJ3qfXmXOP/fvXPNmg/vl59PP/vW8W/3aD9o/duj/p661Ye71cX+x/f+bzK653Pa3zb+l1/e+Y+vt75/PDOz3/Z/7z2+a/p9/28OT9a/fzb/Yyzl0z99OhnnJ1u6qdHP+Psw1M/Pfpp6meqfsbZp6t+evQzzi5i9dOjn3H2OKufHv2MswNb/fTop+ZDmfrZHpoPAfWzP179HGXST82HcvVT86Fc/dR8KFc/Tf3E6Wd797NO+qn5UK5+aj6Uq5+aD+Xqp+ZDufqp+VCqfh6aDwH1s/RXP//zXr/tp+ZDufqp+VCufmo+lKufpn6m6qfmQ7n6qflQrn5qPpSrn5oP5eqn5kOp+nlqPpSrn5oP5eqn5kO5+qn5UK5+mvqZqp+aD+Xqp+ZDufqp+VCufmo+lKufmg+l6uel+VCufmo+lKufmg/l6qfmQ7n6aepnqn5qPpSrn5oP5eqn5kO5+qn5UK5+aj6Uqp+m+VCufmo+lKufmg/l6qfmQ7n6aepnqn5qPpSrn5oP5eqn5kO5+qn5UKp+FvlP/34e/aufxTz7+Tmfush/5uqn/Geufpr6maqf8p+5+in/mauf8p+5+in/mauf+n5Cqn5WfT8hVz81H8rVT82HgPr5eZ9O1XwoVz9N/UzVT82HcvVT8yGgfn7e11E1H8rVT82HcvVT86FU/WyaD+Xqp+ZDufqp+RBQPz9/v69pPpSrn6Z+puqn5kO5+qn5UK5+aj6Uq5+aD+Xqp+ZDqfrZNR/K1U/Nh3L1U/OhXP3UfChXP039TNVPzYdy9VPzoVz91HwoVz81H8rVT82HUvVzaD6Uq5+aD+Xqp+ZDufqp+VCufpr6maqfmg/l6qfmQ7n6qflQrn5qPpSrn5oPZepnf2g+lKufmg/l6qfmQ7n6qflQrn6a+pmqn5oP5eqn5kO5+qn5UK5+aj6Uq5+aD6Xq56H5UK5+yn+69/P8isF8ttZ1H93HfOp+mPqZqp/yn7n6Kf+Zq5/yn7n6Kf+Zq5/yn6n6ecp/5uqnvp+Qq5/6fkKufmo+lKufpn7i9PPjPp1+aj6Uq5+aD+Xqp+ZDufqp+RBQPz/u6+in5kOp+nlpPpSrn5oP5eqn5kO5+qn5UK5+mvqJ08/P3++7NB/K1U/Nh3L1U/OhXP3UfChXPzUfStVP03woVz81H8rVT82HcvVT86Fc/TT1M1U/NR/K1U/Nh3L1U/OhXP3UfChXPzUfStXPovlQrn5qPpSrn5oP5eqn5kO5+mnqZ6p+aj6Uq5+aD+Xqp+ZDufqp+VCufmo+lKqfVfOhXP3UfChXPzUfytVPzYdy9dPUz1T91HwoVz81H8rVT82HcvVT86Fc/dR8KFU/m+ZDufqp+VCufmo+lKuf8p9L/fRNkW5yiTuoy8vtoC7HtYO6fNEG6l3uZQd1eYwd1OUEdlDX57k7qJuob6Aub7qDurypO/XPezG6vOkO6vKmO6jLm26gPuRN3al/zoMf8qY7qMub7qAub7qDuon6Burypjuoy5u6U//8HYEhb7qDurzpDurypn+f+njIm+6gLm+6g7q86Q7q8qY7qJuob6Aub7qDurzpDurypjuoy5vuoC5vuoH6IW+6g7q86Q7q8qY7qMub7qBuor6BurzpDurypjuoy5vuoC5vuoO6vOkG6qe86Q7q8qY7qMub7qAub7qDuon6Burypjuoy5vuoC5vuoO6vOkO6vKmG6hf8qY7qMub7qAub7qDurzpDuom6huop9LrrolF40qlqp3ZpNK+vmwslUJ1ZpNKRzqzSaX2nNmk0mTObExspmxSzd6d2aSakDuzkS6es6HVxR/T8IbR6uLPbAqtLl5gQ6uLF9jQ6uKPyVWj0OriBTYmNlM2tLp4gQ2tLl5gQ6uLF9jQ6uLPnzMUWl38mU2l1cULbGh18QIbWl28wIZWFy+wMbGZsqHVxQtsaHXxAhtaXbzARrp4zka6eMqmSRfP2UgXz9lIF8/ZSBfP2ZjYTNlIF8/ZSBfP2UgXz9lIF8/ZSBdP2XTp4jkb6eI5G+niORvp4jkbE5spG+niORvp4jkb6eI5G+niORvp4imbXJvIndlIF8/ZSBfP2UgXz9mY2EzZSBfP2UgXz9kE1zfH+cXmUY5PbH7w3me9vk5d+7dvGJ/n704yvn42cz7Od2bIUfv/2qNPv/9rj+hbddWjZ4+C6z316Nmj4LpTPXr2KLj+VY+ePTL1KHyPgvsB9ejZo+C+RD169ij45wbq0bNHwT+/UI+ePdKcIXyPom9Izt+jT9kszx5pzhC/R5ozxO+R5gzxe2Tq0d4efcpgefZIc4b4PdKc4f8TvkeaM8TvkeYM8XukOUP4HkXfdp2/R5++F/TskeYM8XukOUP8HmnOEL9Hph6F75HmDPF7pDlD/B5pzhC/R5ozxO+R5gzhexR9c7l69OyR5gzxe6Q5Q/weac4Qv0emHoXvkeYM8XukOUP8HmnOEL9HmjPE75HmDOF7ZJozxO+R5gzxe6Q5Q/weac4Qv0emHoXvkeYM8XukOUP8HmnOEL9HmjPE75HmDOF7VDRniN8jzRni90hzhvg90pwhfo9MPQrfI80Z4vdIc4b4PdKcIX6PNGcI36NK649K/aJeH8enHl3thf2w8u7Rab+rsTxeLy5H/3aO+o07refZzJ3Wx2zmbuK+hTut39jMndZD3Mn9nZlczgl3Wl+wmTut1t/MnfZzwr3cG+1nf3dyv778arkm3OVX93CXX93DXX51D3cT9y3c5Vf3cJdfvYH7+TUnuMqEu/zqHu7yq3u4y69u4d7lV/dwl1/dw11+dQ93+dU93E3ct3CXX93DXX51D3f51T3c5Vf3cJdf3cJ9yK/u4S6/uoe7/Ooe7vKre7ibuG/hLr+6h7v86h7u8qt7uMuv7uEuv7qD+/GQX93DXX51D3f51T3c5Vf3cDdx38JdfnUPd/nVPdzlV/dwl1/dw11+dQv3Q351D3f51T3c5Vf3cJdf3cPdxH0Ld+n3Je7nYa+DnL194v4xb+k4pN/3cJd+38L9lH7fw136fQ936fcbuH/MhThO6fc93E3ct3DX5017uOvzpj3c5Vf3cJdfvYH75/nMKb+6hfslv7qHu/zqHu7yq3u4y6/u4W7ivoW7/Ooe7vKre7jLr+7hLr+6h7v86hbuJr+6h7v86h7u8qt7uMuv7uFu4r6Fu/zqHu7yq3u4y6/u4S6/uoe7/OoW7kV+dQ93+dU93OVX93CXX93D3cR9C3f51T3c5Vf3cJdf3cNdfnUPd/nVLdyr/Ooe7vKre7jLr+7hLr+6h7uJ+xbu8qt7uMuv7uFOq9+PXr5ObeMD94WEjUaryN1J0mpsd5K0qtmdJK0OdidpIrlC0l7nKN8q/JUkrVZ1J0mrPt1J0n7+4U6S9hONn5H8nBXT5HGcSHZ5HC+S8jheJOVxvEjK43iRNJFcIfl5PtnlcbxIyuN4kZTH8SIpj+NFUh7HieSQx/EiKY/jRVIex4ukPI4XSRNJJ5LyOF4k5XG8SMrjeJGUx/EiKY/jQ/J8yON4kZTH8SIpj+NFUh7Hi6SJpBNJeRwvkvI4XiTlcbxIyuN4kZTHcSJ5yON4kZTH8SIpj+NFUh7Hi6SJpBNJeRwvkvI4XiTlcbxIyuN4kZTHcSJ5yuN4kZTH8SIpj+NFklZPPq7jderHsE8kP2YOnCetnnQnSasn3UnS6kl3krR60pvkRasnf0byY3rDedHqSXeStHrSnSTtzNydpInkCsmPv5Q/L3kcL5LyOF4k5XG8SMrjeJGUx3EiafI4SyQ/zydNHseLpDyOF0l5HC+SJpJOJOVxvEjK43iRlMfxIimP40VSHseJJO82e3eS8jheJOVxvEjK43iRNJF0IimP40VSHseLpDyOF0l5HC+S8jhOJHk3oLuTlMfxIimP40VSHseLpImkE0l5HC+S8jheJOVxvEjK43iRlMdxIsm7U96dpDyOF0l5HC+S8jheJE0knUjK43iRlMfxIimP40VSHseJJO3+7qP3r7ce1j+R/Jw5QLu/258kq570J2ki6USSVU/6k2TVkz8k+Tm9gXZ/tz9JVj3pT5J1Zu5OknZ/9w9Jfv6lPO3+bn+S8jheJOVxvEiaSDqRlMfxIimPs0Ty83ySdn+3P0l5HC+S8jg+JC/a/d3+JOVxvEjK43iRlMfxImki6URSHseLpDyOF0l5HC+S8jheJOVxnEjS7u/2JymP40VSHseLpDyOF0kTSSeS8jheJOVxvEjK43iRlMfxIimP40SSdn+3P0l5HC+S8jheJOVxvEiaSDqRlMfxIimP40VSHseLpDyOF0l5HCeStDvl/UnK43iRlMfxIimP40XSRNKJJK2ebI/6euvWxieSHzMHLtr93f4kafWkN0na/d3+JGn1pDtJWj35M5IffwF60e7v9idpIulEknZm7k6SdmbuTlIex4ukPM4Syc++m3Z/tztJ2v3d/iTlcbxIyuN4kZTH8SJpIulEUh7Hi6Q8jhdJeRwvkvI4XiTlcZxI0u7v9icpj+NFUh7Hi6Q8jhdJE0knkvI4XiTlcbxIyuN4kZTH8SIpj+NEknZ/tz9JeRwvkvI4XiTlcbxImkg6kZTH8SIpj+NFUh7Hi6Q8jhdJeRwnkl0ex4ukPI4XSXkcL5LyOF4kTSSdSMrjeJGUx/EimUpP9vH13ueH9/62kdt+PccXm1wbuZ3ZpNJ8zmxSqThnNql0mTMbE5spm1TayZlNKjXkzCbVDNeZTaqprDMb6eIZG8u1xfknbPrjxWaUCRtaXbzAhlYXL7Ch1cULbIyVTXuzqRM2tLp4gQ2tLl5gQ6uLF9jQ6uIFNrS6+DObXJt/f8KmfKVV1TZhQ6uLF9jQ6uIFNrS6eIGNic2UDa0uXmBDq4sX2NDq4gU2tLp4gQ2tLv7MJte2WGc20sVzNtLFczbSxXM2JjZTNtLFczbSxXM20sVzNtLFczbSxVM2uTaMOrORLp6zkS6es5EunrMxsZmykS6es5EunrORLp6zkS6es5EunrLJtSnVmY108ZyNdPGcjXTxnI2JzZSNdPGcjXTxnI108ZyNdPGUTey9h4/ev9g8xrf8jd+zGe316tEmv6WLvZ3whnpD65Ab6jWyekPrhRvqDa0Bfljv8Xg83uceH9599NfTfIzZ0zy0CthOJ7QO2E4n9IRsN53YW+i208mkIv3pZNKc/nQyKdSf0fmJl5uf+k3SRNKJZCZVvZckr173Jsmr7b1J8voAb5K8nsGZZOwNcFAkeb2IN0le3+JNUh7Hi6SJpBNJeRwvkvI4XiTlcbxIyuN4kZTHcSIZewMcFEl5HC+S8jheJOVxvEiaSDqRlMfxIimP40VSHseLpDyOF0l5HCeSsXcYQpGUx/EiKY/jRVIex4ukiaQTSXkcL5JSQUu/Kvy4sa7E3lgHRVI3js8vXctDN44XSd04XiQ1VfMiqamaF0lN1bxISk+ukKxH/ee19Tp/TzL2pjcokpqqeZHUVM2LpDyOF0kTSSeS8jheJOVxvEjK43iRlMfxIimP40Qy9tY+KJLyOF4kiT3OT05ynV/vfH1756PVbyyJXY47SxNLN5bETsedJbHXcWdJ7HbcWRL7HXeWxI7nRyzL10GuevyeZeyNjGAsiV2PO0v5Hj+W8j1+LE0s3VjK9/ixlO/5Ocs+YSnf48dSvsePpXzPGsvx9pBj4iFjb9wEYynf48dSvsePpXyPH0sTSzeW8j1+LOV75r+nLbF3km6nI2/yJzpyG3+gU+Qf/kRHjuBPdKTx/0Qn1b7cj9vXSq59uQv1ptqXu1BvJoW6Um8mzblSbyYVuVJvJl24UG+qvbMr9WbSbiv1ZlJjK/WS6atUO1lX6iXTV6n2m67US6avUu0KXamXTF+l2ru5Ui+Zvkq1w3KlXjJ9lWof5Eq9ZPoq1W7FlXrJ9FWqPYUr9ZLpq1Q7/1bqJdNXqfbnrdRLpq9S7aJbqZdMX6Xa67ZSL5m+SrUjbaVeMn2Vat/YSr1k+irV7q6Vesn0Vao9WCv1kumrQaavBpm+GmT6KtWOtM/11lSbzFbq5dJX9cGlr2qqfXIr9RpZvVz6qqbaoLZSL5e+qqm2ka3US6avUm32WqmXTF+l2pK1Ui+Zvkq1cWqlXjJ9lWp700q9ZPoq1SaklXrJ9FWqrUIr9ZLpq1QbelbqJdNXqTbdrNRLpq9SbYxZqZdMX6XavLJSL5m+SrXBZKVeMn2VahPISr1k+irVRo2Vesn0VarNFCv1kumrVBseVuol01epNiWs1Eumr1JtHFipl0xfpUruX6mXTF+lSsBfqZdMX6VKqV+pl0xfpUqSX6mXTF+lSntfqZdMX5Hlt1ey/PZKlt9eyfLbK1l+eyXLb69k+e2VLL+9kuW3V7L89kqW315T5Xv/cDtUH18nOT+8ttjrHMWuCUni/X7OJIl3AfqSTJV2vpck8Y5BZ5LE+widSRJvHHcmaSLpRJJ427gzSeJd484k5XG8SMrjLJHsrzcuo0xIyuM4kUy1cWAvSXkcL5LyOEsk25tknZCUx/EiaSLpRFIex4ukPI4XSXkcL5LyOEsky+uzxVInny2m2s2xlWSqrR97ScrjeJGUx/EiKY/jRdJE0omkPI4XSXkcL5LyOF4k5XG8SMrj+JBsqTbv7CUpj+NFUh7Hi6Q8jhdJE0knkvI4XiTlcbxIyuN4kZTH8SIpj+NEMtX2q70k5XG8SMrjeJGUx/EiaSLpRFIex4ukPI4XSXkcL5LyOF4k5XGcSKbaQLeXpDyOF0l5HC+S8jheJE0knUjK43iRlMfxIhlbT7brjaZ/+7X/JEeuvbiP9vtkgBZ8L55/vbG1mX+9sRWUf72xdY5/vZao3p89+T+nZLbgW/R204mtGnbTiT3t3E0n9gRzN51MKtKdTvBdgbvpZFKo93m5+anfJDNp370kM6nqvSRNJJ1I8mp7b5K8PsCbJK9n8CbJ6y+8SfJ6EWeSwXdwIpGUx/EiKY/jRVIex4ukiaQTSXkcL5LyOF4k5XG8SMrjeJGUx3EiGXwPLhJJeRwvkvI4XiTlcbxImkg6kZTH8SIpj+NFUh7Hi6Q8jhdJeRwnksG3ayORlMfxIimP40VSHseLpImkE0l5HC+S8jheJOVxnEgG378bheTnPeUt+P5dJJK6cZZIfk4ECL7rFImkbhwvkpqqeZHUVM2JZPBdp0gkpSdXSNaj/vPaep0TktKTXiQ1VfMiaSLpRFIex4ukPI4XSXkcL5LyOF4k5XF8SPbgu06RSMrjeJGUx/EiKY/jRdJ4Sf7gJHbZaxhkV3lPg45Wv7EkdjnuLIl9jjtLYqfjzpLY67izJHY73iyD7z3FYknseH7Esj++WPYxYUnsedxZErsed5Ymlm4s5Xv8WMr3+LGU7/FjKd/zY5ajTljK97ixDL4LFYulfM8SSzu+PKSdEw8ZfB8qFkv5Hj+WJpZuLOV7/FjK9/ixlO/xYynfs8ayXF8s6zlhKd/jxjLVNuDdLOV7/FjK9/ixlO/xY2li6cZSvmeeMdKJdzWv0JE3+RMduY0/0ZF/+AMd4l3NK3Sk8f9EJ5Nq/7y5u6fakrxSr5HVm0mhrtSbSXOu1JtJRa7Um0kXrtSbSekt1JtqX+1KvZnU2Eq9ZPoq1YbWlXqNrF4yfZVqJ+lKvWT6KtV+z5V6yfRVql2ZK/WS6atUeydX6iXTV6l2OK7US6avUu1DXKmXTF+l2i24Ui+Zvkq1p2+lXjJ9lWrn3Uq9ZPoq1f64lXrJ9FWqXWwr9ZLpq0amrxqZvupk+irVnr6Vesn0VSfTV93I6iXTV6k2D67US6avUm3xW6mXTF+l2oi3Ui+Zvkq1XW6lXjJ9lWpT20q9ZPoq1dazlXrJ9FWqDWIr9XLpq5FqG9dKvVz6aqTabLVSL5e+Gg8jq5dLX41U25ZW6uXSVyPV1qKVesn0VartPyv1kumrVFt0Vuol01epttGs1Eumr1JtdVmpl0xfpdqOslIvmb5KtWVkpV4yfZVqW8dKvWT6KtXWi5V6yfRVqu0RK/WS6atUWxhW6iXTV6m2GazUS6avUm0FWKmXTF+lStdfqZdMX6XKtF+pl0xfpcqdX6mXTF+lyoZfqZdMX5Hltw+y/PZBlt8+yPLbB1l++yDLbx9k+e2DLL99kOW3D7L89kGW3z7I8tsHWX77IMtvH2T57YMsv32Q5bcPsvz2QZbfPsjy2wdZfvsgy28fZPntgyy/fZDltw+y/PZBlt8+yPLbB1l++yDLbx9k+e2DLL99kOW3D7L89kGW3z7I8tsHWX77IMtvH2T57YMsv32Q5bcPsvz2QZbfPsjy2wdZfvtIle99PB7vl5/jw7u3Pr5Ocn54bbHzn9cWu35PMlVy+F6SmTTDXpKZ1Mhekpl0zl6SJpJOJDNps70kM6m+vSQzzev2ksw0CdxLUh7HhWR/pErvv5Fkf71xGWVCUh7Hi6Q8jhdJeRwvkiaSKyTbm2SdkJTH8SIpj+NFUh7Hi6Q8jhdJeRwnkqk2aNxIsrw+Wyy1TUjK43iRlMfxIimP40XSRNKJpDyOF0l5HC+S8jheJOVxvEjK4ziRTLXFZi9JeRwvkvI4XiTlcbxImkg6kZTH8SIpj+NFUh7Hi6Q8jhdJeRwnkqk2Se0lKY/jRVIex4ukPI4XSRNJJ5LyOF4k5XG8SMrjeJGUx/EiKY/jRDLVNre9JOVxvEjK43iRlMfxImki6URSHseLpDyOF0l5HC+S8jhOJIPvxSu9fB2kjk8kR3slA4w2SQYIvhfPv97Y2sy/XiOrN7bO8a83thr5Wb0/e/J/TMl80omtMHbTia0adtOJPe3cTCf4Pr/ddDKpSH86mTSnP51MCvU+Lzc/9ZukiaQTyUyqei9JXr3uTZJX23uT5PUB3iR5PYMzyeD7LJFI8noRb5K8vsWbpDyOF0kTSSeS8jheJOVxvEjK43iRlMfxIimP40Qy+E5ZJJLyOF4k5XG8SMrjeJE0kXQiKY/jRVIex4ukPI4XSXkcL5LyOE4kg2/XRiIpj+NFUh7Hi6Q8jhdJE0knkvI4XiTlcbxIyuN4kZTH8SIpj+ND8gi+fzcKyc97yo+HiaQTSd04SyQ/JgIcwXedIpHUjeNEMviuUySSmqp5kdRUzYuk9OQKyXrUf15br3NC0kTSiaSmal4kNVXzIimP40VSHseLpDyOE8ngu06RSMrjeJGUx/EiKY/jRdJE0omkPI4XSWKP84OTdDtfw6Bu13sadLT6jSWxy3FnSexz3FkSOx1vlsF3nmKxJHY77iyJ/Y47S2LH8yOW9fHFso4JSxNLN5bErsedpXyPH0v5Hj+W8j1+LOV73FgG34MakuWT3+9Zyvf4sZTv8WMp37PGcnx5yPKYeMjg+1CxWMr3+LGU7/FjKd/jx1K+x4+lfI8byyLfs8Sy2Je+LDbxkKk29u5mKd/jx1K+x4+liaUbS/keP5byPX4s5Xt+zLJMZm7Em539Wcr3uLEk3hq9kCNEvDV6hY68yZ/oyG38iY6Jzh/oyBH8iY40/p/oZFLto79Gt2NMsllS7UpeqTeT+l2oN9Xe4ZV6M2nOlXozqciVejPpwpV6jazeTNptpd5MamylXjJ9lWpP60q9ZPoq1c7TlXrJ9FWq/aEr9ZLpq1S7OFfqJdNXqfZartRLpq9S7YhcqZdMX6Xat7hSL5m+SrW7cKVeMn2Vag/gSr1k+irVTr2Vesn0Var9dCv1cumr88Glr84Hl746H1z66ky1u3ClXiOrl0tfnQ8ufXWm2vO4Ui+XvjpT7UxcqDfVZsOVesn0VaotgSv1kumrVBv3Vuol01epttet1Eumr1Jtglupl0xfpdqqtlIvmb5KtaFspV4yfZVq29dKvWT6KtXmrJV6yfRVqg1UK/WS6atUm5xW6iXTV6k2Iq3US6avUm0WWqmXTF+l2tCzUi+Zvkq16WalXjJ9lWpjzEq9ZPoq1eaVlXrJ9FWqDSYr9ZLpq1SbQFbqJdNXqTZqrNRLpq9SbaZYqZdMX6Xa8LBSL5m+SrUpYaVeMn2VauPASr1k+ipVcv9KvWT6KlUC/kq9ZPoqVUr9Sr1k+ipVkvxKvWT6KlXa+0q9ZPqKLL/9JMtvP8ny20+y/PaTLL/9JMtvP8ny20+y/PaTLL/9JMtvP8ny20+y/PaTLL/9JMtvP8ny20+y/PaTLL/9JMtvP8ny20+y/PaTLL/9JMtvP8ny20+y/PaTLL/9JMtvP8ny20+y/PaTLL/9JMtvP8ny20+y/PaLLL/9Istvv8jy2y+y/PbrYWT1cumriyy//SLLb7/I8tsvsvz2iyy//SLLb79S5Xsfj8fjfe7x4d1bH18nOT+8ttj5z2uLXROSmW72vSQzaYa9JDOpkb0kM+mcvSQzKaitJFNlv+8lmUn17SWZaV63l2SmSeBekiaSTiTlcZZI9tcbl1EmJOVxvEjK43iRlMfxIimPs0SyvUnW35NMtX9hL0l5HC+S8jheJOVxvEiaSDqRlMdZIlleny2WOvlsMdVujr0k5XG8SMrjeJGUx3EimWoHyl6S8jheJOVxvEjK43iRNJF0IimP40VSHseLpDyOF0l5HC+S8jhOJFPtIdpLUh7Hi6Q8jhdJeRwvkiaSTiTlcbxIyuN4kZTH8SIpj+NFUh7HiWSqXWB7ScrjeJGUx/EiKY/jRdJE0omkPI4XSXkcL5LyOF4k5XG8SMrjOJFMtY9vL0l5HC+S8jheJOVxvEjG1pPXcX0dxM5PJEd7JQOMNkkGCL4Xz7/e2NrMv97YCsq93uB78fzrja1Gflbvz578CymZwbfo7aYTWzXspmOi8wc6sSeYu+lkUpH+dDJpTn86mRTqfV5ufuo3yUzadyvJ4NsQkUjy6nVvkrza3pskrw/wJmki6USS1194k+T1It4keX2LN0l5HC+S8jg+JC34RlIkkvI4XiTlcbxIyuN4kTSRdCIpj+NFUh7Hi6Q8jhdJeRwvkvI4TiSDbwVGIimP40VSHseLpDyOF0kTSSeS8jheJOVxvEjK43iRlMfxIimP40Qy+HZtJJImkiu/Kvy4f9eC799FIqkbx+eXrhZ81ykQyeC7TpFIaqrmRVJTNS+Smqp5kTSRXCBZj/rPa+t1TkhKT3qR1FTNi6Smal4k5XG8SMrjOJEMvusUiaQ8jhdJeRwvkvI4XiRNJJ1IyuN4kZTH8SJJ7HF+cpKzHa93Pv9T1+vV1/WNJbHLcWdJ7HO8WQbfeIrFktjruLMkdjvuLIn9jjtLE8slltbfLI9fWP73q8f10q2jfjvFo/7uFF+fvLVh79ee31pEbKVQWkTs0VBaJPMXvkXylOFbJKsavUXB9+GqRc8WyViHb5H8evgWaQwQvkWmFkVvkaYLSye5HvZ65+v7q78P04KvM8ZiKb/ux1LG2o+lHLAby+BrjbFYylP6sZT5W2N51S+WViYs5dL8WJpYurGU7/FjKd/jx1K+x4+lfI8fS/meH7P8VuMvLFOtOd/NUr7Hj6V8zx8C1YgXrq/QMdH5Ax25jT/RkX/4Ex05gj/Rkcb/E51Mqn3014fZY0xCqlKtOl+pN5P6Xak3k0JdqTeT5lyp18jqzaQLV+rNpPRW6s2k3VbqzaTGVurl0lcl1ZrllXq59FVJtbJ4pV4ufVUeRlYvl74qqVbprtTLpa9KqrW0K/WS6atUK15X6iXTV6nWpa7US6avUq0eXamXTF+lWuO5Ui+Zvkq1EnOlXjJ9lWq95Eq9ZPrqJNNXJ5m+SrXUdKVeMn11kumrk0xfpVoAu1Ivmb5KtUx1pV4yfZVqMelKvWT6KtWSz5V6yfRVqoWZK/WS6atUyydX6iXTV6kWOa7US6avUi1FXKmXTF+lWjC4Ui+Zvkq1rG+lXjJ9lWrt3Uq9ZPoq1fq4lXrJ9FWqNWwr9ZLpq1TrzFbqJdNXqRZtrdRLpq9SrYBaqZdMX6VaTrRSL5m+SrU2Z6VeMn2VaqHLSr1k+irVBpOVesn0VapNICv1kumrVBs1Vuol01epNlOs1Eumr1JteFipl0xfpdqUsFIvmb5KtXFgpV4yfZUquX+lXjJ9lSoBf6VeMn2VKqV+pV4yfZUqSX6lXjJ9lSrtfaVeMn1Flt9eyPLbC1l+eyHLby9k+e2FLL+9kOW3F7L89kKW317I8tsrWX57TZXv/cPtUH18neT88Npi5z+vLXZNSGa62feSJN4F6EySeG+gM0niHYPOJIn3ETqTJN447ksyVar8XpLE28adSRLvGncmKY/jRdJEcoVkf73xc/45ISmP40VSHseLpDyOF0l5nCWS7U2yTkjK4ziRTLXZYS9JeRwvkvI4XiTlcbxImkiukCyvzxZLnXy2mGo3x16S8jheJOVxvEjK43iRlMdxIplqu8pekvI4XiTlcbxIyuN4kTSRdCIpj+NFUh7Hi6Q8jhdJeRwvkvI4TiRTbTjaS1Iex4ukPI4XSXkcL5Imkk4k5XG8SMrjeJGUx/EiKY/jRVIex4lkqi1je0nK43iRlMfxIimP40XSRNKJpDyOF0l5HC+S8jheJOVxvEjK4ziRTLXpby9JeRwvkvI4XiRj68mjHu+DnOcHkgvJAMH34vnXG1ub+dcbW0H51xtb57jXG3wvnn+9sTWDf72xb3b/emPPGP3rNbJ6yfRV8L14P6z3c4JK8L14/vWm0lcL9abSV5/rDb4X74f1fk5RCL4Xz7/eVPpqod5U+mqhXiOrN5W+Wqg3lb76PJ8MvhfPv95U+mqh3lT66nO9wffi+debSl8t1JtKXy3Um0pfLdRrZPWm0lcL9ZLpq+B78fzrJdNXwffiedfbgu/F86+XS1+1B5e+asH3HvrXa2T1cumrFnzTn3+9XPqqBd+a518vmb4KvoHOv14yfRV8m5t/vWT6KvhmNP96yfRV8C1j/vWS6avgG7v86yXTV8G3X/nXS6avgm+S8q+XTF8F38rkX2/k+3eM8f4h5nEeH8od7fX19tGuSbmRr98byo18+/qXG3otyw3lRr57byg38tX7w3J/9pvx0V/P8TEmz/HQO0u2w4l8qW+HE3nCsh1O5HHMdjiJtKM/nERK0x9OIl16X/zL/NBfIEMv6YACmUhL7wVJq9K9QdIqem+QJpA+IGmdgjdIWlfhDZLWgXiDpHUr3iDlbHxAhl7NAQVSzsYJpJyNE0g5GyeQJpA+IOVsnEDK2TiBlLNxAiln4wRSzsYHZOiFHFAg5WycQMrZOIGUs3ECaQLpA1LOxgmknI0TSDkbJ5ByNk4g5Wx8QIZe7gMFUs7GCaScjRNIORsnkCaQPiDlbJxAytk4gZSzcQIpZ+MEUs7GB2TotVpQIOVsnEDK2TiBlLNxAin5swDy8w7WFnqHFBLI0MuL4oD8nBIVeisSFEhdNk4gTSB9QGqM5gRSYzQnkNKRCyDrUf95bb3OCUjpSCeQGqO5gOyht3tBgZSzcQIpZ+MEUs7GCaQJpA9IORsnkHI2TiDlbJxAytk4gZSz8QEZeq8eFEg5GyeQcjZOIOVsnECaQPqA5HU2PzjIeXyRPI+rvM/Rxu9eXcrrxe2YYOf1QVux87qmrdh5PdZW7LyOzAn7F8rQuzjBUPK6MneUvL7MHSWvM3NHaULphVLuzA2lHJcbSrmoJZTjS6Gfj/4Lyn81qsm0cBgJu1yUO/bz/OJh5ffYMy1gRsIud7YFu5zcFuxyfVuwm7DvwC43uQW7nKc/9s+ffvCuFN+LXS51C3a51B3YiZem/wT7efWvErt9wH6Ur1MXm2CXS92CXS7VHbtvclInXvUO0yJTi6K3SE45fIvkqsO3SA48fIvk1sO3SM4+eouKpgDhW6SJQfgWaboQvkWaLoRvkalF0Vuk6UL4Fmm6EL5Fmi6Eb5GmC+FbpOlC9BZVTRfCt0jThfAt0nQhfIs0XQjfIlOLordI04XwLdJ0IXyLNF0I3yJNF8K3SNOF6C1qmi6Eb5GmC+FbpOlC+BZpuhC+RaYWRW+RfNHWFn1eVd6bfFH0FnUpur0t+rg6uHcpuvAtkqIL3yJTi6K3SJ8XhW+RPi8K3yL5oq0tWgjy7fJF4Vukz4uit2jo86LwLdJ0IXyLNF0I3yJNF8K3yNSi6C3SdCF8izRdCN8iTRfCt0jThfAt0nQheIvGQ9OF8C3SdCF8izRdCN8iTRfCt8jUougt0nTBv0U/eOdjvM88jveZj/r4lw3VLCJZQzW5SNZQzTmSNVRTkbAN/WrSobkIQJM0GQFokmYjAE3SdASgSaYmxW+SJiQATdLUA6BJmmQANEnTCYAmaeKwuUnteL3z46i/NOk35/i4BX2cmk4ka6gmGUAN9Y34GacmJMTN1+SFuPmm5vM2X5Mi4uZrAkXcfE22iJuviRlx8zWJ423+pakdcfM14SNuviZ8xM3XhI+4+abm8zZfEz7i5mvCR9x8TfiIm68JH3HzNeHjbb5pwkfcfE34iJuvCR9x8zXhI26+qfm8zdeEj7j58vlJm/95o+ww+Xze5hep/azN/7h5cBSpfeLmm5rP23ypfeLm6/N84ubr83zi5svnJ23+Qlpvkc/nbX7V5/nEzdfn+cTN14SPuPma8BE339R83uZrwkfcfE34iJuvCR9x8zXhI26+Jny8zW+a8BE3XxM+pOb/5J2P8TrzcT6+fa73+N5+zfio268pH3X7Te1nbr8mfdTt16yPuv2a9lG3X/O+FO1/N1QzvFwN7ZrLbW3o83H5+GroKB8aurDhrmvWlqyhmp4BNdQ5+qBrdkbcfFPzeZuvuRlx8zU1I26+ZmbEzdfEjLj5mq7xNn9oEkfcfE3tiJuvCR9x8zXhI26+qfm8zdeEj7j5mvARN18TPuLma8JH3HxN+FibP5641Hze5mvCR9x8TfiIm68JH3HzTc3nbb4mfMTN14SPuPny+Umb/3Fr3Xgc8vnEzZfaz9r8Txtsns03NZ+3+VL7xM2X2iduvj7PJ26+Ps8nbr58ftLmf4w1Ho9TPp+4+fo8n7j5+jyfuPma8BE339R83uZrwkfcfE34iJuvCR9x8zXhI26+Jny8zb804SNuviZ8SM3/wTsv7K54tl8zPur2a8pH3X5T+5nbr0kfdfs166Nuv6Z91O3XvC9F+98N1QwvV0NNc7m9DX0+R1/vfFztQ0OfDbBXhcdlk5Zq2paupZqgAbXUvl5s1+PDO39/bZ80X/Mz4uabmp+z+c8zv97YyqT5mp0RN1+TM+Lma25G3HxNzYibrwkbb/OLpnFZm1/K643bMWm+5nbEzdeEj7j5mvARN9/UfN7ma8JH3HxN+IibrwkfaPMnn9QVTe2SNVSTuFwNrZquJWuoJmbJGqopWLKGarKVrKGmhuZqqCZQyRqqqVKyhmpStLmh799cHbV8aOjS7zmqZkXpWqppUbaWNs2L0rVUE6N0LdXMKF1LNTVK11JTS7O1VJOjdC3V7ChdSzU9StdSTY/StVTTo2wt7ZoepWuppkfpWqrpUbqWanqUrqWmlmZrqaZH6Vqq6VG6lmp6lK6lmh6la6mmR9laOjQ9StdSTY/StVTTo3Qt1fQoXUtNLc3WUk2P0rVU06N0LdX0KF1LNT1K11JNj5K19ElBLc3WUk2P0rVU06N0LdX0KF1LTS3N1lJNj9K1VNOjdC3V9ChdSzU9StdSTY+ytfTQ9ChdSzU9StdSTY/StVTTo3QtNbU0W0s1PUrXUk2P0rVU06N0LdX0KF1LNT3K1tJT06N0LdX0KF1LNT1K11JNj9K11NTSbC3V9ChdSzU9StdSTY/StVTTo3Qt1fQoW0svTY/StVTTo3Qt1fQoXUs1PUrXUlNLs7VU06N0LdX0KF1LNT1K11JNj9K1VNOjbC01TY/StVTTo3Qt1fQoXUs1PUrXUlNLs7VU06N0LdX0KF1LNT1K11JNj9K1VNOjbC0tmh6la6mmR+laqulRupZqepSupaaWZmuppkfpWqrpUbqWanqUrqWaHqVrqaZH2VpaNT1K11JNj9K1VNOjdC3V9ChdS00tzdZSTY/StVTTo3Qt1fQoXUs1PUrXUk2PsrW0aXqUrqWaHqVrqaZH6Vqq6VG6lppamq2lmh6la6mmR+laqulRupZqepSupZoeZWtp1/QoXUs1PUrXUk2P0rVU06N0LTW1NFtLNT1K11JNj9K1VNOjdC3V9ChdSzU9ytbSoelRupZqepSupZoepWuppkfpWmpqabaWanqUrqWaHqVrqaZH6Vqq6VG6lmp6lKyl50PTo3Qt1fQoXUs1PUrXUk2P0rXU1NJsLdX0KF1LNT1K11JNj9K1VNOjdC3V9ChbSw9Nj9K1VNOjdC3V9ChdSzU9StdSU0uztVTTo3Qt1fQoXUs1PUrXUk2P0rVU06NsLT01PUrXUk2P0rVU06O/2NI3dk14tmA3Yd+BXZOSLdg1zdiCXROHLdg1FdiCXc59Bft1lleJl50fsC8p90v+ehN4uWB38Je9Tn0V+/DO9aj/vLZe56RFcrXhWyQHHL5FphbtbNFTq73e2MqkRXLW4VskFx6+RXLs4Vskdx++RZoERG+RaWYQvkWaLuxtUfl643ZMWqTpQvgWaboQvkWmFkVvkaYL4Vuk6UL4Fmm6cGeL6gy7JgZbsGsKsAN7kbPfgl1ufQt2OfAl7P34wj76B+xL330p8tWbwJvAe4N3/rpEkVsO3yK55a0tWvj8o8gth2+RnHX4FsmFR29RlWMP3yK5+/At0iRgb4s+f/5RNTMI3yJTi6K3SNOF8C3SdCF8izRdCN8iTRfCt0jThTtbNPvUs2lisAW7pgBbsMvZb8Eut74Fuwn7Duxy1VuwyylvwS73uwW7HO0W7HKpK9jtGK8S7foUCLj0XcUun7oJvJzqJvDyqpvAy61uAm8Cvwe8HOsm8PKsm8DLtW4CL9+6Cbyc6x7wQ851E3g5103g5Vw3gZdz3QTeBH4PeDnXTeDlXDeBl3PdBF7OdRN4Odct4K+HnOsm8HKum8DLuW4CL+e6CbwJ/B7wcq6bwMu5bgIv57oJvJzrJvByrnvAH3Kum8DLuW4CL+e6Cbyc6ybwJvB7wMu5bgIv57oJvJzrJvByrpvAy7nuAX/KuW4CL+e6Cbyc6ybwcq6bwJvA7wEv57oJvJzrJvByrpvAy7luAi/nugf8Jee6Cbyc6ybwcq6bwMu5bgJvAr8HvJzrJvByrpvAy7luAi/nugm8nOse8Cbnugm8nOsm8HKum8DLuW4CbwK/B7yc6ybwcq6bwMu5bgIv57oJvJzrHvBFznUTeDnXTeDlXDeBl3PdBN4Efg94OddN4OVcN4GXc90EXs51E3g51z3gq5zrJvByrpvAy7luAi/nugm8Cfwe8HKum8DLuW4CL+e6Cbyc6ybwcq57wDc5103g5Vw3gZdz3QReznUTeBP4PeDlXDeBl3PdBF7OdRN4OddN4OVc94Dvcq6bwMu5bgIv57oJvJzrJvAm8HvAy7luAi/nugm8nOsm8HKum8DLue4BP+RcN4GXc90EXs51E3g5103gTeD3gJdz3QReznUTeDnXTeDlXDeBl3PdAt4ecq6bwMu5bgIv57oJvJzrJvAm8HvAy7luAi/nugm8nOsm8HKum8DLue4Bf8i5bgIv57oJvJzrJvByrpvAm8DvAS/nugm8nOsm8HKum8DLuW4CL+e6B/wp57oJvJzrJvByrpvAy7n+10HecExw5nDkAP8ARy7tD3DkpP4AR27nD3DkSOZwLrmGP8CRsv8DHKnvP8CRQv4DHBOcOZxECnn0/s+rx3/+89+Wm0jzrpSbSMWulJtIl66Um0hpLpRribTjSrmJ1OBKuYn03Uq5iRTbSrnGVS6XqjIuVWVcqsq4VJVxqarCpaoKl6oqXKqqcKmqYlzlcqmqwqWqCpeqKlyqqnCpqsqlqiqXqqpcqqpyqapqXOVyqapM2+NXyuVSVZk2pa+Uy6WqMm0FXymXS1Vl2oC9Ui6Xqsq07XmlXC5VlWmz8Uq5XKoq0xbflXK5VFWmjbUr5XKpqkzbWVfK5VJVmTaRrpTLpaoybd1cKZdLVWXaMLlSLpeqyrRNcaVcLlWVaXPgSrlcqirTlryVcrlUVaaNcCvlcqmqTNvPVsqlUlUl06avlXKpVFXJtNVqpVwqVVUexlUulaoqmbYVrZRLpapKps08K+VyqapMW2hWyuVSVZk2rqyUy6WqMm0XWSmXS1Vl2qSxUi6Xqsq0NWKlXC5VlWlDwkq5XKoq0zaAlXK5VFWmVP2VcrlUVabk+5VyuVRVpnT6lXK5VFWmBPmVcrlUVaaU95VyuVRVpiT2lXK5VBVXtnrhylYvXNnqhStbvXBlqxeubPXCla1euLLVC1e2euHKVi9c2eqFK1u9cGWrF65s9cKVrV64stULV7Z64cpWL1zZ6oUrW71wZasXrmz1wpWtXriy1QtXtnrhylYvXNnqhStbvXBlqxeubPXCla1euLLVC1e2euHKVi9c2eqFK1u9cGWrF65s9cKVrV64stULV7Z64cpWL1zZ6oUrW71wZasXrmz1wpWtXriy1QtXtnrhylYvXNnqhStbvXBlqxeubPXCla1euLLVC1e2euHKVi9c2eqFK1u9cGWrF65s9cKVrV64stUrV7Z65cpWr1zZ6pUrW70+jKtcKlVVubLVK1e2euXKVq9c2eqVK1u9cmWrV65s9cqVrV65stUrV7Z65cpWr1zZ6pUrW71yZatXrmz1ypWtXrmy1StXtnrlylavXNnqlStbvXJlq1eubPXKla1eubLVK1e2euXKVq9c2eqVK1u9cmWrV65s9cqVrV65stUrV7Z65cpWr1zZ6pUrW71yZatXrmz1ypWtXjOlbx+Px+N97PHhzX9ykPO8+leJ3d7naON/fedHeZ35fIzyfuf6W3h9fL3z+eGdi53/vLbYNWl+IhWi5v+w+ZmS2dX8nzY/kUJV83/a/ER6Xc3/afMTuRc1/6fNNzWft/mJnK2a/9PmJ/r0RM3/afMTfZak5v+0+ZrwETdfE76sze+vNy7f3veX5mfaEqTm/7T5mvARN18TPuLma8KXtfnt3fw6ab6p+bzN14SPuPma8BE3XxM+4uZrwkfcfE34sja/vI5c6uTbu5k2Vqr5P22+JnzEzdeEj7j5mvARN9/UfN7ma8JH3HxN+IibrwkfcfM14SNuviZ8vM3PtD1dzf9p8zXhI26+JnzEzdeEj7j5pubzNl8TPuLma8JH3HxN+IibrwkfcfM14eNt/tCEj7j5mvARN18TPuLma8JH3HxT83mbrwkfcfM14SNuviZ8xM3XhI+4+Zrw0Ta/PTThI26+JnzEzdeEj7j5mvARN9/UfN7ma8JH3HxN+Iibrwkfb/MP+fytzX9Wcnw1/6iezf+4aaMd8vnEzZfPJ26+fD5x803N522+fD5x8+XziZsvn0/cfH2Th7j5+iYPb/NPTfiIm68JX9bmf1yq2E5N+IibrwkfcfNNzedtviZ8WZv/cbVaOzXhI26+JnzEzdeEj7j5mvDxNv/ShI+4+ZrwZW3+52/vXprwETdfEz7i5puaz9t8TfiIm68JH3HzNeEjbr4mfMTN14SPt/mmCR9x8zXhI26+JnzEzdeEj7j5pubzNl8TPuLma8JH3HxN+IibrwkfcfM14eNtftGEj7j5mvARN18TPuLma8JH3HxT83mbrwkfcfM14SNuviZ8xM3XhI+4+Zrw8Ta/asJH3HxN+IibrwkfcfM14SNuvqn5vM3XhI+4+ZrwETdfEz7i5mvCR9x8Tfh4m9/k8/2b77sPo8mNh2+RqUXRWyRnG75F8p/hWySXGL5F8nLhWyTHFb1FXd98CN8ifT8hfIs0XQjfIk0X9rbo83K0bmpR9BZpuhC+RZouhG+Rpgt7W/R5dU/XdCF8izRdiN6ioelC+BZpuhC+RZouhG+Rpgt7W/T5G0DD1KLoLdJ0IXyLNF0I3yJNF8K3SNOF8C3SdCF4i/pD04XwLdJ0IXyLNF0I3yJNF8K3yNSi6C3SdCF8izRdCN8iTRfCt0jThfAt0nQheosOTRfCt0jThfAt0nQhfIs0XQjfIlOLordI04XwLdJ0IXyLNF0I3yJNF8K3SNOF6C06NV0I3yJNF8K3SNOF8C3SdCF8i0wtit4iTRfCt0jThfAt0nQhfIs0XQjfIk0Xorfo0nQhfIs0XQjfIqNtkWv2Yr943YszSF6P4QyS1wk4g+TV684geVW1L0jj1b7OIHkVqjNI3k+pnEHyfpbkDNIE0geknM0KyI+RyN3kbJxAytk4gZSzcQIpZ7MC8mPIaC9yNk4g5WycQMrZOIGUs3ECaQLpA1LOxudTxCJn4wRSzsYJpJyNE0g5Gx+QVc7GCaScjRNIORsnkHI2TiBNIH1Aytk4gZSzcQIpZ+MEUs7GCaScjQ/IJmfjBFLOxgmknI0TSDkbJ5AmkD4g5WycQMrZOIGUs3ECKWfjBFLOxgdkl7NxAiln4wRSzsYJpJyNE0gTSB+QcjZOIOVsnEDK2TiBlLNxAiln4wNyyNk4gZSzcQIpZ+MEUs7GCWRoHdnL68VjlPqB42ivn/mPNvmZ/wgt9tyrDa3I3KsNLZucqx2P0NrGvdrQAuRH1f7saf90A19v3SZsQmuKzWxCy4TNbExspmxCjyk3s8mjGP3Z5NGX/mzyqNH7HNv8zG+OeXTuVo5HHgW9lyOrNvfmyKrjvTmyan5vjiaOLhxZvYQ3R1bf4c2R1aN4c5Sf8eEoP+PCMfYmciCO8jM+HOVnfDjKz/hwNHF04VjE0YWj/IwPR/kZH47yMz4c5WdcOMbefQzEUX7Gh6P8jA9H+RkfjiaOLhzlZ3w4ys/4cJSf8eEoP+PDUX7GhWPsfdZAHE0cHVbejtgrb4E46p7x+CXqiL1eFIdj7O2iQBw1N/PhqLmZD0fNzXw4mjh+5FiP+s9r63VOOEo/+nDU3MyHo+ZmPhzlZ3w4ys+4cIy9UxSIo/yMD0f5GR+O8jM+HE0cXTjKz/hwlJ/x4UjrZ35wjuMqX1GbV/1G8nF8I0nraNxJ0noab5Kx94lCkaT1Ne4kaZ2NO0lab+NO0kRygWQvXySHTUjS+ht3krQOx52kPI4XSXkcL5LyOE4kY28WhSIpj/MzkvY4JiTlcbxIyuN4kTSR/EzSzvpF8ioTkvI4XiTlcbxIyuN4kZTH8SIpj+NEMvaOUSiS8jjT37zG3hu6mY18yJyNic2UjbzCnI3U/5yN9PycTaKNs583mmXaOPup2v/8U0m0cnal3Dx6dKncPBJzqdw8qnGpXOMqN4+2Wyo3j1xbKjePAlsql0hU/adcLlWVaA3pUrlcqirRUs+lcrlUVaIVmUvlcqmqRAsnl8rlUlWJ1jculculqhItQ1wql0tVJVotuFQul6pKtKhvqVwuVZVo7d1SuVyqKtESuaVyuVRVopVsS+VyqapEC86WyuVSVYnWhS2Vy6WqEi3fWiqXS1UlWmW1VC6Xqkq0GGqpXC5VZVyqyrhUVaJlZEvlcqkq41JVxqWqEi1uWyqXS1UlWoO2VC6Xqkq0VGypXC5VlWhF11K5XKoq0cKrpXK5VFWi9VFL5XKpqkTLmJbK5VJViVYbLZXLpaoSLQpaKpdLVSVau7NULpeqSrTCZqlcLlWVaBnMUrlcqirRWpWlcrlUVaIFJUvlcqmqRKs+lsrlUlWJlmYslculqhKtn1gql0tVJVrksFQul6pKtBJhqVwuVZVoucBSuVyqKlFM/1K5XKoqUeD9UrlcqipR0PxSuVyqKlEc/FK5XKoqUWj7UrlcqoopWv0/5VKpqoMrW/3gylY/uLLVD65s9eNhXOVSqaqDK1v94MpWP7iy1Q+ubPUjUfr2D1c19fF1jvPDa4ud/7y22DUDSbtjzxukCaQPSNrtfd4gaVf9eYOk3QvoDZJ2zbc3SNot384gE6XJbwZJu+PbG6ScjRNIOZsFkP31xmWUGUgTSB+QcjZOIOVsnEDK2SyAbG+QdQZSzsYJpJyND8hEGx02g5SzcQIpZ+MEUs5mAWR5fYpY6uxTxESbMzaDlLNxAiln4wRSzsYJpJyNE0g5Gx+QibaqbAYpZ+MEUs7GCaScjRNIE0gfkHI2TiDlbJxAytk4gZSzcQIpZ+MDMtFmo80g5WycQMrZOIGUs3ECaQLpA1LOxgmknI0TSDkbJ5ByNk4g5Wx8QCbaLrYZpJyNE0g5GyeQcjZOIE0gfUDK2TiBlLNxAiln4wRSzsYJpJyND8hEG/42g5SzcQJpkUG281Xt6Gf7APL56teL2+x3/rH31vmXG1qT+ZcbWjn5lxta3/iXG1qF/Kjcnz3zVzIuY2+52w0ntFrYDSf0bHM3nNDzyt1wTHDmcPIozRvg5NGl99m3+Zm/gcyjeDeDzKOlN4NkVeneIGNvWEQCyar+3UGyOgV3kKyuwh2kCaQPSFa34g5SzsYJpJyNE0g5GyeQcjYuIM/YW06RQMrZOIGUs3ECKWfjBNIE0geknI0TSDkbJ5ByNk4g5WycQMrZ+IA85GycQMrZOIGUs3ECKWfjBNIE0gek5I/L8scz9oJcIJCx15FGAfn5V1ln7HWkSCB12TiB1BjNCaTGaE4gNUZzAikd+RlkPeo/r63XOQMpHekDMvY6UiSQGqM5gZSzcQIpZ+ME0gTSB6ScjRNIORsnkHI2TiDlbJxAytn4gIy9jhQJJK2z+cE5jke1r3f+lqt0tP4dJa238UdJ6278UZpQeqGkdTj+KGk9jj9KWpfjj5LW5/wI5XjJyieCMkNJ63TcUcZeUIqFUm7HDaXcjhtKuR03lCaUXijldn6I8ttA7v8PpdyOG0q5HTeUcjvzH4XEXkK6GU7sxaK74chj/AGOXMMf4MgH/AGOCc4cTqJ1TJ9j78/YKzL9y020jmml3ETrmFbKzaM0V8qNvbrRv9w8anCp3Dz6bqncPIptqVzjKpdLVWVacrlSLpeqyrTkcqVcLlWVaG3lUrlcqirRasmlcrlUVaL1j0vlcqmqRCsal8rlUlWJ1h0ulculqhKtDlwql0tVJVrDt1Qul6pKtNJuqVwuVZVoPdxSuVyqKtGqtaVyqVTVlWht2VK5VKrqSrQCbKlcKlV1PYyrXCpVdSVaTbVULpWquhKteVoql0tVJVqZtFQul6pKtH5oqVwuVZVolc9SuVyq6uBSVQeXqkq0PWqpXC5VdXKpqpNLVSXas7VULpeqSrSzaqlcLlWVaP/TUrlcqirRLqWlcrlUVaK9REvlcqmqRDt+lsrlUlWJ9uUslculqhLtnlkql0tVJdrjslQul6pKtBNlqVwuVZVou8hSuVyqincfwk+WMNv5z2uLXTOQ2vnmBFI735xAauebD0jePQjeILXN2gmktlk7gdQ2ayeQJpA+ILXN2gmknI0TSDmbBZD99cZllBlIORsnkHI2PiB59yl4g5SzWQDZ3iDrDKScjRNIORsnkCaQPiDlbJxAytk4gZSzWQBZXp8iljr7FDHR5ozNIOVsfEAm2vaxGaScjRNIORsnkHI2TiBNIH1Aytk4gZSzcQIpZ+MEUs7GCaScjQ/IRBt3NoOUs3ECKWfjBFLOxgmkCaQPSDkbJ5ByNk4g5WycQMrZOIGUs/EBmWjr1WaQcjZOIOVsnEDK2TiBNIH0ASln4wRSzsYJpJyNE0g5GyeQcjYuIC3R5rnNIOVsnEDK2TiBlLNxAmkC6QNSzsYJZGgdWcxeIOvoH0A+sb9e3K5ZuaHVnnu5sffW+ZcbWjn5lxta3/iXG1qF/Kjcnz3zFzIuLfaWu91wQquF3XBCzzZ3wwk9r9wNJ492vAFOHqXpDyf25r8b4fzEvs3P/A1kHsW7GWQeLb0ZJKtKdwdpAukDklX9u4NkdQruIFldhTtIVgfiDpLVrXiDjL19EwmknI0TSDkbJ5ByNk4gTSB9QMrZOIGUs3ECKWfjBFLOxgmknI0PyNgbcJFAytk4gZSzcQIpZ+ME0gTSB6ScjRNIORsnkHI2TiDlbJxAytn4gIy9+xoJpJyNE0g5GyeQcjZOIE0gfUDK2TiBlLPxARl7QW4QkAtLxC32glwkkLpsfH7dH3sdKRJIXTZOIDVGcwKpMZoTSI3RfEDGXkcaBGQ96j+vrdc5Aykd6QRSYzQnkBqjOYE0gfQBKWfjBFLOxgmknI0TSDkbJ5ByNj4gY68jRQIpZ+MEUs7GCaScjRNIE0gfkHI2TiDlbJxAytk4gaR1Nj84x2FfJA+7yrdzPP4tdloftBV77FWnebHTeqy92GkdmRP2byhpPZk/ShNKL5S0vswfJa0z80dJ6838UcqduaGU43JCWWKvVcVCKWfkhlJuZwVlf1V4lKv+gvI3rz7sNW08jvLt1H18By9vtAm8CbwzeOcfMpbYS2HVov+0SM4vfIvkKMO3SE41fIvkgKO3KNFy7LQtkmMP3yJNAsK3SDOD8C0ytSh6izRdCN8iTRfCt0jThfAt0nQhfIs0XYjeolPThfAt0nQhfIs0XQjfIk0XwrfI1KLoLdJ0IXyLNF0I3yJNF8K3SNOF8C3SdCF6iy5NF8K3SNOF8C3SdCF8izRdCN8iU4uit0jThfAt0nQhfIvki3a2aGFzWDH5ovAtkqLb2qLPm3yeDNSi6C2SogvfIim68C3S50XhW6TPi8K3SL5oZ4sW0klLkS8K3yJ9XhS+Rfq8KHyLNF0I3yJTi6K3SNOF8C3SdCF8izRdCN8iTRfCt0jThegtqpouhG+RpgvuLfrJOx+Pr1Tt4yjf2H3PGK6aLwA0SRMGgCaZmhS/SZoyADRJcwaAJmnSANAkzRr2Nun4In2cddYkTRviN6lp3gDQJE0cAJqkiQNAkzRxAGiSqUnxm6SJw94mrWzaa5o4ADRJEweAJmniANAkTRziN6lr4gDQJE0cAJqkicPfa9I37JohbMFuwv4Z+/OjsS/s/fiA/UnJvh4zl83Ay+lvAi/37g3+PL9wWJlhlx/fgl0Oewt2eeYd2Idc8Bbs8rVbsMupumMv5YWjHTPscqpbsJuw78Aun7oFu1zqFuxyqVuwy6VuwS6XugF7fcilbsEul7oFu1zqFuxyqVuwm7B/xv58KLzeuR7tA/alj/XqQz51E3g51U3g5VU3gZdb3QRefnUP+EOOdRN4edZN4OVaN4GXb90E3gR+D3g5103g5Vw3gZdz3QReznUTeDnXPeBPOddN4OVcN4GXc90EXs51E3gT+D3g5Vw3gZdz3QReznUTeDnXTeDlXPeAv+RcN4GXc90EXs51E3g5103gTeD3gJdz3QReznUTeDnXTeDlXDeBl3PdA97kXDeBl3PdBF7OdRN4OddN4E3g94CXc90EXs51E3g5103g5Vw3gZdz3QO+yLluAi/nugm8nOsm8HKum8CbwO8BL+e6Cbyc6ybwcq6bwMu5bgIv57oHfJVz3QReznUTeDnXTeDlXDeBN4HfA17OdRN4OddN4OVcN4GXc90EXs51D/gm57oJvJzrJvByrpvAy7n+/9o7uxw3kiMI38hgs7O7q46zNvywgLE27LUB394j7HI0MFRkziKk/Il4FDTkML6ClBFFMiMIvAl8DHgl1yDwSq5B4JVcg8AruQaBV3KNAT+UXIPAK7kGgVdyDQKv5BoE3gQ+BrySaxB4Jdcg8EquQeCVXIPAK7nGgJ9KrkHglVyDwCu5BoFXcg0CbwIfA17JNQi8kmsQeCXXIPBKrkHglVxDwF83Jdcg8EquQeCVXIPAK7kGgTeBjwGv5BoEXsk1CLySaxB4Jdcg8EquMeA3Jdcg8EquQeCVXIPAK7kGgTeBjwGv5BoEXsk1CLySaxB4Jdcg8EquMeDvSq5B4JVcg8AruQaBV3INAm8CHwNeyTUIvJJrEHgl1yDwSq5B4JVcY8DvSq5B4JVcg8AruQaBV3INAm8CHwNeyTUIvJJrEHgl1yDwSq5B4JVcY8CbkmsQeCXXIPBKrkHglVyDwJvAx4BXcg0Cr+QaBF7JNQi8kmsQeCXXGPCHkmsQeCXXIPBKrkHglVyDwJvAx4BXcg0Cr+QaBF7JNQi8kmsQeCXX/38dX+GcSpdP4CgBPoGjlPYEjpLUEzgmOGs4SiRP4Cg1PIEjZ/8Ejtz3EzhyyGs4lxzyEzh9HPIc4/HD81rJ7eN5XXL7uFiXXOOS28dpuuT28Y4uuX3coEtuH3/nktvHsXnkjj4ezCWXy1UNLlc1uFzVMC65XK5qcLmqweWqBperGlyuanK5qsnlqiaXq5pcrmoal1wuVzW5XNXkclWTy1VNKlc1blSuajTqsXfJpXJVo1Fnu0uuccmlclWjUSu4Sy6VqxqNGrBdcrlcVaO2Z5dcLlfVqNnYJZfLVTVq8XXJ5XJVjRprXXK5XFWjdlaXXC5X1aiJ1CWXy1U1at10yeVyVY0aJl1yuVxVozZFl1wuV9WoOdAll8tVNWrJc8nlclWNGuFccrlcVaP2M5dcLlfVqOnLJZfLVTVqtXLJ5XJVjRqcXHK5XFWjtiKXXC5X1aiZxyWXy1U1aqFxyeVyVY0aV1xyuVxVo3YRl1wuV9WoScMll8tVNWqNcMnlclWNGhJccrlcVaM2AJdcLlfVaKu+Sy6Xq2q0+d4ll8tVNdpO75LL5aoabZB3yeVyVY22vLvkcrmqRpvYXXK5XBXXbvXBtVt9cO1WH1y71QfXbvXBtVt9cO1WH1y71QfXbvXBtVt9cO1WH1y71QfXbvXBtVt9cO1WH1y71QfXbvXBtVt9cO1WH1y71QfXbvXBtVt9cO1WH1y71QfXbvXBtVt9cO1WH1y71SfXbvXJtVt9cu1Wn1y71efNuORSuarJtVt9cu1Wn1y71SfXbvXJtVt9cu1Wn1y71SfXbvXJtVt9cu1Wn422b2+32+3rq54vnvszr2Oz8VC4Hfv54XV8U+GY7898f/HMh91//9nD9tUR9fEKXY+o0ZbztkfUx5O1PaI+PrLtEfXxvm2PyHRE2Y+oT8Zoe0R9bpvbHlGfG/K2R6TbhfRHpNuF0CMaj5d8zGNxRI3aPtoekW4X0h+RbhfSH5FuF0KP6Pp6ROfqiExHlP2IdLuQ/oh0u5D+iHS7kP6IdLuQ/oh0uxB6RMfjE0DHufoEUKPWq7ZHpNuF9Eek24X0R6TbhfRHZDqi7Eek24X0R6TbhfRHpNuF9Eek24X0R6TbhexH1Kj9se0R6XYh/RHpdiH9Eel2If0RmY4o+xHpdiH9Eel2If0R6XYh/RHpdiH9Eel2IfsRNWpBbntEul1If0S6XUh/RLpdSH9EpiPKfkS6XUh/RLpdSH9Eul1If0S6XUh/RLpdyH5El24X0h+RbhfSH5FuF9IfkW4X0h+R6YiyH5FuF9IfkW4X0h+RbheyH9GgzUXg3YuDNr2gQdJmDDRI2iSABmkCiQFJ66rRIGm9LxokrUNFg6R9lwoNkva9JDDIqWQDAqlkg1mJPJVsQCCVbEAgTSAxIJVsMEtGp5INCKSSDQikkg0IpJINAuSX3y2QGJBKNoh3Ed9+t5INCKSSDQikCSQGpJINCKSSDQikkg0IpJINCKSSDQbkpmQDAqlkAwKpZAMCqWQDAmkCiQGpZAMCqWQDAqlkAwKpZAMCqWSDAXlXsgGBVLIBgVSyAYFUsgGBNIHEgFSyAYFUsgGBVLIBgVSyAYFUssGA3JVsQCCVbEAglWxAIJVsQCBNIDEglWxAIJVsQCCVbEAglWxAIJVsMCAttY/cr4eCaV9WxT0FOa/H9/znta/kpnZ7eLnGJTe1c8LLTe1v8HJTu5BPyf3c//lzvD/1XP4/ntpZRMNJ7RaC4Ryp7zaj4aS+r4yG08c7fgc4fZzmd4BjpHA+E9/Wr/kDyD6ONxhkHy8dDJLVpcNBsjp6OEhW948Gmbu9vhJI1lQBB8maQOAgWdMKHKQJJAakkg0IpJINCKSSDQikkg0IpJINBmTu5uxKIJVsQCCVbEAglWxAIE0gMSCVbEAglWxAIJVsQCCVbEAglWwwIHN3X1cCqWQDAqlkAwIp+4Mof3wDKfuDAZm7jjQLSMe3snLXkVYCqWEDAqlrNBBIE0gMSF2jgUDKR74GeW7n7z977vcVSPlIEEhdo4FA6hoNAnLLXUdaCaSSDQikkg0IpJINCKQJJAakkg0IpJINCKSSDQikkg0IJG2y+cTr+LKi4/2Zz+2DwvMDytyFpLVQ0qYbPErafINHSZtw8ChNKFEoaVMOHiVtzvkUymHvzzz3FUrapINHSZt18CiVdlAoc5eU1kKptANDqbQDQ6m08zmUb79lhdKEEoVSaQeGUmln+aWQLXcJaTQcJZIncJQx1nByF4BGw1EOeAJHzv4JnEZ1TK/X3m+5KzLxchvVMXnkNqpj8sjt4zRdcvt4R5fcPm7QI9f6+DuX3D6OzSW3UcmlRy6Xq+pUcumRy+WqOpVceuRyuapGtZUuuVyuqlG1pEsul6tqVP/oksvlqhpVNLrkcrmqRnWHLrlcrqpRdaBLLperalTD55LL5aoaVdq55HK5qkb1cC65XK6qUdWaSy6Xq2pUW+aSy+WqGlWAueRyuapGdVouuVyuqlE1lUsul6tqVPPkksvlqhpVJrnkcrmqRvVDLrlcrqpRlY9LLperGsYll8tVNWqPcsnlclWDy1UNLlfVqGfLJZfLVTXqrHLJ5XJVjfqfXHK5XFWjLiWXXC5X1aiXyCWXylXdG3X8uORSuap7o74cl1wqV3W/GZdcKld1b9Tj4pJL5arujTpRXHK5XFWjdhGXXC5XxduH8JkSZnvs8D9sX4FU5xsIpDrfQCDV+QYCqc43EEi1WWNA8nYgoEGqzRoEUm3WIJBqswaBNIHEgFSycYAcjyc+5rECqWQDAqlkAwKpZAMCqWTjAHl9BXkuQPL2NKBBKtmAQCrZgEAq2YBAmkBiQCrZOEAej5dxnKt3ERs1ZwSDVLIBgVSyAYFUssGAbNRQEgxSyQYEUskGBFLJBgTSBBIDUskGBFLJBgRSyQYEUskGBFLJBgOyUUtQMEglGxBIJRsQSCUbEEgTSAxIJRsQSCUbEEglGxBIJRsQSCUbDMhGTV3BIJVsQCCVbEAglWxAIE0gMSCVbEAglWxAIJVsQCCVbEAglWwwIBu15QWDVLIBgVSyAYFUsgGBTO0j7/fHD899ny9AzuvxPf95rb7nn7u3Di83tSfDy03tnOByc/fW4eWmdiGfkvu5//M9Oy5zt9xFw0ntFqLhmOCs4aS+r4yG08c7fgc4fZzmd4DTx5d+v/i2fs0fQPZxvLEgc7cVVgLJ6tLhIFkdPRwkq/uHgzSBxIBkTRVwkKwJBA6SNa3AQSrZgEAq2UBA7rkbQyuBVLIBgVSyAYFUsgGBNIHEgFSyAYFUsgGBVLIBgVSyAYFUssGAzN3aWwmkkg0IpJINCKSSDQikCSQGpJINCKSSDQZk7oLcJCAd5Y977oLcSiA1bCDfytpz15FWAqlhAwKpazQQSF2jgUDqGg0DMncdaRKQ53b+/rPnfl+BlI8EgdQ1GgikrtFAIE0gMSCVbEAglWxAIJVsQCCVbEAglWwwIHPXkVYCqWQDAqlkAwJJm2w+8Tq223F/f+Zz+6Dw/IjShBKFkjbd4FHS5hs8StqEg0dJm3HwKGlTDhxl7nLSNCiHvT/z3FcoaZMOHiVt1sGjVNqBoTShRKFU2oGhVNqBoVTa+RzKt9+yQqm0A0OptINCmbuwNATlBzjKL0/gKJE8gaOM8QSOCc4ajnLAEzhy9k/gNKpjer32fs9dkYmX26iOySE3d90kXm4fp+mS28c7uuT2cYMuucYlt49jc8ltVHLpkcvlqjqVXHrkcrmqTiWXHrlcrqpRbaVLLperalQt6ZLL5aoa1T+65HK5qkYVjS65XK6qUd2hSy6Xq2pUHeiSy+WqGtXwueRyuapGlXYuuVyuqlE9nEsulauyRlVrLrlUrsoa1Za55FK5KrsZl1wqV2WN6rRccqlclTWqpnLJ5XJVjWqeXHK5XFWjyiSXXC5X1ah+yCWXy1U1qvJxyeVyVRuXq9q4XFWj9iiXXC5XdedyVXcuV9WoZ8sll8tVNeqscsnlclWN+p9ccrlcVaMuJZdcLlfVqJfIJZfLVTXq+HHJ5XJVjfpyXHK5XFWj7hmXXC5X1ajHxSWXy1U16kRxyeVyVY3aRVxyuVwVbx/CZ0qY7bHD/7B9BVKdbxiQvF0IaJDqfAOBVOcbCKTarEEgTSAxINVmDQKpNmsQSLVZg0Aq2YBAKtk4QI7HEx/zWIDk7T1Ag1SyAYFUsgGBVLJxgLy+gjxXIE0gMSCVbEAglWxAIJVsQCCVbEAglWwcII/Hu4jHuXoXsVFzRjBIJRsQSCUbEEglGxBIE0gMSCUbEEglGxBIJRsQSCUbEEglGwzIRu01wSCVbEAglWxAIJVsQCBNIDEglWxAIJVsQCCVbEAglWxAIJVsMCAbNUgFg1SyAYFUsgGBVLIBgTSBxIBUsgGBVLIBgVSyAYFUsgGBVLKBgDwatbgFg1SyAYFUsgGBVLIBgTSBxIBUsgGBVLIBgVSywYDM3Vu32fYAuY3xAiR4J8CRu+MuFk1qrxeLJrV7i0VjQrNCk9phxaJJ7Zli0aR2QbFoUt/YxqJJfQcbiiZ332AsGlI3/HoxzpG7xzAWDakb9qAxoVmhIXXDr9d5HLl7F2PRkLphDxpSN+xBQ+qGHWhy90TGoiF1w453FHL3T8aiIXXDHjQmNCs0pG7Yg4bUDXvQkLphDxpSN+xBQ+qGHWhy93vGopEbXqKRG16ikRteojGhWaGRG16ikRteopEbXqKRG16ikRteocndYBuLRm54iUZueIlGbniJxoRmhUZueIlGbniJRm54iUZueIlGbniFJnfraSwaueElGrnhJRq54SUaE5oVGrnhJRq54SUaueElGrnhJRq54RWa1L2EY7x/vHe8YUKicXyLLnXTYDAaE5oVmsy+JhhNZl8TjCazrwlGk9nXBKPJ7Gti0aTuyQtGk/mWLxiN3PASDakbdnwFPnXfXDAaUjfsQUPqhj1oSN2w48vMqXvbgtGQumEHmtTdasFoSN2wBw2pG/agIXXDjncUUneUBaMhdcMeNKRu2IOG1A170JC6YQ8aUjf8Gs2Zuo8rGA2pG/agIXXDHjRyw0s0JjQrNHLDSzRyw0s0csNLNHLDSzRywys0qVvFgtHIDS/RyA0v0cgNL9GY0KzQyA0v0cgNL9HIDS/RyA0v0cgNr9CkbhULRiM3vEQjN7xEIze8RGNCs0IjN7xEIze8RCM3vEQjN7xEIze8QpO6VSwYjdzwEo39aDTY77qdP77FCS3grC7gqi5gVBcwiwv48R1AaAFbdQH36gL26gKqT2JLPYlff5X1tNST2CMg9ST2CEg9iT0CUk/i11+WO4/Uk9gjIPUk9ghIPYk9AlJPYo+A1JPYIyD1JHbcShypJ7FHQOpJ7BGQehJ7BKSexA4BZ+pJ7BGQehJ7BKSexB4BqSexR0DqSewRUH0Sn9Un8Vl9Ep/VJ/FZfRJf1SfxVX0SX9Un8VV9Ev/4LfJoAdUn8VV9El/VJ/FVfRJf1SfxqD6JR/VJPKpP4lF9Ev/4DdZoAdUn8ag+iUf1STyqT+JRfRLP6pN4Vp/Es/okntUnMWQP6vZ4TfftNKQAxye2INtKQwWM6gJmbQEXZD9nqICtuoB7dQF7dQFWXcBRXUDxSXzdUk/i1x98vW6pJ7FHQOpJ7BCwpZ7EHgGpJ/Hrj11eW+pJ7BGQehJ7BKSexB4BqSexR0DqSewRkHoSv76VuLbUk9gjIPUkdgi4p57EHgGpJ7FHQOpJ7BGQehJ7BKSexB4BqSexR0DqSewRUH0S36tP4nv1SbxXn8R79Um8V5/Ee/VJDNnwFCqg+iTeq0/ivfok3qtP4r36JLbqk9iqT2KrPomt+iSGbHgKFVB9Elv1SWzVJ7FVn8RWfRIf1SfxUX0SH9Un8VF9EkM2PIUKqD6JEfuFbnY8BNzmDSnA8YktxH6hUAGI/UKxArbqAu7VBezVBVh1AUd1AWd1AVd1AdUn8Zl6Ejs++HqlnsQeAaknsUdA6knsEZB6Ejs+donYLxQrIPUk9ghIPYk9AlJPYo+A1JPYIyD1JHbcSozUk9gjIPUk9ghIPYk9AlJPYo+A1JPYIyD1JPYISD2JPQJST2KPgNST2COg+iSe1SfxrD6JZ/VJPKtP4ll9Es/qk3hWn8Sz+iSe1SfxLD6Jx634JB634pN43IpP4nErPonHrfgkHrfik3jcik/icSs+icet+CQet+qTeKs+ibfqk3irPom36pMYseEpVkD1SbxVn8Rb2Uls1/mnb/8L3m6Hvb/8sX19Qbfbbw+8/vTtbRRflr49Hjhvx4cHbu8PnH/wgd/evuB54PZHH3j/9APf/vSfn/75809//ttf//X2mC9/+e9f/vLrz3//5fc//vrff/z2N28/+z8="},{"name":"check_balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"param_witnesses":{"fee_limit":[{"end":4,"start":3}],"inputs":[{"end":3,"start":0}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"fee_limit","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"5ZztbpTJFYTvxb9R1Od0VX/srURRxO6yERIyq4WNFKG995jNfBh5hKmTiTMlfoGh233aVUzZNS/Pp7uf3/z4+z/+/vb+l/cf7n7466e7d+9/ev3x7fv7h48+3bW/RPz5px9+fX3/+Q8+fHz928e7H9qruzf3Pz/8+seru1/evntz90NO/PG3V583pLqhqxugbqC6YagbprphqRu2uCGbukFVOlWlU1U6VaVTVTpVpVNVOlWlU1W6q0p3VemuKt1VpbuqdFeV7qrSXVW6q0p3VWmoSkNVGqrSUJWGqjRUpaEqDVVpqEpDVZqq0lSVpqo0VaWpKk1VaapKU1WaqtJUlR6q0kNVeqhKD1XpoSo9VKWHqvRQlR6q0kNVeqpKT1XpqSo9VaWnqvRUlZ6q0lNVeqpKT1XppSq9VKWXqvRSlV6q0ktVeqlKL1XppSq9VKW3qvRWld6q0ltVeqtKb1XprSq9VaW3qvRWlY7W5B1yd9Lk8qTJ7UmT65Mm9ydNLlCa3KA0uUJpsuYha673ZXphpjdmemWmd2Z6aaa3ZnptJvdmIRdnkXpHKmsud2chl2cht2ch12ch92chF2ghN2ghV2ghd2jR9WJc1lyu0ULu0UIu0kJu0kKu0kLu0kIu00Ju00Ku0wL6uyGy5nKjFnKlFnKnFnKpFnKrFnKtFnKvFnKxFnKzFnK1FnK3FnK5FnK7FnK9FnK/FnLBFnLDFnLFFnLHFnLJFkN/31PWXO7ZQi7aQm7aQq7aQu7aQi7bQm7bQq7bQu7bYupvdsuay5VbyJ1byKVbyK1byLVbyL1byMVbyM1byNVbLP0JB1lzuX0LuX4LuX8LuYALuYELuYILuYMLuYQLuYWLrT/Woj/XIj/YIvdwKfdwKfdwKfdwKfdwKfdwKfdwKfdwKfdwGfrDTLLmcg+Xcg+Xcg+Xcg+Xcg+Xcg+Xcg+X+vNr+gNshSfYZM31Z9j0h9j0p9j0x9j059j0B9nkHi7lHi7lHi67/tiirLncw6Xcw6Xcw6Xcw6Xcw6Xcw6Xcw6Xcw6XcwyX0Z1VlzeUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLuUeLof+VLqsudzDpdzDpdzDpdzDpdzDpdzDpdzDpdzDpdzD5dT/K4KsudzDpdzDpdzD5eUejn0fNxGxv9j36slq5OqH1ejtvBqXFk+uw9q5cf7EeZwnb2we3Ng8vLF5xo3NM68wT891mqePx/McDlkvcci+xiGDp0NmPD3kcokrH4LTIatdOCRf4pCLwUJwnA6Z45lDGCcj8qGtPq0e88LigXb81AP5xeLDRJdfOh5ucp5oPjPR7keT7LVOayPbhbUP77Af1j50wefPi7z0eYnj4j3ao39HYx2np/X0w3r6aT39sp5+G0/fL7/dYjN9Wk/frad3TqvenNOqN+e06s05rXpzTqverNPq8lvLNtNbZ21cIWujjePPS/HnzF+d/3INdekn/Dj+hD8efU16HCeH7eS0nXzYTj5tJ1+2k2/XybPZTh62k9smUXbbyW0zNG0zNG0zNG0zNG0zNG0ztNtmaLfN0G6bod02Q7tthnbbDO22GdptM7TbZmi3zVDYZihsMxS2GQrbDIVthsI2Q2GbobDNUNhmKGwzlLYZStsMpW2G0jZDaZuhtM1Q2mYobTOUthlK2wwdthk6bDN02GbosM3QYZuhwzZDh22GDtsMHbYZOmwzdNpm6LTN0GmbodM2Q6dthk7bDJ22GTptM3TaZui0zdBlm6HLNkOXbYYu2wxdthm6bDN02Wboss3QZZuhyzZDt22GbtsM3bYZum0z9Brcnf/T5LYZum0zdNtm6LbN0O2aoWiuGYrmmqForhmK5pqhaK4ZiuaaoWiuGYrmmqForhmKZpuhYZuhYZuhtrQfhG2G2nKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspoi2niLacItpyimjLKWJzzVDacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niN/AKVp4bvLo58kHvjjl6eo+87AY0c9r276wNsc8rO0NX6w9TD+tp1/W02/j6cc3cItuefr4305/OCVf5JR+jVMmTqfs8YwSMebx5fPht/v8uTmOM+EGZ+INzjRucKZ5gzOtG5xpv/xMp29GYqz2xUxPVyPX8ZUDvZ1vgMvf5qzjtzn70dB5uGu07+iu+R3dtX9Hd8V3dFfe+F17rtNd+3h818MFhvsF5q1fYPB0gRkXLrBu/gI4XeDR6vMFns/n/VynMFYeDxmrr6eHfAM25wqHxEscktc4BDwdMi5o8g3cmCscgpc4hFfRpJ8Pya+/4vcYx29Ie8zz4n4caL30QJnHH8h7djwZCFf5Cu3jS8LYjU9l+Ib/0vf8ITvydEjOC4fMq9yknQ/Z/53WbC890DNaj2t8hTbPWq/+9YGyn5yane3pQPvGBpqyUQ/7VnHfru1brbgvivuyuK8X96G4j8V9Rd3XLO4r+mUV/bKLftlFv+yiX3bRL7vol130yy76ZRf9sot+2TW/zNaK+6K4L4v7enEfivtY3DeK+2Zx3yruK/olin6Jol+i6Jco+iWKfomiX6Lolyj6JYp+iaJfsuiXLPoli37Jol+y6Jcs+iWLfsmiX7Lolyz6pRf90ot+6UW/9KJfetEvveiXXvRLL/qlF/3Si35B0S8o+gVFv6DoFxT9gqJfUPQLin5B0S8o+oVFv7DoFxb9wqJfWPQLi35h0S8s+oVFv7Dol1H0yyj6ZRT9Mop+GUW/jKJfRtEvo+iXUfTLKPplFv0yi36ZRb/Mol9m0S+z6JdiTztn0S/FfncW+91Z6HcfPvrn69/evv7x3ZsPD3s+/+Xv9z99fPv+/vDhx3/9+p+/eVj7bw=="},{"name":"claim","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":41,"start":40}],"inputs":[{"end":39,"start":0}],"secret":[{"end":42,"start":41}],"to":[{"end":40,"start":39}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"},"return_witnesses":[42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498]},"bytecode":"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","debug_symbols":"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"},{"name":"balance_of_public","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"param_witnesses":{"inputs":[{"end":3,"start":0}],"owner":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[4]},"bytecode":"H4sIAAAAAAAC/83YW2/rRBAH8E0apyU0ztVp7o2buLm7PSUgjqCvCIlHJB5B3IXETVyE+Ip8Kc7O7M7+k/rI1UpH1onkxhnPb2d2nbTZLtSZUheB0o+Jso+KjqhQVfVTmY5HJWf6hI5SqEoSSugiKXOm4+ossUBV+ExXUMGN/nGZKDPCReV9ulChsRaqROg8oDGptjrXR3VBjakP9VFLpDFd58ye1uiHySH2zgJX9ICf6Od3TfKFTb5MyiaoLsEuTU7NnDL9G2GhdaaUUAetg9Yt/RVhoSFTSghBQ9DQ0m8RFtpgSgkN0AZow9K/EBbaZEoJTdAmaNPSnxAW2mJKCS3QFmjL0t8QFtpmSglt0DZo2zxnST2f6GozhIV2mFJCB7QD2rH0G4SFdplSQhe0C9q19GuEhUZMKSECjUAjS39GWGiPKSX0QHugvezy9Fw1T1L3J2E+0XP6HmGhV0wp4Qr0CvTK0q8QFtpnSgl90D5oP9to373Bcoiu9gPCQgdMKWEAOgAdZKsNXIM5RFf7HWGhQ6aUMAQdgg6z1Ybud4wn6fiTyJ80/UnoT9qFVOn6k3ohc2kV0tgzd1+/o/9FWOiIKSWMQEego2y1kVsGT9LxJ71CGgv9SdefRIWQZ1ZMvwu+Q1jomCkljEHHoONstbFb7Byiq/2JsNAJU0qYgE5AJ9lqE/fFx5N0C6nS9CdhIXOJCiHDfBJTfIrv/i8ZKnzhl2/4vFFJZBegR6woPKZcanpa6trgiTmVK7S5uMbGIa7yaWyTbuzGZF7iIeYUooPbHJlXMkeKzRNJm6GauVA2QTVHR3PlihGJ9eVS86itJw1/ULKzfWlyeI7J0YZNJjE93RdVMb3pQgXq9MF3gTd6XMnekIodpsZ9T8wHVAa0t2Fq25m+jgT55KQlmcz1R5WjnIq5M0/7pcfM9EvLOQv4tGZfBgsup27MTjKwNyw2RT6m94xbsTlWLDldsQXaS/SAn+vnW5M8t8lLnuQtnYEtTU5iTuk5Sxr+pJVPdIN/ICx0xZQSVqAr0FW22sr95sghutqPCAtdM6WENegadJ2ttnZ/gjxJ25+M/UnkT1r+pPHGp6/vzz3CQjdMKWEDugHdZKttXDVPUvcnLX/SKGQuXX8SFUKeWTH9LvgHYaFbppSwBd2CbrPVtu5T6klG+UQ3mCIsdMeUEnagO9BdttrO3VpPcutPGv6k5U+W/qTrT1b+pFfIfRn7k6iQ+9IoZC7PrJj+3PyCsNA9U0rYg+5B99lqe/e/Jk8y9icNf9J+Wxvr+pPl27pi/ULm0vInuzc+ff25eYGw0JQpJaSgKWiarZa6P1E5hHZ05c+w73hkqLDZkN1F6jYfiRnxeBd7x6XuTkvdG5yaU7lCG5t7bFoezC72wSa9Z3exB7OLPVCIDm7zU/NK5kjmkEjaC1QzF8omqA7o6KBcMSIPMz3o41FbTxrmXSzN9hFD3Lm1CbA2d6d7snhZtvs83thltpaxvRofDVt1m05eRZ7vF64J+zgzZTktTeztVLXQ7Sv1iMH/Tx5kTAbR4JxPY/vSFPrytFDI95bHC5FdclUCW8mmHzWoUgOorZTfILE0WXY8NWHpiFfD/XskTkSV53Ta/4+OV5aU6Xn3HQAA","debug_symbols":"5ZxtaxRGFIX/Sz5LmXvn3Hnxr5RS0qolIFE0For43xvtbhJx23CKtfvgJ00ys3vHAzm7z47P+4tnz39599vPV9cvXr29ePrj+4uXr369vLl6dX371fuL9kPkp+++fX15/fEbb28u39xcPG1PLp5fP7v988OTixdXL59fPM2pDz89+bihuxvkbih3w3A3THfDcjdsc0M2d0O4G9yk00063aTTTTrdpNNNOt2k0026u0l3N+nuJt3dpLubdHeT7m7S3U26u0l3N2m5SctNWm7ScpOWm7TcpOUmLTdpuUnLTbrcpMtNutyky0263KTLTbrcpMtNutyky016uEkPN+nhJj3cpIeb9HCTHm7Sw016uEkPN+npJj3dpKeb9HSTnm7S0016uklPN+npJj3dpJeb9HKTXm7Sy016uUkvN+nlJr3cpJeb9HKT3m7S2016u0lvN+ntJr3dpLeb9HaT3m7S2006WrN3hL3DhifNpifNxifN5ifNBijNJijNRijNzjzszMPO3AdmPjHzkZnPzHxo5lMzH5vZ3CxscBY2OQsbnYXNzsKGZ2HTs7DxWdj8LGyAFjZBCxuhhc3Qovtg3M7cxmhhc7SwQVrYJC1slBY2SwsbpoVN08LGaSH/0xA7c5uohY3UwmZqYUO1sKla2FgtbK4WNlgLm6yFjdbCZmthw7Ww6VrYeC1svhY2YAubsIWN2MJmbGFDthj+55525jZnCxu0hU3awkZtYbO2sGFb2LQtbNwWNm+L6X/YbWduI7ewmVvY0C1s6hY2dgubu4UN3sImb2Gjt1j+DQc7c5u+hY3fwuZvYQO4sAlc2AgubAYXNoQLm8LF9q+1+Pda7IstNodLm8OlzeHS5nBpc7i0OVzaHC5tDpc2h8vwLzPZmdscLm0OlzaHS5vDpc3h0uZwaXO49O+v+RfY/sUNNjtz/w6bf4nNv8XmX2Pz77H5F9lsDpc2h0ubw2X3ry3amdscLm0OlzaHS5vDpc3h0uZwaXO4tDlc2hwu5d9VtTO3OVzaHC5tDpc2h0ubw6XN4dLmcGlzuLQ5XNocLm0OlzaHS5vDpc3h0uZwaXO4tDlc2hwubQ6XNofL4d9KtzO3OVzaHC5tDpc2h0ubw6XN4dLmcGlzuLQ5XE7/vyLYmdscLm0OlzaHS5vDpc3h0uZwaXO4tDlcnuZwNWYcNtXY87N9T75Yvfs6LN5r3a2NbCfW3n4Adlh7i2ruH1d56nFLx8V7NN2vHus4/URPv9DTb/L0p7ktZvpAT9/R0ws9faGnR7fVRrfVRrfVJrdVb+S26o3cVv30J3GY6cld29tX6Npoox9H+jTzP85/+r3Sl+tmHUeY48G/SY/j5AM7+cROvrCTb+rk0bCTB3byxE7esZNjmygKOzm2QwPboYHt0MB2aGI7NLEdmtgOTWyHJrZDE9uhie3QxHZoYjs0sR3asR3asR3asR3asR3asR3asR3asR3asR3asR3asR0qbIcK26HCdqiwHSpshwrbocJ2qLAdKmyHCtuhhe3QwnZoYTu0sB1a2A4tbIcWtkML26GF7dDCdujAdujAdujAdujAdujAdujAdujAdujAdujAdujAdujEdujEdujEdujEdujEdujEdujEdujEdujEdujEdujCdujCdujCdujCdujCdujCdujCdujCdujCdujCdujGdujGdujGdujGdujXsAL9T5NjO3RjO3RjO3RjO3RTO1SN2qFq1A5Vo3aoGrVD1agdqkbtUGE9RcJ6ioT1FAnrKRLWUySsp0hYT5GwniJhPUXCeoqE9RQJ6ykS1lMkrKdIWE+RsJ4iYT1FwnqKhPUUCespEtZTJKynSFhPkbCeImE9RcJ6ioT1FAnrKRLWUySsp0hYT5GwniJhPUXCeoqE9RQJ6ykS1lMkrKdIWE+RsJ4iYT1FwnqKhPUUCespEtZTJKynSFhPkbCeImE9RcJ6ioT1FAnrKRLWUySsp0hYT5GwniJhPUXCeoqE9RQJ6ykS1lMkrKdIWE+RsJ4iYT1FwnqKhPUUCespEtZTJKynSFhPkbCeImE9RcJ6ioT1FAnrKRLWUySsp0hYT5GwniJhPUXCeoqE9RQJ6ykS1lMkrKdIWE+RsJ4iYT1FwnqKhPUUCespEtZTJKynqLCeosJ6igrrKSqsp6gatUML6ykqrKeosJ6iwnqKCuspKqynqLCeosJ6igrrKSqsp6iwnqLCeooK6ykqrKeosJ6iwnqKCuspKqynqLCeosJ6igrrKSqsp6iwnqLCeooK6ykqrKeosJ6iwnqKCuspKqynqLCeosJ6igrrKSqsp6iwnqLCeooK6ykqrKeosJ6iwnqKCuspKqynqLCeosJ6igrrKSqsp6iwnqLCeooK6ykqrKeosJ6iwnqKCuspKqynqLCeosJ6igrrKSqsp6iwnqLCeooK6ykqrKeosJ6iwnqKCuspKqynqLCeosJ6igrrKSqsp6iwnqLCeooK6ykqrKeosJ6iwnqKCuspKqynqLCeosJ6igrrKSqsp6ge9xTNpscmj34/+dBnz/Ll6j7zsFjR79e2fWJtjnlY2x9M8XHtYfqFnn6Tp3/cWXTW0wd6+vxvpz88S/8mz6Kv8SxTd8+yxyNJxJjHX5+3f933j13jOFOd4UzjDGeaZzjTOsOZ9tnNNFr79jPdvRiJsdpnM325WrmOvznU2/0JdPplzjq+zNkPhs7jWeM7Omv/js6q7+is9R2ddZz5WXuuu7P28fCshwNM+gHWuR9g1N0BZpw4wD77A+juAA9W3x0gzr2zHj3A429Soh47wLx/GTPXQ4Ry6gDSOr5vUrU8MVL/9iPNvx3p9ovfL99cXf7y8vnb2y0ff/bu+tebq1fXhy9v/nj9109u1/4J"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"param_witnesses":{"compute_nullifier":[{"end":5,"start":4}],"contract_address":[{"end":1,"start":0}],"nonce":[{"end":2,"start":1}],"note_type_id":[{"end":4,"start":3}],"serialized_note":[],"storage_slot":[{"end":3,"start":2}]},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[5,6,7,8]},"bytecode":"H4sIAAAAAAAA/+2b227aQBCG18RJTJ24YGMMgQQIyUXvDA2nO16mfe3eV+orVM2YnTJsp2hRx1tWYqWIsb2e/5t/D1jICdSuRe9/gY6v9eeN+rNhn63+LP+tzQRzlXVyBp5wNjzhvPKEMxTkDBhO+Ax1DOsO1tytOlyPv9tWqChTlELBBLoi19URwIMboUU6oBfHUuDrcnNDklNwpcFDfQ0/ASfW1yhYrIus+pBzWGiDnEOdK3IOd0bUibQpwvUuoj2yXN73CQA1NHUu5I5JTK8NiXVhTTVey9f4VsuYlLtVjGNyrXPfkmP0Cj0U/OaYUe1A/zWJptJjhPGA9MV+6EeDjDG0e7Wf180j94XGfQnpc8PUPxau/9bgMecsjEFLx204xj2BsH0g9W1l2ErIG8vnndExCHVu5I9JTYm43/M15L9Th838VhqTOCE89+I85ayeOndj95Gwy+RdvIFXLcOrO8OrhPShDK0a/AuILubG4xajLefFcg3abQsv2gxP27EXbUZb0IsNaKcWXqQMT+rYi5TRlvNi9Rm0MwsvMoYnc+xFxmjLeTGvni06Fl50GJ6OYy86jLbgGqnmRW7hRc7w5I69yBltQS++gnbXwosuw9N17EWX0Rb04gtoFxZeFAxP4diLgtEW3Dur54uehRc9hqfn2Iseoy3oxRy0+xZe9BmevmMv+oy24BqptB8svHhgeB4ce4F6pzJ3PGQuPGTOzoA5MmIZ7WW1fw4svBgwPAPHXtDfck5hzs+AOTJiGe3lArSHFl4MGZ6hYy9Q71Tm1EPmzEPmrofMuYfMhYfM5zCfIyOW0V5Ve+ijhRePDM+jYy9Q71Tm1EPmgYfM2RkwR0Yso72qfpt7svDiieF5cuwF6p3K3POQuX0GzJERy2ivlqA9svBixPCMHHuBeqcy9z1kLjxkHnjInHnI3PWQOfeQ+bIG3TCnZ8AM773gOzA/auWZb2KDBz1TBqMyGGMSJ4QR+26V3PsqiVE7ak3E/diNjzlf8HhSq/Z8DXmn8jVVz/IvOhe+wzdlanrVcSDs5wvJGxAdPB+S+Dvpi/3QD1y3yA7vXD3r+PXIfSPjvoT0eWbqHwvXPzV4pgYzjMk3wlHH3LKZ1y21X8ufCE8N++AbfScXm82+Q/cYQZ5ZTXWW9B2+n0p2TU8Mr5qGVwnpQ/fo/7VvXpgvzH9jps8TTXKO8uC5hlEL/f+GCcnxC57ToyHuNQAA","debug_symbols":"ndpBattQGIXRvWhsiu/vJz3JWymlOIlTDMYOsVMoJnuv3dIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhu3X23A8P++uh/PpfroN6y81/3l7edudHi8u1937ddhueq2G/enl8dQ/V8Pr4bgfttXb57fVY7TAaLOWUWRUMtrIqMlolNEkoy4jKWIjRTQpokkRTYpoUkSTIpoU0aSIJkU0KaJJEaMUMUoRoxQxShGjFDFKEaMUMUoRoxQxShGTFDFJEZMUMUkRkxQxSRGTFDFJEZMUMUkRXYroUkSXIroU0aWILkV0KaJLEV2K6FLELEXMUsQsRcxSxCxFzFLELEXMUsQsRcxSxCJFLFLEIkUsUsQiRSxSxCJFLFLEIkUsUkTWa1qFVkWrDa0arUZaTbTqtJppRW2E2gi1EWoj1EaojVAboTZCbYTaCLVR1EZRG0VtFLVR1EZRG0VtFLVBoBkSzRBphkwzhJoh1QyxZsg1Q7AZks0QbYZsM4SbId0M8WbIN0PAGRLOEHGGjDOEnCHlDDFnyDlD0BmSzhB1hqwzhJ0h7QxxZ8g7Q+AZEs8QeYbMM4SeIfUMsWfIPUPwGZLPEH2G7DOEnyH9DPFnyD9DABoS0BCBhgw0hKAhBQ0xaMhBQxAaktAQhYYsNIShIQ0NcWjIQ0MgGhLREImGTDSEoiEVDbFoyEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFyy56kosWuWiRixa5aJGLFrlokYvWf7vo/fRz937YPR33j7u9j48fp+d/V33vx+uvt79f7v/+Bg=="},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":5,"start":4}],"inputs":[{"end":3,"start":0}],"leaf_index":[{"end":7,"start":6}],"secret":[{"end":6,"start":5}],"to":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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"},{"name":"set_portal","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"param_witnesses":{"inputs":[{"end":3,"start":0}],"portal_address":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"H4sIAAAAAAAC/72WS47TQBCGO8kkk2Rsh8k7cV523PFIbNgwG8QBWHMCEEggAQsECzgKd+AicwhuwB6JxdBV3dW/Hc9EsoTGUift6v+rqq5qyZ2pllLdM2WetXKPeeuqSHXMX5PGcyUzM6HRiFRDTJoWibIzY1ct7QB1xjMTQbVT83PxVEmwTLVV+SF9h6PaUVWQ73OrOKeRUe5s7WvRmFRabtq3cUTTy5vONb11C7BFeg7pZd7DBURBh6cXNDUjTGg9ptl1Axm2XDFIFmpaCMmrzdk5L+3q1jyksgoSh0Zxe/RQUKug2AF8FEKryCoiGk3vjl7Do1flX4My1z3nac/tIuJNPqYZNlltCz29yJO9NnZLjtjJE5rd6+TZj5tmuU79QuXv6m1Q7m3Eve1XextYJJK9YiVEQ6kSA06TTvrgvoYOuKEDctX2zejB656bfkeyYTnZAQ6YaXbjpfl/hEgkvtRNa1SXwC6tJrRTRt/BLOiQURIMgQ6BDh36CmZBR4ySYAR0BHTk0M8wCzpmlARjoGOgY4e+hVnQCaMkmACdAJ049A3Mgk4ZJcEU6BTo1KEvYBZ0xigJZkBnQGcO/QizoHNGSTAHOgc6t/+1ERPtK8yCLhglwQLoAujCoV9gFnTJKAmWQJdAl9VEl/4InEBMtNcwCxozSoIYaAw0dugHmAVdMUqCFdAV0FU10ZU/NScQE20Hs6BrRkmwBroGuq5GW/uy1ETi+sioPjJ+kL1MTiOm2N9gFnTDKAk2QDdAN9VoG9+fE4iJ9h5mQbeMkmALdAt069BPMAu6Y5QEO6A7oLtqojsfrSayeJAow/pI/N8TM8X+DrOgCaMkSIAmQJNqtMSf9JrI5DTCn/2/+IhnDCp8ueVTzUItn3Pj8axwgUk5VFoOtbdwYqeyQtM9bgDaXkO0WzmYghGbN9hFTiYaHP2PfZM9EpNrkWWIZheabjc5MsqVD0aIpg78LqR1lPC1XGAzuEh9bQLUJj26jWF7aeW6+OsnubY3vQQNCZybkPNO7NnxdzWrSV06aaHGPp0U6ezL6YRX7iZob/tY0B7eA9ZlOMuKK1IpEh0407ZtmsgPqDD1TRdq74NpBMvLwQ5X7tzwW4c3N7+h8Q95DkDBpw0AAA==","debug_symbols":"5Z3dahpRGEXfZa6lnG+f/7xKKcUkpgjBhMQUSsi7V6uOlViEdLI4w9xl9JvZ+0TWGZQF89rdLq5ffnxfru4enrurr6/d/cPNfL18WG2OXjv3xezPq8+P89X2hef1/GndXXnzbtYtVrfbP1N6m3V3y/tFd6Uc3mbvpuWU9tNyMffT5nVm2mfth4P546yr566c8qGGCyez32bb8n7M5eOYy6cxl89jLl/GXL6OuLzc55bfhRgRoiFC+v+WXKkXPoZcDo1yjccru7Qv5FsrFForFFsrlForlFsrVForVPFCyfeF0kmh97PV1/1sTfXCbI6lv+5xp9Z+e/NuIuvURNYZJrLONJF15omss0xknRO5r4SJ3FeCTWSdE7l/hsvfrvLpOnenxY+dlj52Wv7Yaf/YY0v/VV7+0mdoUYcfCSzGyP2iEN2Yy9uYy2vM5f2Yy4cxl4+fW34XkoiQPERIPoaUdCakECEVCEmOCDEiRESIHzik2pmQQIREIiQRIZkIKURIBUKyI0KMCBERQhCfCeIzQXwmiM8E8ZkgPhPEF4L4QhBfCOILQXwhiC8E8YUgvhDEF4L4QhBfCeIrQXwliK8E8ZUgvhLEV4L4ShBfCeIrQbw5h6QYkiIkxSMpAUmJSEpCUjKSUpAUhH1D2DeEfUPYN4R9Q9g3hH1D2DeEfUPYN4R9IewLYV8I+0LYF8K+EPaFsC+EfSHsC2HfI+x7hH2PsO8R9j3CvkfY9wj7HmHfI+x7hP2AsB8Q9gPCfkDYDwj7AWE/IOwHhP2AsB8Q9iPCfkTYjwj7EWE/IuxHhP2IsB8R9iPCfkTYTwj7CWE/Iewjzp4h0p4h1p4h2p4h3p4h4p4h5p4h6p4h7p4h8p4h9p4h+p4h/p4hAp8hBp8hCp8hDp8hEp8hFp8hGp8hHp8hIp8hJp8hKp8hLp8hMp8hNp8hOp8hPp8hQp8hRp8hSp8hTp8hUp8hVp8hWp8hXp8Qr0+I1yfE6xPi9ckFJCUiKQlJyUhKQVIQ9hGvT4jXJ8TrE+L1CfH6hHh9Qrw+IV6fEK9PiNcnxOsT4vUJ8fqEeH1CvD4hXp8Qr0+I1yfE6xPi9Qnx+oR4fUK8PiFenxCvT4jXJ8TrE+L1CfH6hHh9Qrw+IV6fEK9PiNcnxOsT4vUJ8fqEeH1CvD4hXp8Qr0+DeH05hkNKruUk5f106h/bkNJfs/3zJwZxAIdt5JtrFJprFJtrlJprVJprVFtrNIjROGyj5nbI1NwOmZrbIVNzO2RqbodMze2Qg1igJR6mrTr/v41Kc41qa40GMVGHbWTNNVJzjXxzjUJzjWJzjVJzjZrbs3Nze3Zubs8uLe3Zm6Of86fl/Pp+sX1g7/bNl9XN4fm9m8P1r8fdO5vZ3w=="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"1"}},{"name":"typ","value":{"kind":"string","value":"Map<AztecAddress, PublicMutable<U128, Context>, Context>"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"2"}},{"name":"typ","value":{"kind":"string","value":"SharedImmutable<EthAddress, Context>"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"fee_limit","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::check_balance_parameters"}}],"kind":"struct","path":"GasToken::check_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::mint_public_parameters"}}],"kind":"struct","path":"GasToken::mint_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"GasToken::balance_of_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::balance_of_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::claim_parameters"}}],"kind":"struct","path":"GasToken::claim_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::claim_public_parameters"}}],"kind":"struct","path":"GasToken::claim_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::_increase_public_balance_parameters"}}],"kind":"struct","path":"GasToken::_increase_public_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"GasToken::set_portal_parameters"}}],"kind":"struct","path":"GasToken::set_portal_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"artifact_hash","type":{"kind":"field"}},{"name":"private_functions_root","type":{"kind":"field"}},{"name":"public_bytecode_commitment","type":{"kind":"field"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"GasToken::deploy_parameters"}}],"kind":"struct","path":"GasToken::deploy_abi"}]}},"file_map":{"100":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nfn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nfn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"101":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nfn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"102":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nfn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n"},"109":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n"},"110":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"111":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nfn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"113":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nfn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"120":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        // This looks the same as the &mut PublicContext impl, but is actually very different. In public execution the\n        // storage read oracle gets transpiled to SLOAD opcodes, whereas in unconstrained execution the PXE returns\n        // historical data.\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n"},"132":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    oracle::{storage::{storage_read, storage_write}}, state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // TODO(#4738): Uncomment the following assert\n        // assert(\n        //     self.context.public.unwrap_unchecked().is_deployment(), \"SharedImmutable can only be initialized during contract deployment\"\n        // );\n\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let fields_read: [Field; 1] = storage_read(initialization_slot);\n        assert(fields_read[0] == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        storage_write(initialization_slot, [0xdead]);\n\n        let fields_write = T::serialize(value);\n        storage_write(self.storage_slot, fields_write);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"145":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n"},"158":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    abis::{gas_settings::GasSettings, gas::Gas}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        let serialized: [Field; CALL_CONTEXT_LENGTH] = self.serialize();\n\n        for i in 0..CALL_CONTEXT_LENGTH {\n            assert(serialized[i] == 0);\n        }\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n        serialized.push(self.side_effect_counter as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n            side_effect_counter: reader.read() as u32,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n            side_effect_counter: 0,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn assert_is_zero() {\n    let context = CallContext::empty();\n    context.assert_is_zero();\n}\n\n#[test(should_fail)]\nfn not_zero_assert_is_zero() {\n    let mut context = CallContext::empty();\n    context.is_delegate_call = true;\n    context.assert_is_zero();\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"160":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"163":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"164":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"165":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse dep::std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: 0 }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"166":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"167":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"168":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"177":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"178":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, nullifier_counter: u32, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, nullifier_counter, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    nullifier_counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.nullifier_counter == other.nullifier_counter)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            nullifier_counter: 0,\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.nullifier_counter as Field, self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            nullifier_counter: reader.read_u32(),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n        assert(\n            (self.nullifier_counter == 0) | (read_request.counter() < self.nullifier_counter), \"Read request counter must be less than the nullifier counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    abis::{caller_context::CallerContext, side_effect::{Ordered, RangeOrdered, Scoped}},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.hash == other.hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x22786e4f971661d2e49095e6b038e5170bc47b795253916d5657c4bdd1df50bf;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"186":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"189":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint\n};\n\nstruct KeyValidationRequest {\n    pk_m: GrumpkinPoint,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: GrumpkinPoint::zero(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: GrumpkinPoint::new(fields[0], fields[1]),\n            sk_app: fields[2],\n        }\n    }\n}\n\n"},"190":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"197":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    new_note_hashes: u32,\n    new_nullifiers: u32,\n    new_l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            new_note_hashes: validate_array(public_inputs.new_note_hashes),\n            new_nullifiers: validate_array(public_inputs.new_nullifiers),\n            new_l2_to_l1_msgs: validate_array(public_inputs.new_l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.new_note_hashes.len() {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..self.new_nullifiers.len() {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.new_l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x1970bf189adc837d1769f9f44a8b55c97d45690e7744859b71b647e808ee8622;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"198":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, note_hash::NoteHash, nullifier::Nullifier, read_request::ReadRequest,\n    gas::Gas, global_variables::GlobalVariables, log_hash::LogHash\n},\n    address::AztecAddress,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH, MAX_UNENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize, Empty}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    l1_to_l2_msg_read_requests: [ReadRequest; MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    // Global variables injected into this circuit\n    global_variables: GlobalVariables,\n\n    prover_address: AztecAddress,\n\n    revert_code: u8,\n    \n    start_gas_left: Gas,\n    end_gas_left: Gas,\n    transaction_fee: Field,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.l1_to_l2_msg_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        for i in 0..MAX_UNENCRYPTED_LOGS_PER_CALL{\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n        fields.push(self.transaction_fee);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            l1_to_l2_msg_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            global_variables: reader.read_struct(GlobalVariables::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            revert_code: reader.read() as u8,\n            start_gas_left: reader.read_struct(Gas::deserialize),\n            end_gas_left: reader.read_struct(Gas::deserialize),\n            transaction_fee: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PublicCircuitPublicInputs {\n    fn empty() -> Self {\n        PublicCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0 as u32,\n            end_side_effect_counter: 0 as u32,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0 as u8,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PublicCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PublicCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x03ab5026ab5b3e6b81be5c3ec31c7937f293180c25a240eb75693cda81bb2a05;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"200":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"201":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"203":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr","source":"use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs = PublicCircuitPublicInputs::empty();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector, note_hash::NoteHash,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x124a62189073cc551fea148d735d1e8b452e38537e075895b02ccfd9c9901819;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x2cbb07062730bfc4933f5e8d533d5b62ac6e1b7922b831993377cd85d7445399;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n"},"205":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"206":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"207":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"209":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"21":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"210":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.tx_tree_height);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"211":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr","source":"use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{ToField, FromField, Hash, Serialize, Deserialize};\n\nstruct ContractClassId {\n  inner: Field\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n  fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field\n    ) -> Self {\n        let hash = dep::std::hash::pedersen_hash_with_separator(\n            [\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ],\n            GENERATOR_INDEX__CONTRACT_LEAF\n        ); // TODO(@spalladino): Update generator index\n\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"212":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"22":{"path":"std/field.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"222":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"233":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"234":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"240":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"242":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"254":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"256":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"257":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"265":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"266":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"267":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nfn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"268":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    contract_class_id::ContractClassId, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{Hash, is_empty},\n    utils::{uint256::U256, field::field_from_bytes_32_trunc}\n};\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u32) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\nfn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_siloed_note_hash(address: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, first_nullifier: Field, index: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, index);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"270":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"271":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use dep::std::cmp::Eq;\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize"},"273":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-contracts/contracts/gas_token_contract/src/lib.nr","source":"use dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::context::PublicContext;\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\npub fn calculate_fee<TPublicContext>(context: PublicContext) -> Field {\n    context.transaction_fee()\n}\n\npub fn get_bridge_gas_msg_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n"},"274":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-contracts/contracts/gas_token_contract/src/main.nr","source":"mod lib;\n\ncontract GasToken {\n    use dep::aztec::{\n        protocol_types::{\n        contract_class_id::ContractClassId, abis::function_selector::FunctionSelector,\n        address::{AztecAddress, EthAddress},\n        constants::{DEPLOYER_CONTRACT_ADDRESS, REGISTERER_CONTRACT_ADDRESS}\n    },\n        state_vars::{SharedImmutable, PublicMutable, Map},\n        oracle::get_contract_instance::get_contract_instance, deploy::deploy_contract\n    };\n\n    use dep::deployer::ContractInstanceDeployer;\n    use dep::registerer::ContractClassRegisterer;\n\n    use crate::lib::{calculate_fee, get_bridge_gas_msg_hash};\n\n    #[aztec(storage)]\n    struct Storage {\n        // This map is accessed directly by protocol circuits to check balances for fee payment.\n        // Do not change this storage layout unless you also update the base rollup circuits.\n        balances: Map<AztecAddress, PublicMutable<U128>>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Not flagged as initializer to reduce cost of checking init nullifier in all functions.\n    // This function should be called as entrypoint to initialize the contract by minting itself funds.\n    #[aztec(private)]\n    fn deploy(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n        portal_address: EthAddress\n    ) {\n        // Validate contract class parameters are correct\n        let self = context.this_address();\n        let instance = get_contract_instance(self);\n        let contract_class_id = ContractClassId::compute(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        );\n        assert(\n            instance.contract_class_id == contract_class_id, \"Invalid contract class id computed for gas token\"\n        );\n\n        // Increase self balance and set as fee payer, and end setup\n        let deploy_fees = 20000000000;\n        GasToken::at(self)._increase_public_balance(self, deploy_fees).enqueue(&mut context);\n        context.set_as_fee_payer();\n        context.end_setup();\n\n        // Register class and publicly deploy contract\n        let _register = ContractClassRegisterer::at(AztecAddress::from_field(REGISTERER_CONTRACT_ADDRESS)).register(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ).call(&mut context);\n        let _deploy = ContractInstanceDeployer::at(AztecAddress::from_field(DEPLOYER_CONTRACT_ADDRESS)).deploy(\n            instance.salt,\n            instance.contract_class_id,\n            instance.initialization_hash,\n            instance.public_keys_hash,\n            true\n        ).call(&mut context);\n\n        // Enqueue call to set the portal address\n        GasToken::at(self).set_portal(portal_address).enqueue(&mut context);\n    }\n\n    // We purposefully not set this function as an initializer so we do not bind\n    // the contract to a specific L1 portal address, since the gas token address\n    // is a hardcoded constant in the rollup circuits.\n    #[aztec(public)]\n    fn set_portal(portal_address: EthAddress) {\n        assert(storage.portal_address.read_public().is_zero());\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[aztec(private)]\n    fn claim(to: AztecAddress, amount: Field, secret: Field) {\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\n        let portal_address = storage.portal_address.read_private();\n        assert(!portal_address.is_zero());\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address);\n\n        // TODO(palla/gas) Emit an unencrypted log to announce which L1 to L2 message has been claimed\n        // Otherwise, we cannot trace L1 deposits to their corresponding claims on L2\n\n        GasToken::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.balances.at(to).read().add(U128::from_integer(amount));\n        storage.balances.at(to).write(new_balance);\n    }\n\n    // TODO(palla/gas) Remove this function and use the private claim flow only\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, leaf_index: Field) {\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\n        let portal_address = storage.portal_address.read_public();\n        assert(!portal_address.is_zero());\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address, leaf_index);\n\n        let new_balance = storage.balances.at(to).read() + U128::from_integer(amount);\n        storage.balances.at(to).write(new_balance);\n    }\n\n    // TODO(@just-mitch): remove this function before mainnet deployment\n    // convenience function for testing\n    // the true canonical gas token contract will not have this function\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.balances.at(to).read().add(amount);\n\n        storage.balances.at(to).write(new_balance);\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn check_balance(fee_limit: Field) {\n        let fee_limit = U128::from_integer(fee_limit);\n        assert(storage.balances.at(context.msg_sender()).read() >= fee_limit, \"Balance too low\");\n    }\n\n    // utility function for testing\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).read().to_field()\n    }\n}\n"},"277":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"mod events;\n\ncontract ContractInstanceDeployer {\n    use dep::aztec::protocol_types::{\n        address::{AztecAddress, EthAddress, PublicKeysHash, PartialAddress},\n        contract_class_id::ContractClassId, constants::DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\n        traits::Serialize\n    };\n\n    use crate::events::{instance_deployed::ContractInstanceDeployed};\n\n    #[aztec(private)]\n    fn deploy(\n        salt: Field,\n        contract_class_id: ContractClassId,\n        initialization_hash: Field,\n        public_keys_hash: PublicKeysHash,\n        universal_deploy: bool\n    ) {\n        // TODO(@spalladino): assert nullifier_exists silo(contract_class_id, ContractClassRegisterer)\n\n        let deployer = if universal_deploy {\n            AztecAddress::zero()\n        } else {\n            context.msg_sender()\n        };\n\n        let partial_address = PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\n\n        let address = AztecAddress::compute(public_keys_hash, partial_address);\n\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\n        context.push_new_nullifier(address.to_field(), 0);\n\n        // Broadcast the event\n        let event = ContractInstanceDeployed { contract_class_id, address, public_keys_hash, initialization_hash, salt, deployer, version: 1 };\n        let event_payload = event.serialize();\n        dep::aztec::oracle::debug_log::debug_log_format(\"ContractInstanceDeployed: {}\", event_payload);\n        context.emit_unencrypted_log(event_payload);\n    }\n}\n"},"28":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"282":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/main.nr","source":"mod events;\nmod capsule;\n\ncontract ContractClassRegisterer {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector};\n    use dep::aztec::protocol_types::{\n        contract_class_id::ContractClassId,\n        constants::{\n        ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, FUNCTION_TREE_HEIGHT,\n        MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS, REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE\n    },\n        traits::Serialize\n    };\n\n    use crate::events::{\n        class_registered::ContractClassRegistered,\n        private_function_broadcasted::{ClassPrivateFunctionBroadcasted, PrivateFunction},\n        unconstrained_function_broadcasted::{ClassUnconstrainedFunctionBroadcasted, UnconstrainedFunction}\n    };\n\n    // docs:start:import_pop_capsule\n    use crate::capsule::pop_capsule;\n    // docs:end:import_pop_capsule\n\n    #[aztec(private)]\n    fn register(artifact_hash: Field, private_functions_root: Field, public_bytecode_commitment: Field) {\n        // TODO: Validate public_bytecode_commitment is the correct commitment of packed_public_bytecode\n        // TODO: Validate packed_public_bytecode is legit public bytecode\n\n        // docs:start:pop_capsule\n        let packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] = pop_capsule();\n        // docs:end:pop_capsule\n\n        // Compute contract class id from preimage\n        let contract_class_id = ContractClassId::compute(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        );\n\n        // Emit the contract class id as a nullifier to be able to prove that this class has been (not) registered\n        let event = ContractClassRegistered { contract_class_id, version: 1, artifact_hash, private_functions_root, packed_public_bytecode };\n        context.push_new_nullifier(contract_class_id.to_field(), 0);\n\n        // Broadcast class info including public bytecode\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ContractClassRegistered: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ]\n        );\n        context.emit_contract_class_unencrypted_log(event.serialize());\n    }\n\n    #[aztec(private)]\n    fn broadcast_private_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        unconstrained_functions_artifact_tree_root: Field,\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n        private_function_tree_leaf_index: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: PrivateFunction\n    ) {\n        let event = ClassPrivateFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            unconstrained_functions_artifact_tree_root,\n            private_function_tree_sibling_path,\n            private_function_tree_leaf_index,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: function_data\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassPrivateFunctionBroadcasted: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_metadata_hash,\n            unconstrained_functions_artifact_tree_root,\n            function_data.selector.to_field(),\n            function_data.vk_hash,\n            function_data.metadata_hash\n        ]\n        );\n        context.emit_contract_class_unencrypted_log(event.serialize());\n    }\n\n    #[aztec(private)]\n    fn broadcast_unconstrained_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        private_functions_artifact_tree_root: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: UnconstrainedFunction\n    ) {\n        let event = ClassUnconstrainedFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            private_functions_artifact_tree_root,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: function_data\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassUnconstrainedFunctionBroadcasted: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_metadata_hash,\n            private_functions_artifact_tree_root,\n            function_data.selector.to_field(),\n            function_data.metadata_hash\n        ]\n        );\n        context.emit_contract_class_unencrypted_log(event.serialize());\n    }\n}\n"},"29":{"path":"std/hash.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n"},"3":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, N> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<N> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, N> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"31":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"44":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not() {\n        let num = U128::from_u64s_le(0, 0);\n        let not_num = num.not();\n\n        let max_u64: Field = pow64 - 1;\n        assert_eq(not_num.hi, max_u64);\n        assert_eq(not_num.lo, max_u64);\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"64":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"65":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize};\n\nuse crate::context::private_context::PrivateContext;\nuse crate::context::public_context::PublicContext;\nuse crate::context::gas::GasOpts;\nuse crate::context::public_context::FunctionReturns;\n\nuse crate::oracle::arguments;\n\nstruct PrivateCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateCallInterface<T> {\n    pub fn call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateVoidCallInterface {\n    pub fn call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nstruct PrivateStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateStaticCallInterface<T> {\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateStaticVoidCallInterface {\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nstruct PublicCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicStaticCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nstruct PublicStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicStaticVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"66":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::encrypted_logs::{payload::compute_encrypted_note_log};\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message,\n    hash::{hash_args_array, ArgsHasher, compute_unencrypted_log_hash},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    note::{note_interface::NoteInterface, utils::compute_note_hash_for_insertion},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{\n    emit_encrypted_note_log, emit_encrypted_event_log, compute_encrypted_event_log,\n    emit_contract_class_unencrypted_log_private_internal, emit_unencrypted_log_private_internal\n},\n    logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field,\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, grumpkin_point::GrumpkinPoint, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::{is_empty, Empty},\n    utils::arrays::find_index\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Ending setup at counter {0}\",\n            [self.side_effect_counter as Field]\n        );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n    // --> might be a better approach to force devs to make a public function call that emits the log if needed then\n    // it would be less easy to accidentally leak information.\n    // If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\n    pub fn emit_unencrypted_log<T, N, M>(\n        &mut self,\n        log: T\n    ) where T: ToBytesForUnencryptedLog<N, M> {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_slice = log.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n        // call oracle\n        let _void = emit_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    pub fn emit_contract_class_unencrypted_log<N>(&mut self, log: [Field; N]) {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n    }\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn encrypt_and_emit_event<N, M>(\n        &mut self,\n        randomness: Field, // Secret random value used later for masked_contract_address\n        event_type_id: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        preimage: [Field; N]\n    ) where [Field; N]: LensForEncryptedLog<N, M> {\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n        let contract_address = self.this_address();\n\n        // We are currently just encrypting it unconstrained, but otherwise the same way as if it was a note.\n        let encrypted_log: [u8; M] = compute_encrypted_event_log(\n            contract_address,\n            randomness,\n            event_type_id,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            preimage\n        );\n\n        self.emit_raw_event_log_with_masked_address(randomness, encrypted_log);\n    }\n\n    pub fn emit_raw_event_log_with_masked_address<M>(\n        &mut self,\n        randomness: Field,\n        encrypted_log: [u8; M]\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, encrypted_log, counter);\n    }\n\n    pub fn encrypt_and_emit_note<Note, N, NB, M>(\n        &mut self,\n        storage_slot: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        note: Note\n    ) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n        let note_hash_counter = note.get_header().note_hash_counter;\n        let note_exists_index = find_index(\n            self.new_note_hashes.storage,\n            |n: NoteHash| n.counter == note_hash_counter\n        );\n        assert(\n            note_exists_index as u32 != MAX_NEW_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n        );\n\n        let contract_address = self.this_address();\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n\n        let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk_m, ivpk_m, note);\n        self.emit_raw_note_log(note_hash_counter, encrypted_log);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, encrypted_log: [u8; M]) {\n        let counter = self.next_counter();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, encrypted_log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"67":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    */\n    pub fn emit_unencrypted_log_with_selector<T, N>(\n        &mut self,\n        event_selector: Field,\n        log: T\n    ) where T: Serialize<N> {\n        emit_unencrypted_log(event_selector, Serialize::serialize(log).as_slice());\n    }\n    // For compatibility with the selector-less API. We'll probably rename the above one.\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        self.emit_unencrypted_log_with_selector(/*event_selector=*/ 5, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(event_selector: Field, message: [Field]) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nfn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nfn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nfn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nfn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nfn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nfn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nfn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nfn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nfn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nfn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nfn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nfn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nfn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nfn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nfn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nfn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nfn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nfn emit_unencrypted_log_opcode(event_selector: Field, message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nfn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nfn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nfn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nfn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"},"79":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse dep::std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"86":{"path":"/mnt/user-data/mara/aztec-packages/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"}}}