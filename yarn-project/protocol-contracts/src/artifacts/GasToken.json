{"transpiled":true,"noir_version":"0.30.0+48d9df4ff227c08a6e66f21c0286bc6349151671","name":"GasToken","functions":[{"name":"_increase_public_balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"deploy","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"artifact_hash","type":{"kind":"field"},"visibility":"private"},{"name":"private_functions_root","type":{"kind":"field"},"visibility":"private"},{"name":"public_bytecode_commitment","type":{"kind":"field"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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1JWH76du8v3UTb6fusn3Uzf5furqZPPsO77vp27y/dRNvp+6yfdTN/l+6mbfT93s+6mbfT91s++nrk42z77j+37qZt9P3ez7qZt9P3Wz76du8f3ULb6fusX3U7f4furqJCPtO77vp27x/dQtvp+6xfdTt/h+6orvp674fuqK76eu+H7q6uRS7Tu+76eu+H7qiu+nrvh+6orvp271/dStvp+61fdTt/p+6urkUu07vu+nbvX91K2+n7rV91O3+n7qNt9P3eb7qdt8P3Wb76euTrbUvuP7fuo230/d5vup23w/dZvvp273/dTtvp+63fdTt/t+6urkPe07vu+nbvf91O2+n7rd91O3+37q+s6mEt/ZVOI7m0p8Z1OJ72wq8Z1NJb6zqcR3NpX4zqYS39lU4jubSnxnU4nvbCrxnU0lvrOpxHc2lfjOphLf2VTiO5tKfGdTVd/ZVNV3NlX1nU1VfWdT1Yfrp271nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVNV3NlX1nU1VfWdTVd/ZVM13NlXznU3VfGdTNd/ZVO3h+qnbfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlXznU3VfGdTNd/ZVM13NlX3nU3VfWdTdd/ZVN13NlV/uH7qdt/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU3VfWdTdd/ZVN13NlX3nU01fGdTDd/ZVMN3NtXwnU01Hq6fusN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTDd/ZVMN3NtXwnU01fGdTTd/ZVNN3NtX0nU01fWdTzYfrp+70nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVNN3NtX0nU01fWdTTd/ZVM9zun7s/v2czs/v+sH7PKfrJ+/znK4fvc9zun72Ps/p+uH7PKfrp+/znK4fv89zOn/++o6pep7f+fPXd1DV8/zOn7++o6qe53f+/PUdVvU8v/Pnr++4quf5nT9/fQdWPc/v/PnrO7LqeX7nz1/foVXP8zt//vqOrXqe3/nz13dw1fP8zp+/vqOrnud3/vz1HV71PL/z56/v+Krn+Z0/f30HWD3P7/z56zvC6nl+589f3yFWz8M5f/76jrF6Hs7589d3kNXzcM6fv76jrJ6Hc/789R1m9Tyc8+ev7zir5/mdP399B1o9z+/8+es70up5fufPX9+hVs/zO3/++o61ep7f+fPXd7DV8/zOn7++o62e53f+/PUdbvU8v/Pnr+94q+f5nT9/fQdcPc/v/PnrO+LqeX7nz1/fIVfP8zt//vqOuXqe3/nz13fQ1fP8zp+/vqOunud3/vz1HXb1PL/z56/vuKvn+Z0/f30HXj3P7/z56zvy6nl+589f36FXz/M7f/76jr16nt/589d38NXz/M6fv76jr57nd/789R1+9Ty/8+ev7/ir5/l9P3+T8/yr5Dz/KjnPv0rO86+ep3N+ft/P3+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z79KzvOvkvP8q+Q8/yo5z7/KzvOvsvP8q+w8/yo7z7/KD9/P3+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvsvP8q+w8/yo7z7/KzvOvivP8q+I8/6o4z78qzvOvysP387c4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8q+I8/6o4z78qzvOvivP8K3GefyXO86/Eef6VOM+/kofv5684z78S5/lX4jz/SpznX4nz/Ctxnn8lzvOvxHn+lTjPvxLn+VfiPP9KnOdfifP8K3GefyXO86/Eef6VOM+/Euf5V+I8/0qc51+J8/wrcZ5/Jc7zr8R5/pU4z78S5/lX4jz/SpznX4nz/Ctxnn8lzvOvxHn+lTjPvxLn+VfiPP9KnOdfifP8K3GefyXO86/Eef6VOM+/Euf5V+I8/0qc51+J8/wrcZ5/Jc7zr8R5/pU4z78S5/lX4jz/SpznX4nz/Ctxnn8lzvOvxHn+lTjPvxLn+VfiPP9KnOdfifP8K3GefyXO86/Eef6VOM+/Euf5V+I8/0qc51+J8/wrcZ5/Jc7zr8R5/pU4z78S5/lX4jz/SpznX4nz/Ctxnn8lzvOvxHn+lTjPvxLn+VfiPP9KnOdfifP8K3GefyXO86/Eef6VOM+/Euf5V+I8/0qc51+J8/wrcZ5/Jc7zr6rz/KvqPP+qOs+/qs7zr+rD9/O3Os+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvqPP+qOs+/qs7zr6rz/KvmPP+qOc+/as7zr5rz/Kv28P38bc7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qOc+/as7zr5rz/KvmPP+qO8+/6s7zr7rz/KvuPP+qP3w/f7vz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/6s7zr7rz/KvuPP+qO8+/Gs7zr4bz/KvhPP9qOM+/Gg/fz9/hPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr4bz/KvhPP9qOM+/Gs7zr6bz/KvpPP9qOs+/ms7zr+bD9/N3Os+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bz/KvpPP9qOs+/ms7zr6bv/Kv88J1/9Ty/6+fv8/yun7/P87t+/j7P7/r5+zy/6+fv8/yun7/P87t+/j7P7/r5+zy/8+ev7/yr5/mdP3995189z+/8+es7/+p5fufPX9/5V8/zO3/++s6/ep7f+fPXd/7V8/zOn7++86+e53f+/PWdf/U8v/Pnr+/8q+f5nT9/fedfPc/v/PnrO//q+R2cP3995189v4Pz56/v/Kvnd3D+/PWdf/X8Ds6fv77zr57fwfnz13f+1fP8zp+/vvOvnud3/vz1nX/1PL/z56/v/Kvn+Z0/f33nXz3P7/z56zv/6nl+589f3/lXz/M7f/76zr96nt/589d3/tXz/M6fv77zr57nd/789Z1/9Ty/8+ev7/yr5/mdP3995189z+/8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5Z5nqNzzDJV7nqFyzzNU7nmGyj3PULnnGSr3PEPlnheo3PMClXteoHLPC1TueXkIVLVIWqpA5Z4XqNzzApV7XqByzwtU7nmByj0vULnnBSr3vEDlnheo3PMClXteoHLPC1TueYHKPS9QuecFKve8QOWeF6jc8wKVe16gcs8LVO55gco9L1C55wUq97xA5Z4XqNzzApV7XqByzwtU7nmByj0vULnnBSr3vEDlnheo3PMClXteoHLPC1TueYHKPS9QuecFKve8QOWeF6jc8wKVe16gcs8LVO55gco9L1C55wUq97xA5Z4XqNzzApV7XqByzwtU7nmByj0vULnnBSr3vEDlnheo3PMClXteoHLPC1TueYHKPS9QuecFKve8QOWeF6jc8wKVe16gcs8LVO55gco9L1C55wUq97xA5Z4XqNzzApV7XqByzwtU7nmByj0vULnnBSr3vEDlnheo3PMClXteoHLPC1TueYHKPS9QuecFKve8QOWeF6jc8wKVe16gcs8LVO55gco9F6jcc4HKPReo3HOByj2Xh0BVi6SlBCr3XKByzwUq91ygcs8FKvdcoHLPBSr3XKByzwUq91ygcs8FKvdcoHLPBSr3XKByzwUq91ygcs8FKvdcoHLPBSr3XKByzwUq91ygcs8FKvdcoHLPBSr3XKByzwUq91ygcs8FKvdcoHLPBSr3XKByzwUq91ygcs8FKvdcoHLPBSr3XKByzwUq91ygcs8FKvdcoHLPBSr3XKByzwUq91ygcs8FKvdcoHLPJVJa9Oz59eFe3lcb6Al0XW2kROE5xuvDs7+vNtAttVBtoFtqoVqBqjaQ41uoNpDjW6g20vP2utpIz9vragM5vutqIyUKL1QLpaUiJQovVOtWSx0ViPsKbGuenuergpH7let+zPY6dUqfTt3qR722VY9+vbZ1j369tpWPfr22tY96vcYzgPXrta1/9Ou1rYD067WtgfTrFbB6wfSV8Txg/XrB9JXxTGD9esH0lfFcYP16wfSV8Wxg/XrB9JXxfGD9esH0lfGMYP16wfSV8Zxg/Xqx9FU1nhWsXy+WvqrG84L168XSV/UhYPVi6atqPDdYv14sfVWNZwfr1wumr4znB+vXC6avjGcI69cLpq+M5wjr1wumr4xnCevXC6avjOcJ69cLpq+MZwrr1wumr4znCuvXC6avjGcL69cLpq+M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778q4P1XBbz/qoD3XxXw/qsC3n9VwPuvCnj/VQHvvyrg/VcFvP+qgPdfFfD+qwLef1XA+68KeP9VAe+/KuD9VwW8/6qA918V8P6rAt5/VcD7rwp4/1UB778q4P1XBbz/qoD3XxXw/qsC3n9VwPuvCnj/VQHvvyrg/VcFvP+qgPdfFfD+qwLef1XA+68KeP9VAe+/KuD9VwW8/6qA918V8P6rAt5/VcH7ryp4/1UF77+q4P1X9Yb9/q3g/VcVvP+qgvdfVfD+qwref1XB+68qeP9VBe+/quD9VxW8/6qC919V8P6rCt5/VcH7ryp4/1UF77+q4P1XFbz/qoL3X1Xw/qsK3n9VwfuvKnj/VQXvv6rg/VcVvP+qgvdfVfD+qwref1XB+68qeP9VBe+/quD9VxW8/6qC919V8P6rCt5/VcH7ryp4/1UF77+q4P1XFbz/qoL3X1Xw/qsK3n9VwfuvKnj/VQXvv6rg/VcVvP+qgvdfVfD+qwref1XB+68qeP9VBe+/quD9VxW8/6qC919V8P6rCt5/VcH7ryp4/1UF77+q4P1XFbz/qoL3X1Xw/qsK3n9VwfuvKnj/VQXvv6rg/VcVvP+qgvdfVfD+qwref1XB+68qeP9VBe+/quD9VxW8/6qC919V8P6rCt5/VcH7ryp4/1UF77+q4P1XFbz/qoL3X1Xw/qsK3n9VwfuvKnj/VQPvv2rg/VcNvP+qgfdftRv2+7eB91818P6rBt5/1cD7rxp4/1UD779q4P1XDbz/qoH3XzXw/qsG3n/VwPuvGnj/VQPvv2rg/VcNvP+qgfdfNfD+qwbef9XA+68aeP9VA++/auD9Vw28/6qB91818P6rBt5/1cD7rxp4/1UD779q4P1XDbz/qoH3XzXw/qsG3n/VwPuvGnj/VQPvv2rg/VcNvP+qgfdfNfD+qwbef9XA+68aeP9VA++/auD9Vw28/6qB91818P6rBt5/1cD7rxp4/1UD779q4P1XDbz/qoH3XzXw/qsG3n/VwPuvGnj/VQPvv2rg/VcNvP+qgfdfNfD+qwbef9XA+68aeP9VA++/auD9Vw28/6qB91818P6rBt5/1cD7rxp4/1UD779q4P1XDbz/qoH3XzXw/qsG3n/VwPuvGnj/VQPvv2rg/VcNvP+qgfdfNfD+qwbef9XA+68aeP9VA++/auD9Vx28/6qD91918P6rDt5/1W/Y798O3n/VwfuvOnj/VQfvv+rg/VcdvP+qg/dfdfD+qw7ef9XB+686eP9VB++/6uD9Vx28/6qD91918P6rDt5/1cH7rzp4/1UH77/q4P1XHbz/qoP3X3Xw/qsO3n/VwfuvOnj/VQfvv+rg/VcdvP+qg/dfdfD+qw7ef9XB+686eP9VB++/6uD9Vx28/6qD91918P6rDt5/1cH7rzp4/1UH77/q4P1XHbz/qoP3X3Xw/qsO3n/VwfuvOnj/VQfvv+rg/VcdvP+qg/dfdfD+qw7ef9XB+686eP9VB++/6uD9Vx28/6qD91918P6rDt5/1cH7rzp4/1UH77/q4P1XHbz/qoP3X3Xw/qsO3n/VwfuvOnj/VQfvv+rg/VcdvP+qg/dfdfD+qw7ef9XB+686eP9VB++/6uD9Vx28/6qD91918P6rDt5/1cH7rzp4/1UH77/q4P1XHbz/qoP3Xw3w/qsB3n81wPuvBnj/1bhhv38HeP/VAO+/GuD9VwO8/2qA918N8P6rAd5/NcD7rwZ4/9UA778a4P1XA7z/aoD3Xw3w/qsB3n81wPuvBnj/1QDvvxrg/VcDvP9qgPdfDfD+qwHefzXA+68GeP/VAO+/GuD9VwO8/2qA918N8P6rAd5/NcD7rwZ4/9UA778a4P1XA7z/aoD3Xw3w/qsB3n81wPuvBnj/1QDvvxrg/VcDvP9qgPdfDfD+qwHefzXA+68GeP/VAO+/GuD9VwO8/2qA918N8P6rAd5/NcD7rwZ4/9UA778a4P1XA7z/aoD3Xw3w/qsB3n81wPuvBnj/1QDvvxrg/VcDvP9qgPdfDfD+qwHefzXA+68GeP/VAO+/GuD9VwO8/2qA918N8P6rAd5/NcD7rwZ4/9UA778a4P1XA7z/aoD3Xw3w/qsB3n81wPuvBnj/1QDvvxrg/VcDvP9qgPdfDfD+qwHef3V/UOwX8H8eFF0A9iv4/qDY7+D7g2K/hO8Piv0Wvj8o9mv4/qDY7+H7g2K/iO8Piv4mBq/CugtAfxODl2HdBaC/icHrsO4C0N/E4IVYdwHob2LwSqy7APQ3MXgp1l0A+psYvBbrLgD9TQxejHUXgP4mBq/GugtAfxODl2PdBaC/icHrse4C0N/E4AVZdwHob2Lwiqy7APQ3MXhJ1l0A+psYvCbrLgD9TQxelHV/OvQ3MXhV1v3p0N/E4GVZ96dDfxOD12Xdnw79TQxemHV/OvQ3MXhl1l0A+psYvDTrLgD9TQxem3UXgP4mBi/OugtAfxODV2fdBaC/icHLs+4C0N/E4PVZdwHob2LwAq27APQ3MXiF1l0A+psYvETrLgD9TQxeo3UXgP4mBi/SugtAfxODV2ndBaC/icHLtO4C0N/E4HVadwHob2LwQq27APQ3MXil1l0A+psYvFTrLgD9TQxeq3UXgP4mBi/WugtAfxODV2vdBaC/icHLte4C0N/E4PVadwHob2Lwgq27APQ3MXjF1l0A+Jt4Q+/Y2tA7tjb0jq0NvWPr/njoAsDfxBt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1oXdsbegdWxt6x9aG3rG1o3ds7egdWzt6x9aO3rG138DfxDt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3ds7egdWzt6x9aO3rG1o3dsHegdWwd6x9aB3rF1oHdsHTfwN/GB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdWwd6x9aB3rF1oHdsHegdW4besWXoHVuG3rFl6B1bdgN/Ext6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHlqF3bBl6x5ahd2wZeseWoXdsGXrHVkHv2CroHVsFvWOroHdslRv4m7igd2wV9I6tgt6xVdA7tgp6x1ZB79gq6B1bBb1jq6B3bBX0jq2C3rFV0Du2CnrHVkHv2CroHVsFvWOroHdsFfSOrYLesVXQO7YKesdWQe/YKugdWwW9Y6ugd2wV9I6tgt6xVdA7tgp6x1ZB79gq6B1bBb1jq6B3bBX0jq2C3rFV0Du2CnrHVkHv2CroHVsFvWOroHdsFfSOrYLesVXQO7YKesdWQe/YKugdWwW9Y6ugd2wV9I6tgt6xVdA7tgp6x1ZB79gq6B1bBb1jq6B3bBX0jq2C3rFV0Du2CnrHVkHv2CroHVsFvWOroHdsFfSOrYLesVXQO7YKesdWQe/YKugdWwW9Y6ugd2wV9I6tgt6xVdA7tgp6x1ZB79gq6B1bBb1jq6B3bBX0jq2C3rFV0Du2CnrHVkHv2CroHVsFvWOroHdsFfSOrYLesVXQO7YKesdWQe/YKugdWxW9Y6uid2xV9I6tit6xVW/gb+KK3rFV0Tu2KnrHVkXv2KroHVsVvWOrondsVfSOrYresVXRO7YqesdWRe/YqugdWxW9Y6uid2xV9I6tit6xVdE7tip6x1ZF79iq6B1bFb1jq6J3bFX0jq2K3rFV0Tu2KnrHVkXv2KroHVsVvWOrondsVfSOrYresVXRO7YqesdWRe/YqugdWxW9Y6uid2xV9I6tit6xVdE7tip6x1ZF79iq6B1bFb1jq6J3bFX0jq2K3rFV0Tu2KnrHVkXv2KroHVsVvWOrondsVfSOrYresVXRO7YqesdWRe/YqugdWxW9Y6uid2xV9I6tit6xVdE7tip6x1ZF79iq6B1bFb1jq6J3bFX0jq2K3rFV0Tu2KnrHVkXv2KroHVsVvWOrondsVfSOrYresVXRO7YqesdWRe/YqugdWxW9Y6uid2xV9I6tit6xVdE7tip6x1ZF79iq6B1bFb1jq6J3bDX0jq2G3rHV0Du2GnrHVruBv4kbesdWQ+/YaugdWw29Y6uhd2w19I6tht6x1dA7thp6x1ZD79hq6B1bDb1jq6F3bDX0jq2G3rHV0Du2GnrHVkPv2GroHVsNvWOroXdsNfSOrYbesdXQO7YaesdWQ+/YaugdWw29Y6uhd2w19I6tht6x1dA7thp6x1ZD79hq6B1bDb1jq6F3bDX0jq2G3rHV0Du2GnrHVkPv2GroHVsNvWOroXdsNfSOrYbesdXQO7YaesdWQ+/YaugdWw29Y6uhd2w19I6tht6x1dA7thp6x1ZD79hq6B1bDb1jq6F3bDX0jq2G3rHV0Du2GnrHVkPv2GroHVsNvWOroXdsNfSOrYbesdXQO7YaesdWQ+/YaugdWw29Y6uhd2w19I6tht6x1dA7thp6x1ZD79hq6B1bDb1jq6F3bDX0jq2G3rHV0Du2GnrHVkPv2GroHVsNvWOroXdsNfSOrYbesdXRO7Y6esdWR+/Y6ugdW/0G/ibu6B1bHb1jq6N3bHX0jq2O3rHV0Tu2OnrHVkfv2OroHVsdvWOro3dsdfSOrY7esdXRO7Y6esdWR+/Y6ugdWx29Y6ujd2x19I6tjt6x1dE7tjp6x1ZH79jq6B1bHb1jq6N3bHX0jq2O3rHV0Tu2OnrHVkfv2OroHVsdvWOro3dsdfSOrY7esdXRO7Y6esdWR+/Y6ugdWx29Y6ujd2x19I6tjt6x1dE7tjp6x1ZH79jq6B1bHb1jq6N3bHX0jq2O3rHV0Tu2OnrHVkfv2OroHVsdvWOro3dsdfSOrY7esdXRO7Y6esdWR+/Y6ugdWx29Y6ujd2x19I6tjt6x1dE7tjp6x1ZH79jq6B1bHb1jq6N3bHX0jq2O3rHV0Tu2OnrHVkfv2OroHVsdvWOro3dsdfSOrY7esdXRO7Y6esdWR+/Y6ugdWx29Y6ujd2x19I6tjt6x1dE7tjp6x9ZA79ga6B1bA71ja6B3bI0b+Jt4oHdsDfSOrYHesTXQO7YGesfWQO/YGugdWwO9Y2ugd2wN9I6tgd6xNdA7tgZ6x9ZA79ga6B1bA71ja6B3bA30jq2B3rE10Du2BnrH1kDv2BroHVsDvWNroHdsDfSOrYHesTXQO7YGesfWQO/YGugdWwO9Y2ugd2wN9I6tgd6xNdA7tgZ6x9ZA79ga6B1bA71ja6B3bA30jq2B3rE10Du2BnrH1kDv2BroHVsDvWNroHdsDfSOrYHesTXQO7YGesfWQO/YGugdWwO9Y2ugd2wN9I6tgd6xNdA7tgZ6x9ZA79ga6B1bA71ja6B3bA30jq2B3rE10Du2BnrH1kDv2BroHVsDvWNroHdsDfSOrYHesTXQO7YGesfWQO/YGugdWwO9Y2ugd2wN9I6tgd6xNdA7tgZ6x9ZA79ga6B1bA71ja6B3bA30jq2B3rE10Du2BnrH1kDv2BrgHVv7Dbxj6y4A+018F4D9Jr4LwH4T3wVgv4nvArDfxHcB2G/iuwDsN/FdAPab+C4A/U0M3rF1F4D+Jgbv2LoLQH8Tg3ds3QWgv4nBO7buAtDfxOAdW3cB6G9i8I6tuwD0NzF4x9ZdAPqbGLxj6y4A/U0M3rF1F4D+Jgbv2LoLQH8Tg3ds3f8J9DcxeMfW/Z9AfxODd2zd/wn0NzF4x9b9n0B/E4N3bN3/CfQ3MXjH1l0A+psYvGPrLgD9TQzesXUXgP4mBu/YugtAfxODd2zdBaC/icE7tu4C0N/E4B1bdwHob2Lwjq27APQ3MXjH1l0A+psYvGPrLgD9TQzesXUXgP4mBu/YugtAfxODd2zdBaC/icE7tu4C0N/E4B1bdwHob2Lwjq27APQ3MXjH1l0A+psYvGPrLgD9TQzesXUXgP4mBu/YugtAfxODd2zdBaC/icE7tu4C0N/E4B1bdwHob2Lwjq27APQ3MXjH1l0A+psYvGPrLgD9TQzesXUXgP4mBu/YugtAfxODd2zdBaC/icE7tu4CwN/EG3rH1obesbWhd2xt6B1b98dDFwD+Jt7QO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tDb1ja0Pv2NrQO7Y29I6tHb1ja0fv2NrRO7Z29I6t/Qb+Jt7RO7Z29I6tHb1ja0fv2NrRO7Z29I6tHb1ja0fv2NrRO7Z29I6tHb1ja0fv2NrRO7Z29I6tHb1ja0fv2NrRO7Z29I6tHb1ja0fv2NrRO7Z29I6tHb1ja0fv2NpjNzwV2399bbEzAaHfAzMCQn8KldIfAmo7ERD6U2hGQOhPoRkBoT+FZgSEzgMTAmL3C80ICP0eqFv99bX12E8EhH4PzAgInQdmBBi6gNBv4hkBod/EMwJCv4lnBIR+E88ICP0mnhAQu19oRgD6mzh2v9CMAPQ3cex+oRkB6G/i2P1CMwLQ38Sx+4VmBPz9N/HpuvB/v7a38XiO3jd7PUft/2wRuaCNaKncjUvuziX3QJX7kmD4Egq+hIovoeFL6PgSYN3EU0KDdQgvCbBv/ZcE2Df5S0Lst3Nvt8cXj49m5B6VH4/Rtj+bkQXNSkvlxn7rfyXX+Zc9Wmw3sRRNbJeyFE1s97MUTWxXtRJNj+3WlqKJ7QKXoontLpeiSeRavdGY0JyhkRs+RSM3fIpGbvgUjdzwKRq54TM0Q274FI3c8CkaueFTNHLDp2hMaM7QyA2fopEbPkUjN3yKRm74FI3c8Ama4yY3fIpGbvgUjdzwKRq54VM0JjRnaOSGT9HIDZ+ikRs+RSM3fIpGbvgMzSY3fIpGbvgUjdzwKRq54VM0JjRnaOSGT9HIDZ+ikRs+RSM3fIpGbvgMzU7qaz43RR47qa+ZQUP6hvrc7HfspG+oGTSkb6gZNKRvqAk0B+m+ZgYN6b5mBg2pr/ncdHQcpL5mBo0JzRka0n3NDBpSNzyDhtQNz6AhdcMzaEjd8AQaI3XDM2hI3fAMGrnhUzRyw6doLBGaL77z1qs9FN7/lddXb3/66s8dSYdl8s5LQWZy2ktBZvLlS0FmcvFOIF9wMvl4bzglk5N3h5PJy7vDyeTm3eFk8vPucExwzuHIpb+Bw+q8R31852204zc4f1C41/5U2PsJSlbvfQFKVvf9JcqnQCt/jjHBr9/ggAx+VwcIJGsCcAfJmhbcQbImC3eQJpA+IFkTy3cgP29xg999AgJJmm3uz/b40et++/nM/zzbBL+CBYWSNN18i/LjCyf4TTAgkKTpxh8kabrxB0mabvxBmkD6gCRNN/4gSdPNlyA/p5tUV+uWgmTNNtv2ZLPt3SPbpLqJtxZlqht6F6L8+MJJdXFvKUjWdOMOkjXduIM0gfQByZpu3EGypht3kKzp5juQn9NNqpuFS0HS/tym1xfI8QFkG8/vfHt97XZPOU+Qqe4hLgVJ+3Mbb5C0yaZuT5DNPNYWqW4zLkZpQjmD8qOXTHX5cSlI2nTjDZI23XiDpE033iBpf3LjC9JS3bdcCpL25zZfgfy4uLBUtzOXglS22be+/zGt2M0E5xyOEsgbOKyp4r68ej7zXj6+MT+vDCzVfc7FKFmTxZcoP/s41mThDTLVrdClIFmThTtI1mThDpI1WbiDNIH0AcmaWL4D+XlpkOp+6lKQyjb3/7s9/pxWUt1bdYejBHIOZ6dNFT+XANvHN+bEymCnzRX+KGmTxXcoP/q4VHeDl4I0gfQBSZssvEHSJgtvkLTJwhskbQrxBkmbWL4C+XlpkOpe91KQyjZOIJVsnEAq2TiBNIH0Aalk4wRSycYJpJLN+Y4x1c1zdzhKIOdwUt09P/3OL7kU3v8lN7ZDH8/6wz5+fOd/Lje2j3aXa3nkTmySgl/7dpcb2zm6y43t79zlxnZs7nJjezBvucFvUH8n93M2C35V2l1uIlc1IzeRq5qRa1xyM7mqCbnBXVV/BcBx/PuIEPwmsrvc4K7qG7kzNiO4q3KWG/wGsLvc4K7KW25wV+UtN7ir8pZrieR+thnBL8i6y03kqmbkJnJVM3IzuaoJuZlc1We5sW+Pjps9vvO4lfrvI0LsC6H+ckO7qu/kTtiM2Nc2/eUal9zQrspfbmhX5S83tKvylxvaVX0pd8JmhHZV7nJj3zz0l5vIVc3IzeSqJuRmclUTcg1Gbv09AL4k4DilUwk47udUQnBHMx7PMe4P8u+zZuz7bP5ygzuab+RO+NXYt8785QZ3NN5ygzsab7nBHY23XOOSG9z9fCX3s1+NfcvKX24iVzUjN5GrmpGbyVV9lFti31jyl5vJVU3IBXJV448ZtsS+FDQnwUJL2Owl4cef6f75P7q+P3pQ+49n3rfth9zY7sddbmz385Xc1p+/7b7tH77z5w1FiX1DZy2a2K5qKZrYDmwlmth3a9aiie3slqKJ7QKXoontLpeiMaE5Q5PI4XqjkRs+RSM3fIpGbvgUjdzwGZrY91bWopEbPkUjN3yKRm74FI0JzRkaueFTNHLDp2jkhk/RyA2fopEbPkMT+z7HWjRyw6do5IZP0cgNn6IxoTlDQ+prij1+U6LYGRpSXzOBJnYv/IVoyuNEQKntBA3pG2oGDekbagYN6RtqBg3pvmYGDem+ZgYNqa+pW/31tfXYT9CQ+poZNKT7mgk0sTv616IhdcMzaEjd8AwaUjc8g8aE5gwNqRueQUPqhmfQyA2fopEbPkUjN3yGJvZthS/RfPGdW3v8EW/77UTqjz8wjH2HYS2aTG7YGU0mN+yMxoTmDE0mN+yMJpMbdkaTyQ3/MzSjnqDJ5Iad0WRyw75ogt/EuAzNj7qNo5ygIXXDM2hI3fAMGlI3PIPGhOYMDakbnkFD6oZn0JC64YmurOA3R5aiIXXDE2iC3zJxQvOSS+FwX3Jju9Z9f3zxOI7xQe526/Z46ruC11e3n/85x/aiFwg2NsGxfeMFgmO7wQsEx/Z4FwiO7dwuEBzbj/kLDn5f5QLBsX3WBYLZnFbwKysXCDY2wWxOK/itlQsEszmt4PdWLhBM5rRq8JsrFwgmc1o1+N2VCwSTOa16MzbBZE6rBr/rcoFgMqdVg99guUAwm9MKfi/lAsFsTiv4bZMLBLM5reB3SC4QzOa0gt8MuUAwm9MKft/jAsFsTiv4LY4LBLM5reB3My4QzOa0gt+4uEAwm9MKfo/iAsFsTiv47YgLBLM5reB3Hi4QzOa0gt9kuEAwm9MKfj/hAsFsTutgc1rB715cIJjNaR1sTsvYnFbwKyQXCGZzWsEvhlwg2NgEszmt4Dc7LhDM5rSC39e4QDCb0wp+C+MCwWxOK/jdigsEszmt4DcmLhDM5rSC34O4QDCb0wp+u+ECwWxOK/idhQsEszmt4DcRLhDM5rSC3y+4QDCb0wp+a+ACwWxOK/hdgAsEszmt4B3+Fwhmc1rB+/YvEMzmtIJ3418gmM1pBe+xv0Awm9MK3jl/gWA2pxW8H/4CwWxOi60jvrJ1xFe2jvjK1hFf2TriK1tHfGXriK9sHfGVrSO+snXEV7aO+MrWEV/ZOuIrW0d8ZeuIr2wd8ZWtI76ydcQ3to74xtYR39g64htbR3y7GZtgMqfV2DriG1tHfGPriG9sHfGNrSO+sXXEN7aO+MbWEd/YOuIbW0d8Y+uIb2wd8Y2tI76xdcQ3to74xtYR39g64htbR3xj64hvbB3xja0jvrF1xDe2jvjG1hHf2DriG1tHfGPriG9sHfGNrSO+sXXEN7aO+MbWEd/YOuIbW0d8Y+uIb2wd8Y2tI76xdcQ3to74xtYR39g64htbR3xj64hvbB3xja0jvrF1xDe2jvjG1hHf2DriG1tHfGPriG9sHfGNrSO+sXXEN7aO+MbWEd/YOuIbW0d8Y+uIb2wd8Y2tI76xdcQ3to74xtYR39g64htbR3xj64hvbB3xja0jvrF1xDe2jvjG1hHf2DriG1tHfGPriG9sHfGNrSO+sXXEN7aO+MbWEd/YOuIbW0d8Y+uIb2wd8Y2tI76xdcQ3to74xtYR39g64htbR3xj64hvbB3xja0jvrF1xHe2jvjO1hHf2TriO1tHfL8Zm2Ayp9XZOuI7W0d8Z+uI72wd8Z2tI76zdcR3to74ztYR39k64jtbR3xn64jvbB3xna0jvrN1xHe2jvjO1hHf2TriO1tHfGfriO9sHfGdrSO+s3XEd7aO+M7WEd/ZOuI7W0d8Z+uI72wd8Z2tI76zdcR3to74ztYR39k64jtbR3xn64jvbB3xna0jvrN1xHe2jvjO1hHf2TriO1tHfGfriO9sHfGdrSO+s3XEd7aO+M7WEd/ZOuI7W0d8Z+uI72wd8Z2tI75nahAfbX98cfv9O7/kJnoLz8hN9Ak9en988WgnchN9Ps/ITfTpPCM30WfzjNxEGXhCbqZG6Rm5md67E3IzvXcn5CbKvjNyjUsul6vK1CI9IxfWVb0kwDqll4TY7udoz/+ObNw8gnjwnucLBMd2QBcIju2BLhAc2wVdINjYBMd2QhcIju2FLhAc2w1dIDi2d7pAMJvTCt7zfIFgNqcVvOf5AsFsTit4z/MFgtmcVvCe5wsEszmt4D3PFwgmc1ojeM/zBYLJnNYI3vN8gWAypzVuxiaYzGmN4D3PFwgmc1ojeM/zBYLZnFbwnucLBLM5reA9zxcIZnNawXueLxDM5rSC9zxfIJjNaQXveb5AMJvTCt7zfIFgNqcVvOf5AsFsTit4z/MFgtmcVvCe5wsEszmt4D3PFwhmc1rBe54vEMzmtIL3PF8gmM1pBe95vkAwm9MK3vN8gWA2pxW85/kCwWxOK3jP8wWC2ZxW8J7nCwSzOa3gPc8XCGZzWsF7ni8QzOa0gvc8XyCYzWkF73m+QDCb0wre83yBYDanFbzn+QLBbE4reM/zBYLZnFbwnucLBLM5rcrmtII3eV8gmM1pVTanVY1NMJvTCt7YfoFgNqcVvLX9AsFsTit4c/sFgtmcVvD29gsEszmt4A3uFwhmc1rBW9wvEMzmtIK3vl8gmM1psXXED7aO+MHWET/YOuIHW0f8YOuIH2wd8YOtI36wdcQPto74wdYRP9g64gdbR/xg64gfbB3xg60jfrB1xA+2jvjB1hE/yDrijxtZR/xdMJfTugvmclp3wVxO6y7Y2ARzOa27YC6ndRfM5bTugrmc1l0wm9Mi64i/C2ZzWmQd8XfBbE6LrCP+LpjNaZF1xN8Fszktso74u2A2p0XWEX8XzOa0yDri74LZnBZZR/xdMJvTIuuIvwtmc1pkHfF3wWxOi6wj/i6YzWmRdcTfBbM5LbKO+LtgNqdF1hF/F8zmtMg64u+C2ZwWWUf8XTCb0yLriL8LZnNaZB3xd8FsTousI/4umM1pkXXE3wWzOS2yjvi7YDanRdYRfxfM5rTIOuLvgtmcFllH/F0wm9Mi64i/C2ZzWmQd8XfBbE6LrCP+LpjNaZF1xN8Fszktso74u2A2p0XWEX8XzOa0yDri74LZnBZZR/xdMJvTIuuIvwtmc1pkHfF3wWxOi6wj/i6YzWmRdcTfBbM5LbKO+LtgNqdF1hF/F8zmtMg64u+C2ZwWWUf8XTCb0yLriL8LZnNaZB3xd8FsTousI/4umM1pkXXE3wWzOS2yjvi7YDKntbF1xG9sHfEbW0f8xtYRf5fDJpjMaW1sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv7F1xG9sHfEbW0f8xtYRv2VqEB9tf3xx+/07P+Vm6g+fkZvoE3r05xePdiI30efzjNxEn84zchN9Ns/ITZSBZ+QmSsAzcjO9dz/LzdQmPSM3UfadkZso+c7I5XJVmVqkZ+TCuqqXBFin9JIQ2/0Ue0TrUUf/FMTL4zHuG6ST/+hiux93ubHdj7fc4A3P7nJjux93ubHdj7vc2O7HXa5xyY3tftzlxnZK7nK5XFXwRmd3uVyuKnibs7tcLlcVvMnZXS6Xqwre4uwul8tVBW9wdpfL5aqCtze7y6VyVXvw5mZ3uVSuag/e2uwul8pV7Tfjkkvlqvbgbc3ucqlc1R68qdldLperCt7S7C6Xy1UFb2h2l8vlqoK3M7vL5XJVwZuZ3eVyuargrczucrlcVfBGZne5XK4qeBuzu1wuVxW8idldLperCt7C7C6Xy1UFb2B2l8vlqoK3L7vL5XJVwZuX3eVyuargrcvucrlcVfDGZXe5XK4qeNuyu1wuVxW8adldLperCt6y7C6Xy1UFb1h2l8vlqoK3K7vL5XJVwZuV3eVyuargrcrucrlcVfBGZXe5XK4qeJuyu1wuVxW8SdldLperKlyuKnhLtrfc4C3Z7nK5XFXlclXBO9Dd5RqXXC5XFbwD3V0ul6sK3oHuLpfLVQXvQHeXy+Wqgnegu8vlclXBO9Dd5XK5quB96e5yuVwVV7f6ztWtvnN1q+9c3eo7V7f6ztWtvnN1q+9c3eo7V7f6ztWtvnN1q+9c3eo7V7f6ztWtvnN1q+9c3eo7V7f6ztWtvnN1q+9c3eo7V7f6ztWtfnB1qx9c3eoHV7f6wdWtftyMSy6Vqzq4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm71g6tb/eDqVj+4utUPrm514+pWN65udePqVjeubnW7GZdcKldlXN3qxtWtblzd6sbVrW5c3erG1a1uXN3qxtWtblzd6sbVrW5c3erG1a1uXN3qxtWtblzd6sbVrW5c3erG1a1uXN3qxtWtblzd6sbVrW5c3erG1a1uXN3qxtWtblzd6sbVrW5c3erG1a1uXN3qxtWtblzd6sbVrW5c3erG1a1uXN3qxtWtblzd6sbVrW5c3erG1a1uXN3qxtWtblzd6sbVrW5c3erG1a1umeqoR9sfX9yOE7mJXkQTcjMVFo/eH1882oncRB9VM3ITfVTNyDUuuYkC4IzcRAFwRm6m9+6E3Ezv3Qm5iQLghNxMhcUzcrlcVabC4hm5sK7qJcHwJcR2P20fDwl9b59i+G3Ux1Nv24+nruWH4Nj+5wLBsR3QBYJje6ALBMd2Qf6Cg1cMXyA4thO6QHBsL3SB4Nhu6ALBxiaYzWkFrxu+QDCb0wpeOXyBYDanFbx2+ALBbE4rePXwBYLZnFbw+uELBLM5reAVxBcIZnNawWuILxBM5rRK8CriCwSTOa0SvI74AsFkTqvcjE0wmdMqwWuJLxBM5rRK8GriCwSzOa3g9cQXCGZzWsErii8QzOa0gtcUXyCYzWkFryq+QDCb0wpeV3yBYDanFbyy+ALBbE4reG3xBYLZnFbw6uILBLM5reD1xRcIZnNawSuMLxDM5rSC1xhfIJjNaQWvMr5AMJvTCl5nfIFgNqcVvNL4AsFsTit4rfEFgtmcVvBq4wsEszmt4PXGFwhmc1rBK44vEMzmtILXHF8gmM1pBa86vkAwm9MKXnd8gWA2pxW88vgCwWxOqxibYDanVdicVvAm7wsEszmtwua0KpvTCt7XfoFgNqcVvLP9AsHGJpjNaQVvbr9AMJvTCt7efoFgNqcVvMH9AsFsTit4i/sFgtmcVvDW9wsEszktto74wtYRX9g64gtbR3xh64gvbB3xha0jvrB1xBe2jvjC1hFf2DriC1tHfGHriC9sHfGFrSO+sHXEF7aO+MLWEV/YOuILW0d8YeuIL2wd8YWtI76wdcRXto74ytYRX9k64itbR3y9GZtgMqdV2TriK1tHfGXriK9sHfGVrSO+snXEV7aO+MrWEV/ZOuIrW0d8ZeuIr2wd8ZWtI76ydcRXto74ytYRX9k64itbR3xl64ivmRrE71/9+OL2+3d+yU30Fp6Qm6lbevT++OLRTuQm+nyekZvo03lGbqLP5hm5iTLwjNxECXhGbqb37oTcTO/dCbmJsu+E3ExN0jNyuVxVphbpGbmwruolwfAlxHY/vbTnf0elfgritj+DuB3l9dVt/BAc2/9cIDi2A7pAcGwPdIHg2C7IX3DwnucLBMd2QhcIju2FLhAc2w1dINjYBLM5reA9zxcIZnNawXueLxDM5rSC9zxfIJjNaQXveb5AMJvTCt7zfIFgNqcVvOf5AsFsTit4z/MFgtmcVvCe5wsEszmt4D3PFwhmc1rBe54vEMzmtIL3PF8gmM1pBe95vkAwm9MK3vN8gWA2pxW85/kCwWxOK3jP8wWC2ZxW8J7nCwSzOa3gPc8XCGZzWsF7ni8QzOa0gvc8XyCYzWkF73m+QDCb0wre83yBYDanFbzn+QLBZE6rBe95vkAwmdNqwXueLxBM5rTazdgEkzmtFrzn+QLBZE6rBe95vkAwm9MK3vN8gWA2pxW85/kCwWxOK3jP8wWC2ZxW8J7nCwSzOa3gPc8XCGZzWsF7ni8QzOa0gvc8XyCYzWkF73m+QDCb09rZnFbwJu8LBLM5rZ3NaR1sTit4X/sFgtmcVvDO9gsEG5tgNqcVvLn9AsFsTit4e/sFgtmcVvAG9wsEszmt4C3uFwhmc1rBW98vEMzmtNg64htbR3xj64hvbB3xja0jvrF1xDe2jvjG1hHf2DriG1tHfGPriG9sHfGNrSO+sXXEN7aO+MbWEd/YOuIbW0d8Y+uIb2wd8Y2tI76xdcQ3to74xtYR39g64htbR3xj64hvbB3xja0jvrF1xDe2jvjG1hHf2DriG1tHfGPriG9sHfGNrSO+sXXEN7aO+MbWEd/YOuIbW0d8Y+uIb2wd8Y2tI76xdcQ3to74xtYR39g64htbR3xj64hvbB3xja0jvrF1xHe2jvjO1hHf2TriO1tHfL8Zm2Ayp9XZOuI7W0d8Z+uI72wd8Z2tI76zdcR3to74ztYR39k64jtbR3xn64jvbB3xna0jvrN1xHe2jvjO1hHf2TriO1tHfGfriO9sHfGdrSO+s3XEd7aO+M7WEd/ZOuI7W0d8Z+uI72wd8Z2tI76zdcR3to74ztYR39k64jtbR3xn64jvbB3xna0jvrN1xHe2jvjO1hHf2TriO1tHfGfriO9sHfGdrSO+s3XEd7aO+M7WEd/ZOuI7W0d8Z+uI72wd8Z2tI75nahAfbX98cfv9O7/kJnoLz8hN9Ak9en9+cTuRm+jzeUZuok/nGbmJPptn5CbKwBNyMzVKz8jN9N6dkJvpvTshN1H2nZFrXHK5XFWmFukZubCu6iUB1im9JMR2P+P5nbfbtm8f/qur2yOI12P/8391wWue/fXG9j/+emMbIH+9sR2Qv14j0xvbA/nrjW2C/PXGdkH+emNbJn+9ZP4qeLmzv14yfxW82tlfL5m/Cl7s7K+XzF8Fr3X210vmr4KXOvvr5fJXI3ils79eLn81ghc6++vl8lfjZmR6ufzVCF7m7K+Xy1+N4FXO/nrJ/FXwImd/vWT+KniNs79eMn8VvMTZXy+Zvwpe4eyvl8xfBS9w9tdL5q+C1zf76yXzV8HLm/31kvmr4NXN/nrJ/FXw4mZ/vWT+Knhts79eMn8VvLTZXy+Zvwpe2eyvl8xfBS9s9tdL5q+C1zX76yXzV8HLmv31kvmr4FXN/nrJ/FXwomZ/vWT+KnhNs79eMn8VvKTZXy+Zvwpe0eyvl8xfBS9o9tdL5q+C1zP76yXzV8HLmf31kvmr4NXM/nrJ/FXwYmZ/vWT+qpL5q+C92/56yfxVJfNX1cj0kvmr4NXq/nrJ/FXwcnV/vWT+Kni9ur9eMn8VvGDdXy+Zvwpese6vl8xfBS9Z99dL5q+CV7L76yXzV2T97YOsv32Q9bcPsv72QdbfPsj62wdZf/sg628fZP3tg6y/fZD1tw+y/vZB1t8+yPrbB1l/+yDrbx9k/e2Dq7/dbqn6vT9eTr/rzfT+ndGb6fP545XPu95Mn88zejN9Ps/ozfT5PKM3U/6d0Zsp/07oTdX/PKM31ft3Qm+m/DujN1P+ndFrZHrJ/BVw//NLA65nemkI7YPuD15fD7Lv+4f/8M6/90twaCN0geDYTc1XCA5tha4QHNoLXSE4tBm6QrCxCQ5th64QHNoPXSE4tHm6QjCb04pd2XyB4NidzVcIZnNasVubrxDM5rRi9zZfIZjNacVubr5CMJvTit3dfIVgNqcVu735CsFsTit2f/MVgtmcVuwG5ysEszmt2B3OVwhmc1qxW5yvEMzmtGL3OF8hmM1pxW5yvkIwm9OK3eV8hWA2pxW7zfkKwWxOK3af8xWC2ZxW7EbnKwSzOa3Ync5XCGZzWrFbna8QzOa0Yvc6XyGYzWnFbna+QjCb04rd7XyFYDanFbvd+QrBbE4rdr/zFYLZnFbshucrBLM5rdgdz1cIZnNasVuerxDM5rRi9zxfIZjNacVuer5CMJvTit31fIVgNqcVu+35CsFsTit23/MVgtmcVuzG5ysEszmt2J3PVwhmc1qxW5+vEMzmtAab0xpkTmuL3ex9hWAyp3X/LmyCU72Wij3a24udCU71WpoQHLsO+WvB5dEvWmo7EZzqQ2tGcKoPrRnBqeLhjGBjE5wqHs4ITvUe/nwlZ4vdoHyF4FTxcEZwqng4IThX3fKM4FROa0ZwKqc1IziV05oRbGyCUzmtGcFsTitX3fKMYGCn9RIB7J6eIqLXIu+1vUT024f/9CbWqdFrkf0FB3dE3wne9+eDWDkRHNwR+Qs2NsHBHZG/4OCOyF9wcEfkLzi4I/pScCmPB2nbieDg7sldcPRaZH/BqZzWjOBcTmtCcC6nNSHY2ATncloTgoM7rWM7fjzI8UHwPQs9djF30/zjSe7rgJfk4F7rCsnB3dYVkoP7rQskR69HvkJycM91heTgrusKycF91xWSjU9ycO91hWQ+9xW9LPkKyXzuK3ph8gWSo1cmXyGZz31Fr02+QjKf+4penXyFZD73Fb0++QrJfO4reoXyFZL53Ff0GuUrJPO5r+hVyldI5nNf0euUr5DM576iVypfIZnPfUWvVb5CMp/7il6tfIVkPvcVvV75Csl87it6xfIVkvncV/Sa5Ssk87mv6FXLV0jmc1/R65avkMznvqIX8n4nebRHTdxov3/vl+BUb+UZwak+rUd/VEyNcVIxFb2u1VvwHr2u1V9wqs/pGcGpMvKM4FQJeUZwrvfwhOBc7+EJwamy8YzgVMl4RjCZ09pvbE4resf0O8EvEcDu6SUiuCOyaq8Hae3Df3qfC4j26F3Q/oKNTXBwR/Sd4M9tLXv0Lmh/wcEdkb/g4I7IX3BwR+QuOHoXtL/g4O7JX3Aqp/W5vGSP3gXtL9jYBOdyWhOCczmtCcG5nNaE4FxOa0IwktPq9uctRvTe6DkRSI7oVERwl1P211KsHPXfbxui9zv7C7ZMgieMe/R+Z3/BwV2Ov+DgLsdfcHCX4y84uMtxFxy93/lLwZ99bPR+Z3/BqZzWjOBUTmtGsLEJzuW0JgTncloTgpGclp38zkT0vuY5EUiO6ExE9E7l0svzQer49ItTvdjt8c1LqT+epP6QHN3nXCA5utO5QHJ0r3OBZOOTHN3vXCA5uuO5QHJ0z3OB5OgO6QLJ0f2Uv+ToncpXSOZzX9E7la+QzOe+oncqXyGZz31F71S+QjKf+4reqXyFZD73Fb1T+QrJfO4reqfyFZL53Ff0TuUrJPO5r+idyldI5nNf0TuVr5DM576idypfIZnPfUXvVL5CMp/7it6pfIVkPvcVvVP5Csl87it6p/IVkvncV/RO5Ssk87mvwee+Bp/7it6cfYVkPvc1+NzX4HNf0TvSr5BM576O6D3pV0imc19H9K70KyTTua/jZnyS6dzXEb0z/QrJdO7riN6bfoVkPvcVvTv9Csl87it6L/sVkvncV/Ru9isk87mv6P3sV0jmc1/RO9qvkMznvqL3tF8hmc99Re9qv0Iyn/uK3td+hWQ+9xW9s/0KyXzuK3pv+xWS+dxX9J73KyTzua/wHfIXSOZzX+F75C+QzOe+wnfJXyCZz32F75O/QDKf+wrfKX+BZD73Fb5X/gLJfO4rfLf8BZL53Ff4fvkLJPO5r/B99BdI5nNffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/X/cHXdX/wdd0ffF33B1/XvfF13Rtf173xdd0bX9e93YxPMp37Mr6ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67o3vq574+u6N76ue+Pruje+rnvj67ovfF33ha/rvvB13Re+rvtyMz7JdO6r8HXdF76u+8LXdV/4uu4LX9d94eu6L3xd94Wv677wdd0Xvq77wtd1X/i67gtf133h67ovfF33ha/rvvB13Re+rvvC13Vf+LruC1/XfeHrui+5WtBH23999Wi/f++X4FRv5RnBqT6tR+8PwaOdCE71WT0jONUn9YzgVJ/TM4JTZeQZwakS8oTgXH3YM4JzvYcnBKfKxjOCUyXjGcHGJpjNaSF3YL9EALunl4jgjqgdt+eDdPv0n95/imt/ffl/iuP+HNWj91RfIDl6T/UVkoP7oiskB3dGV0gO7o2ukGx8koP7oyskB3dIV0gO7qeu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rL+9kPW3F7L+9kLW317I+tsLWX97IetvL2T97YWsv72Q9bcXsv72QtbfXsj62wtZf3sh628vZP3thay/vZD1txey/vZC1t9eyPrbC1l/eyHrby9k/e2FrL+9kPW3F7L+9kLW317I+tsLWX97IetvL2T97YWsv72Q9bdXsv72StbfXsn62ytZf3u9GZleLn9VyfrbK1l/eyXrb69k/e2VrL+9kvW3V7L+9krW317J+tsrWX97Jetvr2T97ZWsv72S9bdXsv72StbfXsn62ytZf3sl62+vZP3tlay/vZL1t1ey/vZK1t9eyfrbK1l/eyXrb69k/e2VrL+9kvW3V7L+9krW317J+tsrWX97Jetvr2T97ZWsv72S9bdXsv72StbfXlP1e98f+/b88n18+ObfPMi+H/0psdvrOfr4t9/5Vh7PvN9G+QHP/vSd+3h+5/3Ddy62//raYsfJ9DO5EU3/y+mn6n7X9L+dfianqul/O/1Mvl3T/3b6mVKMpv/t9E3TJ55+poSr6X87/Uw/T9H0v51+pp8uafrfTl+7Pubpa9eXdvr98Y3Lz+/7c/qp7hBp+t9OX7s+5ulr18c8fe360k6/vaZfT6Zvmj7x9LXrY56+dn3M09euj3n62vUxT1+7vrTTL49HLvXkd3pT3cTU9L+dvnZ9zNPXro95+tr1MU/fNH3i6WvXxzx97fqYp69dH/P0tetjnr52fcTTT3WfXdP/dvra9TFPX7s+5ulr18c8fdP0iaevXR/z9LXrY56+dn3M09euj3n62vURT39o18c8fe36mKevXR/z9LXrY56+afrE09euj3n62vUxT1+7Pubpa9fHPH3t+nin327a9TFPX7s+5ulr18c8fe36mKdvmj7x9LXrY56+dn3M09euj3j6m/L+2ulv9xk8p79Vz+l/vM3RNuV95ukr7zNPX3mfefqm6RNPX3mfefrK+8zTV95nnr5+t4d5+vrdHuLp79r1MU9fu7600/94jbHt2vUxT1+7Pubpm6ZPPH3t+tJO/+NFtrZr18c8fe36mKevXR/z9LXrI57+oV0f8/S160s7/c+/03to18c8fe36mKdvmj7x9LXrY56+dn3M09euj3n62vUxT1+7PuLpm3Z9zNPXro95+tr1MU9fuz7m6ZumTzx97fqYp69dH/P0tetjnr52fczT166PePpFuz7m6WvXxzx9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"},{"name":"claim","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7X3tjiy5ceW7zG9BSJLBL7/KYrGQbXkhwJAMS15gYejdncF7M7tHl9V1pyuDeaIjfmlGk9nnMFhknGIx4vz3L//6x3/+r//7f/7053/7y19/+af/9d+//Ptf/uUPf/vTX/68/9t//xLy+P/++h9/+DP/61//9of//Nsv/7T97pc//vlf9//9++9++bc//fsff/mn2PLff/fDc7Hm9P3RWGs+nw6hTJ6mGOr3pyk2evJ0zzF8f7rn9va3Y+p//9+/+yUUrcTrQuJpo4N4Kq8Sb68Qp5TKSaXG8+kext/ucn87brO/nVI+5jSlHp8g7E+cHwB69+w0jO2IYthCens4Tp4NqR/Mwz6K9w8z86CWeVTLPKllTmqZZ7XMi1rmVS3zppZ518o8qc2hSW0OTWpzaFKbQ5PaHJrU5tCkNocmtTk0qc2hSW0OJbU5lNTmUFKbQ0ltDiW1OZTU5lBSm0NJbQ4ltTmU1ObQrDaHZrU5NKvNoVltDs1qc2hWm0Oz2hya1ebQrDaHZrU5tKjNoUVtDi1qc2hRm0OL2hxa1ObQojaHFrU5tKjNoeWCHErUD+Y1LGNeN7XMg1rmUS3zpJY5qWWe1TIvaplXtcybWuZqc2hTm0Ob2hza1ObQpjaHNrU5tKnNoU1tDm1qc2hTm0Ob2hza1ebQrjaHdrU5tKvNoV1tDu1qc2hXm0O72hza1ebQrjaHhk1tEt3f10tdbRoNm9o8Gja1iTRsajNp2NSm0rCpzaVhU5tMw6Y3mwa92TTozaZBbzYNerNp0JtNg95sGvRm06A3m4YLsmnbjuZFLW1PqO+E68k9tbenv3cjCh2LzxVthi7lE8D4RDA+87RD8YBIVJ524yr56K8V27v1FahOnq75WLit1fPZ2mfr9kkrrge9fpSQz6vJ70c88fwsUHpPfxAqaIQqGqGGRqiDEXrQIedGQgGNUEQjlNAIERqh5Tt1L/nk0/oPfAoYn/X7dN5OQvldR89pIt414PlwjOWNSJn96ZipHUTy+28Wsy8LiVo5x9jflQyE2cOhH4Jg/8f6/uERxeZRvCCK3aP4ehRp8yheEMXgUfyZKMZO55ffsP0QxehRvCCKyaP4M1FMMZ9RpO3jh/cTl+2Mx7uG2/OH03Y+nMKPewX5/Nw8PyWc8/NO404frvkYX33P+NsRMWWfyq8ylcWn8qtMpX9JvXsq+3F2HinWV6bSvyl/man0r+s3TyW1cyrz+xF+k6XZDwKw58ePGLDnxw8vsOfHj0Vunp8Sj5/eYinh44dDO23fQqv0w2SST+bXmUw/RdE0mb2ff3kL7YVvBNmPXGzOu5/P2Jx3P8xRNO9xi2ektxxfmXc/+TE578VPlATm/axZiX17shs/+SG6+InS3fNz1U9exQ+fvsxU+jnV3VN51U9exU+pvsxU+hnVzVP58el+8bMk7PnxMx/s+fGzGez58TOUm+fnwh+8qh+MfKHJ9FMUTZN52a8Z1Y9cbM67n8/YnHfyedcz79f9ilX95MfmvPuJ0vXz3utZubxt9TXd7SdK2PPjJ0o3z8910scPn77KVDY/evoyU+kHT19mKv0s6d6pvO5rQ/PjoS8zleRT+VNTef5yuc8kPfvmf10jpeYnM3fPz1WXHpsftnyZqfRzmS8zlX6Ec/dUXnV/tfkRzleZyu5HODdP5cdX9bqfy2DPjx+2YM+Pn6Bgzw/5/Nw7PxfeXu1+hvKFJtNPUTRN5mU/H3U/crE5734+Y3Pe/TBH0bxf9oNk3Pzkx+a8+4mSwLxf1khpn2ifn5vn56KfvOLmh09fZirJp/LmqbzoJ689ffpUfpWp9DOqm6fyw9P9uPlZEvb8+JkP9vz42Qz0/AQ/Q7l5fq77wSsGPxj5QpPppyiaJvOqXzNi8CMXm/NOPu8m590PcxTN+3W/YgU/+bE5736idP28X9eoJwY/UcKeHz9Runl+LpM+0Q+fvsxU+tHTl5lKP3j6MlPpZ0n3TuV1Xxsi+VR+lalcf+JTtuMWWSglK5nK0A/S+z/+cMs0Fo/iBVGsHsULotg8ihdEsXsUfyaKsZ9ZK4XtH6OYNo/iBVEMHsWfkltiJu0f15ik6PNz8/xcVZiQkk/lV5lK8qn8KlPpX1LvnsqrakySf1P+MlPpX9dvnsqPr9MnPwjAnh8/YoCeH/LDC+z58WORm+fnwgoT8jOULzSZfoqiaTIvu+JB5PNuct79fMbmvPthjqJ5v+7SEPnJj8159xMlgXm/rtkh+YnS3fNz1U9e2Q+fvsxU+jnV3VN51U9e2U+pvsxU+hnVzVP58el+Jp8f6PnxMx/s+fGzGez58TOUm+fnwh+8sh+MfKHJ9FMUTZN52a8ZxY9cbM67n8/YnHc/zFE079f9ilX85MfmvJPP++XzfmEzveInStjz4ydKN8/PddLHD5++zFT60dOXmUo/ePoqU1n9LOneqbzua0P146EvM5V+4vNzUylm0v7x/dXqJzN3z89Vlx4r+VR+lan0c5kvM5V+hHP3VF51f7X6Ec6XmUo/wrl5Kj++qlf9XAZ6fpoftmDPj5+gYM+PH4vcPD8X3l5tfobyhSaTfDIVTeZlPx81P3KxOe9+PmNz3v0wR9G8X/eDZPOTH5vz7idKAvN+XSOl7idKd8/PVT95dT98+jJT6edUd0/lVT95dT+l+jJTST6V907lx6f73c+SsOfHz3yw58fPZrDnx89Qbp6fC3/w6n4w8mUmcz9i8clUNJlX/ZqRNj9ysTnvfj5jc979MEfRvF/2K1bayOfd5Lz7idL1835do560+YkS9vz4idLN83Od9PHDpy8zlX709FWmMvjB05eZSj9Luncqr/vaEPx46MtM5Q0nPueOEmqg91M5CBEaoYxGaP2Xwhr6SYjiD4QqGqGGRmi9Iq397Ytr/IFQ3NAIrVcHtcY3QukHQhGN0Pqdum9HsttlYPmBEKERymiEChqh5Tt1TOmtPIOeCDfqh8jL2zvZlsrk2X6eroctbL96eIy0mRlptzLStH2Zke7jO7+ibGky1GBnqNHOUNMXWqpvI835x5HSlxxpm8xphh5pzoemLHl79vGN2/klJtK7I4hv4iEVMyO9QSaFt5HWZyONB/n8buml6fHtWbEXWvvHs5/UbAyzmxgmbTaGGWwMM9oYZrIxTLIxzGxjmMXGMG2oILKhgsiGCso2VFC2oYKyDRWUbaigTDaGaUMFZRsqKNtQQdmGCso2VFCxoYKKDRVUbKigYkMFFbIxTBsqqNhQQcWGCio2VFCxoYKqDRVUbaigakMFVRsqaL2r8D3DtKGCqg0VVG2ooGpDBVUbKqjZUEHNhgpqNlRQs6GC1rsC3jNMGyqo2VBBzYYKajZUULOhgroNFdRtqKBuQwV1Gypove/MPcO0oYK6DRXUbaigjq2Cajgqxmts74c5uGNLm4+404atV1o8PjPvjVnnH68Pay1pw1YsFw4UW7NcOFBs1XLhQMnKQLGVy4UDxdYuFw4UW71cOFBs/XLhQLHFznUDDVaUUbCijIIVZRSsKKP1TVzvGqgVZRSsKKNgRRkFK8ooWFFG0YoyilaUUbSijKIVZbS+afJdA7WijKIVZRStKKNoRRlFK8ooWVFGyYoySlaUUbKijO5oGX3PQK0oo2RFGYH3i75woFaUEXjP6OsGCt41+sKBWlFG4J2jLxyoFWUE3j36woFaUUbgHaQvHKgVZQTeRfrCgVpRRuCdpC8cqBVlBN5N+sKBWlFG4B2lLxyoFWUE3lX6woFaUUbgnaUvHKgVZQTeXfrCgVpRRuAdpi8cqBVlBN5l+sKBWlFG4J2mLxyoFWUE3m36woFaUUbgHacvHKgVZQTedfrCgVpRRuCdpy8cqBVlBN59+sKBWlFG4B2oLxyoFWUE3oX6woFaUUbgnagvHKgVZQTejfrCgVpRRuAdqS8cqBVlBN6V+sKBWlFG4J2pLxyoFWUE3p36woFaUUbgHaovHKgVZQTepfrCgVpRRuCdqi8cqBFllK30wM5WemBnKz2ws5Ue2HkjKwM1ooyylR7Y2UoP7GylB3a20gM7W+mBna30wM5WemBnKz2ws5Ue2NlKD+xspQd2ttIDO1vpgZ2t9MDOVnpgZys9sLOVHtjZSg/sbKUHdrbSAztb6YGdrfTAzlZ6YGcrPbCzlR7Y2UoP7GylB3a20gM7W+mBna30wM5WemBnKz2ws5Ue2NlKD+xspQd2ttIDO1vpgZ2t9MDOVnpgZys9sLOVHtjZSg/sbKUHdrbSAztb6YGdrfTAzlZ6YGcrPbCzlR7Y2UoP7GylB3a20gM7W+mBna30wM5WemBnKz2ws5Ue2NlKD+xspQd2ttIDO1vpgZ2t9MDOVnpgZys9sLOVHtjZSg/sbKUHdrbSAztb6YGdrfTAzlZ6YGcrPbCzlR7Y2UoP7GylB3a20gM7W+mBna30wM5WemBnKz2ws5Ue2NlKD+xspQd2ttIDO1vpgZ2t9MDOVnpgZys9sLOVHtjZSg/sbKUHdrbSAztb6YGdrfTALlZ6YBcrPbDLDT2w49vT/zDQQegKBdNSOgnl/IRQLcfDtZd3f3mbPNvTEcxe+pNna27n36W3Z+O3YZKNYT5QL/V4J+UtPhlm2PLxaQ9b+TX1gVEWYNQFGA/SZa2PMMZb89yTy7GbpJKefZBC6JTOTSL0t12iz7aUfdP4/nCJb5+ORpNHqeTvj+bQ3j6gocw+dPnc1Xpubx/nmL7tDA/aDIuO9NyqWtw+HmkosRx/uOT+bKzt7aPwbsfcV83kL6d+/mVK6R+X2IOmxObDEj0ss7AkD8ssLORhmYUle1hmYSkelllYqodlFpbmYZmFpXtYJmGJrnKnYXGVOw2Lq9xpWFzlTsNCHpZZWFzlTsPiKncaFle507C4yp2GxVXuLCzJVe40LK5yp2FxlTsNi6vcaVjIwzILi6vcaVhc5U7D4ip3GhZXudOwuMqdhYVc5U7D4ip3GhZXudOwuMqdhoU8LLOwuMqdhsVV7jQsrnKnYXGVOw2Lq9xZWLKr3GlYXOVOw+IqdxoWV7nTsJCHZRYWV7nTsLjKnYbFVe40LK5yp2EBV7ntJF/Dti4sBVzl3hUWcJV7V1jAVe5dYQFXuXeFhTwss7CAq9y7wgKucu8KC7jKvSss4Cr3rrC4yp2FpbrKnYbFVe40LK5yp2FxlTsNC3lYZmFxlTsNi6vcaVhc5U7D4ip3GhZXubOwNFe507C4yp2GxVXuNCyucqdhIQ/LLCyucqdhcZU7DYur3GlYXOVOw+IqdxaW7ip3GhZXudOwuMqdhsVV7jQs5GGZhcVV7jQsrnKnYXGVOw2Lq9xpWFzlTsJSN1e507C4yp2GxVXuNCyucqdhIQ/LLCyucqdhcZU7DYur3GlYsFVuTe0MS6WFYcFWuXeFBdz77LawYKvc28KCrXJvCwu2yr0tLORhmYUFW+XeFhZslXtbWLBV7m1hcZU7DYur3FlYwL3PbguLq9xpWFzlTsPiKncaFvKwzMLiKncaFle507C4yp2GxVXuNCyucmdhAfc+uy0srnKnYXGVOw2Lq9xpWMjDMguLq9xpWFzlTsPiKncaFle507C4yp2FBdz77LawuMqdhsVV7jQsrnKnYSEPyywsrnKnYXGVOw2Lq9xpWFzlTsPiKncWFnDvs9vC4ip3GhZXudOwuMqdhoU8LLOwuMqdhsVV7jQs2Cq3bQeP0GJaGBZslXtbWLBV7l1hAfc+uy0s2Cr3trBgq9zbwoKtcm8LC3lYZmHBVrm3hQVb5d4WFle507C4yp2GxVXuLCzg3me3hcVV7jQsrnKnYXGVOw0LeVhmYXGVOw2Lq9xpWFzlTsPiKncaFle5s7CAe5/dFhZXudOwuMqdhsVV7jQs5GGZhcVV7jQsrnKnYXGVOw2Lq9xpWFzlzsIC7n12W1hc5U7D4ip3GhZXudOwkIdlFhZXudOwuMqdhsVV7jQsrnKnYXGVOwlLA/c+uy0srnKnYXGVOw2Lq9xpWMjDMguLq9xpWMBVLvUzLDUuDAu4yr0rLOAq966wgKvcm8IC7n12W1jAVe5dYQFXuXeFBVzl3hUW8rDMwgKucu8Ki6vcaVhc5U7D4ip3GhZXubOwgHuf3RYWV7nTsLjKnYbFVe40LORhmYXFVe40LK5yp2FxlTsNi6vcaVhc5c7CAu59dltYXOVOw+IqdxoWV7nTsJCHZRYWV7nTsLjKnYbFVe40LK5yp2FxlTsLC7j32W1hcZU7DYur3GlYXOVOw0IelllYXOVOw+IqdxoWV7nTsLjKnYbFVe4sLODeZ7eFxVXuNCyucqdhcZU7DQt5WGZhcZU7DYur3GlYXOVOw+IqdxoWV7mzsKB7n90VFle507C4yp2GxVXuNCzkYZmFxVXuNCyucqdhcZU7DYur3GlYXOXOwgLufda3ePzhHvvCsGCr3NvCgq1ybwsLtsq9LSzkYZmFBVvl3hYWbJV7W1iwVe5tYcFWubeFBVvl3hUWcO+z28LiKncaFle507C4yp2GhTwss7C4yp2GxVXuNCyucqdhcZU7DYur3FlYwL3PbguLq9xpWFzlTsPiKncaFvKwzMLiKncaFle507C4yp2GxVXuNCyucidh6eDeZ7eFxVXuNCyucqdhcZU7DQt5WGZhcZU7DYur3GlYXOVOw+IqdxoWV7mzsIB7n90WFle507C4yp2GxVXuNCzkYZmFxVXuNCyucqdhcZU7DYur3GlYoFVujGf1WYy1PAnLHox6xiW1N9apj7HeYGjW8vG338/qPtbBZ71mDHF7e7rEj6Of4xH8nPP5aJr+3XJ+Ilv7x8/YDdZg94wzGRknGRlnNjLOYmSc1cg4m5FxdhvjvMGi6p5xGtFDyYgeSkb00A02T/eM04geSkb0UDKih5IRPZSM6CEyoofIiB4iI3qIjOihGwyB7hmnET1E4HqoxYP8+w516cHfPdvZRXojEb/9QkDgiujCkYJrogtHCq6KrhtpBtdFF44UXBldOFJwbXThSMHV0YUjJTMjBVdIF47UjEbKZjRSNqORshmNVMxopGJGIxUzGqmY0Ug3GJHcNVIzGqmY0UjFjEYqZjRSMaORqhmNVM1opGpGI1UzGukGG4u7RmpGI1UzGqma0UjVjEaqZjRSM6ORmhmN1MxopGZGI91ggnDXSM1opGZGIzUzGqmZ0UjNjEbqZjRSN6ORuhmN1M1opBta6N81UjMaqZvRSN2MRupmNFK3opHCtlkRSftQraikfahWZNI+VCs6aR8q2RmqFaW0D9WKVNqHakUr7UO1Ipb2odpRS8GOWgp21FKwo5aCHbV0Qzfv24ZqRy0FO2op2FFLwY5aCnbUUrSjltB7aV85VDtqCb2j9pVDJTtDtaOW0FtrXzlUO2oJvcH2lUO1o5bQ22xfOVQ7agm92faVQ7WjltBbbl85VDtqCb3x9pVDtaOW0NtvXzlUO2oJvQn3lUO1o5bQW3FfOVQ7agm9IfeVQ7Wjlsy05d6HakctmWnMvQ/Vjloy05p7H6odtWSmOfc+VDtqyUx77n2odtSSmQbd+1DtqCUzLbr3odpRS2aadO9DtaOWzLTp3odqRy2ZadS9D9WOWjLTqnsfqh21ZKZZ9z5UO2rJTLvufah21JKZht37UO2oJTMtu/eh2lFLZpp270O1o5bMtO3eh2pHLZlp3L0P1Y5aMtO6ex+qHbVkpnn3PlQ7aslM++59qHbUkpkG3vtQ7aglMy2896HeoZZqPp/u5f1Qv1G6QdWk2I6nU6sfRz/mRN8fjoXC+XAIZfJ0z+dk9cxcD97pmIFka7hka7jZ1nCLreFWW8O9Qu3E2Okcbkrh4+EWoiNZFCr08cOxxXwEZ//n9qtQfhtBVz6C8KBzdkvH1KUey9OPXNrOD1FI9I7U9h0lXIKSzziFnOt7lMnQKVE8hk659B+HHm8glXs4SZXUP56+ROkYQqL6toJCqpOna6+HjNve/nBo7ftwk63hkq3hZlvDLbaGW20Nt9kabjc13LDZGm6AH24+T1BSCf3ZcOs53JDeeJcpkf2c+uCxH868PR22TwQSX68pCSS+ElQSSPJAXhNIfPWqJJD4ulhJIPEVt5JA4mt5JYHE/5agI5AR//uHkkBa/mYTyskjtPirQH4LjuVvK0+DY/kbyNPgkAfncXAsf1N4GhzL6v9pcCwr+qfBsazSnwbHsvJ+FpxkWU3vGvrgEVOaBMeyQn4aHMsK+WlwLCvkp8EhD87j4FhWyE+DY1khPw2OZYX8NDiWFfLT4FhWyM+CQ6YVcjnvH8f93PjH4JhWyM+CY1ohPwuOaYX8LDjkwXkcHNMK+VlwTCvkZ8ExrZCfBce0Qn4WHNMK+Ulw8h0KuVA/g9PK9nFwYqlnTd8+mi2+f/zbGAL+GFp8N4ZJRVyOCsbQzs906bMxJPwx9HYsnli32H4cA8GPoe6BPsewfwX+cQwZfwwxnY/XtKUfx1Dwx9DD22epd/pxDBV+DG1L52epvb+Vdo7hDmXR+pm06P2fP0l1QFLljkza65vM6C1+PNutHyqjx7cPRigzkRFietfa5b1wmHUneNZvIJTgwXkcnIgenH42n+i5PwlO23J506f0LjjxU8FJ6MGp/ZB2Ydvyr6LDI0j59/PLYTUcG0qtbwkwxHy+Vj/3Wvvca/1Tr80voTx/LXzutfi516YfohaOD0WL89foc6/lz71WPvda/dxr7XOv9U+9Nv8hprVDfLQep6+Fz70WP/da+txr9LnX8udeK597bfop6du5+YZt+lr73Gv9U6/NDyOevxY+91r83Gvpc69NPyU9nok1TRfO/Lvc89fK516rn3utfe61/qnX5kL7+WvhyWs0nbe5OHv+Wvrca/NPyfmFv5fp6p47Oz1/rXzutfq519rnXuufem3uKvP8tfmnpL1JvNx+9d7vfsvDB0hcAZJWgNAKkLwCpKwAqStA2gqQvgBk7nVwNciKFd9WrPi2YsW3FSu+rVjxbcWKbytWfFux4tuKFd9XrPi+YsX3FSu+r1jxfcWK7ytWfF+x4vuKFd9XrPi+YsU/aIN7OUpYghKXoKQlKLQEJS9BKUtQ6hKUtgRlydoPS9Z+WLL2w5K1H5as/bBk7Yclaz8sWfthydoPS9Z+WLL245K1H5es/bhk7cclaz8uWftxydqPS9Z+XLL245K1H5es/bRk7aclaz8tWftpydpPS9Z+WrL205K1n5as/bRk7acla5+WrH1asvZpydqnJWuflqx9WrL2acnapyVrn5asfVqy9vOStZ+XrP28ZO3nJWs/L1n7ecnaz0vWfl6y9vOStZ+XrP2yZO2XJWu/LFn7ZcnaL0vWflmy9suStV+WrP2yZO2XJWu/Lln7S+7uhSWX98KS23thyfW9sOT+XlhygS8sucEXllzhC0vu8IUll/jCklt8Yck1vrDkHl9YcpEvLLnJF5Zc5QtL7vKFJZf5wpLbfGHJdb6w5D5fWHKhLyy50ReWXOkLS+70hSWX+sKSW31hybW+sOReX1xyry8uudcXl9zri0vu9cWNlqDkJShlCUpdgtKWoCxZ+0vu9cUl9/riknt9ccm9vrjkXl9ccq8vLrnXF5fc64tL7vXFJff64pJ7fXHJvb645F5fXHKvLy651xeX3OuLS+71xSX3+uKSe31xyb2+uOReX1xyry8uudcXl9zri0vu9cUl9/riknt9ccm9vrjkXl9ccq8vLrnXF5fc64tL7vXFJff64pJ7ffGCu3A5H51Lc31rassNbk+QtgDkgttjuR22NPl9z+33IHEFSFoBQitA8gqQ35pYzhfrJ1+84Ef+55/nC37j/wmQvAKkrABZsZFd8Pt+PvvVlndNR38F0heAXPDr/k+AhBUgcQXIBSv+dJYoW5mD0AqQvAKkrACpK0DaCpC+IE1e8Jv+T4CsEGF9hQjrK0TYBb/n/wTIChF2wa/5PwFSV4C0FSALVnzathUgYQVIXAGSVoDQCpC8AqSsAKkrQNoKkBUrPqxY8WHFig8rVnxYseLDihUfVqz4sGLFhxUrPqxY8WHFio8rVnxcseLjihUfV6z4uGLFxxUrPq5Y8VF6xVP4/RQiZDqM4EIub+ZCceozlQ+I1sLHj4bQDielEN/5qsR40GlYdDoWnbmKuZFPAOMTwfgkMD4ExieD8SlgfMB25wC2PQew/TmC7c8RbH+OYPtzBNufI9j+HMH25yi4Px8QVR7i9V30nTlb2l6OasfikzYwPgGMTwTjk8D4EBifDMangPGpYHzA9ucEtj8T2P5MYPszge3PBLY/E9j+TGD7M4HtzyS4Px8QTR6ii0PkTR4iyENEeYgkD0HyEFkeoshDyK/u8vqHNmzb4XMcthBnIHEFyOtTHiK97bdldj5Q+oKR1G0FyIqJr3QBSOknSCszkLwCpKwAqStA2gqQK9ZJCW8gdQLSthUgYQVIXAGSVoDQCpC8AqSsAKkrQNoKkAtWfAh0PBxoplb6tgIkrACJK0DSChBaAZJXgJQVIHUFyAUrPtR4gry/n/YG0heAPHBsvhwlLfjy8MDl+HKUvASlLEHpK1AuuLv3MyhhCUpcgiK/XtL8/ms936r1yfEpbe37oxTzx4+2c4foG/393Tnrbz+UTfOLsgp4d6W858tXA/GglXjUSjxpJU5aiWetxItW4lrzZtCaOIPWzBm1Zs6oNXNGrZkzas2cUWvmjFozZxTLnAdAlQZ4ORPl45dRyjQD6MIAaZMGCNIAURrg5R3tLOCllmYAJA2QpQGKNMCrKzlvx4lT3toMoEkDdGEA2qQBgjTAqx/THI9Hc5wCFGmAVye5pOPCRMlxApA3aQDpEOWXV/J5dpxznQE0aYAuDFA2aYAgDRClAZI0AEkDZGmAIg1w4UouZQbQpAFeX8nnZldnAPXllZz6xwBBGiBKA7y6kst5ubRsfQZA0gBZGqBIA1RpgJdX8lsT67DNALowQNukAYI0QJQGSNIAJA2QpQGKNEC9EGC2kluTBnh9JR+X3kqcAfSXV/J5rvkAIEgDRGmAl3Pyk2+ZnaQBsjRAkQao0gBNGkD6MOTBnc+rEPKDm2WhpPNabclPfjAJtB37XaAQJhgPLhX+NhBqJ0h99hPOZd188qObSVrIR83kk2bypJl81ky+aCZfNZNvmsl3xeSj5gwbNWfYqDnDRs0ZNmrOsFFzho2aM2zUnGGj5gwbUTLsdz4JJWkefBbnwevab+VHd9S0kE+ayZNm8lkz+aKZfNVMvmkm3xWTp00zec0ZljRnWNKcYUlzhiXNGZY0Z1jSnGFJc4YlzRk2o2TYgw9K0jz4oOTBgw9Kajv4oGSrgw9KAjr4oOSUgw9Kmjj4oOz8Bx+Uzfw7nwK2P5fF6/1Jr+P8qPDjVkaLP9NPOnrlR2UNd8aoRjhGCY5RWc3ow/bS+VFhw62MGhyjjsaobXCMlu9HH7ZRzo+qOW5llOAYERyjDMeowDGqcIwaHKOOxqhvcIxW79kfd9vOj+p2bmWU4BgRHKMMx6jAMapwjBoco47G6FHPfEFKHzbYH5QCHqWIRymjndg86vN/K6WKRwnuqC2sLuH7GUoRj1LCo0R4lLD2pbLp9IbYeatscb3zVtnheuet0xuCiavscM3EVXa4ZuIqO1wzcdJKXGWHayau0huCiWvNmzq9IZi41syp0xuCiWvNnDq9IZi41syp0xuCiWvNnLLeEAxQpQFEvSEYoAsDyHpDMECQBojSAKLeEAxA0gBZGqBIA4h6QzBAkwbowgCy3hAMEKQBRL0hGKBIA4i2Q9wBZL0hGEA6RLLeEAzQpAG6MICsNwQDBGmAKA2QpAFIGiBLAxRpAFFvCAZo0gCi3hD8y5SoNwQDBGmAKA0g6g3BACQNkKUBijRAlQYQ9YZggC4MIOsNwQBBGiBKAyRpAJIGyNIARRpA1BuCAZo0gKg3BN9eEPWGYIAgDRClAUS9IRiApAGyNECRBqjSAE0aQPowRNgbonR5b4gdQ683BJNX27mayavtXM3k1XauZvKkmbzaztVMXm3naiavtnM1k1fbuZrJq/WG2Mnr9YZg8pozrF5vCCavOcPq9YZg8pozrF5vCCavOcPq9YZg8kjeEDsfKG8I5qO2czWTV9u5msmr7VzN5EkzebWdq5m82s7VTF5t52omr7ZzNZNX27l6J6/XG4LJa86wer0hmLzmDKvXG4LJa86wer0hmLzmDKvXG4LJa86wUN4QzAfJG4L5IHlDMB8kbwjmg5KtDj5I3hDMB8kbgvkgeUMwHyRvCOaD5A2x84HyhmA+i9f7kw76zAjLG4IZYTWs43tXWN4QzAjLG4IZYXlDMCMsbwhmhOUNwYywvCGYEZY3xM4IzBuCGWF5QzAjLG8IZoTlDcGMCI4RljcEM8LyhmBGWN4QzAjLG4IZYXlD7IzAvCGYEZY3BDPC8oZgRljeEMyI4BhheUMwIyxvCGaE5Q3BjLC8IZgRljfEqDzC8oYYlLC8IQYlLG+IQQmsB3uH84YYlLC8IQYluKM2NG+IQQnLG2JQwvKGGJQIjxLWvlSLfAXvjqG3gpfJq60vYvJq64uYvNr6IiZPmsmrrS9i8mrri5i82voiJq+2vojJq63g3cnrreBl8pozrN4KXiavOcPqreBl8pozrN4KXiavOcPqreBl8kgVvDsfqApe5qO2vojJq60vYvJq64uYPGkmr7a+iMmrrS9i8mrri5i82voiJq+2vmgnr7eCl8lrzrB6K3iZvOYMq7eCl8lrzrB6K3iZvOYMq7eCl8lrzrBQFbzMB6mCl/kgVfAyH6QKXuaDkq0OPkgVvMwHqYKX+SBV8DIfpApe5oNUwbvzgargZT6L1/uTOkdmhFXBy4ywrhXyvSusCl5mhFXBy4ywKniZEVYFLzPCquBlRlgVvMwIq4J3ZwRWwcuMsCp4mRFWBS8zwqrgZUYExwirgpcZYVXwMiOsCl5mhFXBy4ywKnh3RmAVvMwIq4KXGWFV8DIjrApeZkRwjLAqeJkRVgUvM8Kq4GVGWBW8zAirgndUHmFV8A5KWBW8gxJWBe+gBFcph1bBOyhhVfAOSnBHbWgVvIMSVgXvoIRVwTsoER4lrH2p0e9f9UGm7WBD8QmZdm7bfaO3R+Nv/517592U8u5KeYdNK/GglXjUSjxpJU5aiWetxItW4lrzZtCaOIPWzBm1Zs6oNXNGrZkzas2cUWvmjFozZxTLnAdAlQZ4ORPl474NZZoBdGGAtEkDBGmAKA3w8o7WjkVDLc0ASBogSwMUaYBXV3Le6vdH89ZmAE0aoAsD0CYNEKQBXv2Y5ng8muMUoEgDvDrJJR231EqOE4C8SQNIhyi/vJLp/BTlOgNo0gBdGKBs0gBBGiBKAyRpAJIGyNIARRrgwpVcygygSQO8vpLPza7OAOrLK/ncrh8ABGmAKA3w6kouZ8lC2foMgKQBsjRAkQao0gAvr+R+dFguYZsBdGGAtkkDBGmAKA2QpAFIGiBLAxRpgHohwGwltyYN8PpKPi6ilDgD6C+v5PNc8wFAkAaI0gAv5+Qn3zI7SQNkaYAiDVClAZo0gPRhyIO7zVchdJL3huik2Buik2JviE6KvSE6KfaG6KTYG6KTYm+IToq9ITop9obopNgbopNib4hOir0hOin2huik2Buik2JviE6KvSE6KfaG6KTYG6KTYm+IToq9ITpheUN0wvKG6KTYG6KTYm+IToq9ITop9obopNgbopNib4hOir0hOin2huik2Buik2JviE6KvSGYvOYMq9cbgslrzrB6vSE6KfaGYPKaM6xeb4hOir0hOmF5QzAfJG8I5oPkDcF8kLwhmA9Ktjr4IHlDdMLyhuiE5Q3RCcsbohOWN0QnLG+ITmjeEJ3QvCE6oXlDdELzhuiE5g3RCc0bohOaN0QnNG+ITmjeEJ3QvCE6oXlDdELzhuiE5g3RCc0bohOaN0QnNG+ITmjeEJ3QvCE6oXlDdELzhuiE5g3RCc0bohOaN0QnNG+ITmjeEJ3QvCE6oXlDdELzhuiE5g3RCc0bohOcN8SghOUNMShheUMMSlg92AclLG+IQQnLG2JQgjtqQ/OGGJSwvCEGJSxviEGJ8ChB7UtxCyq9IZi3xhbXzFtjh2vmrdIbYhDX2OF6ENfY4XoQ19jhehAnrcQ1drgexDV6QwziWvOmSm+IQVxr5lTpDTGIa82cKr0hBnGtmVOlN8QgrjVzinpDDIAqDSDpDTEAujCAqDfEAAjSAFEaQNIbYgCQNECWBijSAJLeEAOgSQN0YQBRb4gBEKQBJL0hBkCRBpBsh8gAot4QA0A6RKLeEAOgSQN0YQBRb4gBEKQBojRAkgYgaYAsDVCkASS9IQZAkwaQ9IYYv0xJekMMgCANEKUBJL0hBgBJA2RpgCINUKUBJL0hBkAXBhD1hhgAQRogSgMkaQCSBsjSAEUaQNIbYgA0aQBJb4hxe0HSG2IABGmAKA0g6Q0xAEgaIEsDFGmAKg3QpAGkD0NkvSFi2MS9IRhDrTfEIK+1c/Ugr7Vz9SCvtXP1IE+ayWvtXD3Ia+1cPchr7Vw9yGvtXD3Ia/WGYPJqvSEGec0ZVq03xCCvOcOq9YYY5DVnWLXeEIO85gyr1htikAfyhmA+SN4Qg4/WztWDvNbO1YO81s7VgzxpJq+1c/Ugr7Vz9SCvtXP1IK+1c/Ugr7VzNZNX6w0xyGvOsGq9IQZ5zRlWrTfEIK85w6r1hhjkNWdYtd4Qg7zmDIvkDTH4AHlDDD5A3hCDD5A3xOCDkq0OPkDeEIMPkDfE4APkDTH4AHlDDD5A3hDMB8kbYvBZvN4/7qA/GEF5QwxGUA3rxr0rKG+IwQjKG2IwgvKGGIygvCEGIyhviMEIyhtiMILyhmBGWN4QgxGUN8RgBOUNMRhBeUMMRgTHCMobYjCC8oYYjKC8IQYjKG+IwQjKG4IZYXlDDEZQ3hCDEZQ3xGAE5Q0xGBEcIyhviMEIyhtiMILyhhiMoLwhBiMob4hvlUdQ3hDfKEF5Q3yjBOUN8Y0SVg/2QQnKG+IbJShviG+U4I7awLwhvlGC8ob4RgnKG+IbJcKjBLYv1QUVvFVzBW/VXMFbNVfwVs0VvFVzBW/VXMFbNVfwVs0VvFVzBW/VXMFbNVfwVs0VvFVzBW/VXMFbNVfwVs0VvFVzBW/VXMFbNVfwVrAK3gpWwVs1V/BWzRW8VXMFb9VcwVs1V/BWzRW8VXMFb9VcwVs1V/BWzRW8VXMFb9VcwVs1V/BWzRW8VXMFb9VcwVs1V/BWzRW8VXMFbwWr4K1gFbwVrIK3glXwVrAK3gpWwVvBKngrWAVvBavgrWAVvBWsgrfCVfBWuAreClfBW+EqeCtcBW+Fq+CtcBW8Fa6Ct8JV8Fa4Ct4KV8Fb4Sp4K1wFb4Wr4K1wFbwVroK3wlXwVrgK3gpXwVvhKngrXAVvhavgrXAVvBWugrfCVfBWuAreClfBW+EqeCtcBW+Fq+CteBW8Fa+Ct+JV8Fa8Ct6KV8Fb8Sp4K14Fb8Wr4K14FbwVr4K34lXwVrgK3tgfVPBmqsdrudSPMa675b3TaVh0OhadB6XQ9/EJYHwiGJ8ExofA+GQwPgWMD9juHMC25wC2P0ew/TmC7c8RbH+OYPtzBNufI9j+HAX35wOiykO8voted2WU+XQsPmkD4xPA+EQwPgmMD4HxyWB8ChifCsYHbH9OYPszge3PBLY/E9j+TGD7M4HtzwS2PxPY/kyC+/MB0eQhujhE3uQhgjxElIdI8hAkD5HlIYo8hPzqLq9/aJ9crmeQuALk9Sl//pNc6QtGUrcVICsmvtIFIB9ecGeQvAKkrACpK0DaCpAr1smHt2T5B+ltBUhYARJXgKQVILQCJK8AKStA6gqQtgLkghX/8a1PvvOxrQAJK0DiCpC0AoRWgOQVIGUFSF0BcsGK//gmL4P0BSCP7nlfjZIWfHkIGy1ByUtQyhKUvgLlgrt7P4MSlqDEJSji6yWF+f3Xer5V65PjU9qO27gUn1zGbecO0Tf6+7tz1t98KLvzbkp5d6W858tXA/GglXjUSjxpJU5aiWetxItW4lrzZtCaOIPWzBm1Zs6oNXNGrZkzas2cUWvmjFozZxTLnAdAlQZ4ORPl45dRyjQD6MIAaZMGCNIAURrg5R2tHYuGWpoBkDRAlgYo0gCvruS8HSdOeWszgCYN0IUBaJMGCNIAr35MczwezXEKUKQBXp3kko4LEyXHCUDepAGkQ5RfXsnn2XHOdQbQpAG6MEDZpAGCNECUBkjSACQNkKUBijTAhSu5lBlAkwZ4fSWfm12dAdSXV/K5XT8ACNIAURrg1ZVczsulZeszAJIGyNIARRqgSgO8vJJ7PgDCNgPowgBtkwYI0gBRGiBJA5A0QJYGKNIA9UKA2UpuTRrg9ZV8XHorcQbQX17J57nmA4AgDRClAV7OyU++ZXaSBsjSAEUaoEoDNGkA6cOQB3c+r0KgBzfLfmOrx+3Y7wKFMMEIKCb0v/knHHp0M0kL+aiZfNJMnjSTz5rJF83kq2byTTP5rph81Jxho+YMGzVn2Kg5w0bNGTZqzrBRc4aNmjNs1JxhI0qG/c4noSTNgw+KCf1nJjehONZ/ijyKvf2nyJNm8lkz+aKZfNVMvmkm3xWTp00zec0ZljRnWNKcYUlzhiXNGZY0Z1jSnGFJc4YlzRk2o2TYgw9K0jz4oOTBgw9Kajv4oGSrgw9KAjr4oOSUgw9Kmjj4oOz8Bx+Uzfw7nwK2P5fF6/1Jr2N6VPhxKyMsw2Z6VNZwZ4xqhGOU4Bittkf/uL00PSpsuJVRg2PU0Ri1DY7R8v3owzbK9Kia41ZGCY4RwTHKcIwKHKMKx6jBMepojPoGx2j1nv1xt216VLdzK6MEx4jgGGU4RgWOUYVj1OAYdTRGj3rmC1L6sMH+oBTwKEU8ShntxOZRn/9bKVU8SnBHbWF1Cd/PUIp4lBIeJcKjBLYvNZ3eEDtvlS2ud94qO1zvvHV6QzBxlR2umbjKDtdMXGWHayZOWomr7HDNxFV6QzBxrXlTpzcEE9eaOXV6QzBxrZlTpzcEE9eaOXV6QzBxrZlT1huCAao0gKg3BAN0YQBZbwgGCNIAURpA1BuCAUgaIEsDFGkAUW8IBmjSAF0YQNYbggGCNICoNwQDFGkA0XaIO4CsNwQDSIdI1huCAZo0QBcGkPWGYIAgDRClAZI0AEkDZGmAIg0g6g3BAE0aQNQbgn+ZEvWGYIAgDRClAUS9IRiApAGyNECRBqjSAKLeEAzQhQFkvSEYIEgDRGmAJA1A0gBZGqBIA4h6QzBAkwYQ9Ybg2wui3hAMEKQBojSAqDcEA5A0QJYGKNIAVRqgSQNIH4YIe0PkKu8NsWPo9YZg8mo7VzN5tZ2rmbzaztVMnjSTV9u5msmr7VzN5NV2rmbyajtXM3m13hA7eb3eEExec4bV6w3B5DVnWL3eEExec4bV6w3B5DVnWL3eEEweyRti5wPlDcF81HauZvJqO1czebWdq5k8aSavtnM1k1fbuZrJq+1czeTVdq5m8mo7V+/k9XpDMHnNGVavNwST15xh9XpDMHnNGVavNwST15xh9XpDMHnNGRbKG4L5IHlDMB8kbwjmg+QNwXxQstXBB8kbgvkgeUMwHyRvCOaD5A3BfJC8IXY+UN4QzGfxen/SQZ8ZYXlDMCOshnV87wrLG4IZYXlDMCMsbwhmhOUNwYywvCGYEZY3BDPC8obYGYF5QzAjLG8IZoTlDcGMsLwhmBHBMcLyhmBGWN4QzAjLG4IZYXlDMCMsb4idEZg3BDPC8oZgRljeEMwIyxuCGREcIyxvCGaE5Q3BjLC8IZgRljcEM8LyhhiVR1jeEIMSljfEoITlDTEoYfVgH5SwvCEGJSxviEEJ7qgNzRtiUMLyhhiUsLwhBiXCo4S1LxWSr+DdMfRW8DJ5tfVFTF5tfRGTV1tfxORJM3m19UVMXm19EZNXW1/E5NXWFzF5tRW8O3m9FbxMXnOG1VvBy+Q1Z1i9FbxMXnOG1VvBy+Q1Z1i9FbxMHqmCd+cDVcHLfNTWFzF5tfVFTF5tfRGTJ83k1dYXMXm19UVMXm19EZNXW1/E5NXWF+3k9VbwMnnNGVZvBS+T15xh9VbwMnnNGVZvBS+T15xh9VbwMnnNGRaqgpf5IFXwMh+kCl7mg1TBy3xQstXBB6mCl/kgVfAyH6QKXuaDVMHLfJAqeHc+UBW8zGfxen9S58iMsCp4mRHWtUK+d4VVwcuMsCp4mRFWBS8zwqrgZUZYFbzMCKuClxlhVfDujMAqeJkRVgUvM8Kq4GVGWBW8zIjgGGFV8DIjrApeZoRVwcuMsCp4mRFWBe/OCKyClxlhVfAyI6wKXmaEVcHLjAiOEVYFLzPCquBlRlgVvMwIq4KXGWFV8I7KI6wK3kEJq4J3UMKq4B2U4Crl0Cp4ByWsCt5BCe6oDa2Cd1DCquAdlLAqeAclwqOEtS/V+PtXfZBpO9hQfEKmndt23+jt0fjbf+feeTelvLtS3mHTSjxoJR61Ek9aiZNW4lkr8aKVuNa8GbQmzqA1c0atmTNqzZxRa+aMWjNn1Jo5o9bMGcUy5wFQpQFezkT5uG9DmWYAXRggbdIAQRogSgO8vKO1Y9FQSzMAkgbI0gBFGuDVlZy3+v3RvLUZQJMG6MIAtEkDBGmAVz+mOR6P5jgFKNIAr05ySccttZLjBCBv0gDSIcovr2Q6P0W5zgCaNEAXBiibNECQBojSAEkagKQBsjRAkQa4cCWXMgNo0gCvr+Rzs6szgPrySj636wcAQRogSgO8upLLWbJQtj4DIGmALA1QpAGqNMDLK7kfHZZL2GYAXRigbdIAQRogSgMkaQCSBsjSAEUaoF4IMFvJrUkDvL6Sj4soJc4A+ssr+TzXfAAQpAGiNMDLOfnJt8xO0gBZGqBIA1RpgCYNIH0Y8uBu81UILcp7Q7So2BuiRcXeEC0q9oZoUbE3RIuKvSFaVOwN0aJib4gWFXtDtKjYG6JFxd4QLSr2hmhRsTdEi4q9IVpU7A3RomJviBYVe0O0qNgbokXF3hAtKvaGaBHLG6JFLG+IFhV7Q7So2BuiRcXeEC0q9oZoUbE3RIuKvSFaVOwN0aJib4gWFXtDtKjYG6JFxd4QTF5zhtXrDcHkNWdYvd4QLSr2hmDymjOsXm+IFhV7Q7SI5Q3BfJC8IZgPkjcE80HyhmA+KNnq4IPkDdEiljdEi1jeEC1ieUO0iOUN0SKWN0SLaN4QLaJ5Q7SI5g3RIpo3RIto3hAtonlDtIjmDdEimjdEi2jeEC2ieUO0iOYN0SKaN0SLaN4QLaJ5Q7SI5g3RIpo3RIto3hAtonlDtIjmDdEimjdEi2jeEC2ieUO0iOYN0SKaN0SLaN4QLaJ5Q7SI5g3RIpo3RIto3hAtonlDtAjnDTEoYXlDDEpY3hCDElYP9kEJyxtiUMLyhhiU4I7a0LwhBiUsb4hBCcsbYlAiPEpg+1LX6Q2x81bZ4nrnrbLD9c5bpzcEE1fZ4ZqJq+xwzcRVdrhm4qSVuMoO10xcpTcEE9eaN3V6QzBxrZlTpzcEE9eaOXV6QzBxrZlTpzcEE9eaOWW9IRigSgOIekMwQBcGkPWGYIAgDRClAUS9IRiApAGyNECRBhD1hmCAJg3QhQFkvSEYIEgDiHpDMECRBhBth7gDyHpDMIB0iGS9IRigSQN0YQBZbwgGCNIAURogSQOQNECWBijSAKLeEAzQpAFEvSH4lylRbwgGCNIAURpA1BuCAUgaIEsDFGmAKg0g6g3BAF0YQNYbggGCNECUBkjSACQNkKUBijSAqDcEAzRpAFFvCL69IOoNwQBBGiBKA4h6QzAASQNkaYAiDVClAZo0gPRhiLA3RG/y3hA7hl5vCCavtnM1k1fbuZrJq+1czeRJM3m1nauZvNrO1UxebedqJq+2czWTV+sNsZPX6w3B5DVnWL3eEExec4bV6w3B5DVnWL3eEExec4bV6w3B5JG8IXY+UN4QzEdt52omr7ZzNZNX27mayZNm8mo7VzN5tZ2rmbzaztVMXm3naiavtnP1Tl6vNwST15xh9XpDMHnNGVavNwST15xh9XpDMHnNGVavNwST15xhobwhmA+SNwTzQfKGYD5I3hDMByVbHXyQvCGYD5I3BPNB8oZgPkjeEMwHyRti5wPlDcF8Fq/3Jx30mRGWNwQzwmpYx/eusLwhmBGWNwQzwvKGYEZY3hDMCMsbghlheUMwIyxviJ0RmDcEM8LyhmBGWN4QzAjLG4IZERwjLG8IZoTlDcGMsLwhmBGWNwQzwvKG2BmBeUMwIyxvCGaE5Q3BjLC8IZgRwTHC8oZgRljeEMwIyxuCGWF5QzAjLG+IUXmE5Q0xKGF5QwxKWN4QgxJWD/ZBCcsbYlDC8oYYlOCO2tC8IQYlLG+IQQnLG2JQIjxKUPtS2rJ4BS9jqK3gHeS11hcN8lrriwZ5rfVFgzxpJq+1vmiQ11pfNMhrrS8a5LXWFw3yWit4mbzaCt5BXnOGVVvBO8hrzrBqK3gHec0ZVm0F7yCvOcOqreAd5IEqeJkPUgXv4KO1vmiQ11pfNMhrrS8a5Ekzea31RYO81vqiQV5rfdEgr7W+aJDXWl/E5NVW8A7ymjOs2greQV5zhlVbwTvIa86wait4B3nNGVZtBe8grznDIlXwDj5AFbyDD1AF7+ADVME7+KBkq4MPUAXv4ANUwTv4AFXwDj5AFbyDD1AFL/NBquAdfBav94/rHAcjqArewQjqWuG4dwVVwTsYQVXwDkZQFbyDEVQF72AEVcE7GEFV8A5GUBW8zAirgncwgqrgHYygKngHI6gK3sGI4BhBVfAORlAVvIMRVAXvYARVwTsYQVXwMiOsCt7BCKqCdzCCquAdjKAqeAcjgmMEVcE7GEFV8A5GUBW8gxFUBe9gBFXB+63yCKqC9xslqAreb5SgKni/UYKrlAOr4P1GCaqC9xsluKM2sAreb5SgKni/UYKq4P1GifAoQe1LPW4PymdKPIpy6/b2K3NI/Xwtfu619LnX6HOv5d/8Wthz/qPS0a29pZ3tzdg7fPvxff//wqMb9jXW483+zpY9pPr2Zv/smw8uov/Mm+HTb8bf/Ob+b//vD//5pz/887//8a/7O/wf/+vP//K3P/3lz9//9W///z++/Zf92f8B"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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3/ROvumdfNO7+KZ38U3v4pvexTe9i296F9/0Lr7pXXzTu/imd9FN77nRTe+50U3vudFN77nRTe+50U3vudFN77nRTe+50U3vudFN77nxTW/jm97GN72Nb3ob3/Q2vultfNPb+Ka38U1v45vexje9nW96O9/0dr7p7XzT2/mmt/NNb+eb3s43vZ1vejvf9A6+6R180zv4pnfwTe/gm97BN72Db3oH3/QOvukdfNObz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJaTz2s5+byWk89rOfm8lpPPazn5vJbJ57VMPq9l8nktk89rmRvd9E4+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsnntUw+r2XyeS2Tz2uZfF7L5PNaJp/XMvm8lsXntSw+r2XxeS2Lz2tZG930Lj6vZfF5LYvPa1l8Xsvi81oWn9ey+LyWxee1LD6vZfF5LYvPa1l8Xsvi81oWn9ey+LyWxee1LD6vZfF5LYvPa1l8Xsvi81oWn9ey+LyWxee1LD6vZfF5LYvPa1l8Xsvi81oWn9ey+LyWxee1LD6vZfF5LYvPa1l8Xsvi81oWn9ey+LyWxee1LD6vZfF5LYvPa1l8Xsvi81oWn9ey+LyWxee1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"},{"name":"mint_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"check_balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"fee_limit","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"5ZztjpTHFYTvZX+jqM/pqv7gVqIowjaOkNBiGRwpQr73LMl8LNqRlzqZrKfEL3uhe/r0VjHF1rw8n+9+evvDb//4+7v7nz98vHv918937z/8+ObTuw/3D199vmt/ifjPr3785c39l1/4+OnNr5/uXrdXd2/vf3r47++v7n5+9/7t3etc/P1vr75sSHVDVzdA3UB1w1A3THXDUjdscUM2dYOqdKpKp6p0qkqnqnSqSqeqdKpKp6p0V5XuqtJdVbqrSndV6a4q3VWlu6p0V5XuqtJQlYaqNFSloSoNVWmoSkNVGqrSUJWGqjRVpakqTVVpqkpTVZqq0lSVpqo0VaWpKj1UpYeq9FCVHqrSQ1V6qEoPVemhKj1UpYeq9FSVnqrSU1V6qkpPVempKj1Vpaeq9FSVnqrSS1V6qUovVemlKr1UpZeq9FKVXqrSS1V6qUpvVemtKr1Vpbeq9FaV3qrSW1V6q0pvVemtKh2tyTvk7qTJ5UmT25Mm1ydN7k+aXKA0uUFpcoXSZM1D1lzvy/TCTG/M9MpM78z00kxvzfTaTO7NQi7OIvWOVNZc7s5CLs9Cbs9Crs9C7s9CLtBCbtBCrtBC7tCi68W4rLlco4Xco4VcpIXcpIVcpYXcpYVcpoXcpoVcpwX0T0NkzeVGLeRKLeROLeRSLeRWLeRaLeReLeRiLeRmLeRqLeRuLeRyLeR2LeR6LeR+LeSCLeSGLeSKLeSOLeSSLYb+uaesudyzhVy0hdy0hVy1hdy1hVy2hdy2hVy3hdy3xdQ/7JY1lyu3kDu3kEu3kFu3kGu3kHu3kIu3kJu3kKu3WPoTDrLmcvsWcv0Wcv8WcgEXcgMXcgUXcgcXcgkXcgsXW3+sRX+uRX6wRe7hUu7hUu7hUu7hUu7hUu7hUu7hUu7hUu7hMvSHmWTN5R4u5R4u5R4u5R4u5R4u5R4u5R4u9efX9AfYCk+wyZrrz7DpD7HpT7Hpj7Hpz7HpD7LJPVzKPVzKPVx2/bFFWXO5h0u5h0u5h0u5h0u5h0u5h0u5h0u5h0u5h0voz6rKmss9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XMo9XA79qXRZc7mHS7mHS7mHS7mHS7mHS7mHS7mHS7mHS7mHy6n/UwRZc7mHS7mHS7mHy8s9HPs+biJif7Xv1ZPVyNUPq9HbeTVwYfHkOqydG+cXzuM8eWPz4Mbm4Y3NM25snnmFeXqu0zx9PJ7ncMh6iUP2NQ4ZPB0y4+khl0tc+RCcDlntwiH5EodcDBaC43TIHM8cwjgZkQ9t9Wn17hcWD7TjSw/kV4sPE11+63i4yXmi+cxEux9Nstc6rQ3khbUPn7Af1j50wY/+ZFwafjPj+ML8cvJxdd/H6Wk9/bCeflpPv6yn38bT98sft9hMn9bTd+vpndOqN+e06s05rXpzTqvenNOqN+u0uvzRss301lkbV8jaaOP481JEtmfmv1xDXfoJ/zj6HI+/JzhODtvJaTv5sJ182k6+bCffrpNns508bCe3TaLstpPbZmjaZmjaZmjaZmjaZmjaZmi3zdBum6HdNkO7bYZ22wztthnabTO022Zot83QbpuhsM1Q2GYobDMUthkK2wyFbYbCNkNhm6GwzVDYZihtM5S2GUrbDKVthtI2Q2mbobTNUNpmKG0zlLYZOmwzdNhm6LDN0GGbocM2Q4dthg7bDB22GTpsM3TYZui0zdBpm6HTNkOnbYZO2wydthk6bTN02mbotM3QaZuhyzZDl22GLtsMXbYZumwzdNlm6LLN0GWbocs2Q5dthm7bDN22GbptM3TbZug1uDt/0uS2GbptM3TbZui2zdDtmqForhmK5pqhaK4ZiuaaoWiuGYrmmqForhmK5pqhaK4ZimaboWGboWGboba0H4RthtpyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKYItpwi2nCLYcopgyymCLacItpwi2HKKYMspgi2nCLacIthyimDLKaItp4i2nCLacopoyylic81Q2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4i2nCLacopoyymiLaeItpwi2nKKaMspoi2niLacItpyimjLKaItp4jfwClaeG7y6OfJB7465enqvo4vjTx/TyL3hbW5jtP3WF+tPUw/radf1tNv4+nHN3CLbnn6+P9OfzglX+SUfo1TJk6n7PGMEjHm8e3z4X/3+bV7O86EG5yJNzjTuMGZ5g3OtG5wpv3yM53+MhJjta9meroauY7vHOjtfIOLLz25jn/N2Y+GzsNdo31Hd83v6K79O7orvqO78sbv2nOd7trH47seLjDcLzBv/QKDpwvMuHCBdfMXwOkCj1afL/B8Pu/nOoWx8njIWH09PeQbsDlXOCRe4pC8xiHg6ZBxQZNv4MZc4RC8xCG8iib9fEj+8Tt+j9FOP9PO8+J+HGi99ECZeRwoO54MhKt8h/bxLWHsxqcyfMM/6Xv+kB15OuRRtXA+ZF7lJu18yP7ftGZ76YGe0Xpc4zu0edZ69T8eKPvJqdnZng60b2ygKRv1sG8V9+3avtWK+6K4L4v7enEfivtY3FfUfc3ivqJfVtEvu+iXXfTLLvplF/2yi37ZRb/sol920S+76Jdd88tsrbgvivuyuK8X96G4j8V9o7hvFvet4r6iX6Lolyj6JYp+iaJfouiXKPolin6Jol+i6Jco+iWLfsmiX7Lolyz6JYt+yaJfsuiXLPoli37Jol960S+96Jde9Esv+qUX/dKLfulFv/SiX3rRL73oFxT9gqJfUPQLin5B0S8o+gVFv6DoFxT9gqJfWPQLi35h0S8s+oVFv7DoFxb9wqJfWPQLi34ZRb+Mol9G0S+j6JdR9Mso+mUU/TKKfhlFv4yiX2bRL7Pol1n0yyz6ZRb9Mot+Kfa0cxb9Uux3Z7HfnYV+9+Grf7759d2bH96//fiw58tv/nb/46d3H+4PX3761y///Z2Htf8G"},{"name":"set_portal","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/72WzY7TMBDH3XbbbbtJyva7Tb+Sxg0SFy7sBcGdM08AAgkk4IDgAI/CO/Ai+xC8AXckDotn7PE/aXYrRUIbye14/P/NjD2R4ky1lOqeKfOslXvMrKsi1TF/TRrPlVjGoNGIVENcmhaJspbxq5Z2gDpjy2RQ7dT8XDxRkixTbVV+SN/hrHZUFRT73CrOaWRUO3v7WjSmlJYz+zaPaHp504WmWbcAW6TnkF7mI1xAFHTYvCDTjDCh9ZisqwYqbLnDIFmoaSGkqLZmF7y0qxvzkMoqSBwaxc3RQ0mtgnIHiFFIrSKriGg0fTiahkdT5adBmeues9lzu4h4k4/IwiarbaGnF3my18ZuKRAHeUzWnUGe/rhuls+pXzj523oblHsbcW/71d4GFolkr1gJ0VA6iQGX+Yysuxo64IYOKFTbN6OHqHtu+i3FhuViB3jBTLMbL83/A2Qi8aVuWqe6BHZpNaE1GX0Ht6BDRkkwBDoEOnToK7gFHTFKghHQEdCRQz/DLeiYURKMgY6Bjh36Fm5BJ4ySYAJ0AnTi0DdwCzpllARToFOgU4e+gFvQGaMkmAGdAZ059CPcgs4ZJcEc6Bzo3P7XRky2r3ALumCUBAugC6ALh36BW9AloyRYAl0CXVYLXfpX4ARisr2GW9CYURLEQGOgsUM/wC3oilESrICugK6qha78W3MCMdl2cAu6ZpQEa6BroOtqtrU/lppIXB8Z1UfG97KXyWnEHPY3uAXdMEqCDdAN0E0128b35wRisr2HW9AtoyTYAt0C3Tr0E9yC7hglwQ7oDuiuWujOZ6uJLO4ly7A+Ev/3wsxhf4db0IRREiRAE6BJNVvi3/SayOQ0wp/9v/iIZwwqfLnlU81CLZ9zE/GscIFJOVVaTrW3cGJNWSFzjxuAttcQ7VYO5sCIzRscIicXDc7+x85kj8TkWmQZstmFpttNjopy5ZMRoqkDvwtlHRV8JRfYDCFSfzYBziY9uo1he2nluvjrJ4W2N70EDQlcmJDrTuy74+9qVpO6ctLCGftyUpSzL5cTPnQ3QXvbx4L28B6wLsNZVlyRkyLRgStt26aJ/IATpr7pwtn7ZBrJ8nKyw0P33vCsw5ubX9P4B9hf6AanDQAA","debug_symbols":"5Z3rShtRGEXfJb+lzN7n7quUUlIvRZAoXgpFfPeaxkTFlIAdF2eYf07yzex9GNYZlIXzsDg9+3H/8/vF6vzqdnH89WFxeXWyvLu4Wj0dPSyGL9LfT2+vl6v1B7d3y5u7xXFQGI4WZ6vT9Y85Px4tzi8uzxbHrunx6N20B+fnaQ+p7KYVy57pULfD0a9m3fZduWpXo76Z/Xa0Lh+mXD5NuXyecvky5fJ1yuXbhMt7+NzymxARIR4jJJddSG0HbkPZ3YbS0qsrD8+FQm+FYm+FUm+Fcm+FSm+Fam+FGl4oh12h/KbQ+9kW2vNsy+3AbEl1d934MuvNOsMwk3V6JuuMM1lnnsk6y0zWWWeyzpk8V+JMnitRM1nnTJ6f8fBvV+XtOjenpY+dlj92WvnYaf/YY+v2rgSHQ/dQyX6eVkqJ+4tCGqZcXlMu7ymXD1MuH6dcPn1u+U1IJkLKGCHlJaTmPSGVCGlASB6IEBEhJkLCyCFNe0IiEZKIkEyEFCKkEiENCCkDESIixEQIQXwhiC8E8YUgvhDEF4L4QhBfCeIrQXwliK8E8ZUgvhLEV4L4ShBfCeIrQXwjiG8E8Y0gvhHEN4L4RhDfCOIbQXwjiG8E8RoGJEVIipGUgKREJCUhKRlJKUhKRVIQ9oWwL4R9IewLYV8I+0LYF8K+EPaFsC+EfSPsG2HfCPtG2DfCvhH2jbBvhH0j7BthPyDsB4T9gLAfEPYDwn5A2A8I+wFhPyDsB4T9iLAfEfYjwn5E2I8I+xFhPyLsR4T9iLAfEfYTwn5C2E8I+wlhPyHsJ4T9hLCfEPYTwn5C2M8I+xlhPyPsI86eEGlPiLUnRNsT4u0JEfeEmHtC1D0h7p4QeU+IvSdE3xPi7wkR+IQYfEIUPiEOnxCJT4jFJ0TjE+LxCRH5hJh8QlQ+IS6fEJlPiM0nROcT4vMJEfqEGH1ClD4hTp8QqU+I1SdE6xPi9Rnx+ox4fUa8PiNen4eIpCQkJSMpBUmpSArCPuL1GfH6jHh9Rrw+I16fEa/PiNdnxOsz4vUZ8fqMeH1GvD4jXp8Rr8+I12fE6zPi9Rnx+ox4fUa8PiNenxGvz4jXZ8TrM+L1GfH6jHh9Rrw+I16fEa/PiNdnxOsz4vUZ8fqMeH1GvD4jXp8Rr8+I12fE6zPi9XkUr6+kuE0prb5JeT+dd8P51X8HfXn/xCgO4LiNQneNYneNUneNcneNaneNWm+NRjEax23U3Q6Zu9shc3c7ZO5uh8zd7ZC5ux1yFAu0pu202hD+t1HtrlHrrdEoJuq4jdRdI3fXKHTXKHbXKHXXKHfXqLs9u3S3Z5fu9uza0579dPRreXOx/HF5tn5h7/rL+9XJ9v29T4d3v6833zzN/gE="},{"name":"balance_of_public","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83YW2/rRBAH8E0apyU0ztVp7o2buLm7PSUgjqA8IiQekXgEcRcSN3ER4ivypWBndmf/SX3kaqUj60Ry44zntzO7TtpsF+pMqYtA6cdE2UdFR1SoqvqpTMdHSs70CR2lUJUklNBFUuZMx9VZYoGq8JmuoIIb/eMyUWaEi8q7dKFCYy1UidB5QGNSbXWuj+qCGlPv66OWSGO6zpk9rdEPk0PsrQWu6AE/1s9vm+QLm3yZlE1QXYJdmpyaOWX6F8JC60wpoQ5aB61b+gvCQkOmlBCChqChpd8gLLTBlBIaoA3QhqV/Iiy0yZQSmqBN0KalPyIstMWUElqgLdCWpb8iLLTNlBLaoG3QtnnOkno+0dVmCAvtMKWEDmgHtGPp1wgL7TKlhC5oF7Rr6VcIC42YUkIEGoFGlv6EsNAeU0rogfZAe9nl6blqnqTuT8J8ouf0HcJCr5hSwhXoFeiVpV8iLLTPlBL6oH3QfrbRvnuD5RBd7XuEhQ6YUsIAdAA6yFYbuAZziK72G8JCh0wpYQg6BB1mqw3d7xhP0vEnkT9p+pPQn7QLqdL1J/VC5tIqpLFn7r5+R/+DsNARU0oYgY5AR9lqI7cMnqTjT3qFNBb6k64/iQohz6yYfhd8i7DQMVNKGIOOQcfZamO32DlEV/sDYaETppQwAZ2ATrLVJu6LjyfpFlKl6U/CQuYSFUKG+SSm+BTf/V8yVPjCL9/weaOSyC5Aj1hReEy51PS01LXBE3MqV2hzcY2NQ1zl09gm3diNybzEQ8wpRAe3OTKvZI4UmyeSNkM1c6FsgmqOjubKFSMS68ul5lFbTxp+r2Rn+9Lk8ByTow2bTGJ6ui+qYnrThQrU6YPvAm/0uJK9IRU7TI37npgPqAxob8PUtjN9FQnyyUlLMpnrDypHORVzZ572S4+Z6ZeWcxbwac2+DBZcTt2YnWRgb1hsinxI7xm3YnOsWHK6Ygu0l+gBP9PPtyZ5bpOXPMlbOgNbmpzEnNJzljT8SSuf6AZ/R1joiiklrEBXoKtstZX7zZFDdLUfEBa6ZkoJa9A16Dpbbe3+BHmStj8Z+5PIn7T8SeO1T1/fn3uEhW6YUsIGdAO6yVbbuGqepO5PWv6kUchcuv4kKoQ8s2L6XfA3wkK3TClhC7oF3Warbd2n1JOM8oluMEVY6I4pJexAd6C7bLWdu7We5NafNPxJy58s/UnXn6z8Sa+Q+zL2J1Eh96VRyFyeWTH9ufkZYaF7ppSwB92D7rPV9u5/TZ5k7E8a/qT9pjbW9SfLN3XF+oXMpeVPdq99+vpz8wJhoSlTSkhBU9A0Wy11f6JyCO3oyp9i3/HIUGGzIbuL1G0+EjPi8S72jkvdnZa6Nzg1p3KFNjb32LQ8mF3sg016x+5iD2YXe6AQHdzmJ+aVzJHMIZG0F6hmLpRNUB3Q0UG5YkQeZnrQx6O2njTMu1ia7SOGuHNrE2Bt7k73ZPGybPd5vLHLbC1jezU+GrbqNp28ijzfz10T9nFmynJamtjbqWqh21fqEYP/njzImAyiwTmfxvalKfTFaaGQ7y2PFyK75KoEtpJNP2pQpQZQWym/QWJpsux4asLSEa+G+/dInIgqz+m0/y8d/wMOUhUC9x0AAA==","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b227aQBCG18RJTJ24YGMMgQQIyUXvDA2nO16mfe3eV+orVM2YnTJsp2hRx1tWYqWIsb2e/5t/D1jICdSuRe9/gY6v9eeN+rNhn63+LP+tzQRzlXVyBp5wNjzhvPKEMxTkDBhO+Ax1DOsO1tytOlyPv9tWqChTlELBBLoi19URwIMboUU6oBfHUuDrcnNDklNwpcFDfQ0/ASfW1yhYrIus+pBzWGiDnEOdK3IOd0bUibQpwvUuoj2yXN73CQA1NHUu5I5JTK8NiXVhTTVey9f4VsuYlLtVjGNyrXPfkmP0Cj0U/OaYUe1A/zWJptJjhPGA9MV+6EeDjDG0e7Wf180j94XGfQnpc8PUPxau/9bgMecsjEFLx204xj2BsH0g9W1l2ErIG8vnndExCHVu5I9JTYm43/M15L9Th838VhqTOCE89+I85ayeOndj95Gwy+RdvIFXLcOrO8OrhPShDK0a/AuILubG4xajLefFcg3abQsv2gxP27EXbUZb0IsNaKcWXqQMT+rYi5TRlvNi9Rm0MwsvMoYnc+xFxmjLeTGvni06Fl50GJ6OYy86jLbgGqnmRW7hRc7w5I69yBltQS++gnbXwosuw9N17EWX0Rb04gtoFxZeFAxP4diLgtEW3Dur54uehRc9hqfn2Iseoy3oxRy0+xZe9BmevmMv+oy24BqptB8svHhgeB4ce4F6pzJ3PGQuPGTOzoA5MmIZ7WW1fw4svBgwPAPHXtDfck5hzs+AOTJiGe3lArSHFl4MGZ6hYy9Q71Tm1EPmzEPmrofMuYfMhYfM5zCfIyOW0V5Ve+ijhRePDM+jYy9Q71Tm1EPmgYfM2RkwR0Yso72qfpt7svDiieF5cuwF6p3K3POQuX0GzJERy2ivlqA9svBixPCMHHuBeqcy9z1kLjxkHnjInHnI3PWQOfeQ+bIG3TCnZ8AM773gOzA/auWZb2KDBz1TBqMyGGMSJ4QR+26V3PsqiVE7ak3E/diNjzlf8HhSq/Z8DXmn8jVVz/IvOhe+wzdlanrVcSDs5wvJGxAdPB+S+Dvpi/3QD1y3yA7vXD3r+PXIfSPjvoT0eWbqHwvXPzV4pgYzjMk3wlHH3LKZ1y21X8ufCE8N++AbfScXm82+Q/cYQZ5ZTXWW9B2+n0p2TU8Mr5qGVwnpQ/fo/7VvXpgvzH9jps8TTXKO8uC5hlEL/f+GCcnxC57ToyHuNQAA","debug_symbols":"ndpRattAGIXRveg5FN/fGs0oWymlOIlTDMEJsVMoJnuv3dIF9LxpJN237+kwl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLjT9vT2+74+3F6bx7P0/321530/74dHvqn3fT8+FlP93XaJ/f7m6jFUbbjYwio5LRVkazjJqMFhl1GUkRWyliliJmKWKWImYpYpYiZililiJmKWKWImYpokkRTYpoUkSTIpoU0aSIJkU0KaJJEU2KWKSIRYpYpIhFilikiEWKWKSIRYpYpIhFiuhSRJciuhTRpYguRXQpoksRXYroUkSXIoYUMaSIIUUMKWJIEUOKGFLEkCKGFDGkiFWKWKWIVYpYpYhVililiFWKWKWIVYpYpYhsNrQKrYpWW1rNtGq0WmjVaTVoRW2E2gi1EWoj1EaojVAboTZCbYTaCLVR1EZRG0VtFLVR1EZRG0VtFLVBoBkSzRBphkwzhJoh1QyxZsg1Q7AZks0QbYZsM4SbId0M8WbIN0PAGRLOEHGGjDOEnCHlDDFnyDlD0BmSzhB1hqwzhJ0h7QxxZ8g7Q+AZEs8QeYbMM4SeIfUMsWfIPUPwGZLPEH2G7DOEnyH9DPFnyD9DABoS0BCBhgw0hKAhBQ0xaMhBQxAaktAQhYYsNIShIQ0NcWjIQ0MgGhLREImGTDSEoiEVDbFoyEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFyy56kosWuWiRixa5aJGLFrlokYvWf7vo9fRz937YPbzsb3d7bx8/jo//rvpej+dfb3+/XP/9DQ=="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"artifact_hash","type":{"kind":"field"}},{"name":"private_functions_root","type":{"kind":"field"}},{"name":"public_bytecode_commitment","type":{"kind":"field"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"GasToken::deploy_parameters"}}],"kind":"struct","path":"GasToken::deploy_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"GasToken::set_portal_parameters"}}],"kind":"struct","path":"GasToken::set_portal_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::_increase_public_balance_parameters"}}],"kind":"struct","path":"GasToken::_increase_public_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::claim_public_parameters"}}],"kind":"struct","path":"GasToken::claim_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"GasToken::balance_of_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::balance_of_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::mint_public_parameters"}}],"kind":"struct","path":"GasToken::mint_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::claim_parameters"}}],"kind":"struct","path":"GasToken::claim_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"fee_limit","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::check_balance_parameters"}}],"kind":"struct","path":"GasToken::check_balance_abi"}]}},"file_map":{"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nunconstrained fn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"137":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n"},"142":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        // This looks the same as the &mut PublicContext impl, but is actually very different. In public execution the\n        // storage read oracle gets transpiled to SLOAD opcodes, whereas in unconstrained execution the PXE returns\n        // historical data.\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    oracle::{storage::{storage_read, storage_write}}, state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // TODO(#4738): Uncomment the following assert\n        // assert(\n        //     self.context.public.unwrap_unchecked().is_deployment(), \"SharedImmutable can only be initialized during contract deployment\"\n        // );\n\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let fields_read: [Field; 1] = storage_read(initialization_slot);\n        assert(fields_read[0] == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        storage_write(initialization_slot, [0xdead]);\n\n        let fields_write = T::serialize(value);\n        storage_write(self.storage_slot, fields_write);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"163":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse dep::std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: 0 }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"165":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, nullifier_counter: u32, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, nullifier_counter, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    nullifier_counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.nullifier_counter == other.nullifier_counter)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            nullifier_counter: 0,\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.nullifier_counter as Field, self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            nullifier_counter: reader.read_u32(),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n        assert(\n            (self.nullifier_counter == 0) | (read_request.counter() < self.nullifier_counter), \"Read request counter must be less than the nullifier counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"166":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr","source":"use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        // WARNING: if updating, see comment in public_call_stack_item.ts's `PublicCallStackItem.hash()`\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs = PublicCircuitPublicInputs::empty();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector, note_hash::NoteHash,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x2751111aa213d9d21279da53531bf90c2da272cf3f959e2a2a1dfceb487bf102;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x1860d00d9602966e398c6d585216baba2ffa8c5eddda5faee041136665d8482a;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n"},"168":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    new_note_hashes: u32,\n    new_nullifiers: u32,\n    new_l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            new_note_hashes: validate_array(public_inputs.new_note_hashes),\n            new_nullifiers: validate_array(public_inputs.new_nullifiers),\n            new_l2_to_l1_msgs: validate_array(public_inputs.new_l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.new_note_hashes.len() {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..self.new_nullifiers.len() {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.new_l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x1970bf189adc837d1769f9f44a8b55c97d45690e7744859b71b647e808ee8622;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"171":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"174":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint\n};\n\nstruct KeyValidationRequest {\n    pk_m: GrumpkinPoint,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: GrumpkinPoint::zero(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: GrumpkinPoint::new(fields[0], fields[1]),\n            sk_app: fields[2],\n        }\n    }\n}\n\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"188":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"189":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    abis::{caller_context::CallerContext, side_effect::{Ordered, RangeOrdered, Scoped}},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.hash == other.hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"203":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x22786e4f971661d2e49095e6b038e5170bc47b795253916d5657c4bdd1df50bf;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"206":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"21":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"210":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    abis::{gas_settings::GasSettings, gas::Gas}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        let serialized: [Field; CALL_CONTEXT_LENGTH] = self.serialize();\n\n        for i in 0..CALL_CONTEXT_LENGTH {\n            assert(serialized[i] == 0);\n        }\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n        serialized.push(self.side_effect_counter as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n            side_effect_counter: reader.read() as u32,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n            side_effect_counter: 0,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn assert_is_zero() {\n    let context = CallContext::empty();\n    context.assert_is_zero();\n}\n\n#[test(should_fail)]\nfn not_zero_assert_is_zero() {\n    let mut context = CallContext::empty();\n    context.is_delegate_call = true;\n    context.assert_is_zero();\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"212":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, note_hash::NoteHash, nullifier::Nullifier, read_request::ReadRequest,\n    gas::Gas, global_variables::GlobalVariables, log_hash::LogHash\n},\n    address::AztecAddress,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH, MAX_UNENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize, Empty}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    l1_to_l2_msg_read_requests: [ReadRequest; MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    // Global variables injected into this circuit\n    global_variables: GlobalVariables,\n\n    prover_address: AztecAddress,\n\n    revert_code: u8,\n    \n    start_gas_left: Gas,\n    end_gas_left: Gas,\n    transaction_fee: Field,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.l1_to_l2_msg_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        for i in 0..MAX_UNENCRYPTED_LOGS_PER_CALL{\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n        fields.push(self.transaction_fee);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            l1_to_l2_msg_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            global_variables: reader.read_struct(GlobalVariables::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            revert_code: reader.read() as u8,\n            start_gas_left: reader.read_struct(Gas::deserialize),\n            end_gas_left: reader.read_struct(Gas::deserialize),\n            transaction_fee: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PublicCircuitPublicInputs {\n    fn empty() -> Self {\n        PublicCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0 as u32,\n            end_side_effect_counter: 0 as u32,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0 as u8,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PublicCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PublicCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x01681b19fb7fe21aa9c2cf9fb47520149f46edd679b2e7c2b2c4a279fd685125;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"214":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"22":{"path":"std/field.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"221":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"222":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"223":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"230":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"231":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use dep::std::cmp::Eq;\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"232":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.tx_tree_height);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    contract_class_id::ContractClassId, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{Hash, is_empty},\n    utils::{uint256::U256, field::field_from_bytes_32_trunc}\n};\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u32) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, first_nullifier: Field, index: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, index);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"242":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"244":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr","source":"use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{ToField, FromField, Hash, Serialize, Deserialize};\n\nstruct ContractClassId {\n  inner: Field\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n  fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field\n    ) -> Self {\n        let hash = dep::std::hash::pedersen_hash_with_separator(\n            [\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ],\n            GENERATOR_INDEX__CONTRACT_LEAF\n        ); // TODO(@spalladino): Update generator index\n\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"248":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"260":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"267":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"28":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"280":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"281":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"282":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"283":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"285":{"path":"/usr/src/noir-projects/noir-contracts/contracts/gas_token_contract/src/main.nr","source":"mod lib;\n\ncontract GasToken {\n    use dep::aztec::{\n        protocol_types::{\n        contract_class_id::ContractClassId, abis::function_selector::FunctionSelector,\n        address::{AztecAddress, EthAddress},\n        constants::{DEPLOYER_CONTRACT_ADDRESS, REGISTERER_CONTRACT_ADDRESS}\n    },\n        state_vars::{SharedImmutable, PublicMutable, Map},\n        oracle::get_contract_instance::get_contract_instance, deploy::deploy_contract\n    };\n\n    use dep::deployer::ContractInstanceDeployer;\n    use dep::registerer::ContractClassRegisterer;\n\n    use crate::lib::{calculate_fee, get_bridge_gas_msg_hash};\n\n    #[aztec(storage)]\n    struct Storage {\n        // This map is accessed directly by protocol circuits to check balances for fee payment.\n        // Do not change this storage layout unless you also update the base rollup circuits.\n        balances: Map<AztecAddress, PublicMutable<U128>>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Not flagged as initializer to reduce cost of checking init nullifier in all functions.\n    // This function should be called as entrypoint to initialize the contract by minting itself funds.\n    #[aztec(private)]\n    fn deploy(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n        portal_address: EthAddress\n    ) {\n        // Validate contract class parameters are correct\n        let self = context.this_address();\n        let instance = get_contract_instance(self);\n        let contract_class_id = ContractClassId::compute(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        );\n        assert(\n            instance.contract_class_id == contract_class_id, \"Invalid contract class id computed for gas token\"\n        );\n\n        // Increase self balance and set as fee payer, and end setup\n        let deploy_fees = 20000000000;\n        GasToken::at(self)._increase_public_balance(self, deploy_fees).enqueue(&mut context);\n        context.set_as_fee_payer();\n        context.end_setup();\n\n        // Register class and publicly deploy contract\n        let _register = ContractClassRegisterer::at(AztecAddress::from_field(REGISTERER_CONTRACT_ADDRESS)).register(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ).call(&mut context);\n        let _deploy = ContractInstanceDeployer::at(AztecAddress::from_field(DEPLOYER_CONTRACT_ADDRESS)).deploy(\n            instance.salt,\n            instance.contract_class_id,\n            instance.initialization_hash,\n            instance.public_keys_hash,\n            true\n        ).call(&mut context);\n\n        // Enqueue call to set the portal address\n        GasToken::at(self).set_portal(portal_address).enqueue(&mut context);\n    }\n\n    // We purposefully not set this function as an initializer so we do not bind\n    // the contract to a specific L1 portal address, since the gas token address\n    // is a hardcoded constant in the rollup circuits.\n    #[aztec(public)]\n    fn set_portal(portal_address: EthAddress) {\n        assert(storage.portal_address.read_public().is_zero());\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[aztec(private)]\n    fn claim(to: AztecAddress, amount: Field, secret: Field) {\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\n        let portal_address = storage.portal_address.read_private();\n        assert(!portal_address.is_zero());\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address);\n\n        // TODO(palla/gas) Emit an unencrypted log to announce which L1 to L2 message has been claimed\n        // Otherwise, we cannot trace L1 deposits to their corresponding claims on L2\n\n        GasToken::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.balances.at(to).read().add(U128::from_integer(amount));\n        storage.balances.at(to).write(new_balance);\n    }\n\n    // TODO(palla/gas) Remove this function and use the private claim flow only\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, leaf_index: Field) {\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\n        let portal_address = storage.portal_address.read_public();\n        assert(!portal_address.is_zero());\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address, leaf_index);\n\n        let new_balance = storage.balances.at(to).read() + U128::from_integer(amount);\n        storage.balances.at(to).write(new_balance);\n    }\n\n    // TODO(@just-mitch): remove this function before mainnet deployment\n    // convenience function for testing\n    // the true canonical gas token contract will not have this function\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.balances.at(to).read().add(amount);\n\n        storage.balances.at(to).write(new_balance);\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn check_balance(fee_limit: Field) {\n        let fee_limit = U128::from_integer(fee_limit);\n        assert(storage.balances.at(context.msg_sender()).read() >= fee_limit, \"Balance too low\");\n    }\n\n    // utility function for testing\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).read().to_field()\n    }\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-contracts/contracts/gas_token_contract/src/lib.nr","source":"use dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::context::PublicContext;\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\npub fn calculate_fee<TPublicContext>(context: PublicContext) -> Field {\n    context.transaction_fee()\n}\n\npub fn get_bridge_gas_msg_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n"},"288":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"mod events;\n\ncontract ContractInstanceDeployer {\n    use dep::aztec::protocol_types::{\n        address::{AztecAddress, EthAddress, PublicKeysHash, PartialAddress},\n        contract_class_id::ContractClassId, constants::DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\n        traits::Serialize\n    };\n\n    use crate::events::{instance_deployed::ContractInstanceDeployed};\n\n    #[aztec(private)]\n    fn deploy(\n        salt: Field,\n        contract_class_id: ContractClassId,\n        initialization_hash: Field,\n        public_keys_hash: PublicKeysHash,\n        universal_deploy: bool\n    ) {\n        // TODO(@spalladino): assert nullifier_exists silo(contract_class_id, ContractClassRegisterer)\n\n        let deployer = if universal_deploy {\n            AztecAddress::zero()\n        } else {\n            context.msg_sender()\n        };\n\n        let partial_address = PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\n\n        let address = AztecAddress::compute(public_keys_hash, partial_address);\n\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\n        context.push_new_nullifier(address.to_field(), 0);\n\n        // Broadcast the event\n        let event = ContractInstanceDeployed { contract_class_id, address, public_keys_hash, initialization_hash, salt, deployer, version: 1 };\n        let event_payload = event.serialize();\n        dep::aztec::oracle::debug_log::debug_log_format(\"ContractInstanceDeployed: {}\", event_payload);\n        context.emit_unencrypted_log(event_payload);\n    }\n}\n"},"29":{"path":"std/hash.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::EmbeddedCurvePoint;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<N>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n"},"293":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/main.nr","source":"mod events;\nmod capsule;\n\ncontract ContractClassRegisterer {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector};\n    use dep::aztec::protocol_types::{\n        contract_class_id::ContractClassId,\n        constants::{\n        ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, FUNCTION_TREE_HEIGHT,\n        MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS, REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE\n    },\n        traits::Serialize\n    };\n\n    use crate::events::{\n        class_registered::ContractClassRegistered,\n        private_function_broadcasted::{ClassPrivateFunctionBroadcasted, PrivateFunction},\n        unconstrained_function_broadcasted::{ClassUnconstrainedFunctionBroadcasted, UnconstrainedFunction}\n    };\n\n    // docs:start:import_pop_capsule\n    use crate::capsule::pop_capsule;\n    // docs:end:import_pop_capsule\n\n    #[aztec(private)]\n    fn register(artifact_hash: Field, private_functions_root: Field, public_bytecode_commitment: Field) {\n        // TODO: Validate public_bytecode_commitment is the correct commitment of packed_public_bytecode\n        // TODO: Validate packed_public_bytecode is legit public bytecode\n\n        // docs:start:pop_capsule\n        let packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] = pop_capsule();\n        // docs:end:pop_capsule\n\n        // Compute contract class id from preimage\n        let contract_class_id = ContractClassId::compute(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        );\n\n        // Emit the contract class id as a nullifier to be able to prove that this class has been (not) registered\n        let event = ContractClassRegistered { contract_class_id, version: 1, artifact_hash, private_functions_root, packed_public_bytecode };\n        context.push_new_nullifier(contract_class_id.to_field(), 0);\n\n        // Broadcast class info including public bytecode\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ContractClassRegistered: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ]\n        );\n        context.emit_contract_class_unencrypted_log(event.serialize());\n    }\n\n    #[aztec(private)]\n    fn broadcast_private_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        unconstrained_functions_artifact_tree_root: Field,\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n        private_function_tree_leaf_index: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: PrivateFunction\n    ) {\n        let event = ClassPrivateFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            unconstrained_functions_artifact_tree_root,\n            private_function_tree_sibling_path,\n            private_function_tree_leaf_index,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: function_data\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassPrivateFunctionBroadcasted: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_metadata_hash,\n            unconstrained_functions_artifact_tree_root,\n            function_data.selector.to_field(),\n            function_data.vk_hash,\n            function_data.metadata_hash\n        ]\n        );\n        context.emit_contract_class_unencrypted_log(event.serialize());\n    }\n\n    #[aztec(private)]\n    fn broadcast_unconstrained_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        private_functions_artifact_tree_root: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: UnconstrainedFunction\n    ) {\n        let event = ClassUnconstrainedFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            private_functions_artifact_tree_root,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: function_data\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassUnconstrainedFunctionBroadcasted: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_metadata_hash,\n            private_functions_artifact_tree_root,\n            function_data.selector.to_field(),\n            function_data.metadata_hash\n        ]\n        );\n        context.emit_contract_class_unencrypted_log(event.serialize());\n    }\n}\n"},"3":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, N> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<N> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, N> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"31":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"44":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not() {\n        let num = U128::from_u64s_le(0, 0);\n        let not_num = num.not();\n\n        let max_u64: Field = pow64 - 1;\n        assert_eq(not_num.hi, max_u64);\n        assert_eq(not_num.lo, max_u64);\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"79":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse dep::std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"84":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"87":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"90":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_args(self) -> [Field];\n    fn get_original(self) -> fn[Env](T) -> P;\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message,\n    hash::{hash_args_array, ArgsHasher, compute_unencrypted_log_hash},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    note::note_interface::NoteInterface,\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{\n    emit_encrypted_note_log, emit_encrypted_event_log,\n    emit_contract_class_unencrypted_log_private_internal, emit_unencrypted_log_private_internal\n},\n    logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field,\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, grumpkin_point::GrumpkinPoint, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::{is_empty, Empty},\n    utils::arrays::find_index\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n    // --> might be a better approach to force devs to make a public function call that emits the log if needed then\n    // it would be less easy to accidentally leak information.\n    // If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\n    pub fn emit_unencrypted_log<T, N, M>(&mut self, log: T) where T: ToBytesForUnencryptedLog<N, M> {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_slice = log.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n        // call oracle\n        let _void = emit_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    pub fn emit_contract_class_unencrypted_log<N>(&mut self, log: [Field; N]) {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n    }\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, encrypted_log: [u8; M]) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, encrypted_log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, encrypted_log: [u8; M]) {\n        let counter = self.next_counter();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, encrypted_log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    */\n    pub fn emit_unencrypted_log_with_selector<T, N>(\n        &mut self,\n        event_selector: Field,\n        log: T\n    ) where T: Serialize<N> {\n        emit_unencrypted_log(event_selector, Serialize::serialize(log).as_slice());\n    }\n    // For compatibility with the selector-less API. We'll probably rename the above one.\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        self.emit_unencrypted_log_with_selector(/*event_selector=*/ 5, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(event_selector: Field, message: [Field]) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(event_selector: Field, message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}