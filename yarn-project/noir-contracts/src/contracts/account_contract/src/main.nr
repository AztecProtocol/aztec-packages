contract Account {
    mod entrypoint;
    use entrypoint::EntrypointPayload;

    use dep::std;
    use dep::aztec3::abi;
    use dep::aztec3::abi::Inputs;
    use dep::aztec3::abi::CallContext;
    use dep::aztec3::private_call_stack_item::PrivateCallStackItem;
    use dep::aztec3::public_call_stack_item::PublicCallStackItem;
    use dep::aztec3::context::PrivateFunctionContext;

    // This public key corresponds to private key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 (1st one generated by anvil)
    // TODO(#662): unhardcode this key once we settle on a proper way to store or validate it
    global pub_key_x: [u8;32] = [0x83,0x18,0x53,0x5B,0x54,0x10,0x5D,0x4A,0x7A,0xAE,0x60,0xC0,0x8F,0xC4,0x5F,0x96,0x87,0x18,0x1B,0x4F,0xDF,0xC6,0x25,0xBD,0x1A,0x75,0x3F,0xA7,0x39,0x7F,0xED,0x75];
    global pub_key_y: [u8;32] = [0x35,0x47,0xF1,0x1C,0xA8,0x69,0x66,0x46,0xF2,0xF3,0xAC,0xB0,0x8E,0x31,0x01,0x6A,0xFA,0xC2,0x3E,0x63,0x0C,0x5D,0x11,0xF5,0x9F,0x61,0xFE,0xF5,0x7B,0x0D,0x2A,0xA5];

    fn entrypoint(
        inputs: pub Inputs,
        payload: pub EntrypointPayload,
        signature: pub [u8;64]
    ) -> pub [Field; dep::aztec3::abi::PUBLIC_INPUTS_LENGTH] {
        let mut context = PrivateFunctionContext::new();

        // Since the payload exceeds MAX_ARGS, we only push its hash
        // TODO(#681): proper implementation of unpacked args
        context.args = context.args.push(payload.hash());

        // Verify payload signature using ethereum's signing scheme
        // TODO: Switch to keccak when available in Noir
        let payload_bytes: [u8; entrypoint::ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = payload.to_be_bytes();
        let payload_hash: [u8; 32] = std::hash::sha256(payload_bytes);
        let verification = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature, payload_hash);
        constrain verification == 1;

        for i in 0..entrypoint::ACCOUNT_MAX_PRIVATE_CALLS {
            let target_address = payload.flattened_targets[i];
            if target_address != 0 {
                let function_selector = payload.flattened_selectors[i];
                let mut args = [0; abi::MAX_ARGS];
                for j in 0..abi::MAX_ARGS {
                    args[j] = payload.flattened_args[i * abi::MAX_ARGS + j];
                }
                let (_callStackItem, _context) = PrivateCallStackItem::call(target_address, function_selector, args, context);
            }
        }

        for i in entrypoint::ACCOUNT_MAX_PRIVATE_CALLS..entrypoint::ACCOUNT_MAX_CALLS {
            let target_address = payload.flattened_targets[i];
            if target_address != 0 {
                let function_selector = payload.flattened_selectors[i];
                let mut args = [0; abi::MAX_ARGS];
                for j in 0..abi::MAX_ARGS {
                    args[j] = payload.flattened_args[i * abi::MAX_ARGS + j];
                }
                let (_callStackItem, _context) = PublicCallStackItem::call(target_address, function_selector, args, context);
            }
        }

        context.finish(inputs)
    }

    fn constructor(
        inputs: pub Inputs,
    ) -> pub [Field; dep::aztec3::abi::PUBLIC_INPUTS_LENGTH] {
        PrivateFunctionContext::new().finish(inputs)
    }
}
