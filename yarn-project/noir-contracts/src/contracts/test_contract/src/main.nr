// A contract used for testing a random hodgepodge of small features from simulator and end-to-end tests.
contract Test {
    // docs:start:unencrypted_import
    use dep::aztec::log::emit_unencrypted_log;
    // docs:end:unencrypted_import

    use dep::aztec::{
        abi,
        abi::PrivateContextInputs,
        hash::pedersen_hash,
        context::PrivateContext,
        oracle::{
            get_public_key::get_public_key as get_public_key_oracle,
            context::get_portal_address,
            rand::rand
        },
        log::emit_unencrypted_log_from_private,
        types::vec::BoundedVec,
        constants_gen::EMPTY_NULLIFIED_COMMITMENT,
    };
    use dep::token_portal_content_hash_lib::{get_mint_private_content_hash, get_mint_public_content_hash};

    #[event]
    struct ExampleEvent {
        value: Field,
    }

    #[aztec(private)]
    // docs:start:empty-constructor
    fn constructor() {}
    // docs:end:empty-constructor

    #[aztec(private)]
    fn get_public_key(
        address: Field,
    ) -> [Field; 2]{
        let pub_key = get_public_key_oracle(address);
        
        [pub_key.x, pub_key.y]
    }

    // Get the portal contract address through an oracle call
    #[aztec(private)]
    fn get_portal_contract_address(
        aztec_address: Field
    ) -> Field {
        get_portal_address(aztec_address)
    }

    // Get the address of the l1 portal for this contract (taken from the input context)
    #[aztec(private)]
    fn get_this_portal_address() -> Field {
        context.this_portal_address()
    }

    // Get the address of this contract (taken from the input context)
    #[aztec(private)]
    fn get_this_address() -> Field {
        context.this_address()
    }

    // Test codegen for Aztec.nr interfaces
    // See yarn-project/acir-simulator/src/client/private_execution.test.ts 'nested calls through autogenerated interface'
    // Note; this function is deliberately NOT annotated with #[aztec(private)] due to its use in tests
    fn test_code_gen(
        inputs: PrivateContextInputs,
        aField: Field,
        aBool: bool,
        aNumber: u32,
        anArray: [Field; 2],
        aStruct: DummyNote,
        aDeepStruct: DeepStruct,
    ) -> distinct pub abi::PrivateCircuitPublicInputs {
        let mut args: BoundedVec<Field, 17> = BoundedVec::new(0);
        args.push(aField);
        args.push(aBool as Field);
        args.push(aNumber as Field);
        args.push_array(anArray);
        args.push(aStruct.amount);
        args.push(aStruct.secretHash);
        args.push(aDeepStruct.aField);
        args.push(aDeepStruct.aBool as Field);
        args.push(aDeepStruct.aNote.amount);
        args.push(aDeepStruct.aNote.secretHash);
        for note in aDeepStruct.manyNotes {
            args.push(note.amount);
            args.push(note.secretHash);            
        }
        let args_hash = abi::hash_args(args.storage);
        let mut context = PrivateContext::new(inputs, args_hash);
        context.return_values.push(args_hash);
        context.finish()
    }

    // Purely exists for testing
    #[aztec(public)]
    fn create_l2_to_l1_message_public(
        amount: Field,
        secretHash: Field,
    ) {
        // Create a commitment to the amount
        let note = DummyNote::new(amount, secretHash);
        
        // Public oracle call to emit new commitment.
        context.message_portal(note.get_commitment());
        
    }

    // Purely exists for testing
    #[aztec(public)]
    fn create_nullifier_public(
        amount: Field,
        secretHash: Field,
    ) {
        // Create a commitment to the amount
        let note = DummyNote::new(amount, secretHash);
        
        // Public oracle call to emit new commitment.
        context.push_new_nullifier(note.get_commitment(), EMPTY_NULLIFIED_COMMITMENT);
    }

    // Forcefully emits a nullifier (for testing purposes)
    #[aztec(private)]
    fn emit_nullifier(nullifier: Field) {
        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);
    }

    #[aztec(private)]
    fn emit_msg_sender() {
        // Note: don't use emit_unencrypted_log_from_private in production code
        emit_unencrypted_log_from_private(&mut context, context.msg_sender());
    }

    // docs:start:is-time-equal
    #[aztec(public)]
    fn is_time_equal(
        time: Field,
    ) -> Field {
        assert(context.timestamp() == time);
        time
    }
    // docs:end:is-time-equal

    #[aztec(public)]
    fn emit_unencrypted(
        value: Field
    ) -> Field {
        // docs:start:emit_unencrypted
        emit_unencrypted_log(&mut context, value);
        // docs:end:emit_unencrypted
        0
    }

    #[aztec(public)]
    fn consume_mint_public_message(
        to: Field,
        amount: Field,
        canceller: Field,
        msg_key: Field,
        secret: Field,
    ) {
        let content_hash = get_mint_public_content_hash(to, amount, canceller);
        // Consume message and emit nullifier
        context.consume_l1_to_l2_message(msg_key, content_hash, secret);
    }

     #[aztec(private)]
    fn consume_mint_private_message(
        secret_hash_for_redeeming_minted_notes: Field, 
        amount: Field,
        canceller: Field,
        msg_key: Field,
        secret_for_L1_to_L2_message_consumption: Field, 
    ) {
        // Consume L1 to L2 message and emit nullifier
        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount, canceller);
        context.consume_l1_to_l2_message(msg_key, content_hash, secret_for_L1_to_L2_message_consumption);
    }

    // Purely exists for testing
    unconstrained fn get_random(
        kindaSeed: Field
    ) -> Field {
        kindaSeed * rand()
    }

    struct DummyNote {
        amount: Field,
        secretHash: Field
    }

    impl DummyNote {
        fn new(amount: Field, secretHash: Field) -> pub Self {
            Self {
                amount: amount,
                secretHash: secretHash
            }
        }

        fn get_commitment(self) -> pub Field {
            pedersen_hash([self.amount, self.secretHash],0)
        }
    }

    struct DeepStruct {
        aField: Field,
        aBool: bool,
        aNote: DummyNote,
        manyNotes: [DummyNote; 3],
    }
}
