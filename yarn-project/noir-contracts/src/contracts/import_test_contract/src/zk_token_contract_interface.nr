
/* Autogenerated file, do not edit! */


use dep::std;
use dep::aztec::context::Context;
use dep::aztec::constants_gen::RETURN_VALUES_LENGTH;

// ---



use dep::aztec::types::type_serialisation::{
  
  field_serialisation::{
    FieldSerialisationMethods,
    FIELD_SERIALISED_LEN,
  },


};


// Spread an array into an array:
fn spread<SRC_LEN, TARGET_LEN>(mut target_arr: [Field; TARGET_LEN], src_arr: [Field; SRC_LEN], at_index: Field) -> [Field; TARGET_LEN] {
  let mut j = at_index;
  for i in 0..SRC_LEN {
      target_arr[j] = src_arr[i]; 
  }
  target_arr
}


struct ZkToken_ContractInterface {
  address: Field,
}


impl ZkToken_ContractInterface {
  fn at(address: Field) -> Self {
      Self {
          address,
      }
  }
  
  fn constructor(
    self,
    context: &mut Context,
    initial_supply: Field,
		owner: Field
  ) -> [Field; RETURN_VALUES_LENGTH] {
    
    let mut serialised_args = [0; FIELD_SERIALISED_LEN + FIELD_SERIALISED_LEN];


    let mut spread_index: Field = 0;

    
    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(initial_supply),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(owner),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    
    context.call_private_function(self.address, 0x968ffe4f, serialised_args).public_inputs.return_values
  
  }
  

  fn mint(
    self,
    context: &mut Context,
    amount: Field,
		owner: Field
  ) -> [Field; RETURN_VALUES_LENGTH] {
    
    let mut serialised_args = [0; FIELD_SERIALISED_LEN + FIELD_SERIALISED_LEN];


    let mut spread_index: Field = 0;

    
    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(amount),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(owner),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    
    context.call_private_function(self.address, 0x1dc9c3c0, serialised_args).public_inputs.return_values
  
  }
  

  fn transfer(
    self,
    context: &mut Context,
    amount: Field,
		sender: Field,
		recipient: Field
  ) -> [Field; RETURN_VALUES_LENGTH] {
    
    let mut serialised_args = [0; FIELD_SERIALISED_LEN + FIELD_SERIALISED_LEN + FIELD_SERIALISED_LEN];


    let mut spread_index: Field = 0;

    
    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(amount),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(sender),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(recipient),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    
    context.call_private_function(self.address, 0xdcd4c318, serialised_args).public_inputs.return_values
  
  }
  

  // fn createClaims(
  //   self,
  //   context: &mut Context,
  //   amounts: [Field; 2],
	// 	secrets: [Field; 2],
	// 	sender: Field
  // ) -> [Field; RETURN_VALUES_LENGTH] {
    
  //   let mut serialised_args = [0; [FIELD; 2]_SERIALISED_LEN + [FIELD; 2]_SERIALISED_LEN + FIELD_SERIALISED_LEN];


  //   let mut spread_index: Field = 0;

    
  //   let serialise[Field; 2] = [Field; 2]SerialisationMethods.serialise;
  //   serialised_args = spread(
  //     serialised_args,
  //     serialise[Field; 2](amounts),
  //     spread_index
  //   );
  //   spread_index += [FIELD; 2]_SERIALISED_LEN;
  

  //   let serialise[Field; 2] = [Field; 2]SerialisationMethods.serialise;
  //   serialised_args = spread(
  //     serialised_args,
  //     serialise[Field; 2](secrets),
  //     spread_index
  //   );
  //   spread_index += [FIELD; 2]_SERIALISED_LEN;
  

  //   let serialiseField = FieldSerialisationMethods.serialise;
  //   serialised_args = spread(
  //     serialised_args,
  //     serialiseField(sender),
  //     spread_index
  //   );
  //   spread_index += FIELD_SERIALISED_LEN;
  

    
  //   context.call_private_function(self.address, 0xd3ebc0af, serialised_args).public_inputs.return_values
  
  // }
  

  fn claim(
    self,
    context: &mut Context,
    amount: Field,
		secret: Field,
		owner: Field
  ) -> [Field; RETURN_VALUES_LENGTH] {
    
    let mut serialised_args = [0; FIELD_SERIALISED_LEN + FIELD_SERIALISED_LEN + FIELD_SERIALISED_LEN];


    let mut spread_index: Field = 0;

    
    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(amount),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(secret),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    let serialiseField = FieldSerialisationMethods.serialise;
    serialised_args = spread(
      serialised_args,
      serialiseField(owner),
      spread_index
    );
    spread_index += FIELD_SERIALISED_LEN;
  

    
    context.call_private_function(self.address, 0x9f7bacc8, serialised_args).public_inputs.return_values
  
  }
  
}

