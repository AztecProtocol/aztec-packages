import { BBNativeRollupProver, type BBProverConfig } from '@aztec/bb-prover';
import {
  NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP,
  NUM_BASE_PARITY_PER_ROOT_PARITY,
  PARITY_BASE_VK_INDEX,
  RECURSIVE_PROOF_LENGTH,
} from '@aztec/constants';
import { makeTuple } from '@aztec/foundation/array';
import { parseBooleanEnv } from '@aztec/foundation/config';
import { randomBytes } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { createLogger } from '@aztec/foundation/log';
import { ServerCircuitVks } from '@aztec/noir-protocol-circuits-types/server/vks';
import { getVKTreeRoot } from '@aztec/noir-protocol-circuits-types/vk-tree';
import { ParityBasePrivateInputs, ParityPublicInputs, ParityRootPrivateInputs } from '@aztec/stdlib/parity';
import { makeRecursiveProof } from '@aztec/stdlib/proofs';
import { VerificationKeyData } from '@aztec/stdlib/vks';

import { TestContext } from '../mocks/test_context.js';
import { toProofData } from '../orchestrator/block-building-helpers.js';

const logger = createLogger('prover-client:test:bb-prover-parity');

describe('prover/bb_prover/parity', () => {
  const FAKE_PROOFS = parseBooleanEnv(process.env.FAKE_PROOFS);

  let context: TestContext;
  let bbProver: BBNativeRollupProver | undefined;

  beforeAll(async () => {
    const buildProver = async (bbConfig: BBProverConfig) => {
      bbConfig.circuitFilter = ['ParityBaseArtifact', 'ParityRootArtifact'];
      bbProver = await BBNativeRollupProver.new(bbConfig);
      return bbProver;
    };
    context = await TestContext.new(logger, 1, FAKE_PROOFS ? undefined : buildProver);
  });

  afterAll(async () => {
    await context.cleanup();
  });

  it(
    'proves the parity circuits',
    async () => {
      const l1ToL2Messages = makeTuple<Fr, typeof NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP>(
        NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP,
        Fr.random,
      );
      const baseParityInputs = makeTuple(NUM_BASE_PARITY_PER_ROOT_PARITY, i =>
        ParityBasePrivateInputs.fromSlice(l1ToL2Messages, i, getVKTreeRoot()),
      );

      // Generate the base parity proofs
      const baseParityProofsAndPublicInputs = await Promise.all(
        baseParityInputs.map(baseInputs => context.prover.getBaseParityProof(baseInputs)),
      );

      const rootInputs = makeTuple(NUM_BASE_PARITY_PER_ROOT_PARITY, i => {
        const inputs = baseParityProofsAndPublicInputs[i];
        return toProofData(inputs);
      });

      // These could differ if artifacts generated by `generate_vk_json.js` are not consistent with what we do,
      // which would cause the root parity proof to fail, because the proof of VK root inclusion would not match the key in the proof.
      expect(ServerCircuitVks.ParityBaseArtifact.keyAsFields.hash).toEqual(rootInputs[0].vkData.vk.keyAsFields.hash);

      // Verify the base parity proofs
      if (bbProver) {
        await expect(
          Promise.all(
            baseParityProofsAndPublicInputs.map(input =>
              bbProver!.verifyProof('ParityBaseArtifact', input.proof.binaryProof),
            ),
          ),
        ).resolves.not.toThrow();
      }

      // Now generate the root parity proof
      const rootParityInputs = new ParityRootPrivateInputs(rootInputs);
      const rootOutput = await context.prover.getRootParityProof(rootParityInputs);

      // We only test validity and negative proofs with actual proofs enabled
      if (!bbProver) {
        return;
      }

      // Verify the root parity proof
      await expect(bbProver.verifyProof('ParityRootArtifact', rootOutput.proof.binaryProof)).resolves.not.toThrow();

      // Now test for negative cases. We will try and generate 3 invalid proofs.
      // One where a single child has an invalid proof
      // One where a child has incorrect public inputs
      // One where a child has an invalid verification key
      // In each case either the proof should fail to generate or verify

      const validVk = rootParityInputs.children[0].vkData.vk;
      const validPublicInputs = rootParityInputs.children[0].publicInputs;
      const validProof = rootParityInputs.children[0].proof;

      const defectiveProofInput = toProofData({
        inputs: validPublicInputs,
        proof: makeRecursiveProof<typeof RECURSIVE_PROOF_LENGTH>(RECURSIVE_PROOF_LENGTH, 0x500),
        verificationKey: validVk,
      });

      const shaRoot = randomBytes(32);
      shaRoot[0] = 0;

      const defectivePublicInputs = toProofData({
        inputs: new ParityPublicInputs(Fr.fromBuffer(shaRoot), Fr.random(), getVKTreeRoot()),
        proof: validProof,
        verificationKey: validVk,
      });

      const defectiveVerificationKey = toProofData(
        {
          inputs: validPublicInputs,
          proof: validProof,
          verificationKey: VerificationKeyData.makeFakeHonk(),
        },
        PARITY_BASE_VK_INDEX,
      );

      const tupleWithDefectiveProof = makeTuple(NUM_BASE_PARITY_PER_ROOT_PARITY, (i: number) => {
        if (i == 0) {
          return defectiveProofInput;
        }
        return rootParityInputs.children[i];
      });

      const tupleWithDefectiveInputs = makeTuple(NUM_BASE_PARITY_PER_ROOT_PARITY, (i: number) => {
        if (i == 0) {
          return defectivePublicInputs;
        }
        return rootParityInputs.children[i];
      });

      const tupleWithDefectiveVK = makeTuple(NUM_BASE_PARITY_PER_ROOT_PARITY, (i: number) => {
        if (i == 0) {
          return defectiveVerificationKey;
        }
        return rootParityInputs.children[i];
      });

      // Check the invalid VK scenario with an invalid witness assertion
      await expect(
        context.prover.getRootParityProof(new ParityRootPrivateInputs(tupleWithDefectiveVK)),
      ).rejects.toThrow('Failed to generate witness');

      for (const t of [tupleWithDefectiveProof, tupleWithDefectiveInputs]) {
        await expect(async () => {
          const result = await context.prover.getRootParityProof(new ParityRootPrivateInputs(t));
          await bbProver!.verifyProof('ParityRootArtifact', result.proof.binaryProof);
          fail('Proof should not be generated and verified');
        }).rejects.toThrow(/Failed to generate proof|Failed to verify proof/);
      }
    },
    FAKE_PROOFS ? undefined : 600_000,
  );
});
