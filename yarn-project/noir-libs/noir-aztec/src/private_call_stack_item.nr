use crate::abi::CallContext;
use crate::abi::hash_args;
use crate::abi::ContractDeploymentData;
use crate::abi::FunctionData;
use crate::context::Context;
use crate::abi::PrivateCircuitPublicInputs;
use crate::abi::CommitmentTreesRoots;
use crate::types::vec::BoundedVec;
use crate::types::point::Point;
use crate::utils::arr_copy_slice;
use crate::constants_gen;

use crate::oracle::call_private_function::call_private_function_internal;
use crate::oracle::arguments;

struct PrivateCallStackItem {
    contract_address: Field,
    function_data: FunctionData,
    public_inputs: PrivateCircuitPublicInputs,
    is_execution_request: bool,
}

impl PrivateCallStackItem {
    fn call<ARGS_COUNT>(
        contract_address: Field, 
        function_selector: Field, 
        args: [Field; ARGS_COUNT], 
        mut context: Context) -> (Self, Context) {
        let args_hash = hash_args(args);
        assert(args_hash == arguments::pack_arguments(args));
        PrivateCallStackItem::call_with_packed_args(contract_address, function_selector, args_hash, context)
    }

    fn call_with_packed_args(contract_address: Field, function_selector: Field, args_hash: Field, mut context: Context) -> (Self, Context) {
        let fields = call_private_function_internal(
            contract_address, 
            function_selector, 
            args_hash
        );
        let item = PrivateCallStackItem {
            contract_address: fields[0],
            function_data: FunctionData {
                function_selector: fields[1],
                is_internal: fields[2] as bool,
                is_private: fields[3] as bool,
                is_constructor: fields[4] as bool,
            },
            public_inputs: PrivateCircuitPublicInputs {
                call_context: CallContext {
                    msg_sender : fields[5],
                    storage_contract_address : fields[6],
                    portal_contract_address : fields[7],
                    
                    is_delegate_call : fields[8] as bool,
                    is_static_call : fields[9] as bool,
                    is_contract_deployment: fields[10] as bool,
                },
                // TODO handle the offsets as a variable incremented during extraction?
                args_hash: fields[11],
                return_values: arr_copy_slice(fields, [0; constants_gen::RETURN_VALUES_LENGTH], 12),
                read_requests: arr_copy_slice(fields, [0; constants_gen::MAX_READ_REQUESTS_PER_CALL], 16),
                new_commitments: arr_copy_slice(fields, [0; constants_gen::MAX_NEW_COMMITMENTS_PER_CALL], 20),
                new_nullifiers: arr_copy_slice(fields, [0; constants_gen::MAX_NEW_NULLIFIERS_PER_CALL], 24),
                nullified_commitments: arr_copy_slice(fields, [0; constants_gen::MAX_NEW_NULLIFIERS_PER_CALL], 28),
                private_call_stack: arr_copy_slice(fields, [0; constants_gen::MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),
                public_call_stack: arr_copy_slice(fields, [0; constants_gen::MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),
                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; constants_gen::MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),
                encrypted_logs_hash: arr_copy_slice(fields, [0; constants_gen::NUM_FIELDS_PER_SHA256], 42),
                unencrypted_logs_hash: arr_copy_slice(fields, [0; constants_gen::NUM_FIELDS_PER_SHA256], 44),
                encrypted_log_preimages_length: fields[46],
                unencrypted_log_preimages_length: fields[47],
                commitment_trees_roots: CommitmentTreesRoots {
                    // Must match order in `private_circuit_public_inputs.hpp`
                    private_data_tree_root : fields[48],
                    nullifier_tree_root : fields[49],
                    contract_tree_root : fields[50],
                    l1_to_l2_messages_tree_root : fields[51],
                    blocks_tree_root : fields[52],
                },
                contract_deployment_data: ContractDeploymentData {
                    deployer_public_key: Point::new(fields[53], fields[54]),
                    constructor_vk_hash : fields[55],
                    function_tree_root : fields[56],
                    contract_address_salt : fields[57],
                    portal_contract_address : fields[58],
                },
                chain_id: fields[59],
                version: fields[60],
            },
            is_execution_request: fields[61] as bool,
        };
        assert(contract_address == item.contract_address);
        assert(function_selector == item.function_data.function_selector);

        assert(args_hash == item.public_inputs.args_hash);

        assert(item.is_execution_request == false);

        // Assert that the call context of the enqueued call generated by the oracle matches our request.
        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain
        // the msg_sender in the nested call to be equal to our address, and the execution context address
        // for the nested call to be equal to the address we actually called.
        assert(item.public_inputs.call_context.is_delegate_call == false);
        assert(item.public_inputs.call_context.is_static_call == false);
        assert(item.public_inputs.call_context.is_contract_deployment == false);
        assert(item.public_inputs.call_context.msg_sender == context.inputs.call_context.storage_contract_address);
        assert(item.public_inputs.call_context.storage_contract_address == contract_address);

        context.private_call_stack = context.private_call_stack.push(item.hash());

        (item, context)
    }

    fn hash(self) -> Field {
        dep::std::hash::pedersen_with_separator([
            self.contract_address,
            self.function_data.hash(),
            self.public_inputs.hash(),
        ], constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM)[0]
    }
}