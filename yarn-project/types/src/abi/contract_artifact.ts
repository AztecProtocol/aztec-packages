import {
  type ABIParameter,
  type ABIParameterVisibility,
  type AbiType,
  type BasicValue,
  type ContractArtifact,
  type ContractNote,
  type FieldLayout,
  type FunctionArtifact,
  FunctionType,
  type IntegerValue,
  NoteSelector,
  type StructValue,
  type TypedStructFieldValue,
} from '@aztec/foundation/abi';
import { Fr } from '@aztec/foundation/fields';

import {
  AZTEC_INITIALIZER_ATTRIBUTE,
  AZTEC_INTERNAL_ATTRIBUTE,
  AZTEC_PRIVATE_ATTRIBUTE,
  AZTEC_PUBLIC_ATTRIBUTE,
  AZTEC_VIEW_ATTRIBUTE,
  type NoirCompiledContract,
} from '../noir/index.js';
import { mockVerificationKey } from './mocked_keys.js';

/**
 * Serializes a contract artifact to a buffer for storage.
 * @param artifact - Artifact to serialize.
 * @returns A buffer.
 */
export function contractArtifactToBuffer(artifact: ContractArtifact): Buffer {
  return Buffer.from(
    JSON.stringify(artifact, (key, value) => {
      if (
        key === 'bytecode' &&
        value !== null &&
        typeof value === 'object' &&
        value.type === 'Buffer' &&
        Array.isArray(value.data)
      ) {
        return Buffer.from(value.data).toString('base64');
      }
      return value;
    }),
    'utf-8',
  );
}

/**
 * Deserializes a contract artifact from storage.
 * @param buffer - Buffer to deserialize.
 * @returns Deserialized artifact.
 */
export function contractArtifactFromBuffer(buffer: Buffer): ContractArtifact {
  return JSON.parse(buffer.toString('utf-8'), (key, value) => {
    if (key === 'bytecode' && typeof value === 'string') {
      return Buffer.from(value, 'base64');
    }
    if (typeof value === 'object' && value !== null && value.type === 'NoteSelector') {
      return new NoteSelector(Number(value.value));
    }
    if (typeof value === 'object' && value !== null && value.type === 'Fr') {
      return new Fr(BigInt(value.value));
    }
    return value;
  });
}

/**
 * Gets nargo build output and returns a valid contract artifact instance.
 * @param input - Input object as generated by nargo compile.
 * @returns A valid contract artifact instance.
 */
export function loadContractArtifact(input: NoirCompiledContract): ContractArtifact {
  if (isContractArtifact(input)) {
    return input;
  }
  return generateContractArtifact(input);
}

/**
 * Checks if the given input looks like a valid ContractArtifact. The check is not exhaustive,
 * and it's just meant to differentiate between nargo raw build artifacts and the ones
 * produced by this compiler.
 * @param input - Input object.
 * @returns True if it looks like a ContractArtifact.
 */
function isContractArtifact(input: any): input is ContractArtifact {
  if (typeof input !== 'object') {
    return false;
  }
  const maybeContractArtifact = input as ContractArtifact;
  if (typeof maybeContractArtifact.name !== 'string') {
    return false;
  }
  if (!Array.isArray(maybeContractArtifact.functions)) {
    return false;
  }
  for (const fn of maybeContractArtifact.functions) {
    if (typeof fn.name !== 'string') {
      return false;
    }
    if (typeof fn.functionType !== 'string') {
      return false;
    }
  }
  return true;
}

/** Parameter in a function from a noir contract compilation artifact */
type NoirCompiledContractFunctionParameter = NoirCompiledContractFunction['abi']['parameters'][number];

/**
 * Generates a function parameter out of one generated by a nargo build.
 * @param param - Noir parameter.
 * @returns A function parameter.
 */
function generateFunctionParameter(param: NoirCompiledContractFunctionParameter): ABIParameter {
  const { visibility } = param;
  if ((visibility as string) === 'databus') {
    throw new Error(`Unsupported visibility ${param.visibility} for noir contract function parameter ${param.name}.`);
  }
  return { ...param, visibility: visibility as ABIParameterVisibility };
}

/** Function from a noir contract compilation artifact */
type NoirCompiledContractFunction = NoirCompiledContract['functions'][number];

/**
 * Generates a function build artifact. Replaces verification key with a mock value.
 * @param fn - Noir function entry.
 * @param contract - Parent contract.
 * @returns Function artifact.
 */
function generateFunctionArtifact(fn: NoirCompiledContractFunction, contract: NoirCompiledContract): FunctionArtifact {
  if (fn.custom_attributes === undefined) {
    throw new Error(
      `No custom attributes found for contract function ${fn.name}. Try rebuilding the contract with the latest nargo version.`,
    );
  }
  const functionType = getFunctionType(fn);
  const isInternal = fn.custom_attributes.includes(AZTEC_INTERNAL_ATTRIBUTE);
  const isStatic = fn.custom_attributes.includes(AZTEC_VIEW_ATTRIBUTE);

  // If the function is not unconstrained, the first item is inputs or CallContext which we should omit
  let parameters = fn.abi.parameters.map(generateFunctionParameter);
  if (hasKernelFunctionInputs(parameters)) {
    parameters = parameters.slice(1);
  }

  let returnTypes: AbiType[] = [];
  if (functionType === FunctionType.UNCONSTRAINED && fn.abi.return_type) {
    returnTypes = [fn.abi.return_type.abi_type];
  } else {
    const pathToFind = `${contract.name}::${fn.name}_abi`;
    const abiStructs: AbiType[] = contract.outputs.structs['functions'];

    const returnStruct = abiStructs.find(a => a.kind === 'struct' && a.path === pathToFind);

    if (returnStruct) {
      if (returnStruct.kind !== 'struct') {
        throw new Error('Could not generate contract function artifact');
      }

      const returnTypeField = returnStruct.fields.find(field => field.name === 'return_type');
      if (returnTypeField) {
        returnTypes = [returnTypeField.type];
      }
    }
  }

  return {
    name: fn.name,
    functionType,
    isInternal,
    isStatic,
    isInitializer: fn.custom_attributes.includes(AZTEC_INITIALIZER_ATTRIBUTE),
    parameters,
    returnTypes,
    bytecode: Buffer.from(fn.bytecode, 'base64'),
    verificationKey: mockVerificationKey,
    debugSymbols: fn.debug_symbols,
    assertMessages: fn.assert_messages,
  };
}

function getFunctionType(fn: NoirCompiledContractFunction): FunctionType {
  if (fn.custom_attributes.includes(AZTEC_PRIVATE_ATTRIBUTE)) {
    return FunctionType.PRIVATE;
  } else if (fn.custom_attributes.includes(AZTEC_PUBLIC_ATTRIBUTE)) {
    return FunctionType.PUBLIC;
  } else if (fn.is_unconstrained) {
    return FunctionType.UNCONSTRAINED;
  } else {
    // Default to a private function (see simple_macro_example_expanded for an example of this behavior)
    return FunctionType.PRIVATE;
  }
}

/**
 * Returns true if the first parameter is kernel function inputs.
 *
 * Noir macros #[aztec(private|public)] inject the following code
 * fn <name>(inputs: <Public|Private>ContextInputs, ...otherparams) {}
 *
 * Return true if this injected parameter is found
 */
function hasKernelFunctionInputs(params: ABIParameter[]): boolean {
  const firstParam = params[0];
  return firstParam?.type.kind === 'struct' && firstParam.type.path.includes('ContextInputs');
}

/**
 * Generates a storage layout for the contract artifact.
 * @param input - The compiled noir contract to get storage layout for
 * @returns A storage layout for the contract.
 */
function getStorageLayout(input: NoirCompiledContract) {
  // If another contract is imported by the main contract, its storage layout its going to also show up here.
  // The layout export includes the contract name, so here we can find the one that belongs to the current one and
  // ignore the rest.
  const storageExports = input.outputs.globals.storage ? (input.outputs.globals.storage as StructValue[]) : [];
  const storageForContract = storageExports.find(storageExport => {
    const contractNameField = storageExport.fields.find(field => field.name === 'contract_name')?.value as BasicValue<
      'string',
      string
    >;
    return contractNameField.value === input.name;
  });
  const storageFields = storageForContract
    ? ((storageForContract.fields.find(field => field.name == 'fields') as TypedStructFieldValue<StructValue>).value
        .fields as TypedStructFieldValue<StructValue>[])
    : [];

  if (storageFields.length === 0) {
    return {};
  }

  return storageFields.reduce((acc: Record<string, FieldLayout>, field) => {
    const name = field.name;
    const slot = field.value.fields[0].value as IntegerValue;
    acc[name] = {
      slot: Fr.fromString(slot.value),
    };
    return acc;
  }, {});
}

/**
 * Generates records of the notes with note type ids of the artifact.
 * @param input - The compiled noir contract to get note types for
 * @return A record of the note types and their ids
 */
function getNoteTypes(input: NoirCompiledContract) {
  // The type is useless here as it does not give us any guarantee (e.g. `AbiValue` can be one of many different
  // types) so we nuke it and later we manually check the values are as we expect.
  const notes = input.outputs.globals.notes as any[];

  if (!notes) {
    return {};
  }

  return notes.reduce((acc: Record<string, ContractNote>, note) => {
    const noteFields = note.fields;

    // We find note type id by looking for respective kinds as each of them is unique
    const rawNoteTypeId = noteFields.find((field: any) => field.kind === 'integer');
    const rawName = noteFields.find((field: any) => field.kind === 'string');
    const rawNoteFields = noteFields.find((field: any) => field.kind === 'struct');

    if (!rawNoteTypeId || !rawName || !rawNoteFields) {
      throw new Error(`Could not find note type id, name or fields for note ${note}`);
    }

    const noteTypeId = NoteSelector.fromField(Fr.fromString(rawNoteTypeId.value));
    const name = rawName.value as string;

    // Note type id is encoded as a hex string
    const fields = rawNoteFields.fields.map((field: any) => {
      return {
        name: field.name,
        index: parseInt(field.value.fields[0].value.value, 16),
        nullable: field.value.fields[1].value.value,
      };
    });
    acc[name] = {
      id: noteTypeId,
      typ: name,
      fields,
    };
    return acc;
  }, {});
}

/**
 * Given a Nargo output generates an Aztec-compatible contract artifact.
 * @param compiled - Noir build output.
 * @returns Aztec contract build artifact.
 */
function generateContractArtifact(contract: NoirCompiledContract, aztecNrVersion?: string): ContractArtifact {
  try {
    return {
      name: contract.name,
      functions: contract.functions.map(f => generateFunctionArtifact(f, contract)),
      outputs: contract.outputs,
      storageLayout: getStorageLayout(contract),
      notes: getNoteTypes(contract),
      fileMap: contract.file_map,
      aztecNrVersion,
    };
  } catch (err) {
    throw new Error(`Could not generate contract artifact for ${contract.name}: ${err}`);
  }
}
