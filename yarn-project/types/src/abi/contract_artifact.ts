import {
  ABIParameter,
  ABIParameterVisibility,
  ABIType,
  ContractArtifact,
  FunctionArtifact,
  FunctionType,
} from '@aztec/foundation/abi';

import { NoirCompiledContract } from '../noir/index.js';
import { mockVerificationKey } from './mocked_keys.js';

/**
 * Serializes a contract artifact to a buffer for storage.
 * @param artifact - Artifact to serialize.
 * @returns A buffer.
 */
export function contractArtifactToBuffer(artifact: ContractArtifact): Buffer {
  // TODO(@spalladino): More efficient serialization
  return Buffer.from(JSON.stringify(artifact), 'utf8');
}

/**
 * Deserializes a contract artifact from storage.
 * @param buffer - Buffer to deserialize.
 * @returns Deserialized artifact.
 */
export function contractArtifactFromBuffer(buffer: Buffer): ContractArtifact {
  // TODO(@spalladino): More efficient serialization
  return JSON.parse(buffer.toString('utf8')) as ContractArtifact;
}

/**
 * Gets nargo build output and returns a valid contract artifact instance.
 * @param input - Input object as generated by nargo compile.
 * @returns A valid contract artifact instance.
 */
export function loadContractArtifact(input: NoirCompiledContract): ContractArtifact {
  if (isContractArtifact(input)) {
    return input;
  }
  const contractArtifact = generateContractArtifact(input);
  validateContractArtifact(contractArtifact);
  return contractArtifact;
}

/**
 * Checks if the given input looks like a valid ContractArtifact. The check is not exhaustive,
 * and it's just meant to differentiate between nargo raw build artifacts and the ones
 * produced by this compiler.
 * @param input - Input object.
 * @returns True if it looks like a ContractArtifact.
 */
function isContractArtifact(input: any): input is ContractArtifact {
  if (typeof input !== 'object') {
    return false;
  }
  const maybeContractArtifact = input as ContractArtifact;
  if (typeof maybeContractArtifact.name !== 'string') {
    return false;
  }
  if (!Array.isArray(maybeContractArtifact.functions)) {
    return false;
  }
  for (const fn of maybeContractArtifact.functions) {
    if (typeof fn.name !== 'string') {
      return false;
    }
    if (typeof fn.functionType !== 'string') {
      return false;
    }
  }
  return true;
}

/** Parameter in a function from a noir contract compilation artifact */
type NoirCompiledContractFunctionParameter = NoirCompiledContractFunction['abi']['parameters'][number];

/**
 * Generates a function parameter out of one generated by a nargo build.
 * @param param - Noir parameter.
 * @returns A function parameter.
 */
function generateFunctionParameter(param: NoirCompiledContractFunctionParameter): ABIParameter {
  const { visibility } = param;
  if ((visibility as string) === 'databus') {
    throw new Error(`Unsupported visibility ${param.visibility} for noir contract function parameter ${param.name}.`);
  }
  return { ...param, visibility: visibility as ABIParameterVisibility };
}

/** Function from a noir contract compilation artifact */
type NoirCompiledContractFunction = NoirCompiledContract['functions'][number];

/**
 * Generates a function build artifact. Replaces verification key with a mock value.
 * @param fn - Noir function entry.
 * @returns Function artifact.
 */
function generateFunctionArtifact(fn: NoirCompiledContractFunction): FunctionArtifact {
  const functionType = fn.function_type.toLowerCase() as FunctionType;
  const isInternal = fn.is_internal;

  // If the function is not unconstrained, the first item is inputs or CallContext which we should omit
  let parameters = fn.abi.parameters.map(generateFunctionParameter);
  if (functionType !== 'unconstrained') {
    parameters = parameters.slice(1);
  }

  // If the function is secret, the return is the public inputs, which should be omitted
  let returnTypes: ABIType[] = [];
  if (functionType !== 'secret' && fn.abi.return_type) {
    returnTypes = [fn.abi.return_type.abi_type];
  }

  return {
    name: fn.name,
    functionType,
    isInternal,
    parameters,
    returnTypes,
    bytecode: fn.bytecode,
    verificationKey: mockVerificationKey,
    debugSymbols: fn.debug_symbols,
  };
}

/** Validates contract artifact instance, throwing on error. */
function validateContractArtifact(contract: ContractArtifact) {
  const constructorArtifact = contract.functions.find(({ name }) => name === 'constructor');
  if (constructorArtifact === undefined) {
    throw new Error('Contract must have a constructor function');
  }
  return contract;
}

/**
 * Given a Nargo output generates an Aztec-compatible contract artifact.
 * @param compiled - Noir build output.
 * @returns Aztec contract build artifact.
 */
function generateContractArtifact(contract: NoirCompiledContract, aztecNrVersion?: string): ContractArtifact {
  return {
    name: contract.name,
    functions: contract.functions.map(generateFunctionArtifact),
    events: contract.events,
    fileMap: contract.file_map,
    aztecNrVersion,
  };
}
