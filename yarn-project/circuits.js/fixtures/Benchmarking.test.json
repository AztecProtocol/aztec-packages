{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "Benchmarking",
  "functions": [
    {
      "name": "create_note",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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oI43bUEdb9qCOt60AfWAN21BHW/agjretAV1vGkL6gL1BtTxpi2o401bUMebtqCON21BHW96BPWdp5Ai3rQFdbxpC+p40xbU8aaHXE0fP3EXBeoNqONNG3SOEW/agjretAV1vGkL6njTBtQT3rQFdbxpC+p40xbU8aYtqAvUG1DHm7agjjdtQR1v2oI63rQFdbxpA+oZb9qCOt60BXW8aQvqeNMW1AXqDajjTVtQx5seQX3neZiMN21BHW/agjre9PXUw4I3PeRq+vDZr7DgTVtQx5u+vnMMC960BXWBegPqeNMW1PGmLajjTVtQx5u2oI43bUDd4E1bUMebtqCON21BHW/agrpAvQF1vGkL6njTFtTxpi2o401bUMebNqBu8aYtqONNW1DHmx5BfefJDIs3bUFdoN6AOt60BXW86SFX08dPIVm8aQvqeNMWnSPetAF1hzdtQR1v2oI63rQFdbxpC+oC9QbU8aYtqONNW1DHm7agjjdtQR1v2oC64E1bUMebtqCON21BHW/agrpAvQF1vGkL6njTFtTxpkdQ33lGQPCmLajjTRtQ93jTFtTxpodcTR8/D+Pxpi2o400bdI5eoN6AOt60BXW8aQvqeNMW1PGmLajjTRtQD3jTFtTxpi2o401bUMebtqAuUG9AHW/agjretAV1vGkL6njTFtTxpg2oR7xpC+p40yOo79ytjnjTFtTxpi2oC9QbUMebHnI1ffxkRsSbtqCON23ROeJNW1DHmzagnvCmLajjTVtQx5u2oI43bUFdoN6AOt60BXW8aQvqeNMW1PGmLajjTRtQz3jTFtTxpi2o401bUMebtqAuUP/Ty++bZrxpC+p40xbU8aYtqONND7maPn5GIONNX089LnjT13eOccGbtqCON21BHW/agrpAvQF1vGkL6njTFtTxpi2o401bUMebNqBu8KYtqONNW1DHm7agjjdtQV2g3oA63rQFdbzpEdQf38GLBm/agjretAV1vGkD6hZvesjV9PHdaos3bUEdb9qgc7R40xbUBeoNqONNW1DHm7agjjdtQR1v2oI63rQBdYc3bUEdb9qCOt60BXW8aQvqAvUG1PGmLajjTVtQx5seQX3nXpLDm7agjjdtQF3wpi2o400PuZo+vm8qeNMW1PGmDTpHEag3oI43bUEdb9qCOt60BXW8aQvqeNMG1D3etAV1vGkL6njTFtTxpi2oC9QbUMebtqCON21BHW96BPWduxoeb9qCOt60AfWAN21BHW96yNX08R28gDdtQR1v2qBzDAL1BtTxpi2o401bUMebtqCON21BHW/agHrEm7agjjdtQR1v2oI63rQFdYF6A+p40xbU8aZHUN/J1yPetAV1vGkL6njTBtQT3vSQq+nje0kJb9qCOt60QeeY8KYtqAvUG1DHm7agjjdtQR1v2oI63rQFdbxpA+oZb9qCOt60BXW8aQvqeNMW1AXqf3p50pvxpi2o401bUMebtqCONz3kavr4rkbGm76eelrwpq/vHNOCN21BHW/agjretAV1gXoD6njTFtTxpi2o401bUMebtqCON21A3eBNW1DHm74+c0wGb9qCOt60BXWBegPqeNNDrqaP83WDN21BHW/aonPEm7agjjdtQN3iTVtQx5u2oI43bUEdb9qCukC9AXW8aQvqeNMW1PGmDdIvizdtQR1v2oC6w5u2oI43bZD0OrxpC+p40wadoxOoN6CON21BHW/agjretAV1vGkL6njTBtQFb9qCOt60BXW8aYMcRvCmLagL1BtQx5u2oI43bZA5Ct60BXW8aYvOEW/agLrHm7agjjdtQR1v2oI63rQFdYF6A+p40xbU8aYNEgGPN21BHW/agjretAH1gDdtkH4FvGkL6njTBp1jwJu2oC5Qb0Adb9qCOt60BXW8aQvqeNMW1PGmDbxpxJu2oI43bUEdb9qCOt60QQ4TBeoNqONNG3SOEW/agjretAV1vGkL6njTBtQT3rQFdbxpA5eU8KYtqONNW1AXqDegjjdtkAgkvGkL6njTFp0j3rQFdbxpA+oZb9qCOt60BXW8aYN+PeNNW1AXqDegjjdtQR1v2sCbZrxpC+p40xadI9709dTzgjdtQR1v2oI63vT1nWNe8KYtqAvUG1DHm7agjjd9vUs6XWGh3oA63rRF54g3bUDd4E1bUMebNuhhDN60BXW8aQvqAvUG1PGmDfp1gzdtQR1v2qJzxJu2oI43bXA1tXjTFtTxpi2o401bUMebNugcrUC9AXW8aYPO0eJNW5zX8aYtqONNW1DHmzag7vCmDXoYhzdtQR1v2uIMgzdtQV2g3oA63rQFdbxpi6sp3rQFdbzpc9STXA7SJr/sUXfpMpEsS7weZips7Hy+zMOF5VoiE0sbW3eZh7Nibzf+LCemd6RyCm56qHJi04cqJ/7/vcrp1so4l9JdOQkWhiqnUM63Kufpz102Fmsfb2yTW9ZJy97GRtaNjY93QiFkQSjnje1yqYy1bmdjHy918TnfHt6npoiQ0JS2pgjI0JS2poj/0NSXprxfNRXTTzRFBommlDXlCULR1Hnjq+u3LrvfzZwnYkUoTwmF8BahPCUUYmGE8pRQBKEglM+NZZ2G9S4+3tj4ZC/swrLcqYp0GlXpq4p8GlVVqCralV305ieGnjAbATYVIMk3AmwqQGJyBFgjwLishfnVhH5TgIFMHQE2FSBZ/cgCDNdJ793703ugIRDroyltTXEHAE19aUrrgYYgaApNKWuKWwUDayrLZRo2x5+l/4H0H6E8JRRSeoSinHsGgnc0pa0psnQ0paypSDyOpv6sm3hHEm80pa0pEu8301Ryq6byXjjU5rXQSOKNprQ1JWgKTf1DNfGOJN5oSltThOMja+o7d+Ye/25UJBxHKNpNEuE4mtLWFOE4mlLWVCIcR1PKjXciHEdT2poiHEdT540f/3hHIvFGKE8JRRAKQnlGKGTTCOW8seIPtyTSaVSlryqibFRVoSq1hy0TuTcCbCpAQnIE2FKAmUQdAdYIUOs54kz8jgCbCpCsfmABKr6VnMnqEcpTQhGEglCU+3RifTSlrSlCfTSlrSkifTSl7dBI6dGUtqYI3p/UVJRSglPWVIyXByhjum7rP4ibZSFqfjlywtWXIydOfA55tutbjvkD8w3yM0jiNiWQAkgdkDNnMNetxZrHIJO7pKMp7jB3cYV3wnHT0IUv5DNHFI2Qz+zgD0KesrkgzyXkMxvcRshn9n9tkJuZ/V8j5DP7v0bIZ/Z/jZDP7BQbIReQvxr5UO7T+9WYL8HsIE8pXqaS8t7fDnm5cAzZ7NzXSHa9+5BssLcbn6EP5T/fBfpQDvRdoA/lQd8F+lAu9E2g26F86LtAH8qJvgv0obzou0Afyo2+C3QB+uuh40gbQMeRNoCOI20AHUfaADqO9PXQHY60AXQcaQPoONIG0HGkDaAL0F8PHUfaADqOtAF0HGkD6DjSBtBxpK+HLjjSBtBxpA2g40gbQMeRNoAuQH89dBxpA+g40gbQcaQNoONIG0DHkT4FPVq5/Olog9xx9JhMHY74Rh2OWMEnOebLxtGZAkfcnQ5HgaMKRzyYDkdslQ5HnJLO9Rrzo8MRP6PCMeBnVM6PAT+jwxE/o8MRP6PDUeCowhE/o8MRP6PDET+j0z/iZ3Q44mdUOEb8jA5H/IwOR/yMyvU64md0OAocVTjiZ3Q44md0OOJndDjiZ3Q44mdUOCb8jA5H/IyKn0n4GR2O+BkdjgJHFY74GR2O+Bmd6zV+RocjfkaHI35GhWPGz+hwxM/ocMTP6HDEz+hwFDiqcMTPqPiZjJ/R4Yif0eGIn9HhiJ/R4GgW/IzG9dos+BkdjvgZHY74GR2OAkcVjvgZHY74GR2O+BkdjvgZHY74GRU/Y/AzOhzxMzoc8TM6HPEzOhwFjhrXa4Of0eGIn9HhiJ/R4Yif0eGIn1HhaPEzOhzxMzoc8TM6HPEzKn7GChxVOOJndDjiZ3Q44md0OOJndK7X+BkVjg4/o8MRP6PDET+jwxE/o8NR4KjCET+jwxE/o8MRP6PiZxx+RocjfkaFo+BndDjiZ3Q44mdUrteCn9HhKHBU4Yif0eGIn9HhiJ/R4Yif0eGIn1Hh6PEzOhzxMyp+xuNndDjiZ3Q4ChxVOOJndDjiZ3Su1/gZHY74GR2O+BkVjgE/o8MRP6PDET+jwxE/o8NR4KjCET+j4mcCfkaHI35GhyN+RocjfkaFY8TPqFyvI35GhyN+RocjfkaHo8BRhSN+RocjfkaHI35GhyN+RocjfkbFzyT8jA5H/IwOR/yMDkf8jA5HgaPG9TrhZ3Q44md0OOJndDjiZ3Q44mdUOGb8jA5H/IwOR/yMDkf8jIqfyQJHFY74GR2O+BkdjvgZHY74GZ3rNX5Gg6Nd8DM6HPEzOhzxMzoc8TM6HAWOKhzxMzoc8TM6HPEzGn7GLvgZHY74GRWOBj+jwxE/o8MRP6NyvTb4GR2OAkcVjvgZHY74GR2O+BkdjvgZHY74GRWOFj+jwxE/o+JnLH5GhyN+RoejwFGFI35GhyN+Rud6jZ/R4Yif0eGIn1Hh6PAzOhzxMzoc8TM6HPEzOhwFjioc8TMqfsbhZ3Q44md0OOJndDjiZ1Q4Cn5G5Xot+BkdjvgZHY74GR2OAkcVjvgZHY74GR2O+BkdjvgZHY74GRU/4/EzOhzxMzoc8TM6HPEzOhwFjhrXa4+f0eGIn9HhiJ/R4Yif0eGIn1HhGPAzOhzxMzoc8TM6HPEzKn4mCBxVOOJndDjiZ3Q44md0OOJndK7X+BkVjhE/o8MRP6PDET+jwxE/o8NR4KjCET+jwxE/o8MRP6PiZyJ+RocjfkaFY8LP6HDEz+hwxM+oXK8TfkaHo8BRhSN+RocjfkaHI35GhyN+RocjfkaFY8bP6HDEz6j4mYyf0eGIn9HhKHBU4Yif0eGIn9G5XuNndDjiZ3Q44mc0OLoFP6PDET+jwxE/o8MRP6PDUeCowhE/o+Fn3IKf0eGIn9HhiJ/R4YifUeFo8DMq12uDn9HhiJ/R4Yif0eEocFThiJ/R4Yif0eGIn9HhiJ/R4YifUfEzFj+jwxE/o8MRP6PDET+jw1HgqHG9tvgZHY74GR2O+BkdjvgZHY74GRWODj+jwxE/o8MRP6PDET+j4mecwFGFI35GhyN+RocjfkaHI35G53qNn1HhKPgZHY74GR2O+BkdjvgZHY4CRxWO+BkdjvgZHY74GRU/I/gZHY74GRWOHj+jwxE/o8MRP6Nyvfb4GR2OAkcVjvgZHY74GR2O+BkdjvgZHY74GRWOAT+jwxE/o+JnAn5GhyN+RoejwFGFI35GhyN+Rud6jZ/R4Yif0eGIn1HhGPEzOhzxMzoc8TM6HPEzOhwFjioc8TMqfibiZ3Q44md0OOJndDjiZ1Q4JvyMyvU64Wd0OOJndDjiZ3Q4ChxVOOJndDjiZ3Q44md0OOJndDjiZ1T8TMbP6HDEz+hwxM/ocMTP6HAUOGpcrzN+RocjfkaHI35GhyN+RocjfkaDoyz4GR2O+BkdjvgZHY74GQ0/I4vAUYUjfkaHI35GhyN+Rocjfkbneo2fUeFo8DM6HPEzOhzxMzoc8TM6HAWOKhzxMzoc8TM6HPEzKn7G4Gd0OOJnVDha/IwOR/yMDkf8jMr12uJndDgKHFU44md0OOJndDjiZ3Q44md0OOJnVDg6/IwOR/yMip9x+BkdjvgZHY4CRxWO+BkdjvgZnes1fkaHI35GhyN+RoWj4Gd0OOJndDjiZ3Q44md0OAocVTjiZ1T8jOBndDjiZ3Q44md0OOJnVDh6/IzK9drjZ3T0iJ/R4Yif0eEocFThiJ/R4Yif0ble42d09Iif0eGIn1HhGPAzOhzxMzoc8TMq1+uAn9HhKHBU4Yif0eGIn3mOo1h/4Sg23nOc189kF+3X1tnlnY1DXszXxiGbXzgWKmRFLhWywd5Dn9f8NIQ+r1NqBz3Oa6saQp/XgzWEPq9hawh9XnfXELoA/fXQ5/WNDaHPazIbQseRNoCOI20AHUf6eugJR9oAOo60AXQcaQPoONIG0AXor4eOI20AHUfaADqOtAF0HGkD6DjS10PPONIG0HGkDaDjSBtAx5E2gC5Afz10HGkD6DjSBtBxpA2g40gbQMeRvhy6X3CkDaDjSJ+CvvPmpF8wmToc8Y06HAWOz3F8+MafX3B3OhwxbDoc8WA6HLFVOhxxSirXa4P50eGIn9HhiJ9ROT8a/IwOR4GjCkf8jA5H/IwOR/yMDkf8jA5H/IxK/2jxMzoc8TM6HPEzOhzxMzocBY4a12uLn9HhiJ/R4Yif0eGIn9HhiJ9R4ejwMzoc8TM6HPEzOhzxMyp+xgkcVTjiZ3Q44md0OOJndDjiZ3Su1/gZFY6Cn9HhiJ/R4Yif0eGIn9HhKHBU4Yif0eGIn9HhiJ9R8TOCn9HhiJ9R4ejxMzoc8TM6HPEzKtdrj5/R4ShwVOGIn9HhiJ/R4Yif0eGIn9HhiJ9R4RjwMzoc8TMqfibgZ3Q44md0OAocVTjiZ3Q44md0rtf4GR2O+BkdjvgZFY4RP6PDET+jwxE/o8MRP6PDUeCowhE/o+JnIn5GhyN+RocjfkaHI35GhWPCz6hcrxN+RocjfkaHI35Gh6PAUYUjfkaHI35GhyN+RocjfkaHI35Gxc9k/IwOR/yMDkf8jA5H/IwOR4GjxvU642d0OOJndDjiZ3Q44md0OOJnNDiGBT+jwxE/o8MRP6PDET+j4WfCInBU4Yif0eGIn9HhiJ/R4Yif0ble42dUOBr8jA5H/IwOR/yMDkf8jA5HgaMKR/yMDkf8jA5H/IyKnzH4GR2O+BkVjhY/o8MRP6PDET+jcr22+BkdjgJHFY74GR2O+BkdjvgZHY74GR2O+BkVjg4/o8MRP6PiZxx+RocjfkaHo8BRhSN+Rocjfkbneo2f0eGIn9HhiJ9R4Sj4GR2O+BkdjvgZHY74GR2OAkcVjvgZFT8j+BkdjvgZHY74GR2O+BkVjh4/o3K99vgZHY74GR2O+BkdjgJHFY74GR2O+BkdjvgZHY74GR2O+BkVPxPwMzoc8TM6HPEzOhzxMzocBY4a1+uAn9HhiJ/R4Yif0eGIn9HhiJ9R4RjxMzoc8TM6HPEzOhzxMyp+JgocVTjiZ3Q44md0OOJndDjiZ3Su1/gZFY4JP6PDET+jwxE/o8MRP6PDUeCowhE/o8MRP6PDET+j4mcSfkaHI35GhWPGz+hwxM/ocMTPqFyvM35Gh6PAUYUjfkaHI35GhyN+RocjfkaHI35Gg2Nc8DM6HPEzGn4mLvgZHY74GR2OAkcVjvgZHY74GZ3rNX5GhyN+RocjfkaFo8HP6HDEz+hwxM/ocMTP6HAUOKpwxM+o+BmDn9HhiJ/R4Yif0eGIn1HhaPEzKtdri5/R4Yif0eGIn9HhKHBU4Yif0eGIn9HhiJ/R4Yif0eGIn1HxMw4/o8MRP6PDET+jwxE/o8NR4KhxvXb4GR2O+BkdjvgZHY74GR2O+BkVjoKf0eGIn9HhiJ/R4YifUfEzInBU4Yif0eGIn9HhiJ/R4Yif0ble42dUOHr8jA5H/IwOR/yMDkf8jA5HgaMKR/yMDkf8jA5H/IyKn/H4GR2O+BkVjgE/o8MRP6PDET+jcr0O+BkdjgJHFY74GR2O+BkdjvgZHY74GR2O+BkVjhE/o8MRP6PiZyJ+RocjfkaHo8BRhSN+Rocjfkbneo2f0eGIn9HhiJ9R4ZjwMzoc8TM6HPEzOhzxMzocBY4qHPEzKn4m4Wd0OOJndDjiZ3Q44mdUOGb8jMr1OuNndDjiZ3Q44md0OAocVTjiZ3Q44md0OOJndDjiZ3Q44mc0/Exa8DM6HPEzOhzxMzoc8TM6HAWOCtfrtOBndDjiZ3Q44md0OOJndDjiZ1Q4GvyMDkf8jA5H/IwOR/yMip8xAkcVjvgZHY74GR2O+BkdjvgZnes1fkaFo8XP6HDEz+hwxM/ocMTP6HAUOKpwxM/ocMTP6HDEz6j4GYuf0eGIn1Hh6PAzOhzxMzoc8TMq12uHn9HhKHBU4Yif0eGIn9HhiJ/R4Yif0eGIn1HhKPgZHY74GRU/I/gZHY74GR2OAkcVjvgZHY74GZ3rNX5GhyN+RocjfkaFo8fP6HDEz+hwxM/ocMTP6HAUOKpwxM+o+BmPn9HhiJ/R4Yif0eGIn1HhGPAzKtfrgJ/R4Yif0eGIn9HhKHBU4Yif0eGIn9HhiJ/R4Yif0eGIn1HxMxE/o8MRP6PDET+jwxE/o8NR4KhxvY74GR2O+BkdjvgZHY74GR2O+BkVjgk/o8MRP6PDET+jwxE/o+JnksBRhSN+RocjfkaHI35GhyN+Rud6jZ9R4ZjxMzoc8TM6HPEzOhzxMzocBY4qHPEzOhzxMzoc8TMqfibjZ3Q44mc0OOYFP6PDET+jwxE/o3G9zgt+RkePAkcVjvgZHY74GR2O+BkdjvgZnes1fkZFjwY/o8MRP6PDET+jwxE/o8NR4KhxvTb4GR2O+BkdjvgZHY74mec4ivUXjmLjPUf8zFMcw+nOwdfG4bSIbzneb5ysyNfGyQZ7B91ifhpAxyk1gI6tagAdD9YAugD99dBxdw2gYwUbQMc3NoCOyWwAHUf6eugOR9oAOo60AXQcaQPoONIG0AXor4eOI20AHUfaADqOtAF0HGkD6DjS10MXHGkD6DjSBtBxpA2g40gbQBegvx46jrQBdBxpA+g40gbQcaQNoONIXw/d40gbQMeRNoCOI20AHUf6FPS9Nye9wFGFI75RhyNW8EmOj9/487g7HY4YNh2OeDAVjgFbpcMRp6RyvQ6YHx2O+BkdjgJHlfMjfkaHI35GhyN+RocjfkaHI35GhWPEz+hwxM+o9I8RP6PDET+jw1HgqMIRP6PDET+jc73Gz+hwxM/ocMTPqHBM+BkdjvgZHY74GR2O+BkdjgJHFY74GRU/k/AzOhzxMzoc8TM6HPEzKhwzfkblep3xMzoc8TM6HPEzOhwFjioc8TM6HPEzOhzxMzoc8TM6HPEzCn7GLgt+RocjfkaHI35GhyN+RoejwPHn1+sTR/yMDkf8jA5H/IwOR/yMDkf8jApHg5/R4Yif0eGIn9HhiJ9R8TNG4KjCET+jwxE/o8MRP6PDET+jc73Gz6hwtPgZHY74GR2O+BkdjvgZHY4CRxWO+BkdjvgZHY74GRU/Y/EzOhzxMyocHX5GhyN+Rocjfkbleu3wMzocBY4qHPEzOhzxMzoc8TM6HPEzOhzxMyocBT+jwxE/o+JnBD+jwxE/o8NR4KjCET+jwxE/o3O9xs/ocMTP6HDEz6hw9PgZHY74GR2O+BkdjvgZHY4CRxWO+BkVP+PxMzoc8TM6HPEzOhzxMyocA35G5Xod8DM6HPEzOhzxMzocBY4qHPEzOhzxMzoc8TM6HPEzOhzxMyp+JuJndDjiZ3Q44md0OOJndDgKHDWu1xE/o8MRP6PDET+jwxE/o8MRP6PCMeFndDjiZ3Q44md0OOJnVPxMEjiqcMTP6HDEz+hwxM/ocMTP6Fyv8TMqHDN+RocjfkaHI35GhyN+RoejwFGFI35GhyN+RocjfkbFz2T8jA5H/IwGR7PgZ3Q44md0OOJnNK7XZsHP6HAUOKpwxM/ocMTP6HDEz+hwxM/ocMTPqHA0+BkdjvgZFT9j8DM6HPEzOhwFjioc8TM6HPEzOtdr/IwOR/yMDkf8jApHi5/R4Yif0eGIn9HhiJ/R4ShwVOGIn1HxMxY/o8MRP6PDET+jwxE/o8LR4WdUrtcOP6PDET+jwxE/o8NR4KjCET+jwxE/o8MRP6PDET+jwxE/o+JnBD+jwxE/o8MRP6PDET+jw1HgqHG9FvyMDkf8jA5H/IwOR/yMDkf8jApHj5/R4Yif0eGIn9HhiJ9R8TNe4KjCET+jwxE/o8MRP6PDET+jc73Gz6hwDPgZHY74GR2O+BkdjvgZHY4CRxWO+BkdjvgZHY74GRU/E/AzOhzxMyocI35GhyN+Rocjfkbleh3xMzocBY4qHPEzOhzxMzoc8TM6HPEzOhzxMyocE35GhyN+RsXPJPyMDkf8jA5HgaMKR/yMDkf8jM71Gj+jwxE/o8MRP6PCMeNndDjiZ3Q44md0OOJndDgKHFU44mdU/EzGz+hwxM/ocMTP6HDEz2hwtAt+RuN6bRf8jA5H/IwOR/yMDkeBowpH/IwOR/yMDkf8jA5H/IwOR/yMip8x+BkdjvgZHY74GR2O+BkdjgJHjeu1wc/ocMTP6HDEz+hwxM/ocMTPqHC0+BkdjvgZHY74GR2O+BkVP2MFjioc8TM6HPEzOhzxMzoc8TM612v8jApHh5/R4Yif0eGIn9HhiJ/R4ShwVOGIn9HhiJ/R4YifUfEzDj+jwxE/o8JR8DM6HPEzOhzxMyrXa8HP6HAUOKpwxM/ocMTP6HDEz+hwxM/ocMTPqHD0+BkdjvgZFT/j8TM6HPEzOhwFjioc8TM6HPEzOtdr/IwOR/yMDkf8jArHgJ/R4Yif0eGIn9HhiJ/R4ShwVOGIn1HxMwE/o8MRP6PDET+jwxE/o8Ix4mdUrtcRP6PDET+jwxE/o8NR4KjCET+jwxE/o8MRP6PDET+jwxE/o+JnEn5GhyN+RocjfkaHI35Gh6PAUeN6nfAzOhzxMzoc8TM6HPEzOhzxMyocM35GhyN+RocjfkaHI35Gxc9kgaMKR/yMDkf8jA5H/IwOR/yMzvUaP6PB0S34GR2O+BkdjvgZHY74GR2OAkcVjvgZHY74GR2O+BkNP+MW/IwOR/yMCkeDn9HhiJ/R4YifUbleG/yMDkeBowpH/IwOR/yMDkf8jA5H/IwOR/yMCkeLn9HhiJ9R8TMWP6PDET+jw1HgqMIRP6PDET+jc73Gz+hwxM/ocMTPqHB0+BkdjvgZHY74GR2O+BkdjgJHFY74GRU/4/AzOhzxMzoc8TM6HPEzKhwFP6NyvRb8jA5H/IwOR/yMDkeBowpH/IwOR/yMDkf8jA5H/IwOR/yMip/x+BkdjvgZHY74GR2O+BkdjgJHjeu1x8/o6BE/o8MRP6PDET+jwxE/o8Ix4GdUrtcBP6OjR/yMDkf8jA5HgaMKR/yMDkf8jM71Gj+jwxE/o8MRP6PCMeJnnuMo1l84io33HPEzT3EMeTFfG4dsfuF4v3GyIl8bJxvsPXTMTwPoOKUG0AXor4eOB2sAHcPWADrurgF0rGAD6PjG10NPmMwG0HGkDaDjSBtAx5E2gC5Afz10HGkD6DjSBtBxpA2g40gbQMeRvh56xpE2gI4jbQAdR9oAOo60AXQB+uuh40gbQMeRNoCOI20AHUfaADqO9OXQZcGRNoCOI20AHUfaADqOtAF0AfrroeNIn4K+8+akLJhMHY74Rh2OWMEnOT58408W3J0KR4Nh0+GIB9PhiK3S4YhTUrleG4GjCkf8jA5H/IzO+RE/o8MRP6PDET+jwtHiZ3Q44md0OOJndDjiZ1T6RytwVOGIn9HhiJ/R4Yif0eGIn9G5XuNnVDg6/IwOR/yMDkf8jA5H/IwOR4GjCkf8jA5H/IwOR/yMip9x+BkdjvgZFY6Cn9HhiJ/R4YifUbleC35Gh6PAUYUjfkaHI35GhyN+RocjfkaHI35GhaPHz+hwxM+o+BmPn9HhiJ/R4ShwVOGIn9HhiJ/RuV7jZ3Q44md0OOJnVDgG/IwOR/yMDkf8jA5H/IwOR4GjCkf8jIqfCfgZHY74GR2O+BkdjvgZFY4RP6NyvY74GR2O+BkdjvgZHY4CRxWO+BkdjvgZHY74GR2O+BkdjvgZFT+T8DM6HPEzOhzxMzoc8TM6HAWOGtfrhJ/R4Yif0eGIn9HhiJ/R4YifUeGY8TM6HPEzOhzxMzoc8TMqfiYLHFU44md0OOJndDjiZ3Q44md0rtf4GQ2OfsHP6HDEz+hwxM/ocMTP6HAUOKpwxM/ocMTP6HDEz2j4Gb/gZ3Q44mdUOBr8jA5H/IwOR/yMyvXa4Gd0OAocVTjiZ3Q44md0OOJndDjiZ3Q44mdUOFr8jA5H/IyKn7H4GR2O+BkdjgJHFY74GR2O+Bmd6zV+RocjfkaHI35GhaPDz+hwxM/ocMTP6HDEz+hwFDiqcMTPqPgZh5/R4Yif0eGIn9HhiJ9R4Sj4GZXrteBndDjiZ3Q44md0OAocVTjiZ3Q44md0OOJndDjiZ3Q44mdU/IzHz+hwxM/ocMTP6HDEz+hwFDhqXK89fkaHI35GhyN+RocjfkaHI35GhWPAz+hwxM/ocMTP6HDEz6j4mSBwVOGIn9HhiJ/R4Yif0eGIn9G5XuNnVDhG/IwOR/yMDkf8jA5H/IwOR4GjCkf8jA5H/IwOR/yMip+J+BkdjvgZFY4JP6PDET+jwxE/o3K9TvgZHY4CRxWO+BkdjvgZHY74GR2O+BkdjvgZFY4ZP6PDET+j4mcyfkaHI35Gh6PAUYUjfkaHI35G53qNn9HhiJ/R4Yif0eAYFvyMDkf8jA5H/IwOR/yMDkeBowpH/IyGnwkLfkaHI35GhyN+RocjfkaFo8HPqFyvDX5GhyN+RocjfkaHo8BRhSN+RocjfkaHI35GhyN+RocjfkbFz1j8jA5H/IwOR/yMDkf8jA5HgaPG9driZ3Q44md0OOJndDjiZ3Q44mdUODr8jA5H/IwOR/yMDkf8jIqfcQJHFY74GR2O+BkdjvgZHY74GZ3rNX5GhaPgZ3Q44md0OOJndDjiZ3Q4ChxVOOJndDjiZ3Q44mdU/IzgZ3Q44mdUOHr8jA5H/IwOR/yMyvXa42d0OAocVTjiZ3Q44md0OOJndDjiZ3Q44mdUOAb8jA5H/IyKnwn4GR2O+BkdjgJHFY74GR2O+Bmd6zV+RocjfkaHI35GhWPEz+hwxM/ocMTP6HDEz+hwFDiqcMTPqPiZiJ/R4Yif0eGIn9HhiJ9R4ZjwMyrX64Sf0eGIn9HhiJ/R4ShwVOGIn9HhiJ/R4Yif0eGIn9HhiJ9R8TMZP6PDET+jwxE/o8MRP6PDUeCocb3O+BkdjvgZHY74GR2O+BkdjvgZDY5xwc/ocMTP6HDEz+hwxM9o+Jm4CBxVOOJndDjiZ3Q44md0OOJndK7X+BkVjgY/o8MRP6PDET+jwxE/o8NR4KjCET+jwxE/o8MRP6PiZwx+RocjfkaFo8XP6HDEz+hwxM+oXK8tfkaHo8BRhSN+RocjfkaHI35GhyN+RocjfkaFo8PP6HDEz6j4GYef0eGIn9HhKHBU4Yif0eGIn9G5XuNndDjiZ3Q44mdUOAp+RocjfkaHI35GhyN+RoejwFGFI35Gxc8IfkaHI35GhyN+RocjfkaFo8fPqFyvPX5GhyN+RocjfkaHo8BRhSN+RocjfkaHI35GhyN+RocjfkbFzwT8jA5H/IwOR/yMDkf8jA5HgaPG9TrgZ3Q44md0OOJndDjiZ3Q44mdUOEb8jA5H/IwOR/yMDkf8jIqfiQJHFY74GR2O+BkdjvgZHY74GZ3rNX5GhWPCz+hwxM/ocMTP6HDEz+hwFDiqcMTP6HDEz+hwxM+o+JmEn9HhiJ9R4ZjxMzoc8TM6HPEzKtfrjJ/R4ShwVOGIn9HhiJ/R4Yif0eGIn9HhiJ/R4JgW/IwOR/yMhp9JC35GhyN+RoejwFGFI35GhyN+Rud6jZ/R0SN+RocjfkaFo8HP6HDEz+hwxM+oXK8NfkZHjwJHFY74GR2O+BkdjvgZHY74GZ3rNX5GhaPFz+hwxM/ocMTPPMdRrL9wFBvvOY7kZ4zxN9MO4fHm9jTbr62tM3bdOObiVOz6p+PNXy5vbOI6bbvs/OWUL/SyuQGS7FeBhAK1LVDO67bLkn6p0P3GIS/ma+uQzS/rrVB6K/K1cbLB3i/Okcwdtf9e7UcypNT+e7UfyURT++/VfiTjT+2/V/uRwgpq/63au5ECFmr/vdqPFApR++/VfqQgi9p/r/aEb/PWXqj9tLUn15u39uR689aeXG/e2pPrzVt7cr1pay/kevPWnlxv3tqT681be3K9eWsv1H7a2pPrzVt7cr15a0+uN2/tyfXmrT253rS19+R689aeXG/e2pPrzVt7cr15ay/Uftrak+vNW3tyvXlrT643b+3J9eatPbneO9V+77f0AlHdUOUkfRuqnARq71XOxz/MF8jIhiqnUM6RykmSNVQ5CaeGKid501CdLRHSUOUkFRqpnJFUaKRrZyQVGqqcpEJDlZNUaKhyCuUcqZykQkOVk1RoqHKSCg3lO0mFhionqdBI5UykQkOVk1RoqHKSCo3U2SZSoaHKKZRzpHKSCg1VTlKhocpJKjRUOUmFhionqdBI5cykQkOVk1RopFQokwoNVU5SoaHKKZRzpHKSCg1VTlKhoTpbUqGhykkqNFQ5SYUGKmdeSIWGKiep0FDlJBUaqpykQkOVUyjnSOUkFRooFcoLqdBQ5SQVGqqcpEJDlZNUaKRyGlKhkTpbQyo0VDlJhYYqJ6nQUOUUyjlSOUmFhionqdBQ5SQVGqqcpEJDlZNUaKRUyJIKDVVOUqGhykkqNFQ5SYWGKqdQzoE6W0sqNFQ5SYWGKiep0FDlJBUaqpykQiOV05EKDVVOUqGhykkqNFQ5SYVGSoWcUM6RykkqNFQ5SYWGKiep0FDlJBUaqrMlFRqpnEIqNFQ5SYWGKiep0FDlJBUaqpxCOUcqJ6nQUOUkFRqqnKRCI6VCQio0VDlJhUYqpycVGqqcpEJDlZNUaKTO1pMKDVVOoZwjlZNUaKhykgoNVU5SoaHKSSo0VDlJhUYqZyAVGqqcpEIjpUKBVGiocpIKDVVOoZwjlZNUaKhykgoN1dmSCg1VTlKhocpJKjRSOSOp0FDlJBUaqpykQkOVk1RoqHIK5RypnKRCI6VCkVRoqHKSCg1VTlKhocpJKjRSOROp0EidbSIVGqqcpEJDlZNUaKhyCuUcqZykQkOVk1RoqHKSCg1VTlKhocpJKjRSKpRJhYYqJ6nQUOUkFRqqnKRCQ5VTKOdAnW0mFRqqnKRCQ5WTVGiocpIKDVVOUqFxyumWhVRoqHKSCg1VTlKhocpJKjROKnQqp1DOkcpJKjRUOUmFhionqdBQ5SQVGqqzJRUaqZyGVGiocpIKDVVOUqGhykkqNFQ5hXKOVE5SoaHKSSo0VDlJhUZKhQyp0FDlJBUaqZyWVGiocpIKDVVOUqGROltLKjRUOYVyjlROUqGhykkqNFQ5SYWGKiep0FDlJBUaqZyOVGiocpIKjZQKOVKhocpJKjRUOYVyjlROUqGhykkqNFRnSyo0VDlJhYYqJ6nQSOUUUqGhykkqNFQ5SYWGKiep0FDlFMo5UjlJhUZKhYRUaKhykgoNVU5SoaHKSSo0Ujk9qdBIna0nFRqqnKRCQ5WTVGiocgrlHKmcpEJDlZNUaKhykgoNVU5SoaHKSSo0UioUSIWGKiep0FDlJBUaqpykQkOVUyjnQJ1tIBUaqpykQkOVk1RoqHKSCg1VTlKhkcoZSYWGKiep0FDlJBUaqpykQiOlQlEo50jlJBUaqpykQkOVk1RoqHKSCg3V2ZIKjVTORCo0VDlJhYYqJ6nQUOUkFRqqnEI5RyonqdBQ5SQVGqqcpEIjpUKJVGiocpIKjVTOTCo0VDlJhYYqJ6nQSJ1tJhUaqpxCOUcqJ6nQUOUkFRqqnKRCQ5WTVGiocpIKDVTO01+gnCOVk1RooFTILKRCQ5WTVGiocgrlHKmcpEJDlZNUaKjOllRoqHKSCg1VTlKhkcppSIWGKiep0FDlJBUaqpykQkOVUyjnSOUkFRopFTKkQkOVk1RoqHKSCg1VTlKhkcppSYVG6mwtqdBQ5SQVGqqcpEJDlVMo50jlJBUaqpykQkOVk1RoqHKSCg1VTlKhkVIhRyo0VDlJhYYqJ6nQUOUkFRqqnEI5B+psHanQUOUkFRqqnKRCQ5WTVGiocpIKjVROIRUaqpykQkOVk1RoqHKSCo2UColQzpHKSSo0VDlJhYYqJ6nQUOUkFRqqsyUVGqmcnlRoqHKSCg1VTlKhocpJKjRUOYVyjlROUqGhykkqNFQ5SYVGSoU8qdBQ5SQVGqmcgVRoqHKSCg1VTlKhkTrbQCo0VDmFco5UTlKhocpJKjRUOUmFhionqdBQ5SQVGqmckVRoqHKSCo2UCkVSoaHKSSo0VDmFco5UTlKhocpJKjRUZ0sqNFQ5SYWGKiep0EjlTKRCQ5WTVGiocpIKDVVOUqGhyimUc6RykgqNlAolUqGhykkqNFQ5SYWGKiep0EjlzKRCI3W2mVRoqHKSCg1VTlKhocoplHOkcpIKDVVOUqGhykkqNFQ5SYWGKiep0ECpkF1IhYYqJ6nQUOUkFRqqnKRCQ5VTKOc4na1dSIWGKiep0FDlJBUaqpykQkOVk1RopHIaUqGhykkqNFQ5SYWGKiep0EipkBHKOVI5SYWGKiep0FDlJBUaqpykQkN1tqRCI5XTkgoNVU5SoaHKSSo0VDlJhYYqp1DOkcpJKjRUOUmFhionqdBIqZAlFRqqnKRCI5XTkQoNVU5SoaHKSSo0UmfrSIWGKqdQzpHKSSo0VDlJhYYqJ6nQUOUkFRqqnKRCI5VTSIWGKiep0EipkJAKDVVOUqGhyimUc6RykgoNVU5SoaE6W1KhocpJKjRUOUmFRiqnJxUaqpykQkOVk1RoqHKSCg1VTqGcI5WTVGikVMiTCg1VTlKhocpJKjRUOUmFRipnIBUaqbMNpEJDrU5SoaHKSSo0VDmFco5UTlKhocpJKjRUZ0sqNNTqJBUaqpykQiOVM5IKDVVOUqGhykkqNFJnG0mFhiqnUM6RykkqNFQ5SYXeqpxi/aWcYuN9OUmFGpfTLHZZ6ynLTj1NDpdJm5MQdrbOLsnX1lmWX6p/v7Hz+fKnXViuh2hiaWPrLkX/+EWG243PuiKeQldH6IqcDF0doKtEYIeuanTlVoU4l9K9rkgO0dURuiLCRFc1ujr9ucvGYu3jjW1yl0O0SfY2tstFIda6nY39CtrnfGdKE4Eu4h5W3IK4EXdf4vZ+FXdMPxI3YT/iHlbc3PpA3MeLO4RV3Ht6tUbWlXCq571L5O4Oiu1LsYqNNLeYEPew4uY+F+IeVdyZm22IuzNxq7nEzB0/xD2suLntiLj7Evf1Rrl1t0f4FYFk7iWi2PdSrKBYFPtWiuWuH4rtS7GyTsN6Fx9vbHyyFxxhWe7lzX0/5D2wvLlJiLzfWN7RrjiiNz9KN7ijyEpgJXysBG4/shJYCX9ybuFeJSvhnVdCXOHFX6Obb68EbmyyElgJHyuBu6CshMNXQpbLNE4Rzc8yHrdwFxTFvpdiBcWi2K4Uq2gquWGKuIcVN7dLEfew4uZmKeLuTNx6uQb3PxH3sOLmlibirhJ3cqu4814i/a2fJnn86w3OcOsRxfalWLV3gJ3hbiLiHlbc3CBE3MOKm3uJiLszcWu94O6MIG7EPaq4ue2IuPsS9+M3i53hXiKKfS/FcoMQxb6XYrnrh2L7Uqzi6+3OcN8PeY8rb8tNQuT9xvLWezTPckeRlcBK+FgJ3H5kJbASPlYC9ypZCe+8EtQef7XCSmAlsBJOK4G7oKyE41dCk0/rOMsNU8Q9rLi5t4q4OxO32sNZltuwiHtYcXMTFnEfLm7N359y3FdFse+lWO5/oti+FKt3I8dxSxNxDytu7lIi7mHFLYgbcfclbrV7iY57iYh7WHFzL7G1uN0qE+N+qZD9KhF3xLovEfd1uiqRLZSIuxO9l0iI47svEflz9yUiRe2+RGSB3ZdIKJF+iVy8ErlxxKeNz9BJWhpAJwFoAB1P3wA6Lr0BdHz366F7nHQD6HjjBtBxuw2g418bQBegvx46jrQBdBxpA+g40gbQcaQNoONIXw894EgbQMeRNoCOI20AHUfaALoA/fXQcaQNoONIG0DHkTaAjiNtAB1H+nroEUfaADqOtAF0HGkD6DjSBtAF6K+HjiNtAB1H2gA6jrQBdBxpA+g40tdDTzjSBtBxpA2g40gbQMeRNoAuQH89dBxpA+g40gbQcaQNoONIG0DHkb4eesaRNoCOI20AHUfaADqOtAF0AfrroeNIG0DHkTaAjiNtAB1H2gA6jvTl0GXBkTaAjiNtAB1H2gA6jrQBdAH666HjSA+ALmn99JB3y+5flvUvu+snf2wozXnxl0/+2CX6xxvLqTJfG4tJy+3G59pjjOetPf583toTE8xbe9KKaWtvCE3mrT3Zzby1J0Kat/YkWfPWXqj9tLUn1xu39qfyXmp/m+kWN842Xuac3c338FahEAIilKeEQmKIUD6FcoJ3Ecqpoo83NpLzisMvxt3rijQSXR2hK5JOdPXMhc0SiyKUp4RChopQDrhSWfJZdHWErsh+0dVTFzZBKAjlGaGQKiOUj41TXv9yyh8T/V0opMoI5akzCqkyQnlKKMTECOUIk0RMjK4O0JUjVUZXz1zYHKkyQnlKKMTECOWIKxUxMbo6QleCrtDVMxc2UmWE8pRQSJURysfGe7cfHKkyQnnqjEKqjFCeEgoxMUI5wCQJMTG6OkJXpMro6pkLm5AqI5SnhEJMjFCOuFIJukJXB+iKVBldPXVhI1VGKE8JhVQZoXxsvHf7QUiVEcpTZxRSZYTyjFA8MTFCOcAkeWJidHWErkiV0dVTFzZSZYTylFAEoSCUA65UxMTo6ghdkSqjq6cubKTKCOUpoZAqI5SPjfduP3hSZYTyzBklkCojlKeEQkyMUA4wSYGYGF0doStSZXT11IVNEApCeUYoxMQI5YgrFTExujpCV6TK6OqpCxupMkJ5SiikygjlY+O92w+RVBmhPHNGiaTKCOUpoRATI5QDTFIkJkZXR+hK0BW6eubCRqqMUJ4SCjExQjniSkVMjK6O0BWpMrp66sJGqoxQnhFKIlVGKB8b791+SKTKCOWpMwqpMkJ5SijExAjlAJOUBF2hqwN0RaqMrp66sJEqI5SnhEJMjFCOuFIRE6OrI3RFqoyunrmwZVJlhPKUUEiVEcrHxnu3HzKpMkJ56oxCqoxQnhKKIBSEom+SMjExujpCV6TK6OqpCxupMkJ5SijExAjliCsVMTG60teVX0iV0dUTF7aTeBAKQnlGKKTKCOVj453bD34hVUYoTwlFEMqwQvHLZc7ifdi59IR8mUaOfmcaxix2WUkvLt3rilQZXR2hK1JldHWErgih0dURuiKzRldH6IrMGl0doCtDZo2ujtAVEfewuvLRX26b+WTife1JreetPUH0vLUXaj9t7cl/5609Ge28tSdHnbf2ZJ3z1p48ctraWzLDeWtPrjdv7cn1xq19urLOVh5vbGIyaxljint3C5a0XP746Z/d/VOJltQQZR2jLEFZKOsQZZF4oqyfK0v8vbLIU1FWjbJ2n8qwpLUo6xhlkQWjrGOURdKMsg5RliPHRlnHKIuUHGWdp5HlkqmbtJhlZ3N7w9qavNwriwweZVUpy6a1NCd8BWWRwaOsY5QlKAtlHaIsMniUdYyyyOBR1jHKIoNHWccoiwweZR2jLDJ4lHWIsoQMHmV9TiNZa1ZlWW/upUKojlSelAopOVI5S+VUu1Uqstz/aL8Qe48rleziKpWwd1c3hWBXqYR8f1dXBKkgleekQjCNVJ6UCkkzUnlSKkTHSOVJqZAFI5UnpUK4i1Sek4onrUUqT0qFtBapPCkV0lqk8qRUSGuRylkqMV+D/dMNocebh7xctg755qeNTCpsnKxcDjHZYG83PotQECEibC1CEmZE2FyEZNeIsLkIScURYXMRkrcjwuYiJMlHhK1FGLhHgAibi5C7D4iwuQi5r4EIm4uQOyaIsLkIBREiwtYi5I4JImwuQu6YIMLmIuSOCSJsLkLumCDC5iLkjgkibC3CyB0TRNhchNwxQYTNRcgdE0TYXITcMUGEzUUoiBARthYhd0wQYXMRcscEETYXIXdMEGFzEXLHBBE2FyF3TBBhaxEm7pggwuYi5I4JImwuQu6YIMLmIuSOCSJsLkJBhIiwtQi5Y4IIm4uQOyaIsLkIuWOCCJuLkDsmiLC5CLljgghbizBzxwQRNhchd0wQYXMRcscEETYXIXdMEGFzEQoiRIStRcgdE0TYXITcMUGEzUXIHRNE2FyE3DFBhM1FyB0TRNhYhGHhjgkibC7Coe6Y2LzOxDj5RYTnox0pmrdG1m9ZW3MzleLmuqoZKV1uyVHgqMJxpIyvJceRYqqWHEdKWlpyHCksaMlxJL/bkKMZybK15DiS62jJET+jwxE/o8NR4KjCET+jwxE/o8MRP6PDET+jwxE/o8LR4md0OOJndDjiZ3Q44md0OAocVTjiZ3Q44md0OOJndDjiZ3Q44mdUODr8jA5H/IwOR/yMDkf8jA5HgaMKR/yMDsd5/Uy0cnlQPdog92jmtSi7aOZ1Hbto5jUS0ebLVKIz92hkXm+wi2bedn8Xzbwd/C6aeZvyXTTCFWrjCiXzts67aOiGN9HM3A3vnGtm7oZ30NANb6HxdMObaOiGN9HQDW+ioRveRCP0NRt9jacb3kRDN7yJhmx4Ew3Z8CYauuGtK1SgG95EQze8iYZueBMN3fAmGgHNFpqZu+EdNDN3wztoyIY30dANb3XDYeZu+DGaOHM3vINm5m54B83M3fAOGrrhrStUFNBsoaEb3kRDN7yJhm54Ew1PSmyiIRveQpPIhjfRkA1voqEb3uqG08zd8A4aAc0WGp6U2ETDkxKbaOiGN69QdMObaOiGt9BkuuFNNHTDm2h4UmITDdnwJhoBzRYasuFNNHTDW93wUB+AVkbDkxKbaHhSYgNNHOoTrspo6IY3rlBx4q+Q7qKhG95EI6DZQkM3vImGJyU20ZANb6IhG95EQza8hWbir2PudcMTf/ByFw1PSmyi4UmJTTQCmi00dMObVyi64U00dMObaOiGN9HQDW+hmfjbirtoyIY30ZANb6IhG95EI3TDG93wxJ8e3EXDkxKbaHhSYhMNT0psoqEb3rpCTfxlvl00dMObaOiGN9HQDW+iEdBsoSEb3kRDNryJhmx4Ew3d8FY3PPW36B6jmfpbdDtoeFJiEw1PSmyioRveukJN/S26HTR0w5to6IY30dANb6LhSYlNNGTDW2j4Ft02GrLhTTR0w1vd8NTfottBI6DZQsOTEptoeFJiEw3d8OYVim54Ew3d8BYavkW3jYZueBMNT0psoiEb3kQjoNlCQza8iYZueKsbnvpbdDtoeFJiEw1PSmyh4Vt022johreuUFN/i24HDd3wJhoBzRYauuFNNDwpsYmGbHgTDdnwJhqy4S00U3+L7nE3PPW36HbQ8KTEJhqelNhEI6DZQkM3vHmFohveREM3vImGbngTDd3wFhq+RbeNhmx4Ew3Z8CYasuFNNEI3vNENT/0tuh00PCmxiYYnJTbR8KTEJhq64Y0rVJr6W3Q7aOiGN9HQDW+ioRveRCOg2UJDNryJhmx4Ew3Z8CYauuGNbjhN/S26x2j4Ft02Gp6U2ETDkxKbaOiGt65QU3+LbgcN3fAmGrrhTTR0w5toeFJiEw3Z8BYavkW3jYZseBMN3fBWNzz1t+h20AhottDwpMQmGp6U2ERDN7x5haIb3kRDN7yFhm/RbaOhG95Ew5MSm2jIhjfRCGi20JANb6KhG97qhqf+Ft0OGp6U2ETDkxJbaPgW3TYauuGtK9TU36LbQUM3vIlGQLOFhm54Ew1PSmyiIRveREM2vImGbHgLzdTfonvcDU/9LbodNDwpsYmGJyU20QhottDQDW9eoeiGN9HQDW+ioRveREM3vIWGb9FtoyEb3kRDNryJhmx4E43QDW90w1N/i24HDU9KbKLhSYlNNDwpsYmGbnjrCjX1t+h20NANb6KhG95EQze8iUZAs4WGbHgTDdnwJhqy4U00dMNb3fDU36J7jIZv0W2j4UmJTTQ8KbGJhm546wo19bfodtDQDW+ioRveREM3vImGJyU20ZANb6HhW3TbaMiGN9HQDW91w1N/i24HjYBmCw1PSmyi4UmJTTR0w5tXKLrhTTR0wxtoMt+i20ZDN7yJhiclNtGQDW+iEdBsoSEb3kRDN7zRDeepv0W3g4YnJTbR8KTEFhq+RbeNhm546wo19bfodtDQDW+iEdBsoaEb3kTDkxKbaMiGN9GQDW+iIRveQjP1t+ged8NTf4tuBw1PSmyi4UmJTTQCmi00dMObVyi64U00dMObaOiGN9HQDW+h4Vt022jIhjfRkA1voiEb3kQjdMMb3fDU36LbQcOTEptoeFJiEw1PSmyioRveukJN/S26HTR0w5to6IY30dANb6IR0GyhIRveREM2vImGbHgTDd3wVjc89bfoHqPhW3TbaHhSYhMNT0psoqEb3rpCTf0tuh00dMObaOiGN9HQDW+i4UmJTTRkw1to+BbdNhqy4U00dMNb3fDU36LbQSOg2ULDkxKbaHhSYhMN3fDmFYpueBMN3fAWGr5Ft42GbngTDU9KbKIhG95EI6DZQkM2vImGbnirG576W3Q7aHhSYhMNT0psoeFbdNto6Ia3rlBTf4tuBw3d8CYaAc0WGrrhTTQ8KbGJhmx4Ew3Z8CYasuEtNFN/i+5xNzz1t+h20PCkxCYanpTYRCOg2UJDN7x5haIb3kRDN7yJhm54Ew3dcBmNLHyLbhsN2fAmGrLhTTRkw5tohG642A2f0PDc8CYanpTYRMOTEptoeFJiEw3d8NYVaupv0e2goRveREM3vImGbngTjYBmCw3Z8CYasuFNNGTDm2johre64am/RfcYDd+i20bDkxKbaHhSYhMN3fDWFWrqb9HtoKEb3kRDN7yJhm54Ew1PSmyiIRveQsO36LbRkA1voqEb3uqGp/4W3Q4aAc0WGp6U2ETDkxKbaOiGN69QZMObqiEb3kIz9bfodtCQDW+ioRveREM2vHWFmvpbdDuqoRveREM3vImG54Y30dANb6IhG966Qk39LbodNGTDm2h4bngTzcTdsFh/QSM23qORgdA4sWadiYRwu/n5aEdqcMXKOhO5vcSuRztSz7p/tCO1oftHO1JnuX+0IzWLu0c71NfX9o92pJZu/2hH6tL2j3akxmv/aGWqo52qlxrqe2P7RztVLzXUV8H2j3aqXmqob3ftH+1UvdRQX9jaP9qpeqmhvoO1f7RT9VJDfa1q/2in6qWG+qbU/tGO1Ev57NZp+xzj3dEO9eUnn9PlxogJpxv1jzfPNl3uZmfn83UuEr/YjNR5Bb+s0w7e+HsljNR57R/tSJ3X/tHKVEc7Uue1f7QjdV77RztS57V/tCN1XvtH23fnFc3N0bqd5sK46NZexEVv180/9nS3uT31IsvX5tbmJd9u/gmn848StYNz+pd/+cdf/vrXv/yff/7r3//1z//xl7//7d8/Bi8f/6/8AJVbFvn6e87bqxCN+VRi+dGivUFSM8jXDAo1g2LNoFQzKFcMKt8e3xtkagbVKCLUKCLUKCLUKCLUKCLUKCLUKCLUKCLWKCLWKCLWKCLWKCLWKCLWKCLWKCLWKCLWKCLWKCLVKCLVKCLVKCLVKCLVKCLVKCLVKCLVKCLVKCLVKCLXKCLXKCLXKCLXKCLXKCLXKCLXKCLXKCLXKCLXKMIsS9UoUzXKVo1yVaOkapSvGhWqRsWqUWVpyHJ56NuJu+n3fdF8XGJce+NBbbCFbdM6m3TzZ8vb5nRxSzn/uu3nxPObTrz8BYN3mLh514nbd524e9eJy7tO3L/rxMO7Tjy+68Tf9cpp3vXKaTu+cobLtqcO2N7PvONL587MO7527sy844vnzsw7vnruzLzjy+fOzDeun+vDSs5HszPzdH2JOPnrg00xFTZ2+bKtmOvfNRLOsylfFP3KxkW7PJ6NdflyR8j621s28byHdPge8tF7KP/er+oezOF7sIfvwR2+Bzl8D/7wPYTD93D4mnaHr2l3+JqWw9e0HL6m5fA1LYevaTl8Tcvha1oOX9Ny+JqWw9e0HL6m/eFr2h++pv3ha9ofvqb94WvaH76m/eFr2h++pv3ha9ofvqbD4Ws6HL6mw+FrOhy+psPhazocvqbD4Ws6HL6mw+FrOhy+puPhazoevqbj4Ws6Hr6m4+FrOh6+puPhazoevqbj4Ws6Hr6mk8Ka9vHyJLoNi9ztwRy+B3v4Htzhe5DD9+AP30M4fA/x8D0k3T3cvEZz2YPCmvYmrHu4eavk4/3hu4317q/m5W1nbt525vZtZ+7edubytjP3bzvz8LYzj2878/S2M3/Xa6hd3vUaapd3vYba5V2voXbp+Rr68IEZu/R8Ed2Zes9X0Z2p93wZ3Zl6z9fRnan3fCHdmbrClTRIXKd+86NOZ79rzXL4Hszhe1C4ggR/KUTI5n4P7vA9yOF78IfvIRy+h3j4HtLhe8hH78Euh+/BHL6Hw9e0PXxN28PXtD18TdvD17Q9fE3bw9f0xufPvb/5QcXroI2n4S8dRpJr12CcO+8gHb2DfPAONj5orbgDc/QO7NE7UCjyum2K4ZcdFDS9rG8xnNrA69a+9CtSKV3uU2Zjd/6wO90Dv6ys0825dWtn8vk48xzH6Zc5jjPsH6f95Tg/B5maQbZmUPEiGc3622/RxPTY0sVwoRXjL2A//3748d+3Ia4GJ974wK/LS/kBKNU9pMP3kI/eQ/kBKNU9mMP3YA/fgzt8D6KxB3vdg9ztYWM9pPWbp6d7bXt7eNjQxXT4HvLRe0jL4Xswh+/BHr4Hd/ge5PA9+MP3EA7fw+FrOh2+ptPhazofvqbz4Ws6H76ms8Kajmm9xiVjdzZ267cQTkY6/N6AZulrOr6v6YS+phP7mk7qazq5p+m4ZelrOubl01mu00l307F9Tcf1NZ1Xn5X9cn3U/+bB42Lu8/ER6K+NP76pdDd33/Xc0/rrKEthkYR34V6Y+6svDhL8OvfbDxR8O1x2S3rfqee3nbpZ3nfq5n2nbt936u5tp26l56l/50aKWT/7Z42//r5X8UbKaZ5f257av9tNP5F4kPyOJIDkdyRddxVtkHTdrbRB0nUX1ASJ67q7aoOk666tDZKuu8E2SLruMtsgEZD8joTu9Q4J3esdErrXOyR0r3dI6F5/RyJ0r3dIhlHJUc/imhTi5a7W6Z/T9b0Fe374wflhZNWQ4TAuqiHDYWxXQ4bD+LSGDAWGP2Y4jBNsyHAY69iQ4TBesyHDYcxpQ4b4lB8zDPiUnzPEp/ycIT7l5wzxKT9nKDD8MUN8ys8Z4lN+zhCf8nOG+JSfM8Sn/JhhxKf8nCE+5ecM8Sk/Z4hP+TlDgeGPGeJTfs4Qn/JzhviUnzPEp/ycIT7lxwwTPuXnDPEpP2eIT/k5Q3zKzxkKDH/MEJ/yc4b4lJ8zxKf8nCE+5ecM8Sk/ZpjxKT9niE/5OUN8ys8Z4lN+zlBg+GOG+JSfM8Sn/JwhPuXnDPEpP2eIT/kpQ1nwKT9niE/5OUN8ys8Z4lN+zlBg+GOG+JSfM8Sn/JwhPuXnDPEpP2eIT/kxw74/MfEmDPEpP2eIT/k5Q3zKzxkKDH/MEJ/yc4b4lJ8zxKf8nCE+5ecM8Sk/ZmjxKT9niE/5OUN8ys8Z4lN+zlBg+GOG+JSfM8Sn/JwhPuXnDPEpP2eIT/kxw3E+KtmQIT7l5wzxKT9niE/5OUOB4Y8Z4lN+zhCf8nOG+JSfM8Sn/JwhPuXHDMf5fGhDhviUnzPEp/ycIT7l5wwFhj9miE/5OUN8ys8Z4lN+zhCf8nOG+JQfM+R79AoM8Sk/ZziOT4n5yjA+Znia59e2bjG3m34iGcd2qCERkPyGpOnHPd3yGEkMl3NEjOFu5vK2M/dvO3MF+5NknXm+kW5xY+eWy192zl3/spFwnk/sbD6ps/nkvuaj8bk91fmYzuZjO5uP62w+0tl8fGfz6ez8HA89P3/uIR2+h3z0HjQ+xJCtrHsQc7eHcPge4uF7SIfvIR+9B42fR9/Zgzl8D/bwPbjD9yCH7+HwNZ0PX9P58DWdD1/T+eg17Zfl8D2Yw/dgD9+DO3wPcvge/OF7CIfvIR6+h3T4Hg5f0+bwNW0OX9Pm8DVtDl/T5vA1bQ5f0+bwNW0OX9Pm8DVtDl/T9vA1bQ9f0/bwNW0PX9P28DVtD1/T9vA1bQ9f0/bwNW0PX9Pu8DXtDl/T7vA17Q5f0+7wNe0OX9Pu8DXtDl/T7vA17Q5f03L4mpbD17Qcvqbl8DUth69pOXxNy+FrWg5f03L4mpbD17Q/fE37w9e0P3xN+8PXtD98TfvD17Q/fE37w9e0P3xN+8PXdDh8TYfD13Q4fE2Hw9d0OHxNh8PXdDh8TYfD13Q4fE2Hw9d0PHxNx8PXdDx8TcfD13Q8fE3Hw9d0PHxNx8PXdDx8TcfD13Q6fE2nn69pt6wveLglubs9aKzpcHk5xZnFPd44LZfjTS6vm9riA9M5ha9tc/5128+Zu7edubztzP3bzjy87czj2848ve3M87vOXOU5yDYzN28787e9hua3vYaqPGfaZuZvew3NPV9Dw2Vbsyz2fuo9X0R3pt7zVXRn6j1fRh9OPSw9X0d3pt7zhXRn6j+/kjpj15eyjfO/+d2g8LT03h7k8D34w/cQDt9DOnwP+eg9KDzLvLcHc/geDl9x5vAVZw5fcebwFWcOX3EKzzLv7eHwNW0OX9P28DVtD1/T9vA1bQ9f0/bwNW0PX9P28DVtD1/T9vA1bQ9f0+7wNe0OX9Pu8DXtDl/T7vA17Q5f0+7wNe0OX9Pu8DXtDl/TcvialsPXtBy+puXwNS2Hr2k5fE3L4WtaDl/TcvialsPXtD98TfvD17Q/fE37w9e0P3xN+8PXtD98TfvD17Q/fE37w9d0OHxNh8PXdDh8TYfD13Q4fE2Hw9d0OHxNh8PXdDh8TYfD13Q8fE3Hw9d0PHxNx8PXdDx8TcfD13Q8fE3Hw9d0PHxNx8PXdDp8TafD13Q6fE2nw9d0OnxNp8PXdDp8TafD13Q6fE2nw9d0PnxN58PXdD58TefD13Q+fE3nw9d0PnxNKzyi57y7/MS+8xLu9qCwpuX6No2X9HhjtScvg8KDdG1mHhWeo2s1c/O2M7dvO3P3tjOXt525f9uZh7edeXzbmb/rNTQub3sNNW97DTVvew01PV9DHz5EH03PF9Gdqfd8Fd2Zes+X0Z2p93wd3Zl6zxfSnakrXEl9DOvU88636h59fi5qPFitNhmNZ7D1JmOOnMznHuzhe3CH70HhxJ3NZb247HbeOXM2p8vGzsi6cTjPxnc1m9DVbOKLZ+NCXmeT4s1s7rcVs85crIm/zzy97czzu85c49H525mn32PfqPHo/M4e7OF7+Pn5VSRfwnHxYae+RuLaWnhz3dgUtw7LpcDB3nz+OH5VWN547v6N5x7eeO7xjeee3nju+X3nrvDCRru5mzeeu33jub/xdVXhxZh2c3/j66q88XVV3vi6Km98XZU3vq76vs/vctk4eHM/977PM+tvIIWQ7uf+6vOMN36du5Nf5v45n9jZfFJn88l9zSe8vB8Wc52P39G+CTHEy+YhpuW3XCiYt569fevZu7eevbz17A+9Yn3uIRy+h3j4HhTO/cFc7jfJicnOxvlSM29uz7SusK2Ny+Wybk+33n6vb37XmSu8lNdq5uZtZ27fdububWcubztz/7YzD2878/i2M3/ba2h822toettraHrba2jq5hr6OZturoufs+nmWvc5m26uX5+z6eaa9Dmbbq4zn7Pp5trxOZturgcfs8ndnOM/Z/Pi87ZfX8G9fdS5fN42S1pfpz39s/89C8n2jefu3nju8sZzjz3PPfs1KlxyML/OPS1L13NPl7cYjFmW8Pvcuz7P7My96/PMztxffZ7x69Umye7cY/bXtWru5i5vPHf/xnMPbzz32PPcH16b0pLeeO75feduljeee9fn98f9jOn6PPP4umq6Ps/szL3r88zO3A89z3zswS6H78Ecvgd7+B7c4XuQn+8hrU8uerv3FUET/SUlNqfb8NeNw3cj5aTw+mezqYf3nXp836mn9516ftupK7xb2mzq5n2nbt936u59p/6+V1P3vldT975XU/e+V1P3vldT975XU3nfq6m879VU3vdqKu97NdV4t1Zp6p/T6ecK+Tmdfq56n9Pp50r2OZ1+rk6f0+nnivMxHd/PVeRzOv1cGT6n08/Z/nM6/ZzBP6fT11nZ93VW9n2dlX1fZ2Xf11nZ93VWDn2dlUNfZ+XQ11k59HVWDn2dlUNfZ+XQ11k59HVWDn2dlUNfZ+XY11k59nVWjn2dlWNfZ+XY11k59nVWjn2dlWNfZ+XY11k59nVWTn2dlVNfZ+XU11k59XVWTn2dlVNfZ+XU11k59XVWTn2dlVNfZ+Xc11k593VWzn2dlXNfZ+Xc11k593VWzn2dlXNfZ+Xc11k5d3VWzktXZ+W8dHVWzktXZ+W8dHVWzktXZ+W8dHVWzktXZ+W8dHVWzktXZ+W89HVWNn2dlU1fZ2XT11nZ9HVWNn2dlU1fZ2XT11nZ9HVWNn2dlU1fZ2Xb11nZ9nVWtn2dlW1fZ+WO3qX9nE5fZ+WO3nn9nE5fZ+WO3k39nE5fZ+WO3iH9nE5fZ+WO3vX8nE5fZ+WO3sn8nE5fZ+WO3p38nE5fZ+WO3nH8nE5fZ+WO3kX8nE5fZ+WO3hn8nE5fZ+W+3u3Lfb3bl/t6ty/39W5f7uvdvtzXu325r3f7cl/v9uW+3u3Lfb3bl/t6ty/39W5f7uvdvtzXu325r3f7cl/v9uW+3u3Lfb3bl/t6ty/39W5f7uvdvtzXu325r3f7cl/v9uW+3u3Lfb3bl/t6ty/39W5f7uvdvtzXu325r3f7cl/v9uW+3u3Lfb3bl/t6ty/39W5f7uvdvtzXu325r3f7cl/v9uW+3u3L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",
      "brillig_names": [
        "discover_new_notes",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "decompose_hint",
        "field_less_than",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sha256_hash_2048",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "data",
            "type": {
              "kind": "array",
              "length": 2048,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["sha256_hash_2048"]
    },
    {
      "name": "increment_balance",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["increment_balance"]
    },
    {
      "name": "recreate_note",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+x9BZgcRdf1JtkNWY9iISR4CBC6eqwbDe7uzsz0DPbi7u5uwQIEd3d3l+DuHgjukIS/LvSSnklNrM/t7xb/1PfUl06zb+WculL3dFf1dmv4pzUP0P9vln+uu+neI/yzu+5Dqu51/Rm9bjL8XKvhXrvhXqfhXh/DvZl1H1F1b7Dh54YY7s1luDe34d4ChnvDwnvR1i38c0T4Z8rJptOlnFtSKZV3XL/gZZx0ppD1lKcyXiZwvVSq5KW9nF/wc46v0qmSKmf8VNn5p/XuMWksJ1Zzi5w4+8w4znT1DcLWV/fGCFaah4nh9dCGSdcLRq77hD/T9b/rq//eT/f+ug/oMel+V+tRNQdOvKaGAcfq2wNnm5lhPmS2zcwR2/SLXPePXA+oss0s+u+z6j6b7rMbbNMdbJsFgL4+EDefKppPaNwhkTnq3jB56wael264sRwDXNTYedPY8CQ2B9CwnDgH9eAxGhrnnDOO062+YUo8c9RYFAZF7s9ZlXgGU5DpPpfuc4eJh3qfCP8pzYkTr6nB4GTc1ebpwQj438GBztEYYm1rsG/S+zaYG+rfqI9bH7c+bn3c+rj/7XGRY3c9MeH8N+rj1setj1sf9786riVjT/HhghOvIZ9i8s2BUjm2seu4jci7/Iz+3CW8nlfr6vl0n1/3BXQfqvuCug/TfSHdF9Z9Ed2H676o7o7uSndX95Tuad0zumd1z+nu6e7rvpjui+u+hO5L6r6U7kuThtd9Gd2X1X053ZfXfQXdV9R9Jd1X1n0V3VfVfTXdV9d9Dd3X1H0t3dfWfR3d19V9Pd3X130D3TfUfSPdN9Z9E9031X0z3TfXfQvdt9R9K9231j2ve0H3ou6B7iXdy7pvo/u2um+n+/a676D7/3TfUfeddN9Z911031X33XTfXfc9dN9T971031v3fXTfV/f9dN9f9wN0P1D3g3Q/WPdDdD9U98N0P1z3I3Q/UvejdD9a92N0P1b343Q/XvcTdD9R95N0P1n3U3Q/VffTdD+9R0Pl6ywyZvXrOzLkkKp7Cxl+Thl+zjX8nGf4Od/wc0sbfm6E4edWNPzcSoafW8Pwc2safm59w89tYPi5zQw/t7nh5wqGnysafm47w89tb/i5XQw/t6vh5/Y2/Nw+hp87yPBzBxt+7kjDzx1l+LkTDD93ouHnTg9/jv5ODwLrCeU/klBCe3ZvmFSYRBeMhsg9aiPCP514TZHfgMZyuDDOZwHG+S3AuIAFGIdagHFBCzAOswDjQhZgXNgCjItYgHG4BRgXtQCjYwFGZQFG1wKMKQswpi3AmLEAY9YCjDkLMHoWYPQtwLiYBRgXtwDjEhZgXNICjEtZgHFpCzCOsADjMhZgXNYCjMtZgHF5CzCuYAHGFS3AuJIFGFe2AOMqFmBc1QKMq1mAcXULMK5hAcY1LcC4lgUY17YA4zoWYFzXAozrWYBxfQswbmABxg0twLiRBRg3tgDjJhZg3NQCjJtZgHFzCzBuYQHGLS3AuJUFGLe2AGPeAowFCzAWLcAYWICxZAHGsgUYt7EA47YWYNzOAozbW4BxBwsw/s8CjDtagHEnCzDubAHGXSzAuKsFGHezAOPuFmDcwwKMe1qAcS8LMO5tAcZ9LMC4rwUY97MA4/4WYDzAAowHWoDxIAswHmwBxkMswHioBRgPswDj4RZgPMICjEdagPEoCzAebQHGYyzAeKwFGI+zAOPxFmA8wQKMJ1qA8SQLMJ5sAcZTLMB4qgUYT7MA4+lAjNGv728dXp+hxz9T95G6n6X72bqfo/u5up+n+yjdz9f9At0v1H207hfpfrHul+h+qe6X6X657lfofqXuV+l+te7X6H6t7tfpfr3uN+h+o+436X6z7rfofqvut+l+u+536H6n7nfpfrfu9+h+r+736X6/7g/o/qDuD+n+sO6P6P6o7o/p/rjuT+j+pO5P6f607s/o/qzuz+n+vO5jdH9B9xd1f0n3l3V/RfdXdX9N99d1f0P3N3V/S/e3dX9H93d1f0/393X/QPcPdf9I9491/0T3T3X/TPfPdf9C97G6f6n7V7qP0/1r3b/R/Vvdv9P9e91/0P3HHv/Y4Kce/9ikd2iTn/Xff9H9V91/0/133f/Q/U/dx+s+QfeJuv9F/3tt1G66d9e9h+6NoZGbur7Q3yP8k4w6pOrehYZ7lxnuXWO4d5Ph3h2Ge/cZ7j1iuPeU4d4Yw71XDffeNtz70HDvc8O9rw33fjTc+8lw72fDvV8M93413PvNcO93w70/DPf+NNwbb7g3wXBvouHeX4Z75FjV97oZ7nU33OthuNdouNcU3ou2MCZgCRT4cbGKjwXF/Q0aPRtxuBoa8AsPfZyEMFaPG5f3TDjeTtSXZjL4Uncwdhdo/15g+///Fj/NjdjizZb4OaifbN7k180MvA/uhy/WTfESF2cLMK6BtlbA+WNZb+iDNC0MftPKtN60JrDe+MB82ZbQehMXZ/t/P35Y8i5X/BwinDf5dTsD70MtWW86gPECtLU6VPh6M0IbooPBbzqZ1pvOBNabEcD1prcl602f/378sORdrvg5TDhv8us+DLwPt2S96QuMF6Ct1eHC1xv68FRfBr/px7Te9EtgvVkJuN70t2S9GfDfjx+WvMsVP0cI501+PYCB95GWrDczA+MFaGt1pPD1hj42NjOD38zCtN7MksB6syZwvZnVkvVmtv9+/LDkXa74OUo4b/Lr2Rh4H23JejM7MF6AtlZHC19v6ANzszP4zUCm9WZgAuvNBsD1Zg5L1ptB//34Ycm7XPFzjHDe5NeDGHgfa8l6MycwXoC2VscKX2/oo4JzMvjNYKb1ZnAC683mwPVmiCXrzVz//fhhybtc8XOccN7k13Mx8D7ekvVmbmC8AG2tjhe+3tCHJOdm8Jt5mNabeRJYb4rA9WZeS9ab+f778cOSd7ni5wThvMmv52PgfaIl6838wHgB2lqdKHy9oY+Hzs/gNwswrTcLJLDebA9cb4Zast4s+N+PH5a8yxU/JwnnTX69IAPvky1Zb4YB4wVoa3Wy8PWGPhg7jMFvFmJabxZKYL3ZFbjeLGzJerPIfz9+WPIuV/ycIpw3+fUiDLxPtWS9GQ6MF6Ct1anC1xv6SPBwBr9ZlGm9WTSB9WYf4HrjWLLeqP9+/LDkXa74OU04b/JrxcD7dEvWGxcYL0Bbq9OFrzf0YWiXwW9STOtNKoH15mDgepO2ZL3J/PfjhyXvcsXPGcJ5k19nGHifacl6kwXGC9DW6kzh6w19DDzL4Dc5pvUml8B6cxRwvfEsWW/8/378sORdrvgZKZw3+bXPwPssS9abxYDxArS1Okv4ekMfgF+MwW8WZ1pvFk9gvTkRuN4sYcl6s+R/P34ck6848dq/8YMaj/xlSYZ4/KkHTx5Hz+dPwNhrAuYgPVRD3wjfaBNoK9V1YYALGzs6F0s1/vPn0o0NlR/rXip05ui9pRun/gFv5CTO4FhuOJZaqhGHa+lGnAGmxymdeE39DEgg5X9aYk45InTKZaqdcoTBKZeZBqd04rWKSYzrlCOATrlMI9a4aOf7OwAZVsURjdhVEYWv9M9c5slfiDt4lc39DFxllwXOIfEMY7aiIW3E4Z/LNsrHuBwa4/+Pzr48sNS31dmXt8DZV7DF2cEVBtTZkWXvijiDuLYGzooWBM5K9cCJjbGMDJyVcQZJ2Ro4K1sQOKvUAyc2xhIycFbFGSRta+CsakHgrFYPnNgYA2TgrI4zSMbWwFndgsBZoy7oAd/2xU1i1lZnX9MCZ19LqrNHxfJyeGevePfkxGsVjwDj8qUx0BsvzggTBnLuVmCwyRnABIR+UgXfcNxj0jtc5LijhG+oI84r4as+dSbQd4APa9Qo5o02sTdgMuSGVRhyw0igfVcRnhvOYsoNoy3IDasx5IazgL4DlNVqtPDccDZDbliDITecDbQvWv2hbXIOg03WYrDJOUCbrNUoO2911dcN2HFZsJ5pEdaRFmE9yyKsZ1uE9RwmrJZuPFYGuKixK/Z4rh3O+TrVezzXsWyT8drAhzPr4DYZqyQ3Gf9i4SbjdUMHXK/aAdc1bDJeL4FNxr8AnXJdoFOuJ3yTMQXgugxqdl3hm4zJX9ZmeE3zC7CyXr++yVit3ygf4wbS30na4Owb1jcZqw0tcPaNbHF29M4VpLMjy96N65uM1cYWBM4m9cCJv8kYGTib1jcZq00tCJzN6oETf5MxMnA2r28yVptbEDhb1AMn/iZjZOBsWd9krLa0IHC2qgv6+M6+dX2TsdraAmfPS99kTI6+AcMmiLWBT5w2EL7J+NwwYSDnbiMGm5wLTEDoJ1Vom5zHYJNNGGxyHtAmmwi3ySgGm2zGYJNRQJtsJtwm5zPYZAsGm5wPtMkWwm1yAYNNtmKwyQVAm2wl3CYXMtgkz2CTC4E2QRavpj0/HAfm6CQnek6Rp0MB+5ES/xJnIVSHxer9SAXDfqRiZD8S2sBdx38bLTFw3L1SBaDwKTbyOB460SI5B8CEbfJnJ177+wSC6REtIhGixkI+oi0Jtwf5S6kRn7dK4OKGK69KXjjLwk/CdD0EasCOy4L1PIuwjrII6/kWYb3AIqwXMmG19CSMa4DLUvhvE875ttWF/zaGwn/baTiIIOl0zDbAwmZbXHHtJnk65lcLT8dsFzrl9tVOuZ3BKbdP4HTMr0Cn3A7olNsLPx1DAbgdQ7W9ndBqu2t/AfnLNgz7C34FVts71E/HqB0a5WP8n/TNNDY4+4710zFqRwucfSdbnB295RLp7Miyd+f66Ri1swWBs0s9cOKfjkEGzq710zFqVwsCZ7d64MQ/HYMMnN3rp2PU7hYEzh71wIl/OgYZOHvWT8eoPS0InL3qgj6+s+9dPx2j9rbA2feRfjqGHP1/DBsjtgE+cfofcJWgMbqD53B0mDCQc7cTg01GAxMQ+kkV2iYXMdhkFwabXAS0yS7CbXIxg012Y7DJxUCb7CbcJpcw2GQPBptcArTJHsJtcimDTfZisMmlQJvsJdwmlzHYZB8Gm1wGtAm8eA0b2jbIpwj7Mm/gRmx8X5thS8l+QN6m/V1om9McIL583IWZxiszxCPykxiAvWyJn6zaP3yycED1Xrb9DXvZDmA8WdX1zRP0uA8K/707XY6N5v1QP57FoSeYP1cAxt0HuT9w0ToAmLyB/qwAPpLIiTykLQ4UfgKMCpz9GPLBQY2y8yDZ5SALeHP5+L5AHz8Y7ONdrRFsc2TuP+S/m2P/bRxxRw+dD26cZGPJWC+yCOvFFmG9xCKsl1qE9TImrNNzQEvQqcGUAS6LqD00nPPDqkXtoQZRe1hE1HY1yacGDwUWCofhTg2mkjw1+JuFpwYPD53yiGqnPNzglEckcGrwN6BTHg50yiMascZFOx8F4OEMSuVwZoUWd98V+cuhDPuufgOqgCPrpwbVkY3yMR4lfZOhDc5+dP3UoDraAmc/xhZnR29FRzo7suw9tn5qUB1rQeAcVw+c+KcGkYFzfP3UoDregsA5oR448U8NIgPnxPqpQXWiBYFzUj1w4p8aRAbOyfVTg+pkCwLnlLqgj+/sp9ZPDapTLXD206SfGiRHP4pht+yhwCdORwFXCRoDvSHn8jBhIOfuGAabXA5MQOgnVWibXMFgk+MYbHIF0CbHCbfJlQw2OYHBJlcCbXKCcJtcxWCTkxhschXQJicJt8nVDDY5hcEmVwNtcopwm1zDYJPTGGxyDdAm8OI1bGjbIJ8inC781GDXpn/0Fh/kacn9gPY4A+iD03Ka0YnX/p5HxJfqu8ajTaGHMGwhAuyLS/wE4pnhU4qR1fvizjTsixs5hROITrz291f092UwyhjhJwC4nPEFphOITWCcyH2QZwKT5Ehg8gb6oHrBklODSFucxVxAOPGaogLnDIYYPrtRdu4iu5xtAW8uHz8d6OPngH28q6EPU5z7382L/zaOWKEHxedEXglJxnqFRVivtAjrVRZhvdoirNcwYTWJ264m+KRf2gCXRTyeF875qGrxeJ5BPI6KiMeuJvmk33nAxX0U7qRfOsmTfr9beNLv/NApL6h2yvMNTnlBAif9fgc65flAp7ygEWtctPNRAJ7PoC7OZ1ZVcfdKkb+cx7BX6nfga4wL6yf91IWN8jGOlr4x0AZnv6h+0k9dZIGzX2yLs6O3jyOdHVn2XlI/6acusSBwLq0HTvyTfsjAuax+0k9dZkHgXF4PnPgn/ZCBc0X9pJ+6woLAubIeOPFP+iED56r6ST91lQWBc3Vd0AM2HtdP+qlrLHD2a6Wf9CNHH82w4/w84BOn0cBVgsZAb6K5NkwYyLm7mMEm1wITEPpJFdom1zHY5FIGm1wHtMmlwm1yPYNNLmewyfVAm1wu3CY3MNjkSgab3AC0yZXCbXIjg02uZrDJjUCbXC3cJjcx2ORaBpvcBLQJvHgNG9o2yKcI1wk/6de1UR+9xQd5wvEMoD2uB/pgEif9aB4RX5fvGo82hZ7LsIUIsC8u8ZN+N4RPKW6s3hd3g2Ff3I2MJ/3IwKczGOU94ScAuJzxfUtO+iH3Qd4ATJI3ApM30AfV+5ac9EPa4ibmAsKJ1xQVONczxPDNjbJzF9nlZgt4c/n4dUAfvwXs410NfZji1v9uXvy3ccQKPSi+JfJKSDLW6yzCer1FWG+wCOuNFmG9iQmrSdx2NcEn/TIGuCzi8bZwzm+vFo+3GcTj7RHx2NUkn/S7Dbi434476ZdJ8qTfHxae9LsjdMo7q53yDoNT3pnASb8/gE55B9Ap72zEGhftfBSAdzCoizuYVVXcvVLkL7cx7JX6A/ga4676ST91V6N8jHdL3xhog7PfUz/pp+6xwNnvtcXZ0dvHkc6OLHvvq5/0U/dZEDj31wMn/kk/ZOA8UD/ppx6wIHAerAdO/JN+yMB5qH7STz1kQeA8XA+c+Cf9kIHzSP2kn3rEgsB5tC7o4zv7Y/WTfuoxC5z9cekn/cjR72bYcX4b8InT3cBVgsZAb6K5OUwYyLm7l8EmNwMTEPpJFdomtzDY5H4Gm9wCtMn9wm1yK4NNHmSwya1Amzwo3Ca3MdjkYY71BGiTh4Xb5HYGmzzKYJPbgTZ5VLhN7mCwyeMMNrkDaBN48Ro2eA4D1odPCD/p17VRH73FB3nC8XqgPZ4E+mASJ/1oHhFfl+8ajzaF3sqwhQiwLy7xk35PhU8pnq7eF/eUYV/c04wn/cjA1zEY5WvhJwC4nPEbS076IfdBPgVMkk8DkzfQB9U3lpz0Q9riGeYCwonXFBU4TzLE8LONsnMX2eVZC3hz+fgTQB9/DuzjXQ19mOL5/25e/LdxxAo9KH4u8kpIMtZbLMJ6q0VYb7MI6+0WYb2DCatJ3HY1wSf9sga4LOJxTDjnL1SLxzEG8fhCRDx2Nckn/cYAF/cXcCf9skme9PvTwpN+L4ZO+VK1U75ocMqXEjjp9yfQKV8EOuVLjVjjop2PAvBFBnXxIrOqirtXivxlDMNeqT+BrzFerp/0Uy83ysf4ivSNgTY4+6v1k37qVQuc/TVbnB29fRzp7Miy9/X6ST/1ugWB80Y9cOKf9EMGzpv1k37qTQsC56164MQ/6YcMnLfrJ/3U2xYEzjv1wIl/0g8ZOO/WT/qpdy0InPfqgh7wFfT6ST/1vgXO/oH0k37k6K8w7DgfA3zi9ApwlaAx0Jto7gwTBnLuXmOwyZ3ABIR+UoW2yV0MNnmDwSZ3AW3yhnCb3M1gk7cYbHI30CZvCbfJPQw2eYfBJvcAbfKOcJvcy2CT9xhsci/QJu8Jt8l9DDb5gMEm9wFtAi9ew4a2DfIpwofCT/p1bdRHb/FBnnB8EmiPj4A+mMRJP5pHxNflu8ajTaHPM2whAuyLS/yk38fhU4pPqvfFfWzYF/cJ40k/MvATDEYZL/wEAJczTrDkpB9yH+THwCT5CTB5A31QTbDkpB/SFp8yFxBOvKaowPmIIYY/a5Sdu8gun1nAm8vHPwT6+OdgH+9q6MMUX/x38+K/jSNW6EHx55FXQpKx3mUR1rstwnqPRVjvtQjrfUxYTeK2qwk+6ZczwGURj2PDOf+yWjyONYjHLyPisatJPuk3Fri4f4k76ZdL8qTfeAtP+n0VOuW4aqf8yuCU4xI46Tce6JRfAZ1yXCPWuGjnowD8ikFdfMWsquLulSJ/GcuwV2o88DXG1/WTfurrRvkYv5G+MdAGZ/+2ftJPfWuBs39ni7Ojt48jnR1Z9n5fP+mnvrcgcH6oB078k37IwPmxftJP/WhB4PxUD5z4J/2QgfNz/aSf+tmCwPmlHjjxT/ohA+fX+kk/9asFgfNbXdDHd/bf6yf91O8WOPsf0k/6kaN/w7DjfCzwidM3wFWCxkBvork/TBjIufuOwSb3AxMQ+kkV2iYPMNjkBwabPAC0yQ/CbfIgg01+YrDJg0Cb/CTcJg8x2OQXBps8BLTJL8Jt8jCDTX5jsMnDQJv8JtwmjzDY5A8GmzwCtAm8eA0b2jbIpwh/Cj/p17VRH73FB3nC8SOgPcYDfTCJk340j4ivy3eNR5tCv+A4VGbhSb8J4VOKidX74iYY9sVNZDzpRwb+kMEorf2xCRfNm8sZ2/rzLDTok37IfZATgElyIjB5A31QAeyayEk/pC3+Yi4gnHhNUYEzniGGKdhAGFlyF9mFMErnzeXjfwJ9vFsT1se7GvowRfem/2xe/LdxxAo9KO7WNMkukrE+YBHWBy3C+pBFWB+2COsjTFin51CVoJN+ngEui3jsEc55Y1NDpVDs0TS5eKQfGlIFSvJJvx5NOFyNTTjjJnnSb4KFJ/2aQqfsWe2UTQan7DkNTunEaxWTGNcpm4BO2bMJa1y081EANjGoiyZmVRV3rxT5C3EHP0bNTQC+xpgJOIfE08a9UjM1ycfYC43x/0dnbwZKXludvdkCZ2+xxdnR28eRzo4se1txBrH2pF+rBYHTVg+c+Cf9kIHTjjOItSf92i0InI564MQ/6YcMnE6cQaw96ddpQeD0rgdO/JN+yMDpgzOItSf9+lgQOH3rgj6+s/fDTaK1J/36WeDs/aU6e1Qs98I7e8W7Jydeq3gEKPGk36NhwkDOXQuDTR4FJiD0kyq0TR5jsEkbg00eA9qkTbhNHmewSQeDTR4H2qRDuE2eYLBJbwabPAG0SW/hNnmSwSZ9GWzyJNAmfYXb5CkGm/RnsMlTQJvAi9ewoW2DfIowALyJGf672MKN+ugtPsgTjuOBm8pnBvpgEif9/rYP8KQfbQrtzrCFCLAvLvGTfrOE++Jmrd4XN4thX9ysTXwn/cjAfzKclpld+AkALmccaMlJP+Q+yFmAi9aswEUL6INqoCUn/ZC2mI25gHDiNUUFzswMMTy78JN+ZJfZLeDN5eMDgD4+EOzjXQ19mGKO/25e/LdxxAo9KB7YNMkukrE+ZhHWxy3C+oRFWJ+0COtTTFgtPennG+CyiMdB4ZzPWS0eBxnE45yWnfQbBFzc58Sd9POTPOk30cKTfoNDpxxS7ZSDDU45JIGTfhOBTjkY6JRDhJ/0owAczKAuBjOrqrh7pchfBjHslZoIfI0xV/2kn5qrST7GuaVvDLTB2eepn/RT81jg7PPa4uzo7eNIZ0eWvfPVT/qp+SwInPnrgRP/pB8ycBaon/RTC1gQOEPrgRP/pB8ycBasn/RTC1oQOMPqgRP/pB8ycBaqn/RTC1kQOAvXBX18Z1+kftJPLWKBsw+XftKPHH1uhh3ng4BPnOYGrhI0BnoTzdNhwkDO3bwMNnkamIDQT6rQNnmGwSbzM9jkGaBN5hduk2cZbDKUwSbPAm0yVLhNnmOwyTAGmzwHtMkw4TZ5nsEmCzPY5HmgTRYWbpMxDDYZzmCTMUCbwIvXsKFtg3yKsKjwk35dG/XRW3yQJxxnBtrDseykH80j4uvyXePRptA5GLYQAfbFJX7ST4X74tzqfXHKsC/OZTzpRwYewGCUBYWfAOByxmGWnPRD7oNUwCTpApM30AfVMEtO+iFtkRJ+0o8KHIchhtNNsnMX2SVtAW8uH18U6OMZsI93NfRhiux/Ny/+2zhihR4UZ5om2UUy1mcswvqsRVifswjr8xZhHcOE1dKTfnkDXBbxmAvn3KsWjzmDePSm4VCVpJN+OeDi7uFO+uWTPOn3l4Un/fzQKRerdkrf4JSLJXDS7y+gU/pAp1xM+Ek/CkCfQV34zKoq7l4p8pccw16pv4CvMRavn/RTizfJx7iE9I2BNjj7kvWTfmpJC5x9KVucHb19HOnsyLJ36fpJP7W0BYEzoh448U/6IQNnmfpJP7WMBYGzbD1w4p/0QwbOcvWTfmo5CwJn+XrgxD/phwycFeon/dQKFgTOinVBH9/ZV6qf9FMrWeDsK0s/6UeOvgTDjvMc8InTEsBVgsZAb6J5IUwYyLlbisEmLwATEPpJFdomLzLYZASDTV4E2mSEcJu8xGCTZRls8hLQJssKt8nLDDZZnsEmLwNtsrxwm7zCYJMVGWzyCtAmKwq3yasMNlmZwSavAm0CL17DhrYN8inCKsJP+nVt1Edv8UGecHSA9ljVspN+NI+Ir8t3jUebQrMMW4gA++ISP+m3WrgvbvXqfXGrGfbFrc540o8MvCiDUTzhJwC4nNG35KQfch/kasAkuToweQN9UPmWnPRD2mIN4Sf9qMBZlSGG12ySnbvILmtawJvLx1cB+vhaYB/vaujDFGv/d/Piv40jVuhB8VpNk+wiGeuLFmF9ySKsL1uE9RWLsL7KhNXSk34FA1wW8bhOOOfrVovHdQzicd1pOFQl6aTfOsDFfV3cSb9Ckif9aA9D3LGSPum3XuiU61c75XoGp1w/gZN+0UmM65TrAZ1yfeEn/SgA12NQF+sxq6q4e6XIX9Zh2CsF8MN/53CD+kk/tUGTfIwbSt8YaIOzb1Q/6ac2ssDZN7bF2dHbx5HOjix7N6mf9FObWBA4m9YDJ/5JP2TgbFY/6ac2syBwNq8HTvyTfsjA2aJ+0k9tYUHgbFkPnPgn/ZCBs1X9pJ/ayoLA2bou6OM7e75+0k/lLXD2gvSTfuToGzLsOF8H+MRpQ+AqQWOgN9G81uOfhIGcu40ZbPIa8BQA+kkV2iavM9hkUwabvA60yabCbfIGg002Z7DJG0CbbC7cJm8y2GRLBpu8CbTJlsJt8haDTbZmsMlbQJtsLdwmbzPYpMBgk7eBNoEXr2FD2wb5FKEo/KRf10Z99BYf5AnHVYH2CCw76UfziPi6fNd4tCl0bYYtRIB9cYmf9CuF++LK1fviSoZ9cWXGk35k4FUYjLKS8BMAXM64siUn/ZD7IEvAJFkGJm+gD6qVLTnph7TFNsJP+lGBEzDE8LZNsnMX2WVbC3hz+XgR6OPbgX28q6EPU2z/382L/zaOWKEHxds1TbKLZKyvW4T1DYuwvmkR1rcswvo2E1ZLT/oVDXBZxOMO4Zz/r1o87mAQj/+bhkNVkk767QBc3P+HO+lXTPKkXzcLT/rtGDrlTtVOuaPBKXdK4KRfN6DC3RHolDsJP+lHAbgjg7rYkVlVxd0rRf6yA8NeqW7AvVI710/6qZ2b5GPcRfrGQBucfdf6ST+1qwXOvpstzo7ePo50dmTZu3v9pJ/a3YLA2aMeOPFP+iEDZ8/6ST+1pwWBs1c9cOKf9EMGzt71k35qbwsCZ5964MQ/6YcMnH3rJ/3UvhYEzn51QR/f2fevn/RT+1vg7AdIP+lHjr4Lw47zHYBPnHYBrhI0BnoTzTs9/kkYyLnbjcEm7wBPAaCfVKFt8i6DTfZgsMm7QJvsIdwm7zHYZC8Gm7wHtMlewm3yPoNN9mGwyftAm+wj3CYfMNhkPwabfAC0yX7CbfIhg00OYLDJh0CbwIvXsKFtg3yKcKDwk35dG/XRW3yQJxwDoD0OsuykH80j4uvyXePRptDtGbYQdbPwpN/B4b64Q6r3xR1s2Bd3CONJPzJwkcEoGwo/AcDljBtZctIPuQ/yYGCSPASYvIE+qDay5KQf0haHCj/pRwXOQQwxfFiT7NxFdjnMAt5cPn4g0McPB/t4V0Mfpjjiv5sX/20csUIPig9vmmQXyVjftQjrexZhfd8irB9YhPVDJqyWnvQLDHBZxOOR4ZwfVS0ejzSIx6Om4VCVpJN+RwIX96NwJ/2CJE/6dbfwpN/RoVMeU+2URxuc8pgETvp1Byrco4FOeYzwk34UgEczqIujmVVV3L1S5C9HMuyV6g7cK3Vs/aSfOrZJPsbjpG8MtMHZj6+f9FPHW+DsJ9ji7Ojt40hnR5a9J9ZP+qkTLQick+qBE/+kHzJwTq6f9FMnWxA4p9QDJ/5JP2TgnFo/6adOtSBwTqsHTvyTfsjAOb1+0k+dbkHgnFEX9PGd/cz6ST91pgXOPlL6ST9y9OMYdpwfCXzidBxwlaAx0JtoPurxT8JAzt0JDDb5CHgKAP2kCm2TjxlschKDTT4G2uQk4Tb5hMEmpzDY5BOgTU4RbpNPGWxyGoNNPgXa5DThNvmMwSZnMNjkM6BNzhBuk88ZbDKSwSafA20CL17DhrYN8inCWcJP+nVt1Edv8UGecDwIaI+zLTvpR/OI+Lp813i0KfQIhi1E3S086XdOuC/u3Op9cecY9sWdy3jSjwx8IINRSsJPAHA5Y9mSk37IfZDnAJPkucDkDfRBVbbkpB/SFucJP+lHBc7ZDDE8qkl27iK7jLKAN5ePnwX08fPBPt7V0IcpLvjv5sV/G0es0IPi85sm2UUy1o8twvqJRVg/tQjrZxZh/ZwJq6Un/UoGuCzi8cJwzkdXi8cLDeJx9DQcqpJ00u9C4OI+GnfSr5TkSb8eFp70uyh0yournfIig1NenMBJvx5AhXsR0CkvbsIaF+18FIAXMaiLi5hVVdy9UuQvFzLsleoB3Ct1Sf2kn7qkST7GS6VvDLTB2S+rn/RTl1ng7Jfb4uzo7eNIZ0eWvVfUT/qpKywInCvrgRP/pB8ycK6qn/RTV1kQOFfXAyf+ST9k4FxTP+mnrrEgcK6tB078k37IwLmuftJPXWdB4FxfF/Txnf2G+kk/dYMFzn6j9JN+5OiXMuw4vxD4xOlS4CpBY6A30XzR45+EgZy7yxls8gXwFAD6SRXaJmMZbHIlg03GAm1ypXCbfMlgk6sZbPIl0CZXC7fJVww2uZbBJl8BbXKtcJuMY7DJ9Qw2GQe0yfXCbfI1g01uZLDJ10CbwIvXsKFtg3yKcJPwk35dG/XRW3yQJxzPBtrjZstO+tE8Ir4u3zUebQq9gGELUQ8LT/rdEu6Lu7V6X9wthn1xtzKe9CMDn8VglD2EnwDgcsY9LTnph9wHeQswSd4KTN5AH1R7WnLSD2mL24Sf9KMC52aGGL69SXbuIrvcbgFvLh+/Cejjd4B9vKuhD1Pc+d/Ni/82jlihB8V3NE2yi2SsYy3C+qVFWL+yCOs4i7B+zYTV0pN+ZQNcFvF4Vzjnd1eLx7sM4vHuaThUJemk313Axf1u3Em/cpIn/RotPOl3T+iU91Y75T0Gp7w3gZN+jUCFew/QKe8VftKPAvAeBnVxD7OqirtXivzlLoa9Uo3AvVL31U/6qfua5GO8X/rGQBuc/YH6ST/1gAXO/qAtzo7ePo50dmTZ+1D9pJ96yILAebgeOPFP+iED55H6ST/1iAWB82g9cOKf9EMGzmP1k37qMQsC5/F64MQ/6YcMnCfqJ/3UExYEzpN1QR/f2Z+qn/RTT1ng7E9LP+lHjn4/w47zu4BPnO4HrhI0BnoTzTc9/kkYyLl7kMEm3wBPAaCfVKFt8i2DTR5msMm3QJs8LNwm3zHY5FEGm3wHtMmjwm3yPYNNHmewyfdAmzwu3CY/MNjkSQab/AC0yZPCbfIjg02eZrDJj0CbwIvXsKFtg3yK8Izwk35dG/XRW3yQJxxvBtrjWctO+tE8Ir4u3zUebQq9k2ELUaOFJ/2eC/fFPV+9L+45w7645yP74tBGJgMjA6bLyOjNpMh9e88Bg/r5Jh7nQy8sSM5jhJ8Ao4XvWYZE8wLzXkUnXlNklxcs5I14aPVME34+v+khm/e3TLy/Fc77Oybe3wnn/T0T7++F8/6BifcPwnn/yMT7RzDvrobmv3aj7DqDxluqEV/rdgNiPAtnazW6nx1+8+KM1yuZ6huEjYR2YwTrHHpOJ4bXZ0Suz4xcE4aJkf/dS/rvL+v+iu6vNk3+lhr9EGQk0O4vAbXDa0wP4tDzNxg4fy8D5+914PyZfPu1pkk+/Hrk+pXI9atVvv2G/vubur+l+9uhb1Pv0zAptqMNnYfP6YGdk672ThMj4HcYFvZ3wbsLOHi/2zRpgkHjsi4m7wE3sXLifH/Gcaaqb5gSw3uRBHBWZKF7I3L//arE8IH++4e6f6T7x4ZFDz0HnwB36pvm4JMI17Mjc/DBFObgU/33z3T/XPcvmirHi3J34jVFhei7DA9elwJu9UPmp7HC32512QP9wB45h18Kf7A3sIdZYDnxmhrYQ2Z8fAX06egLpK8iL5C6GvoFA3IexoFjGx2DtOYh8w+tEV8yPLj/GvzGOamC/mymgv6bJkbA33A8iRde0BPvb5kKeg5x9C1DgYRckJH2/k74W1pK8l8zJL3vmZ+Q1BJC309BBPyg//6j7j/p/nMoAqZHYPwwhbF/0X//VfffdP+dUWCQvb5jsNcfwovQLt7oImIcMNb/BC/0PRqSWejPBC707RGc48M1aUL458Twz7+61qqeIZ/wz+7hnz3CPxvDP5vCP3uGf84U/tmrZ2R+OAINNJYTVQETmybfWtat5+T3Gg33Zuo5uUOgA625J4p3ivVJW8uM4wyqb5gWAZqHrmQ/PpL4J0SuW3pWLgKt+u9turfr3tGT//XSRGBx0doTZ5vOntjFhGv+/gLOXxtw/npbMn8NOJyqHTh/fXryFp+dkdzQO3LdJ3LdUZUb+uq/99O9v+4DEsgN3YC26Qu0zcyW+HZ34Pz1A87fLJbMXw/g/PUHzt+szLlh5kgOmCVyPWvkekBVbphN/3123QfqPkcCuaERaJvZgLYZZIlvNwHnb3bg/M1pyfz1BM7fQOD8DWbODYMiOWDOyPXgyPUcVblhiP77XLrPrfs8CeSGmYC2GQK0zbzMtpk3YoO5ItdzR67nqbLNfPrv8+u+gO5De/LvrFgQNwdl0xwsGOE6X+S6V8/aDz6H6f+2kO4L675Iz0nbzhobknl4NQzoF90jOIeHD5kWteUhExe+4T3xjuyAg7nrARmNewijrRZlmAvFNBdqCnOBeBrP4RfHMf/GqqngK04FH5sPHC/8N3URb0q06LcvQHsr5BzS4kUvKaILQnWb1n9raj4VHRNtt+Hg3NLVXBvfvERBTydmNbV/hzC7DInhBKZfWds4nTabnr1icTmnespMMEhbRP0yFVmoZ9Q+U5tzpH3SEfuoVErHRpBT5aCcyuR8t6CyqWy2nC7nsl46KGfS+SBXUul8yvVLOaesvFIpl0kVc9myHxSz5WjSVkEqlQ78QlFl3Gy+4HhBKu+U07mU6+SDVC4IUl42m0+lgqxX9nzPdfPllOdkcjnfybop3+WyTzq0z99KqGGS4p4e+0ylqYlTHs8tllUqo2fOyebTmSCbcgM35wTpTFlpo7l+WpusXEx7geemym7OLXapNdoPSn92LWR0PTyi5hYNrzP6z6zuuVDBJfXb1HJMT6zA9nGjc+GFytDv2VD5ep7+w4Sqe77hlT36kU0O8Jil61c2eMBHNn5PbEU2rRtf4+KOzoHyUq6bS9HPeYGj0oHWCK4bFNJO0ckX3ZKfVn457aZTxaBY0GPmVdkp54t+2ftnrCjexXoyAl7MUJ7HBb8YcCVeHOhYXHO4uKGCizuHi4MzHJq3X4N33HGXYHqssUTPyVcm9GZi5L6QDNDvl/w/SqhOvKaWBPtCV1uqJyPgpXrix12aOQk68drfvJfuOWmCQeNO8WVi7HkALlJZoH1GWBqsI5iCdZmejICXYQjWZYUHK/FeNuFgdeK1itXQidegyXQ55irNidf+fia6NMMDeOR50eUtmMNuwudwBXDybQ7ncbnIM59s5Hr5npNOGfwV2dneEPmZFcKfWVH/uZLuK4c5h8M+vnD7rMJkn0wN+6wSsc/UfmZV/edquq/OZJ+lw/UGrRTXsCBvrMHAe03hTwa6eKPjEfkuYi3wHKK5Us4EYlQU42sy+OLaFsSgz8B7HQtikIP3ukCf5IgbWrNX7In1n7UZ5nE9S2peNO/1LYgbDt4bCI8bquGBOU1RnliPYR43FL5uU60N9HFFfrMhwzxuZEEcbsRQQwI/WaBGAT+obNpVX+v0+MQpfE5kYz1nm+i+qe6b9Zz+j7nGtdvGEb9y85mglM6VgpTj5MturpBzsvl8XqVzWbdcTGe9cqZYLqpsMfCUypYK2YLjF5yym9XvRPNuwY/i3bwnI+DNDY4WF/zmwCSwhfBX4DSHWxiSVNw53AL8JoR8qHvD1IPAidfUxnZsTnKix462DANsq/DPrcM/82RXtMOQYcc18VStqMmJ7h3YOvI0rTpLbxl5orZV5HrrnrWzdEH/t6Luge6lnrU/+oRYRbcQ/iSmzFzRIZIbEKMqhOM1YG3C+hXtbWD8UxmTjZx4TdHH24Af0VL0UbY/GD6Wtq1w1Z8PfRPNezvw24/qHLxNJNduG7nebgo5eHv933bQ/X+678iYg+kDk+OEf4BuJ+F+SV98HscQj+f+3x4bnKavMnPwPk/I6aCpNBfp4zsD13Cg36jzmE6fEN8hoU1maqg8fdLV0HG6vfA8QnluW+baC53nub5278RrqtqHRIs5DnzkSDsxFEu7MD094LRP7N8P3fDPEbnJnEq3Xbn2f57BVFXsxlztRn+B3W6RCndoQ+1fYLe7/rk9dN9T97168n8NaFfgars78PHn3kzBJfkX2O0BnL99mH1774g/7xO53jNyvVfPSt/eV/99P9331/2AyDsP2iPX1DB5Q+cRoK1YH/d2VYecc7EbQ3yhMQ5tkI9xV0uKgH3BOMEKUnX9DirkeMjCh7Ah9xl3PTHg2FcFGstFF/b/Ng7phTYOdbSTCzVOxWOSuHN3Qf9kCre4OA8EFr7AR0MKOH8Vv5zuwMhjppaGyg+GZBrMDYMjneIZN1tmGrfEM24uzYQ3w4TXs2seXCa7cfkDl//a5mcZrjhm8t+sYrIbV57kmgeuvMM0D26RaVyHaX6Z/Cyb5RnXuvXN5RmXyx9yXONaFsds+cxnGperfsjxjMuWz7jmgct/6/P7z7j1OvXvxma3ep36D16meUjlecZlW+cLTPPAhTegZ0i9q8aW/gIDPw/1cevj1setj/sfHHdK274O6tmQ7C+EOgi4EnSP4Dw43L92SM8qAug9QwcB9/kcPO1jTfWX3xwC3jNk07f0gfj+5h59vXZwZE/UIeH1ofrPw3Q/vOf0nft24jV1WMTGMb98raJ4j+jJCPiInvBPn6sjgO9/j2Q+9+3Ea3/P4ZE94Z8+r+DtxGwUBK0NyZz7PoxRSwDnt+Lrukf1nMIW/rhOBzRkxaaDKOjpxFycFuc7agbOTE9t0o8CBvPR4BW1a15p3ENm0BeUnruicsqO7zp5J1fM5gp+4Ba8fDlVzqSC1IzO69ScHTmvxzDN6zHhvCZZziKTUTR5HhuuyMdxfBiiy0nQk3EU88E0FO/pDQ5nOnjH/l2Twg/3kWMez3Ae6wSmpHBCT77fOXsc01ycyDQXJ8ZYeKaGmcsvRgv/nbNcPnCR8N85e1jIG51LgfZWF9V/52x1+zt/o+YkWmCd1JPxkPLxTAnxpCkonKkMM9XfOUuYT2JIDBdb8jtnjwcWRSf3lJlgLmb6qsTJPfl/5yzSPqdEn0vG/J2zFwF/5yyXfU6JKE3UojC1JxvRMW1ZFE61cVE4lXlROJVhUbhEyKJQ04lz//z+WmTSOU3oonAJU9I5DbAoTO0xH9I+pwtdFLjsc/p/6PHjGeHjxzNNjx+deK3ms3/ke5C4YwEfZSoOw3fNIfpgLdccxh1rpHB7UMCMZFjYz2Iqcs5ifCx6JtNcnM00F2czPhbl8ovLhD8W5fKByy14LDqS4bEo0N7q8vpj0er2d/5GzUm08DuHUwGPZEqI5zAqYMJ8DkNiuMKSx6IjgUXRuT1lJpgrmBTWuQk8FkXa5zygAr4cqIC57HOewT7oDV5I+4xiyp+jAPMwtSc1yHk4n2kezp+Gx+SSF3IDXJgfR4uEC2wsEi5gLhIuYCgSrkyoSIi5Oxaa5C4EjoUsEq5kWoQunIYiIe4uW6R9RvfELezIIoHLPqMZnzzRN2eHNjBsxhK+KZM4X8Sx1wTg56V/3vyx8CZ8F3O8ThVub+J8CQPvS4XzJnyXcjxNFc6b8F3G8TRVOG/CdznHwyLhvAnfFRz1r3DehO9KBt5XCedN+K5i4H21BevY1Qy8rxHOm/Bdw8D7WgvsfS0D7+uE8yZ81zHwvl44b8J3PQPvG4TzJnw3MPC+0YL4vpGB903CeRO+mxh43yycN+G7mYH3LcJ5E75bGHjfKpw34buVgfdtFuS12xh43y6cN+G7nYH3HcJ5E747GHjfKZw34buTgfddFsT3XQy87xbOm/DdzcD7HgvsfQ8D73uF8yZ89zLwvs8Ce9/HwPt+4bwJ3/0MvB8QzpvwPcDA+0HhvAnfgwy8H7Igvh9i4P2wcN6E72EG3o9YYO9HGHg/Kpw34XuUgfdjFtj7MQbejwvnTfgeZ+D9hHDehO8JBt5PCudN+J5k4P2UBfH9FAPvp4XzJnxPM/B+RjhvwvcMA+9nLfDzZxl4PyecN+F7joH38xbY+3kG3mOE8yZ8Yxh4v2CBvV9g4P2icN6E70UG3i8J5034XmLg/bJw3oTvZQberwjnTfheYeD9qnDehO9VBt6vWZDPX2Pg/bpw3oTvdQbebwjnTfjeYOD9pnDehO9NBt5vWRDfbzHwfls4b8L3NgPvdyyw9zsMvN8VzpvwvcvA+z3hvAnfewy83xfOm/C9z8D7A+G8Cd8HDLw/tCCvfcjA+yPhvAnfRwy8P7bA3h8z8P5EOG/C9wkD70+F8yZ8nzLw/swCP/+MgffnwnkTvs8ZeH8hnDfh+4KB91jhvAnfWAbeXwrnTfi+ZOD9lXDehO8rBt7jhPMmfOMYeH8tnDfh+5qB9zfCeRO+bxh4f2tB3fItA+/vhPMmfN8x8P5eOG/C9z0D7x8s8PMfGHj/KJw34fuRgfdPwnkTvp8YeP8snDfh+5mB9y8WxPcvDLx/Fc6b8P3KwPs3C+z9GwPv34XzJny/M/D+QzhvwvcHA+8/LfDzPxl4jxfOm/CNZ+A9wQJ7T2DgPVE4b8I3kYH3XxbY+y8G3g0zyeZN+KijeXcTzpvwdWPg3V04b8LXnYF3D+G8CV8PBt6NwnkTvkYG3k3CeVM+b2Lg3VM4b8LXk4H3TMJ5E76ZGHj3ssDPezHwbhbOm/A1M/BuEc6b8LUw8G4VzpvwtTLwbhPOm/C1MfBuF86b8LUz8O4QzpvwdTDw7rRgHetk4N1bOG/C15uBdx/hvAlfHwbefYXzJnx9GXj3E86b8PVj4N3fgrzWn4H3AOG8Cd8ABt4zC+dN+GZm4D2LBX4+CwPvWYXzJnyzMvCezQJ7z8bAe3bhvAnf7Ay8BwrnTfgGMvCewwI/n4OB9yDhvAnfIAbec1pg7zkZeA8WzpvwDWbgPUQ4b8I3hIH3XBb4+VwMvOcWzpvwzc3Aex4L7D0PA+95hfMmfPMy8J5POG/CNx8D7/kt8PP5GXgvIJw34VuAgfdQ4bwJ31AG3gsK5034FmTgPUw4b8I3jIH3QsJ5E76FGHgvLJw34VuYgfciwnkTvkUYeA+3YP0ezsB7UeG8Cd+iDLwdC+ztMPBWwnkTPsXA2xXOm/C5DLxTwnkTvhQD77Rw3oQvzcA7I5w34csw8M4K5034sgy8c8J5E74cA2/PgvXbY+DtC+dN+HwG3osJ5034FmPgvbgFfr44A+8lhPMmfEsw8F5SOG/CtyQD76Us8POlGHgvLZw34VuagfcIC+w9goH3MsJ5E75lGHgvK5w34VuWgfdywnkTvuUYeC8vnDfhW56B9wrCeRO+FRh4r2hBPl+RgfdKwnkTvpUYeK8snDfhW5mB9yoW+PkqDLxXFc6b8K3KwHs1C+y9GgPv1YXzJnyrM/BewwJ7r8HAe03hvAnfmgy81xLOm/CtxcB7bQv8fG0G3usI50341mHgva5w3oRvXQbe6wnnTfjWY+C9vgXxvT4D7w2E8yZ8GzDw3lA4b8K3IQPvjSzw840YeG8snDfh25iB9ybCeRO+TRh4byqcN+HblIH3ZsJ5E77NGHhvLpw34ducgfcWwnkTvi0YeG9pwTq2JQPvrYTzJnxbMfDe2gJ7b83AOy+cN+HLM/AuCOdN+AoMvIvCeRO+IgPvwIL4Dhh4l4TzJnwlBt5lC+xdZuC9jXDehG8bBt7bWmDvbRl4byecN+HbjoH39hbYe3sG3jsI5034dmDg/T8L7P0/Bt47CudN+HZk4L2TcN6EbycG3jtb4Oc7M/DeRThvwrcLA+9dhfMmfLsy8N5NOG/CtxsD792F8yZ8uzPw3kM4b8K3BwPvPS3I53sy8N5LOG/CtxcD772F8yZ8ezPw3kc4b8K3DwPvfS2I730ZeO8nnDfh24+B9/7CeRO+/Rl4HyCcN+E7gIH3gcJ5E74DGXgfJJw34TuIgffBFuTzgxl4HyKcN+E7hIH3oRbY+1AG3ocJ5034DmPgfbgF9j6cgfcRwnkTviMYeB9pgb2PZOB9lHDehO8oBt5HC+dN+I5m4H2McN6E7xgG3sdaEN/HMvA+TjhvwnccA+/jLbD38Qy8TxDOm/CdwMD7ROG8Cd+JDLxPssDPT2LgfbJw3oTvZAbep1hg71MYeJ8qnDfhO5WB92kW2Ps0Bt6nC+dN+E5n4H2GcN6E7wwG3mcK5034zmTgPdKC+B7JwPss4bwJ31kMvM8Wzpvwnc3A+xwL/PwcBt7nCudN+M5l4H2eBfY+j4H3KOG8Cd8oBt7nW2Dv8xl4XyCcN+G7gIH3hcJ5E74LGXiPFs6b8I1m4H2RcN6E7yIG3hdLz2sa38UMvC+xIJ9fwsD7UuG8Cd+lDLwvE86b8F3GwPty4bwJ3+UMvK+wIL6vYOB9pXDehO9KBt5XCedN+K5i4H21cN6E72oG3tcI5034rmHgfa0Fee1aBt7XCedN+K5j4H29cN6E73oG3jdY4Oc3MPC+UThvwncjA++bhPMmfDcx8L5ZOG/CdzMD71uE8yZ8tzDwvlU4b8J3KwPv2yzI57cx8L5dOG/CdzsD7zsssPcdDLzvFM6b8N3JwPsuC+x9FwPvu4XzJnx3M/C+xwJ738PA+17hvAnfvQy877PA3vcx8L5fOG/Cdz8D7weE8yZ8DzDwflA4b8L3IAPvh4TzJnwPMfB+WDhvwvcwA+9HLMjnjzDwflQ4b8L3KAPvxyyw92MMvB8XzpvwPc7A+wkL7P0EA+8nhfMmfE8y8H7KAns/xcD7aeG8Cd/TDLyfscDezzDwflY4b8L3LAPv54TzJnzPMfB+3gI/f56B9xjhvAnfGAbeLwjnTfheYOD9ogV+/iID75eE8yZ8LzHwftkCe7/MwPsV4bwJ3ysMvF8VzpvwvcrA+zXhvAnfawy8X7cgvl9n4P2GcN6E7w0G3m8K50343mTg/ZZw3oTvLQbeb1sQ328z8H5HOG/C9w4D73ctsPe7DLzfE86b8L3HwPt9C+z9PgPvD4TzJnwfMPD+0AJ7f8jA+yPhvAnfRwy8P7bA3h8z8P5EOG/C9wkD708tsPenDLw/E86b8H3GwPtz4bwJ3+cMvL8QzpvwfcHAe6xw3oRvLAPvL4XzJnxfMvD+SjhvwvcVA+9xwnkTvnEMvL8Wzpvwfc3A+xvhvAnfNwy8vxXOm/B9y8D7O+G8Cd93DLy/F86b8H3PwPsH4bwJ3w8MvH8Uzpvw/cjA+yfhvAnfTwy8fxbOm/D9zMD7F+G8Cd8vDLx/Fc6b8P3KwPs34bwJ328MvH8Xzpvw/c7A+w/hvAnfHwy8/xTOm/D9ycB7vHDehG88A+8JwnkTvgkMvCcK5034JjLw/ks4b8L3FwPvhl64sRr1GH0i3KMNPR9R3E7MFsXbrRcjYBocPW53oAG5eHfvNWmCQeOyvZTkeBnboxeWd1frXs0/63rptOemCvmcq/LpQi5b9oNivux6BTfIOyXPyQY5N5/y8l5aFYp5zykEeTeTC/LpUla5SF9qjIyl/8Wi45edfMbL50p6IKfk6IuCVypn3XyhmHbcQClVSuv/55aCtF8IsqqQ1f96pqD0/85ka7dQ9LO5nP5fFoNCOq0yvpsPCiqniHy67OVSBVVIaaipXKbslsppx9eToWmW9RSkCiV6CUt8J5vDtJ8v6WELqWyqVNBgy24mm/f1/6qYLaWy6QLNbybllrPplJ4310ml8+ViOuM5vusV0+noC+i4c9jUS3a8EL6mXvh46SmcN+HrycB7JuG8Cd9MDLx7CedN+Hox8G4WzpvwNTPwbhHOm/C1MPBuFc6b8LUy8G4TzpvwtTHwbhfOm/C1M/DuEM6b8HUw8O4UzpvwdTLw7i2cN+HrzcC7j3DehK8PA+++wnkTvr4MvPsJ5034+jHw7i+cN+Hrz8B7gHDehG8AA++ZhfMmfDMz8J5FOG/CNwsD71mF8yZ8szLwnk04b8I3GwPv2YXzJnyzM/AeKJw34RvIwHsO4bwJ3xwMvAcJ5034BjHwntPSl7pzMr3UHdyLEfBghpe6Q4S/1CXeQ3pNmmDQuCxY6eVrI0OQzZXQS924LzqRvjR3L9yLUpOtVblcLOeCXKmcct1iLlfIpYqZTKFY1C+sCwWlbwWerydA33Vy+l9xc1kv5aWKRaegskH57xemQwwvdZWTzWWyfr6s/wE9J66jVKpULmv+erwgnc86mULGLWRTQdYra1qqqGcgyOTccrrku8ptAs7hPMIXJcI3D0O8zCucN+Gbl4H3fMJ5E775GHjPL5w34ZufgfcCwnkTvgUYeA8VzpvwDWXgvaBw3oRvQQbew4TzJnzDGHgvJJw34VuIgffCwnkTvoUZeC8inDfhW4SB93DhvAnfcAbeiwrnTfgWZeDtCOdN+BwG3ko4b8KnGHi7wnkTPpeBd0o4b8KXYuCdFs6b8KUZeGeE8yZ8GQbeWeG8CV+WgXdOOG/Cl2Pg7QnnTfg8Bt6+cN6Ez2fgvZhw3oRvMQbei1v6cnNxppebS/RiBLwEw8vNJYW/3CTeS/aaNMGgcVmw0kvIuRmCbKmEXm7GfeGH9KWle+FeGBptnSk75XIhly8VS5lSKq+yhUzazaTzXraULnhePnCClP6JUqHs+iXXzeSU/ocymVTOyxWLJW+e0C8ne0Gcz6XSpUIh5WZTaVUq55VfcFJZFfgq5RSDdK7gZgu5tOfpF7OBmy2VivpmWb+z9XJ6RlR+HuAcjhC+KP2NjyFelhHOm/Atw8B7WeG8Cd+yDLyXE86b8C3HwHt54bwJ3/IMvFcQzpvwrcDAe0XhvAnfigy8VxLOm/CtxMB7ZeG8Cd/KDLxXEc6b8K3CwHtV4bwJ36oMvFcTzpvwrcbAe3XhvAnf6gy81xDOm/CtwcB7TeG8Cd+aDLzXEs6b8K3FwHtt4bwJ39oMvNcRzpvwrcPAe13hvAnfugy81xPOm/Ctx8B7feG8Cd/6DLw3EM6b8G3AwHtD4bwJ34YMvDey9CXfRkwv+TbuxQh4Y4aXfJsIf8lHvDfpNWmCQeOyYKWXcUszBNmmCb3ki/viC+lLm/XCvTgz2Vq/qUzn3Xwho380Xc7kUvq9ptL/hFPWrzMJTCrIBHnfSRdS2bRfLri5QtFJFRz698qFfG5E6JeTzWHRL+cLxZyXzgQZR9PMuCU376RyqqgnRJVVOlNygoLnljxNx8+qopspq1JKvzIt0ASNAM7h5sIXJcK3OUO8bCGcN+HbgoH3lsJ5E74tGXhvJZw34duKgffWwnkTvq0ZeOeF8yZ8eQbeBeG8CV+BgXdROG/CV2TgHQjnTfgCBt4l4bwJX4mBd1k4b8JXZuC9jXDehG8bBt7bCudN+LZl4L2dcN6EbzsG3tsL5034tmfgvYNw3oRvBwbe/xPOm/D9j4H3jsJ5E74dGXjvJJw34duJgffOwnkTvp0ZeO8inDfh24WB967CeRO+XRl472bpy67dmF527d6LEfDuDC+79hD+sot479Fr0gSDxmXBSi+lNmMIsj0TetkV9wUQ0pf26oV7gWSytVvKpDL6+YKXzRUD/ZYsTS/NsulMMZMJCjk3FSj9bs11vEw2KAS5nPJKfrrgeHpicuWUfsO3eeiXk73scpVTLmVTmXwhXcylA/0WrlAs55xC0dVvD1N+Jus5GrXjukHg+6qsXycG6YyTzRf0/YwfbA6cw72FL0qEb2+GeNlHOG/Ctw8D732F8yZ8+zLw3k84b8K3HwPv/YXzJnz7M/A+QDhvwncAA+8DhfMmfAcy8D5IOG/CdxAD74OF8yZ8BzPwPkQ4b8J3CAPvQ4XzJnyHMvA+TDhvwncYA+/DhfMmfIcz8D5COG/CdwQD7yOF8yZ8RzLwPko4b8J3FAPvo4XzJnxHM/A+RjhvwncMA+9jhfMmfMcy8D5OOG/CdxwD7+OF8yZ8xzPwPsHSlz4nML30ObEXI+ATGV76nCT8pQ/xPqnXpAkGjcuClV7O7MUQZCcn9dIn5osQpC+d0gv3IsVkaw2ioMpu0S2nvKJGVcrny7lsuVzO5J0gm86lisov+umUfqmU99JBxtf/sMqlgnRQyhYKXnrv0C+r51DlA98tp7N6cC/w83oi806xpHkXSo7nqkypqPKq7OiJ9kulQkG/KssGQSmTzbvK1/NY2hs4h6cKX5QI36kM8XKacN6E7zQG3qcL5034TmfgfYZw3oTvDAbeZwrnTfjOZOA9UjhvwjeSgfdZwnkTvrMYeJ8tnDfhO5uB9znCeRO+cxh4nyucN+E7l4H3ecJ5E77zGHiPEs6b8I1i4H2+cN6E73wG3hcI5034LmDgfaFw3oTvQgbeo4XzJnyjGXhfJJw34buIgffFwnkTvosZeF8inDfhu4SB96XCeRO+Sxl4X2bpy4/LmF5+XN6LEfDlDC8/rhD+8oN4X9Fr0gSDxmXBSi8pTmEIsisTevkR94UA0peu6oV7oWCytXJz2WK67KZSTqaYcjRPt5Ry8rlyoeRlCoFTLKdKJTdw8uVMWaU0AKX8XOAE5ZRGkg/Kp4Z+OdkcBqXA8z0nX3ILQaDyadfVCB09qO+Vi14x45UzTiaXK+Yz+UyxlCq4RS/neZlyMXAKGTd1KnAOrxa+KBG+qxni5RrhvAnfNQy8rxXOm/Bdy8D7OuG8Cd91DLyvF86b8F3PwPsG4bwJ3w0MvG8Uzpvw3cjA+ybhvAnfTQy8bxbOm/DdzMD7FuG8Cd8tDLxvFc6b8N3KwPs24bwJ320MvG8Xzpvw3c7A+w7hvAnfHQy87xTOm/DdycD7LuG8Cd9dDLzvFs6b8N3NwPse4bwJ3z0MvO8Vzpvw3cvA+z5LXwLcx/QS4P5ejIDvZ3gJ8IDwlwDE+4FekyYYNC4LVnpYfxVDkD2Y1EuAmA/Gkb70UC/cg3WjrfMZ/d4gUEHOdYvlYtan326TLxdz9OIjk/FzBQ1R/yt+UCymCmX9s77+j6W8XyzqwfOFq0O/rJ5DN6vcTJBXTt4pBU425eYyjpcv5J1soPRkpvLFrMrq20GhFKTSfjmT0myCvJ9JpVI5L5O7GjiHDwtflAjfwwzx8ohw3oTvEQbejwrnTfgeZeD9mHDehO8xBt6PC+dN+B5n4P2EcN6E7wkG3k8K5034nmTg/ZRw3oTvKQbeTwvnTfieZuD9jHDehO8ZBt7PCudN+J5l4P2ccN6E7zkG3s8L5034nmfgPUY4b8I3hoH3C8J5E74XGHi/KJw34XuRgfdLwnkTvpcYeL8snDfhe5mB9yuWPgx/helh+Ku9GAG/yvAw/DXhD8OJ92u9Jk0waFwWrPTQ+iGGIHs9oYfhcR8QI33pjV64B8xGW5ecVDaXLumH55kgE+Sy2WJQcPXT/3xZvwZI58q5kvIdJ1vOZl3Xz2RLuWLaL6q0Vyo6fiqdeTj0y8kehrtZR9NOe+l0QT+cdzPKc/1UJuVnvVLaVxn9nsHNeGnlpTK5dC6lH96rQM9sOatS5WyxEDwMnMM3hS9KhO9Nhnh5SzhvwvcWA++3hfMmfG8z8H5HOG/C9w4D73eF8yZ87zLwfk84b8L3HgPv94XzJnzvM/D+QDhvwvcBA+8PhfMmfB8y8P5IOG/C9xED74+F8yZ8HzPw/kQ4b8L3CQPvT4XzJnyfMvD+TDhvwvcZA+/PhfMmfJ8z8P5COG/C9wUD77HCeRO+sQy8v7T0ofCXTA+Fv+rFCPgrhofC44Q/FCbe43pNmmDQuCxY6eHtGwxB9nVSD4VjPihF+tI3vXAPWk22Vlkv66tiKp/NpzN6oEwxXSqWCvlioZgr551y1i2mMuW0n9X/wdfPmvUz8EIqU9IwUm6q7Lpvhn5ZPYfKDwINspzKe0E6W1SZoqNy2XKhkCn4mVI6KGZyjueVyxpaOlCFwEsXs4VyPpMLikFRG+BN4Bx+K3xRInzfMsTLd8J5E77vGHh/L5w34fuegfcPwnkTvh8YeP8onDfh+5GB90/CeRO+nxh4/yycN+H7mYH3L8J5E75fGHj/Kpw34fuVgfdvwnkTvt8YeP8unDfh+52B9x/CeRO+Pxh4/ymcN+H7k4H3eOG8Cd94Bt4ThPMmfBMYeE8UzpvwTWTg/ZelD0f/Yno42tDMCJgGR4/brVn2w1Hi3a150vyCxmXBSg8xv2EIsu7NyTwcjfvAEOlLPZpxDxxNtlZ6INfxcik/o3/Qzer/Zbnglcp+Pufqh795TckpF/yym9I8yl5KFfWPasquyjn5nAq+Df1ysjkslD030JOWC3Jp39EzprEVi/pBslPKKv2QOaPcUjGvHy1nMq5ySm4uW9Lz4RVLXjnjlTLfIhNqs+x4IXyNzfh4aRLOm/A1MfDuKZw34evJwHsm4bwJ30wMvHsJ5034ejHwbhbOm/A1M/BuEc6b8LUw8G4VzpvwtTLwbhPOm/C1MfBuF86b8LUz8O4QzpvwdTDw7hTOm/B1MvDuLZw34evNwLuPcN6Erw8D777CeRO+vgy8+wGfCyT5kLAf0F5RvP2bGQH3Z3hIOED4Q0LiPcCSh4T0MK8HQ5DNnNRDwpgPzpC+NEsz7sGbydZuOZfx9YheLl8uuKV0JlXIeNmyp5+FlnOFTEmpbMHzXD2oly67KpVzc+WsX1Yqo3+ymC40hn7ZfTIfKpUKbrGQ8T1VCtKZbNrPF0qFoOR4KijqB5nZopd1VFBKp9K5Ui4IVNb1Cnk3yOeL6VQh1wicw1mFL0qEb1aGeJlNOG/CNxsD79mF8yZ8szPwHiicN+EbyMB7DuG8Cd8cDLwHCedN+AYx8J5TOG/CNycD78HCeRO+wQy8hwjnTfiGMPCeSzhvwjcXA++5hfMmfHMz8J5HOG/CNw8D73mF8yZ88zLwnk84b8I3HwPv+S19WDY/08OyBZoZAS/A8LBsqPCHZcR7qCUPy+ih1iwMQbZgQg/L4j5AQvrSsGbcAyijrVNpL+85KS9XKhdTvlfIBrRHsKhyfsYteoGbdfxCSRVSXj4V6AeIfj4f+EU/m1eBr1JObtbQLyebw0AV8tmsppLW2HzlqJz+v3I+65eKbiFwHNfN6/8L0nrW8o7j5+mctlcO0iU3WyqWC7MC53Ah4YsS4VuIIV4WFs6b8C3MwHsR4bwJ3yIMvIcL5034hjPwXlQ4b8K3KANvRzhvwucw8FbCeRM+xcDbFc6b8LkMvFPCeRO+FAPvtHDehC/NwDsjnDfhyzDwzgrnTfiyDLxzwnkTvhwDb8/Sh0Ye00Mjv5kRsM/w0Ggx4Q+NiPdiljw0ooc7wxiCbPGEHhrFfZCC9KUlmnEPYoy2dotB2XOVSmVyhULe831HlVPlUi6VT+tHZumcJpn3szlHP6kqZugylSunAuWVvJSvcsFCoV9O/tDIz2ayGVUMAr+U9pQqp0sZVfCcICjm9ewW0hpdqaRyadfJ50vZvH6y5aiim1W5YrbkZRYCzuGSwhclwrckQ7wsJZw34VuKgffSwnkTvqUZeI8QzvtvfAy8lxHOm/Atw8B7WeG8Cd+yDLyXE86b8C3HwHt54bwJ3/IMvFcQzpvwrcDAe0XhvAnfigy8VxLOm/CtxMB7ZeG8Cd/KDLxXsfThySpMD09WbWYEvCrDw5PVhD88Id6rWfLwhB5yLMEQZKsn9fAk5gMFpC+t0Yx7IGGytVsup/Mp13e9Yq6sirmCl3Iz+VLJ8YqlsiqpTEblyulsplTQf2gKZT8V6Ccz2Uw6Tb8S110y9MvJ5tDJlvOFtOab9TUU16GdQPmil/MKbjabKwQpVSinSq5XSunHPblsOp+nHw78QiHQ/63igUfcOVxT+KJE+NZkiJe1hPMmfGsx8F5bOG/CtzYD73WE8yZ86zDwXlc4b8K3LgPv9YTzJnzrMfBeXzhvwrc+A+8NhPMmfBsw8N5QOG/CtyED742E8yZ8GzHw3lg4b8K3MQPvTSx9iLAJ00OETZsZAW/K8BBhM+EPEYj3ZpY8RCCxvwZDkG2e0EOEuMIa6UtbNOOEucnWbi7l5ryg6KT044ayyheyOTeXSbte2s1q5qmCSru5kqecfCETpAPPzfl5z3FVqVwI3ELRWzP0y8keIvgp+hWF2aDklgPllDXUIHByqbKeKd/J+7lsWWX9ov7DSWl8viqmc7lMTnNKu0E6lV8TOIdbCl+UCN+WDPGylXDehG8rBt5bC+dN+LZm4J0Xzpvw5Rl4F4TzJnwFBt5F4bwJX5GBdyCcN+ELGHiXhPMmfCUG3mXhvAlfmYH3NsJ5E75tGHhva6mY3pZJTG/XzAh4OwYxvb1wMU28t7dETJPo3YIhyHZISkzHFJhIX/pfM06gmmztajmuvFIpncsW/UK55KTpt1MFpaCYLpTzpUK2nNOUtBLPuOlcuZjNpYKcX/TzOT+bCZT7t1Dd3iSm3Vw+lfHSvl/UhN1CIa3vlINcPpPKZIKcKnhF5RZVLpf202WnmA+0Fsh4Zc3Bz7ulkrslcA53FL4oEb4dGeJlJ+G8Cd9ODLx3Fs6b8O3MwHsX4bwJ3y4MvHcVzpvw7crAezfhvAnfbgy8dxfOm/DtzsB7D+G8Cd8eDLz3FM6b8O3JwHsvS0XlXkyicu9mRsB7M4jKfYSLSuK9jyWiksTf/xiCbN+kRGVMoYX0pf2acULNZGvX1/DTBZVTyi8X6Zea+MrzPf2/LfulbM4vlTSrkpcLnFLW90rZlCp5mXLBTaUCldfqdcfQLycTlVmte30NxlG5fNp1SoVCqVDUmB0vl1OlVIq+XOkXnbwX6JfJ+YJSZd/PlJT+mVLGV+6OwDncX/iiRPj2Z4iXA4TzJnwHMPA+UDhvwncgA++DhPMmfAcx8D5YOG/CdzAD70OE8yZ8hzDwPlQ4b8J3KAPvw4TzJnyHMfA+3FJxdTiTuDqimRHwEQzi6kjh4op4H2mJuCIRtB9DkB2VlLiKKTiQvnR0M06wmGztqnQ2qzKpUj6dzznFoOD5jtI6MZ8qZTOqlEs7TqpQcrK5IK2xqUIhn9dvActu3iuX8l4qvX/ol5OJq7LSalS/xMxq8uVMoawn0i06pSDwC3q0TMlLOW4+rcrFnKfBZjw/lc+V8yqtyWVyxdL+wDk8RviiRPiOYYiXY4XzJnzHMvA+TjhvwnccA+/jhfMmfMcz8D5BOG/CdwID7xOF8yZ8JzLwPkk4b8J3EgPvky0VGScziYxTmhkBn8IgMk4VLjKI96mWiAwSA0czBNlpSYmMmIU30pdOb8YV7iZbu14h5flKpQoqUEU3XcwV824mWyi5af32J18sZjW7TDmt3KyXK2WdXCFd8unNUSGTp19Rf0zol5OJjFzBKWayWnSptJd29BslL+s66bxfTmXLZQ1X5fy0m0lr2E7ZTTlFDTarfJXT/2wun8seA5zDM4QvSoTvDIZ4OVM4b8J3JgPvkcJ5E76RDLzPEs6b8J3FwPts4bwJ39kMvM8RzpvwncPA+1xLi+1zmYrt85oZAZ/HUGyPEl5sE+9RlhTbVBSfzhBk5ydVbMcsQJG+dEEzroA12Vr5uUA5uUxKKwg/q//i6cHSyvd919NVeuDks57vllJFt5hz0/pNQjZI5fXbjFQm65Zy5b8LxVGGYltpQZAKykGevqTh+yooZ4ol/TpCv/vwNUdHBcVCJpNNF7JlmmDf169HtCgoFvJ+oKdGnQGcwwuFL0qE70KGeBktnDfhG83A+yLhvAnfRQy8LxbOm/BdzMD7EuG8Cd8lDLwvtbTovJSp6LysmRHwZQxF5+XCi07ifbklRScVhxcwBNkVCRWdcQsxpC9d2Ywr5Ey2VsV0MaVLal2++r6T0U+PnVQ2n3ZSOX07n82XlBeowE1n3EAPHOgyO10s571SUMo55aDoXRj65WRzmNb/YjodZAqO55SLeardg0Ium/YLGr/Gl81niwU37WZLKTddKAUFP63r5oxSXtlxU/kLgXN4lfBFifBdxRAvVwvnTfiuZuB9jXDehO8aBt7XCudN+K5l4H2dpcXXdUzF1/XNjICvZyi+bhBefBHvGywpvqhIupIhyG5MqviKWZAgfemmZlxBY7K1m/XLqpAv6meJWf04MeeqwHMzeT9Fe4Ez+slnURVUyi2Ws65+mpmj54z6EWPaKaTT+VKQcq8K/XKy1+t+MaP/Z1nNv+CnAtoW7bmOE6RzRafg5n2/qCeRfolPyiuV9JPVVKkUpPX/JFUoZJQbVBRMcefwZuGLEuG7mSFebhHOm/DdwsD7VuG8Cd+tDLxvs7QIuY2pCLm9mRHw7QxFyB3CixDifYclRQgVCzcxBNmdSb12jLkwI33prmbcwm60tX6KpPk5xXw2U3J02VLQ/34255SKuurSD7u8UjFTKmZzWTebz6XL+slXsVgqFPX/oKwRl3M3h3452Rwqx3P121qly6JCOV1SxWxJT5N+VBUEGccr+n42KOt/S78TLZULvldQKqP56fJJT1jWKdwMnMO7hS9KhO9uhni5RzhvwncPA+97LV2M72VajO9rZgR8H8NifL/wxZh432/JYkyL5l0MQfZAQotx3AUK6UsPNuMWOKOtMykn0P+u8nL60YFDI6fzOS9bygcq67vZIBPQcBpt3s1mvWy+nEmnvbR+G5V288pz7w79crLFuJBK5QINUVcu6bLrloqaYMkt+3qEkn67lXGzbi6VzZY9lXPyjq5lPP1UI53XdU6QKXkVC2jcOXxI+KJE+B5iiJeHLV2UHmZalB5pZgT8CMOi9KjwRYl4P2rJokSLx4MMQfZYUotSzESN9KXHm3GJflpsXUgV00HOD9Iq76tcxisW0n4xlVG5ol7W0vmMq1fesnJTWccrF/1i8aHQL7tPxdZO2itkS0oTC7y00lNQLOXddDlbDjTiQqnoppTrpHN61Jx+J5DKPgScwycsTc5PMCXnJ5sZAT/JkJyfEp6cifdTliRnSqKPMyTnp5NKzlVtehMW0peeacYlPJOtETZ5hsHWz0bfnXopV6869HNe4Kh0UHQ91w0KaUc/Ti26JT+t/HLaTaeKQbGgx8yrslPOF/2y989YSSbUZ5kS6nPNjICfY0iozwtPqMT7eYaESs7W2jApqZha178V17E55qUroNHzEnXmMRF/g2eO53ERqAhbjxBjF+jGsEcJ2WKEqFO+EI7/IvHiMMIYhqwyhvnhD4r31EqK6WwVvONifEn4AzRyzJcYSoqXwUtzV2KgcQ8Jx0XPxYtMc/EK01y8wjgXXKXmq8JzClc8XNX//5R3cSr42Hz/6v6y8x9xfpVhDQHaWyHnkIqppoZpq5inNtbUfCo6Jse6hZqTaHH52pSqZSdeUy8xLQRR0NOJWU3t3yHMrzEkhmvBiaGrNU6nzaangIvL+fVmmQkGaYuoX74eKVBm1D5Tm3Okfd6IPgdLpXRsBDlVDsqpTM53CypL72LS5VzWSwf6FVE+yJVUOp9yfTrOQL8oKpdJ0a/y9YNithxN2ipIpdKBXygq/UonX3C8IJV3yulcynXygX4FFKS8bDafSgVZr+z5+qlEvpzynEwu5ztZN+W7XPZ5w2Cf6V0Ip/bYBGmfN5ny55uAeZja4yXkPLzFNA9vhfMwpSJB8kJugAvz42iR8LaNRcLbzEXC2wxFwnUJFQlTU09JJrl3gGMhi4TrmBahd6ahSJjaPGgHVUXllB1fr6hOrpjNFfzALXh6HS1nUkEKaZ93m3ELO7JI4LLPuzGeMk0tbrqe4PbAxuP0vA+b6ljIp8HvNWMXpC4bvRfDRlMrXGbQRlONyel5Zzm1sZA2er8ZN3dRG70fKa6qX2k1zKDtpgYP+bQ1Wgx+EL7O+tD0OsuJ11St1zrId5VxxwK+GjN+6seJ19SMBu3/1RzGHesj4faggPmIoUD+mEksfMz4aulDprn4hGkuPpnCXMTFzOUXNwh/3cTlAzcKf930asgb/boJaG91Y/11U3X7O3+j5iRa+H3K+STpI6aE+CnjkyTC/ClDYrjJktdNHwGLos+aZSaYm5ieVHyWwOsmpH0+B75uuhH4JInLPp9Pw+uFhum017Ts2u1qtiwKX9i4KHzBvCh8wbAo3CxkUajpxLny3w2ZdMYKXRRuZko6YwGLwtQe8yHt86XQRYHLPl9GFoWkzg1FH4vGPBaioni/amYE/JVBNsYF/xUwGYwDBgHXHI4zLCJx53Ac845mJ177e8Efx/AoGJn0kL7zNfhRcFdDv454Fcj5G+G76mv5oBOvIYtZaP76FmwP9ONC8j0gRkUx9w1Dgf4dWKz0apjkg/T3obpPDK/p35qInee//83ukX/v4J6T/r1Dwuvv9b/7g+4/Nv9TBPVtSGbj3Y9CNt5NpbnRufgpLLB+bg4npKuKpP8woQoAOtn8CEgQpX8EXfknYLL5GWjI6anC4+L+CVeFVzw++aWZEfAv+Crc+QWYiX9lrsIRc/grvgp3fhVeAf1cg3fccX9jepz3W+jnlBD6NUxKptGGXpEG97BhRXL5xlaTEhn9OSS8/l3b4g/d/9R9PC10VKno/hcluhb9s7p3172H7o26N+neU/eZdO+le7PuLbq36t6me7vuHbp36t5b9z6699W9n+79dR+g+8y6z6L7rC0NlSstgelVde8Pw70/DffGG+5NMNybaLj3l+Eeka++181wr7vhXg/DvUbDvSbDvZ6GezMZ7vUy3Gs23Gsx3Gs13Gsz3Gs33Osw3Os03OttuNfHcK+v4V4/w73+hnsDDPdmNtybxXBv1vBetM0V/jki/NOJ1yqSTtxk/DusQnTUH6CxiOOfkLH+ma/x8cdyu3ZsTIg7VnrS7o+J8cZyojtJ/oozllu1K6Vlhsdyqne4dJvBsfTrgMl2y3SfsbE8086bHjMylmfexdM4/WPlau0IapresXK1dxf1nL6x3CntVJppesbKTXnXU69pH2uqu/Kap3Ws3FRzoWqZtrGcacirqnVaxnKmKUertqmPlZnGfK/apzZWeprXDtUxxbHoW+XTPlbnlMbKTdeapnrXHsubzvVR9akxll+e7rVW9TWP5czAuq36mcZyZqgGUP0nH0vNYD2hBlSPFcxwbaJmrhwrFaPOUbNExnLLsWomNWvL/83TKydeq8Adr9YLKt4hz9bCCJgGR73H6gI/G86AanbApHK+Q6Y5JIyopzhdczg7OAiSeoeAC96A9alKdC4GhgE2R/WTjYGhYaP35jAoUPR7BVwmcdRAYADNATYu2vkoaAYCg7GL90BLV6RZYH7kB1G8g1oYAQ+Cr0h+MAi4Is0pfEWiOZwTviL5wZyWrkizwHD7RQNclhVpcBhgQ6pXpMGGFWlIAivSLMAVaTAwgIYwGRe9tQvJeS5gMmtowK+Ws4cJCL1FCSkF5gYmM9McOvGaIhvPzVDJzG1pJTMzLP8UUlG887QwAp4HXskUUvMAg39e4ZUMzeG88EqmkJqXOfgRCXRu4Ql0PvAcdjX0wov08fmBsZdkBTwzDHfBNcBlqYAXCBPz0OoKeAFDBTw0gQoYtwI5agGgUw5lMi46EJGcF2SugJ14TVFynJ+hehsmvGoluwyzgDeXjw8D+vhCwn28VpGCKH5QYy0MXrCTUjsDYGuNV47iXaSFEfAicLXjlRcBGnC4cLVDczgcrna88nDhaocS3cItspPxouBk3NXQnJE+7liqdgbAcHslA1wWtaPCxOxWqx1lUDtuAmoHtwI5SgGd0mUyLjoQkZxTwitBSo4OQ9WfFq52yC5pC3hz+Xga6OMZ4T5eq0hx4jWFLFKylr7b6Q9ba9yKU7+5FkbAObjacZ0cMAg84WqH5tCDqx3X8YSrHUp02RbZydi3RO0gfXwxS9VOfxhuVTbAZVE7i4eJeYlqtbO4Qe0skYDawa1Ajloc6JRLMBkXHYhIzksKrwQpOS7GUPUvJVztkF2WsoA3l48vBfTxpYX7eK0ixYnXFLJIGWGp2ukHW2uCCrWzTAsj4GXgaidwlgEGwbLC1Q7N4bJwtRM4ywpXO38nuhbZyXg5S9QO0seXt1Tt9IPhLiamdlYIE/OK1WpnBYPaWTEBtYNbgRy1AtApV2QyLjoQkZxXEl4JUnJcnqHqX1m42iG7rGwBby4fXxno46sI9/FaRYoTrylkkbKqpWqnL2ytyVZ8E2O1FkbAq8HVTlatBgyC1YWrHZrD1eFqJ1vB24nZTLwRiW7VFtnJeA1L1A7Sx9e0VO30heHOJvYtlbXCxLx2tdpZy6B21k5A7eBWIEetBXTKtZmMiw5EJOd1hFeClBzXZKj61xWudsgu61rAm8vH1wX6+HrCfbxWkeLEawpZpKxvqdrpg3u340XxbtDCCHgD/LsdbwNgEGwoXO3QHG6If7fjbShc7VCiW79FdjLeyBK1g/TxjS1VO31guIOcAS6L2tkkTMybVqudTQxqZ9ME1A5uBXLUJkCn3JTJuOhARHLeTHglSMlxY4aqf3PhaofssrkFvLl8fHOgj28h3MdrFSlOvKaQRcqWlqqd3rC1Ju1H8W7Vwgh4K7jaSftbAYNga+Fqh+Zwa7jaSftbC1c7lOi2bJGdjPOWqB2kjxcsVTu9YbjTngEui9ophok5qFY7RYPaCRJQO7gVyFFFoFMGTMZFByKSc0l4JUjJscBQ9ZeFqx2yS9kC3lw+Xgb6+DbCfbxWkeLEawpZpGxrqdrphK01hYqdbNu1MALeDq52Cmo7YBBsL1zt0BxuD1c7hQreTsxm4o1IdNu2yE7GO1iidpA+/j9L1U4nDHchsZ1sO4aJeadqtbOjQe3slIDawa1AjtoR6JQ7MRkXHYhIzjsLrwQpOf6PoerfRbjaIbvsYgFvLh/fBejjuwr38VpFihOvKWSRspulaqcDp3aKUby7tzAC3h2vdoq7A4NgD+Fqh+ZwD7zaKe4hXO1QotutRXYy3tMStYP08b0sVTsduIK4YIDLonb2DhPzPtVqZ2+D2tknAbWDW4EctTfQKfdhMi46EJGc9xVeCVJy3Iuh6t9PuNohu+xnAW8uH98P6OP7C/fxWkWKE68pZJFygKVqpx23k60QxXtgCyPgA/E72QoHAoPgIOFqh+bwIPxOtsJBwtUOJboDWmQn44MtUTtIHz/EUrXTjtvslDfAZVE7h4aJ+bBqtXOoQe0cloDawa1AjjoU6JSHMRkXHYhIzocLrwQpOR7CUPUfIVztkF2OsIA3l48fAfTxI4X7eK0ixYnXFLJIOcpStdMGW2u8ii9QH93CCPhouNrxnKOBQXCMcLVDc3gMXO14zjHC1Q4luqNaZCfjYy1RO0gfP85StdMGw51L7AvUx4eJ+YRqtXO8Qe2ckIDawa1Ajjoe6JQnMBkXHYhIzicKrwQpOR7HUPWfJFztkF1OsoA3l4+fBPTxk4X7eK0ixYnXFLJIOcVStdPKpHZObWEEfCqD2jkVGASnCVc7NIenMaid04SrHUp0p7TITsanW6J2kD5+hqVqp9VCtXNmmJhHVqudMw1qZ2QCage3AjnqTKBTjrRE7SA5nyW8EqTkeAZD1X+2cLVDdjnbAt5cPn420MfPEe7jtYoUJ15TyCLlXEvVTgtsrclXfJPtvBZGwOfB1U7ePw8YBKOEqx2aw1FwtZP3RwlXO5Tozm2RnYzPt0TtIH38AkvVTgsMdz6xb7JdGCbm0dVq50KD2hmdgNrBrUCOuhDolKOZjIsORCTni4RXgpQcL2Co+i8WrnbILhdbwJvLxy8G+vglwn28VpHixGsKWaRcaqnaacapnXQU72UtjIAvw6ud9GXAILhcuNqhObwcr3bSlwtXO5ToLm2RnYyvsETtIH38SkvVTjOuIE4Z4LKonavCxHx1tdq5yqB2rk5A7eBWIEddBXTKq5mMiw5EJOdrhFeClByvZKj6rxWudsgu11rAm8vHrwX6+HXCfbxWkeLEawpZpFxvqdrpBVtrgop3Oze0MAK+Aa52Av8GYBDcKFzt0BzeCFc7gX+jcLVDie76FtnJ+CZL1A7Sx2+2VO30guEOEnu3c0uYmG+tVju3GNTOrQmoHdwK5KhbgE55K5Nx0YGI5Hyb8EqQkuPNDFX/7cLVDtnldgt4c/n47UAfv0O4j9cqUpx4TSGLlDstVTszwdaaYimK964WRsB3wdVOsXQXMAjuFq52aA7vhqudYulu4WqHEt2dLbKT8T2WqB2kj99rqdqZCYa7GBjgsqid+8LEfH+12rnPoHbuT0Dt4FYgR90HdMr7mYyLDkQk5weEV4KUHO9lqPofFK52yC4PWsCby8cfBPr4Q8J9vFaR4sRrClmkPGyp2ukJW2tUxbudR1oYAT8CVzvKfwQYBI8KVzs0h4/C1Y7yHxWudijRPdwiOxk/ZonaQfr445aqnZ4w3CqxdztPhIn5yWq184RB7TyZgNrBrUCOegLolE8yGRcdiEjOTwmvBCk5Ps5Q9T8tXO2QXZ62gDeXjz8N9PFnhPt4rSLFidcUskh51lK10wRbawoVaue5FkbAz8HVTsF/DhgEzwtXOzSHz8PVTsF/XrjaoUT3bIvsZDzGErWD9PEXLFU7TTDchcTUzothYn6pWu28aFA7LyWgdnArkKNeBDrlS0zGRQcikvPLwitBSo4vMFT9rwhXO2SXVyzgzeXjrwB9/FXhPl6rSHHiNYUsUl6zVO00wtYaz4vifb2FEfDrcLXjea8Dg+AN4WqH5vANuNrxvDeEqx1KdK+1yE7Gb1qidpA+/palaqcRhtvLGeCyqJ23w8T8TrXaedugdt5JQO3gViBHvQ10yneYjIsORCTnd4VXgpQc32Ko+t8TrnbILu9ZwJvLx98D+vj7wn28VpHixGsKWaR8YKna6QFba9IVaufDFkbAH8LVTtr7EBgEHwlXOzSHH8HVTtr7SLjaoUT3QYvsZPyxJWoH6eOfWKp2esBwpxNTO5+GifmzarXzqUHtfJaA2sGtQI76FOiUnzEZFx2ISM6fC68EKTl+wlD1fyFc7ZBdvrCAN5ePfwH08bHCfbxWkeLEawpZpHxpqdrpDltrfBXF+1ULI+Cv4GrHV18Bg2CccLVDczgOrnb8Ct5OzGbijUh0X7bITsZfW6J2kD7+jaVqpzsMt+8Y4LKonW/DxPxdtdr51qB2vktA7eBWIEd9C3TK75iMiw5EJOfvhVeClBy/Yaj6fxCudsguP1jAm8vHfwD6+I/CfbxWkeLEawpZpPxkqdrpBltrck4U788tjIB/hqudnPMzMAh+Ea52aA5/gaudnPOLcLVDie6nFtnJ+FdL1A7Sx3+zVO10g+HOlg1wWdTO72Fi/qNa7fxuUDt/JKB2cCuQo34HOuUfTMZFByKS85/CK0FKjr8xVP3jhasdsst4C3hz+fh4oI9PEO7jtYoUJ15TyCJloqVqpwG21hQqvkD9Vwsj4L/gaqdQ+gsZBK2y1Q7NIWEEf6WgFOXtxGwm3ohEN7FFdjLu1opNxl0NzRnp492BnJNUOw2wnFFI7AvUPVr/+bOxtaFS2fRonVzt0A9xq50GoNrpAXTKxlYe46IDEcm5CZx84I8XNL7urfiFoSfzwuXEa4rs0tMC3lw+3hPo4zMJ9/FaRYoTrylkkdIL6DdJqp2/mlFrjVvxbqe5lREwDY5VO67TDAyCFuFqh+awBa52XKdFuNqhRNerVXYybrVE7SB9vM1StRNNnk6sphJ7t9MeJuaOarXTblA7HQmoHdwK5Kh2oFN2tPIYFx2ISM6dwitBSo5tDFV/b+Fqh+zS2wLeXD7eG+jjfYT7eK0ixYnXFLJI6Wup2pmIW2uKUbz9WhkB94OrHafYDxgE/YWrHZrD/nC14xT7C1c7lOj6tspOxgMsUTtIH5/ZUrUzEaZ2nIIBLovamSVMzLNWq51ZDGpn1gTUDnAFUrMAnXLWVh7jogMRyXk24ZUgJceZGar+2YWrHbLL7Bbw5vLx2YE+PlC4j9cqUpx4TSGLlDksVTsTYGtNtmIn26BWRsCD4GonWxoEDII5hasdmsM54WonW5pTuNqhRDdHq+xkPNgStYP08SGWqp0JMLWTTWwn21xhYp67Wu3MZVA7cyegdiYA1c5cQKecu5XHuOhARHKeR3glSMlxCEPVP69wtUN2mdcC3lw+Pi/Qx+cT7uO1ihQnXlPIImV+S9XOeNhaoyq+ybZAKyPgBeBqR6kFgEEwVLjaoTkcClc7qoK3E7OZeCMS3fytspPxgpaoHaSPD7NU7YzH7WRL7JtsC4WJeeFqtbOQQe0snIDaGQ9UOwsBnXLhVh7jogMRyXkR4ZUgJcdhDFX/cOFqh+wy3ALeXD4+HOjjiwr38VpFihOvKWSR4liqdv7EbcaoOLejWhkBq1b8uK5whUK83dZJEwwal0VVUEJxWmUnvZQlqgLpl2nmRI+wSZrBx5NMqH8wJdRMKyPgDENCzQpPqMQ7W0+osLFyliRUpF96whMq2cSzPKH+3oybjyhev5URsM8QrD7Q2RYTnpxpDhdjkPeLCX8eb0OiX9ySRI/08SWEPyIhmyzBEC9LCn8MSHliSaYijssvlwT65VLC/bJWPnPiNYXMZ0sL93Gy8dIMAg3ph1QQ9muY9Cos2tC4d+vJE+cNUJwu6/vLbpG5HdI1trbnMrovq/tyui+v+wq6r6j7SrqvrPsquq+q+2q6r677Grqvqftauq+t+zq6r6v7erqvr/sGum+o+0a6b6z7Jrpvqvtmum+u+xa6b6n7VtXvTkeE70mj95Yx3FvWcG85w73lDfdWMNxb0XBvJcO9lQ33VjHcW9VwbzXDvdUN99Yw3FvTcG8tw721DffWMdxb13BvPcO99Q33NjDc29BwbyPDvY0N9zYx3NvUcG8zw73NDfe2MNzb0nBvq9bJ38nPFf45IvzTidcqkk7cZDkCkHi73u8vAxqLOC4LGeuf+Vou/lhuOF9q+bhjpf+de7VCvLGciB3VinHGcit8Qq0042M5Vf6lVp7BsbLlyXxVrTJjY3kGv1erzshYnjGG1GrTP1auRjyq1ad3rFzN2FZrTN9Y7hTyhFpzesbKTTHnqLWmfaziVPKXWntax8pNNReqdaZtLGca8qpad1rGcqYpR6v1pj5WZhrzvVp/amOlp3ntUBtMcax0eTrWIbXhlMbKTdeapjaqPZY3neuj2rjGWH55utdatYl5LGcG1m21qWksZ4ZqALXZ5GOpGawn1ObVYwUzXJuoLSrHSsWoc9SWkbHccqyaSW0FFOlJvr3YClbrBRWnCbZuZQS8dSv6NEGgtsYZUOUBk8r59oLmMA98Gts1h3lwECS1KxwXvEFiu8ILYYAVq59sFFon3xVebOXfFY7LJI4qAAOoCDYu2vkoaArAYOziXbB0RdoS5kd+EMUbtDICDuArkh8EwBWpJHxFojkswVckPyhZuiJtCcPtFw1wWVakchhg21SvSGXDirRNAivSlsAVqQwMoG2YjIt+EYzkvC0wmTU04FfLfJiA0C+CkVJgO2AyM82hE68psvF2DJXMdpZWMlvA8k8hFcW7fSsj4O3hlUwhtT0w+HcQXsnQHO4Ar2QKqR2Ygx+RQLcTnkD/B57DroZeeJE+viMw9pKsgLeA4S64BrgsFfBOYWLeuboC3slQAe+cQAWMW4EctRPQKXdmMi46EJGcd2GugJ14TVFy3JGhettVeNVKdtnVAt5cPr4r0Md3E+7jtYoURPGDGmt38IKdlNrZHLbWeOUo3j1aGQHvAVc7XnkPoAH3FK52aA73hKsdr7yncLVDiW73VtnJeC9wMu5qaM5IH9/bUrWzOQy3VzLAZVE7+4SJed9qtbOPQe3sm4Dawa1AjtoH6JT7MhkXHYhIzvsJrwQpOe7NUPXvL1ztkF32t4A3l4/vD/TxA4T7eK0ixYnXFLJIOdDSdzubwdYat+KrDwe1MgI+CK52XOcgYBAcLFzt0BweDFc7rnOwcLVDie7AVtnJ+BBL1A7Sxw+1VO1sBsNd+SvnG5A4q9TOYWFiPrxa7RxmUDuHJ6B2cCuQow4DOuXhTMZFByKS8xHCK0FKjocyVP1HClc7ZJcjLeDN5eNHAn38KOE+XqtIceI1hSxSjrZU7WwKW2uCCrVzTCsj4GPgaidwjgEGwbHC1Q7N4bFwtRM4xwpXO5Tojm6VnYyPs0TtIH38eEvVzqYw3MXE1M4JYWI+sVrtnGBQOycmoHZwK5CjTgA65YlMxkUHIpLzScIrQUqOxzNU/ScLVztkl5Mt4M3l4ycDffwU4T5eq0hx4jWFLFJOtVTtbAJba7IV38Q4rZUR8GlwtZNVpwGD4HThaofm8HS42slW8HZiNhNvRKI7tVV2Mj7DErWD9PEzLVU7m8BwZxP7lsrIMDGfVa12RhrUzlkJqB3cCuSokUCnPIvJuOhARHI+W3glSMnxTIaq/xzhaofsco4FvLl8/Bygj58r3MdrFSlOvKaQRcp5lqqdjXHvdrwo3lGtjIBH4d/teKOAQXC+cLVDc3g+/t2Od75wtUOJ7rxW2cn4AkvUDtLHL7RU7WwMwx3kDHBZ1M7oMDFfVK12RhvUzkUJqB3cCuSo0UCnvIjJuOhARHK+WHglSMnxQoaq/xLhaofscokFvLl8/BKgj18q3MdrFSlOvKaQRcpllqqdjWBrTdqP4r28lRHw5XC1k/YvBwbBFcLVDs3hFXC1k/avEK52KNFd1io7GV9pidpB+vhVlqqdjWC4054BLovauTpMzNdUq52rDWrnmgTUDm4FctTVQKe8hsm46EBEcr5WeCVIyfEqhqr/OuFqh+xynQW8uXz8OqCPXy/cx2sVKU68ppBFyg2Wqp0NYWtNoWIn242tjIBvhKudgroRGAQ3CVc7NIc3wdVOoYK3E7OZeCMS3Q2tspPxzZaoHaSP32Kp2tkQhruQ2E62W8PEfFu12rnVoHZuS0Dt4FYgR90KdMrbmIyLDkQk59uFV4KUHG9hqPrvEK52yC53WMCby8fvAPr4ncJ9vFaR4sRrClmk3GWp2tkAp3aKUbx3tzICvhuvdop3A4PgHuFqh+bwHrzaKd4jXO1QorurVXYyvtcStYP08fssVTsb4AriggEui9q5P0zMD1SrnfsNaueBBNQObgVy1P1Ap3yAybjoQERyflB4JUjJ8T6Gqv8h4WqH7PKQBby5fPwhoI8/LNzHaxUpTrymkEXKI5aqnfVxO9kKUbyPtjICfhS/k63wKDAIHhOudmgOH8PvZCs8JlztUKJ7pFV2Mn7cErWD9PEnLFU76+M2O+UNcFnUzpNhYn6qWu08aVA7TyWgdnArkKOeBDrlU0zGRQcikvPTwitBSo5PMFT9zwhXO2SXZyzgzeXjzwB9/FnhPl6rSHHiNYUsUp6zVO2sB1trvIovUD/fygj4ebja8ZzngUEwRrjaoTkcA1c7njNGuNqhRPdcq+xk/IIlagfp4y9aqnbWg+HOJfYF6pfCxPxytdp5yaB2Xk5A7eBWIEe9BHTKl5mMiw5EJOdXhFeClBxfZKj6XxWudsgur1rAm8vHXwX6+GvCfbxWkeLEawpZpLxuqdpZl0ntvNHKCPgNBrXzBjAI3hSudmgO32RQO28KVzuU6F5vlZ2M37JE7SB9/G1L1c66Fqqdd8LE/G612nnHoHbeTUDt4FYgR70DdMp3LVE7SM7vCa8EKTm+zVD1vy9c7ZBd3reAN5ePvw/08Q+E+3itIsWJ1xSySPnQUrWzDmytyVd8k+2jVkbAH8HVTt7/CBgEHwtXOzSHH8PVTt7/WLjaoUT3YavsZPyJJWoH6eOfWqp21oHhzif2TbbPwsT8ebXa+cygdj5PQO3gViBHfQZ0ys+ZjIsORCTnL4RXgpQcP2Wo+scKVztkl7EW8Oby8bFAH/9SuI/XKlKceE0hi5SvLFU7a+PUTjqKd1wrI+BxeLWTHgcMgq+Fqx2aw6/xaif9tXC1Q4nuq1bZyfgbS9QO0se/tVTtrI0riFMGuCxq57swMX9frXa+M6id7xNQO7gVyFHfAZ3yeybjogMRyfkH4ZUgJcdvGar+H4WrHbLLjxbw5vLxH4E+/pNwH69VpDjxmkIWKT9bqnbWgq01QcW7nV9aGQH/Alc7gf8LMAh+Fa52aA5/haudwP9VuNqhRPdzq+xk/Jslagfp479bqnbWguEOEnu380eYmP+sVjt/GNTOnwmoHdwK5Kg/gE75J5Nx0YGI5DxeeCVIyfF3hqp/gnC1Q3aZYAFvLh+fAPTxicJ9vFaR4sRrClmk/GWp2lkTttYUSxV42xgB0+BYtVMs0ZgojN3aZKsdmkPCiFU72gHaeBcNRKL7q1V2Mu7ehk3GXQ3NGenjPYCck1Q7a8KSfjEwwGVRO41hYm5qa6hUNo1tk6sd+iFutbMmUO00Ap2yqY3HuOhARHLuCU4+6ICj5NijDb8wzMS8cDnxmiK7zGQBby4fnwno472E+3itIsWJ1xSySGkG+k2SamcN2FqjKt7ttLQxAm6Bqx3ltwCDoFW42qE5bIWrHeW3Clc7lOia22Qn4zZL1A7Sx9stVTtrwNSOSuzdTkeYmDur1U6HQe10JqB21gCqnQ6gU3a28RgXHYhIzr2FV4KUHNsZqv4+wtUO2aWPBby5fLwP0Mf7CvfxWkWKE68pZJHSz1K1szpsrSlUqJ3+bYyA+8PVTsHvDwyCAcLVDs3hALjaKfgDhKsdSnT92mQn45ktUTtIH5/FUrWzOkztFBJTO7OGiXm2arUzq0HtzJaA2lkdqHZmBTrlbG08xkUHIpLz7MIrQUqOszBU/QOFqx2yy0ALeHP5+ECgj88h3MdrFSlOvKaQRcogS9XOarC1xvOieOdsYwQ8J1zteN6cwCAYLFzt0BwOhqsdzxssXO1QohvUJjsZD7FE7SB9fC5L1c5qMLXj5QxwWdTO3GFinqda7cxtUDvzJKB2VgOqnbmBTjlPG49x0YGI5Dyv8EqQkuNcDFX/fMLVDtllPgt4c/n4fEAfn1+4j9cqUpx4TSGLlAUsVTurwtaadIXaGdrGCHgoXO2kvaHAIFhQuNqhOVwQrnbS3oLC1Q4lugXaZCfjYZaoHaSPL2Sp2lkVpnbSiamdhcPEvEi12lnYoHYWSUDtrApUOwsDnXKRNh7jogMRyXm48EqQkuNCDFX/osLVDtllUQt4c/n4okAfd4T7eK0ixYnXFLJIUZaqnVVga42vonjdNkbALlzt+MoFBkFKuNqhOUzB1Y5fwduJ2Uy8EYlOtclOxmlL1A7SxzOWqp1VYGrHdwxwWdRONkzMuWq1kzWonVwCamcVoNrJAp0y18ZjXHQgIjl7witBSo4ZhqrfF652yC6+Bby5fNwH+vhiwn28VpHixGsKWaQsbqnaWRm21uScKN4l2hgBLwFXOzlnCWAQLClc7dAcLglXOzlnSeFqhxLd4m2yk/FSlqgdpI8vbanaWRmmdrJlA1wWtTMiTMzLVKudEQa1s0wCamdloNoZAXTKZdp4jIsORCTnZYVXgpQcl2ao+pcTrnbILstZwJvLx5cD+vjywn28VpHixGsKWaSsYKnaWQn3lYKKL1Cv2MYIeEW42imUVgQGwUrC1Q7N4UpwtVMorSRc7VCiW6FNdjJe2RK1g/TxVSxVOyvhvlKQ2BeoVw0T82rVamdVg9pZLQG1sxJQ7awKdMrV2niMiw5EJOfVhVeClBxXYaj61xCudsgua1jAm8vH1wD6+JrCfbxWkeLEawpZpKxlqdpZEbbWuBXvdtZuYwS8NlztuM7awCBYR7jaoTlcB652XGcd4WqHEt1abbKT8bqWqB2kj69nqdpZEfcF6sTe7awfJuYNqtXO+ga1s0ECamdFoNpZH+iUG7TxGBcdiEjOGwqvBCk5rsdQ9W8kXO2QXTaygDeXj28E9PGNhft4rSLFidcUskjZxFK1swJurSlG8W7axgh4U7jacYqbAoNgM+Fqh+ZwM7jacYqbCVc7lOg2aZOdjDe3RO0gfXwLS9XOCrhfKV0wwGVRO1uGiXmrarWzpUHtbJWA2gGuQGpLoFNu1cZjXHQgIjlvLbwSpOS4BUPVnxeudsgueQt4c/l4HujjBeE+XqtIceI1hSxSipaqneVha022Yidb0MYIOICrnWwpAAZBSbjaoTkswdVOtlQSrnYo0RXbZCfjsiVqB+nj21iqdpbHndtJbCfbtmFi3q5a7WxrUDvbJaB2lgeqnW2BTrldG49x0YGI5Ly98EqQkuM2DFX/DsLVDtllBwt4c/n4DkAf/59wH69VpDjxmkIWKTtaqnaWg601quKbbDu1MQLeCa52lNoJGAQ7C1c7NIc7w9WOquDtxGwm3ohEt2Ob7GS8iyVqB+nju1qqdpbD7WRL7Jtsu4WJefdqtbObQe3snoDaWQ6odnYDOuXubTzGRQcikvMewitBSo67MlT9ewpXO2SXPS3gzeXjewJ9fC/hPl6rSHHiNYUsUva2VO0si9uMUXFuZ582RsD7tOHH3Ve4QiHe+7ZNmmDQuCyqghLK3m2yk95+lqgKpF/uz5zoETbZn8HHk0yoyzAl1APaGAEfwJBQDxSeUIn3gfWEChvrIEsSKtIvDxaeUMkmB1ueUEe04uYjiveQNkbAhzAE6yFAZztUeHKmOTyUQd4fKvx5vA2J/jBLEj3Sxw8X/oiEbHI4Q7wcIfwxIOWJI5iKOC6/PALol0cK98ta+cyJ1xQynx0l3MfJxkcxCDSkH1JB2K9h0quwaEPjHtrAE+cNUJwu6/vLbpG5HRJeH63teYzux+p+nO7H636C7ifqfpLuJ+t+iu6n6n6a7qfrfobuZ+o+UvezdD9b93N0P1f383Qfpfv5ul+g+4W6j9b9It0v1v0S3S/V/TLdL69+d3p0+J40eu8Yw71jDfeOM9w73nDvBMO9Ew33TjLcO9lw7xTDvVMN904z3DvdcO8Mw70zDfdGGu6dZbh3tuHeOYZ75xrunWe4N8pw73zDvQsM9y403BttuHeR4d7FhnuXGO5darh3meHe5W2Tv5OfK/xzRPinE69VJJ24yfJoQOLter9/DGgs4ngsZKx/5uu4+GO54Xyp4+OOlf537tUJ8cZyInZUJ8YZy63wCXXSjI/lVPmXOnkGx8qWJ/NVdcqMjeUZ/F6dOiNjecYYUqdN/1i5GvGoTp/esXI1Y1udMX1juVPIE+rM6RkrN8Wco0ZO+1jFqeQvdda0jpWbai5UZ0/bWM405FV1zrSM5UxTjlbnTn2szDTme3Xe1MZKT/PaoUZNcax0eTrWIXX+lMbKTdeapi6oPZY3neujurDGWH55utdaNdo8ljMD67a6yDSWM0M1gLp48rHUDNYT6pLqsYIZrk3UpZVjpWLUOeqyyFhuOVbNpC4HivQk315cDqv1gorTBFe0MQK+og19miBQV+AMqK4ETCrn2wuawyuBT2O75vBKcBAktSscF7xBYrvCrwoD7OrqJxtXtU2+K/zqNv5d4bhM4qirgAF0Ndi4aOejoLkKGIxdvK+ydEW6DOZHfhDFe00bI+Br4CuSH1wDXJGuFb4i0RxeC1+R/OBaS1eky2C4/aIBLsuKdF0YYNdXr0jXGVak6xNYkS4DrkjXAQPoeibjol8EIznfAExmDQ341fLKMAGhXwQjpcCNwGRmmkMnXlNk4xsZKpkbLa1kLoXln0IqivemNkbAN8ErmULqJmDw3yy8kqE5vBleyRRSNzMHPyKB3ig8gd4CnsOuhl54kT5+KzD2kqyAL4XhLrgGuCwV8G1hYr69ugK+zVAB355ABYxbgRx1G9Apb2cyLjoQkZzvYK6AnXhNUXK8laF6u1N41Up2udMC3lw+fifQx+8S7uO1ihRE8YMa627wgp2U2rkEttZ45Sjee9oYAd8DVzte+R6gAe8VrnZoDu+Fqx2vfK9wtUOJ7u422cn4PnAy7mpozkgfv99StXMJDLdXMsBlUTsPhIn5wWq184BB7TyYgNrBrUCOegDolA8yGRcdiEjODwmvBCk53s9Q9T8sXO2QXR62gDeXjz8M9PFHhPt4rSLFidcUskh51NJ3OxfD1hq34qsPj7UxAn4MrnZc5zFgEDwuXO3QHD4OVzuu87hwtUOJ7tE22cn4CUvUDtLHn7RU7VwMw135K+cbkDir1M5TYWJ+ulrtPGVQO08noHZwK5CjngI65dNMxkUHIpLzM8IrQUqOTzJU/c8KVztkl2ct4M3l488Cffw54T5eq0hx4jWFLFKet1TtXARba4IKtTOmjRHwGLjaCZwxwCB4QbjaoTl8Aa52AucF4WqHEt3zbbKT8YuWqB2kj79kqdq5CIa7mJjaeTlMzK9Uq52XDWrnlQTUDm4FctTLQKd8hcm46EBEcn5VeCVIyfElhqr/NeFqh+zymgW8uXz8NaCPvy7cx2sVKU68ppBFyhuWqp3RsLUmW/FNjDfbGAG/CVc7WfUmMAjeEq52aA7fgqudbAVvJ2Yz8UYkujfaZCfjty1RO0gff8dStTMahjub2LdU3g0T83vVauddg9p5LwG1g1uBHPUu0CnfYzIuOhCRnN8XXglScnyHoer/QLjaIbt8YAFvLh//AOjjHwr38VpFihOvKWSR8pGlaudC3LsdL4r34zZGwB/j3+14HwOD4BPhaofm8BP8ux3vE+FqhxLdR22yk/GnlqgdpI9/ZqnauRCGO8gZ4LKonc/DxPxFtdr53KB2vkhA7eBWIEd9DnTKL5iMiw5EJOexwitBSo6fMVT9XwpXO2SXLy3gzeXjXwJ9/CvhPl6rSHHiNYUsUsZZqnYugK01aT+K9+s2RsBfw9VO2v8aGATfCFc7NIffwNVO2v9GuNqhRDeuTXYy/tYStYP08e8sVTsXwHCnPQNcFrXzfZiYf6hWO98b1M4PCagd3ArkqO+BTvkDk3HRgYjk/KPwSpCS43cMVf9PwtUO2eUnC3hz+fhPQB//WbiP1ypSnHhNIYuUXyxVO+fD1ppCxU62X9sYAf8KVzsF9SswCH4TrnZoDn+Dq51CBW8nZjPxRiS6X9pkJ+PfLVE7SB//w1K1cz4MdyGxnWx/hol5fLXa+dOgdsYnoHZwK5Cj/gQ65Xgm46IDEcl5gvBKkJLjHwxV/0ThaofsMtEC3lw+PhHo438J9/FaRYoTrylkkdLQbqfaGYVTO8Uo3m7tjIBpcLDaKXbDGVB1b5etdmgOCSNY7RS7t/MuGohE19AuOxn3aMcm466G5oz08UYg5yTVzihcQVwwwGVRO01hYu7Z3lCpbJraJ1c79EPcamcUUO00AZ2yZzuPcdGBiOQ8Ezj5oAOOkmNjO35h6MW8cDnxmiK79LKAN5eP9wL6eLNwH69VpDjxmkIWKS2Wqp3zcDvZClG8re2MgFvhaiddaAUGQZtwtUNz2AZXO+lCm3C1Q4mupV12Mm63RO0gfbzDUrVzHm6zU94Al0XtdIaJuXe12uk0qJ3eCaid84BqpxPolL3beYyLDkQk5z7CK0FKjh0MVX9f4WqH7NLXAt5cPt4X6OP9hPt4rSLFidcUskjpb6naORe21ngVX6Ae0M4IeABc7XjOAGAQzCxc7dAczgxXO54zs3C1Q4muf7vsZDyLJWoH6eOzWqp2zoWpnVxiX6CeLUzMs1erndkMamf2BNTOuUC1MxvQKWdv5zEuOhCRnAcKrwQpOc7KUPXPIVztkF3msIA3l4/PAfTxQcJ9vFaR4sRrClmkzGmp2jmHSe0MbmcEPJhB7QwGBsEQ4WqH5nAIg9oZIlztUKKbs112Mp7LErWD9PG5LVU751ioduYJE/O81WpnHoPamTcBtXMOUO3MA3TKeS1RO0jO8wmvBCk5zs1Q9c8vXO2QXea3gDeXj88P9PEFhPt4rSLFidcUskgZaqnaORu21uQrvsm2YDsj4AXhaifvLwgMgmHC1Q7N4TC42sn7w4SrHUp0Q9tlJ+OFLFE7SB9f2FK1czZM7eQT+ybbImFiHl6tdhYxqJ3hCaids4FqZxGgUw5v5zEuOhCRnBcVXglSclyYoep3hKsdsotjAW8uH3eAPq6E+3itIsWJ1xSySHEtVTtn4dROOoo31c4IOIVXO+kUMAjSwtUOzWEar3bSaeFqhxKd2y47GWcsUTtIH89aqnbOwqmdlAEui9rJhYnZq1Y7OYPa8RJQO2cB1U4O6JReO49x0YGI5OwLrwQpOWYZqv7FhKsdsstiFvDm8vHFgD6+uHAfr1WkOPGaQhYpS1iqdkbC1pqg4t3Oku2MgJeEq53AXxIYBEsJVzs0h0vB1U7gLyVc7VCiW6JddjJe2hK1g/TxEZaqnZG4X0CZ2LudZcLEvGy12lnGoHaWTUDtjASqnWWATrlsO49x0YGI5Lyc8Erw7+TIUPUvL1ztkF2Wt4A3l48vD/TxFYT7eK0ixYnXFLJIWdFStXMmbK0plqJ4V2pnBLwSXO0USysBg2Bl4WqH5nBluNopllYWrnYo0a3YLjsZr2KJ2kH6+KqWqp0zYWqnGBjgsqid1cLEvHq12lnNoHZWT0DtnAlUO6sBnXL1dh7jogMRyXkN4ZUgJcdVGar+NYWrHbLLmhbw5vLxNYE+vpZwH69VpDjxmkIWKWtbqnbOgK01quLdzjrtjIDXgasd5a8DDIJ1hasdmsN14WpH+esKVzuU6NZul52M17NE7SB9fH1L1c4ZMLWjEnu3s0GYmDesVjsbGNTOhgmonTOAamcDoFNu2M5jXHQgIjlvJLwSpOS4PkPVv7FwtUN22dgC3lw+vjHQxzcR7uO1ihQnXlPIImVTS9XO6bjfLlqhdjZrZwS8GVztFPzNgEGwuXC1Q3O4OVztFPzNhasdSnSbtstOxltYonaQPr6lpWrndNxvF01M7WwVJuatq9XOVga1s3UCaud0oNrZCuiUW7fzGBcdiEjOeeGVICXHLRmq/oJwtUN2KVjAm8vHC0AfLwr38VpFihOvKWSREliqdk7DfYHai+IttTMCLsHVjueVgEFQFq52aA7LcLXjeWXhaocSXdAuOxlvY4naQfr4tpaqndNgasfLGeCyqJ3twsS8fbXa2c6gdrZPQO2cBlQ72wGdcvt2HuOiAxHJeQfhlSAlx20Zqv7/CVc7ZJf/WcCby8f/B/TxHYX7eK0ixYnXFLJI2clStXMqbK1JV6idndsZAe8MVztpb2dgEOwiXO3QHO4CVztpbxfhaocS3U7tspPxrpaoHaSP72ap2jkVpnbSiamd3cPEvEe12tndoHb2SEDtnApUO7sDnXKPdh7jogMRyXlP4ZUgJcfdGKr+vYSrHbLLXhbw5vLxvYA+vrdwH69VpDjxmkIWKftYqnZOga01vori3bedEfC+cLXjq32BQbCfcLVDc7gfXO34FbydmM3EG5Ho9mmXnYz3t0TtIH38AEvVzikwteM7BrgsaufAMDEfVK12DjSonYMSUDunANXOgUCnPKidx7joQERyPlh4JUjJ8QCGqv8Q4WqH7HKIBby5fPwQoI8fKtzHaxUpTrymkEXKYZaqnZNha03OieI9vJ0R8OFwtZNzDgcGwRHC1Q7N4RFwtZNzjhCudijRHdYuOxkfaYnaQfr4UZaqnZNhaidbNsBlUTtHh4n5mGq1c7RB7RyTgNo5Gah2jgY65THtPMZFByKS87HCK0FKjkcxVP3HCVc7ZJfjLODN5ePHAX38eOE+XqtIceI1hSxSTrBU7ZyE+0pBxReoT2xnBHwiXO0USicCg+Ak4WqH5vAkuNoplE4SrnYo0Z3QLjsZn2yJ2kH6+CmWqp2TcF8pSOwL1KeGifm0arVzqkHtnJaA2jkJqHZOBTrlae08xkUHIpLz6cIrQUqOpzBU/WcIVztklzMs4M3l42cAffxM4T5eq0hx4jWFLFJGWqp2ToStNW7Fu52z2hkBnwVXO65zFjAIzhaudmgOz4arHdc5W7jaoUQ3sl12Mj7HErWD9PFzLVU7J+K+QJ3Yu53zwsQ8qlrtnGdQO6MSUDsnAtXOeUCnHNXOY1x0ICI5ny+8EqTkeC5D1X+BcLVDdrnAAt5cPn4B0McvFO7jtYoUJ15TyCJltKVq5wTcWlOM4r2onRHwRXC14xQvAgbBxcLVDs3hxXC14xQvFq52KNGNbpedjC+xRO0gffxSS9XOCTC14xQMcFnUzmVhYr68Wu1cZlA7lyegdoArkLoM6JSXt/MYFx2ISM5XCK8EKTleylD1Xylc7ZBdrrSAN5ePXwn08auE+3itIsWJ1xSySLnaUrVzPGytyVbsZLumnRHwNXC1ky1dAwyCa4WrHZrDa+FqJ1u6VrjaoUR3dbvsZHydJWoH6ePXW6p2jsed20lsJ9sNYWK+sVrt3GBQOzcmoHaOB6qdG4BOeWM7j3HRgYjkfJPwSpCS4/UMVf/NwtUO2eVmC3hz+fjNQB+/RbiP1ypSnHhNIYuUWy1VO8fB1hpV8U2229oZAd8GVztK3QYMgtuFqx2aw9vhakdV8HZiNhNvRKK7tV12Mr7DErWD9PE7LVU7x+F2siX2Tba7wsR8d7Xaucugdu5OQO0cB1Q7dwGd8u52HuOiAxHJ+R7hlSAlxzsZqv57hasdssu9FvDm8vF7gT5+n3Afr1WkOPGaQhYp91uqdo7FbcaoOLfzQDsj4Afa8eM+KFyhEO8H2ydNMGhcFlVBCeX+dtlJ7yFLVAXSLx9mTvQImzzM4ONJJtRjmBLqI+2MgB9hSKiPCk+oxPvRekKFjfWYJQkV6ZePC0+oZJPHLU+oR7fh5iOK94l2RsBPMATrE0Bne1J4cqY5fJJB3j8p/Hm8DYn+KUsSPdLHnxb+iIRs8jRDvDwj/DEg5YlnmIo4Lr98BuiXzwr3y1r5zInXFDKfPSfcx8nGzzEINKQfUkHYr2HSq7BoQ+PetSdPnDdAcbqs7y+7ReZ2SHj9vLbnGN1f0P1F3V/S/WXdX9H9Vd1f0/113d/Q/U3d39L9bd3f0f1d3d/T/X3dP9D9Q90/0v1j3T/R/VPdP9P9c92/0H2s7l/q/pXu43T/uvrd6fPhe9LovTGGey8Y7r1ouPeS4d7LhnuvGO69arj3muHe64Z7bxjuvWm495bh3tuGe+8Y7r1ruPee4d77hnsfGO59aLj3keHex4Z7nxjufWq495nh3ueGe18Y7o013PvScO8rw71xhntft0/+Tn6u8M8R4Z9OvFaRdOImy+cBibfr/f4Y0FjE8QXIWP/M14vxx3LD+VIvxR0r/e/cq5fjjeVE7KheiTOWW+ET6tUZH8up8i/12gyOlS1P5qvq9RkbyzP4vXpjRsbyjDGk3pz+sXI14lG9Nb1j5WrGtnp7+sZyp5An1DvTM1ZuijlHvTvtYxWnkr/Ue9M6Vm6quVC9P21jOdOQV9UH0zKWM005Wn049bEy05jv1UdTGys9zWuH+niKY6XL07EOqU+mNFZuutY09WntsbzpXB/VZzXG8svTvdaqz81jOTOwbqsvTGM5M1QDqLGTj6VmsJ5QX1aPFcxwbaK+qhwrFaPOUeMiY7nlWDWT+hoo0pN8e/E1rNYLKk4TfNPOCPibdvRpgkB9gzOg+hYwqZxvL2gOvwU+je2aw2/BQZDUrnBc8AaJ7Qr/Lgyw76ufbHzXPvmu8O/b+XeF4zKJo74DBtD3YOOinY+C5jtgMHbx/s7SFWkczI/8IIr3h3ZGwD/AVyQ/+AG4Iv0ofEWiOfwRviL5wY+WrkjjYLj9ogEuy4r0UxhgP1evSD8ZVqSfE1iRxgFXpJ+AAfQzk3HRL4KRnH8BJrOGBvxq+W2YgNAvgpFS4FdgMjPNoROvKbLxrwyVzK+WVjJfwfJPIRXF+1s7I+Df4JVMIfUbMPh/F17J0Bz+Dq9kCqnfmYMfkUB/FZ5A/wDPYVdDL7xIH/8TGHtJVsBfwXAXXANclgp4fJiYJ1RXwOMNFfCEBCpg3ArkqPFAp5zAZFx0ICI5T2SugJ14TVFy/JOhevtLeNVKdvnLAt5cPv4XsqDqkO3jtYoURPGDGqtbB3bBTkrtfAlba7xyFG/3DkbANDhW7Xjl7kAD9uiQrXZoDgkjVu145R4dvIsGItF165CdjBvByfjfgARzRvp4Ezh5JqV2voQVC17JAJdF7fQME/NMHQ2VyqZnx+Rqh36IW+18CVQ7PYFOOVMHj3HRgYjk3Et4JUjJsakDvzA0My9cTrymyC7NFvDm8vFmoI+3CPfxWkWKE68pZJHSCvSbJNXOWNha41Z89aGtgxFwG1ztuE4bMAjahasdmsN2uNpxnXbhaocSXWuH7GTcYYnaQfp4p6VqZyxM7VT+yvkGJM4qtdM7TMx9qtVOb4Pa6ZOA2hkLVDu9gU7Zp4PHuOhARHLuK7wSpOTYyVD19xOudsgu/SzgzeXj/YA+3l+4j9cqUpx4TSGLlAGWqp0vcKfEKtTOzB2MgGeGq53AmRkYBLMIVzs0h7PA1U7gzCJc7VCiG9AhOxnPaonaQfr4bJaqnS9gaqeYmNqZPUzMA6vVzuwGtTMwAbXzBVDtzA50yoEdPMZFByKS8xzCK0FKjrMxVP2DhKsdsssgC3hz+fggoI/PKdzHaxUpTrymkEXKYEvVzuewtSZb8U2MIR2MgIfA1U5WDQEGwVzC1Q7N4VxwtZOt4O3EbCbeiEQ3uEN2Mp7bErWD9PF5LFU7n8PUTjaxb6nMGybm+arVzrwGtTNfAmrnc6DamRfolPN18BgXHYhIzvMLrwQpOc7DUPUvIFztkF0WsIA3l48vAPTxocJ9vFaR4sRrClmkLGip2vkM927Hi+Id1sEIeBj+3Y43DBgECwlXOzSHC+Hf7XgLCVc7lOgW7JCdjBe2RO0gfXwRS9XOZ7iPC+YMcFnUzvAwMS9arXaGG9TOogmonc+Aamc40CkX7eAxLjoQkZwd4ZUgJcdFGKp+JVztkF2UBby5fFwBfdwV7uO1ihQnXlPIIiVlqdr5FLbWpP0o3nQHI+A0XO2k/TQwCDLC1Q7NYQaudtJ+RrjaoUSX6pCdjLOWqB2kj+csVTufwtRO2jPAZVE7XpiY/Wq14xnUjp+A2vkUqHY8oFP6HTzGRQcikvNiwitBSo45hqp/ceFqh+yyuAW8uXx8caCPLyHcx2sVKU68ppBFypKWqp1PcF+grtjJtlQHI+Cl4GqnoJYCBsHSwtUOzeHScLVTqODtxGwm3ohEt2SH7GQ8whK1g/TxZSxVO5/gPlKc2E62ZcPEvFy12lnWoHaWS0DtfAJUO8sCnXK5Dh7jogMRyXl54ZUgJcdlGKr+FYSrHbLLChbw5vLxFYA+vqJwH69VpDjxmkIWKStZqnY+xqmdYhTvyh2MgFfGq53iysAgWEW42qE5XAWvdoqrCFc7lOhW6pCdjFe1RO0gfXw1S9XOxzi1UzDAZVE7q4eJeY1qtbO6Qe2skYDa+RiodlYHOuUaHTzGRQcikvOawitBSo6rMVT9awlXO2SXtSzgzeXjawF9fG3hPl6rSHHiNYUsUtaxVO18hNvJVojiXbeDEfC6+J1shXWBQbCecLVDc7gefidbYT3haocS3TodspPx+paoHaSPb2Cp2vkIt5Mtb4DLonY2DBPzRtVqZ0OD2tkoAbXzEVDtbAh0yo06eIyLDkQk542FV4KUHDdgqPo3Ea52yC6bWMCby8c3Afr4psJ9vFaR4sRrClmkbGap2vkQ99tFK75AvXkHI+DN4WrHczYHBsEWwtUOzeEWcLXjOVsIVzuU6DbrkJ2Mt7RE7SB9fCtL1c6HMLWTS+wL1FuHiTlfrXa2NqidfAJq50Og2tka6JT5Dh7jogMRybkgvBKk5LgVQ9VfFK52yC5FC3hz+XgR6OOBcB+vVaQ48ZpCFiklS9XOB0xqp9zBCLjMoHbKwCDYRrjaoTnchkHtbCNc7VCiK3XITsbbWqJ2kD6+naVq5wML1c72YWLeoVrtbG9QOzskoHY+AKqd7YFOuYMlagfJ+X/CK0FKjtsxVP07Clc7ZJcdLeDN5eM7An18J+E+XqtIceI1hSxSdrZU7bwPW2vyFd9k26WDEfAucLWT93cBBsGuwtUOzeGucLWT93cVrnYo0e3cITsZ72aJ2kH6+O6Wqp33YWonn9g32fYIE/Oe1WpnD4Pa2TMBtfM+UO3sAXTKPTt4jIsORCTnvYRXgpQcd2eo+vcWrnbILntbwJvLx/cG+vg+wn28VpHixGsKWaTsa6naeQ+ndtJRvPt1MALeD6920vsBg2B/4WqH5nB/vNpJ7y9c7VCi27dDdjI+wBK1g/TxAy1VO+/h1E7KAJdF7RwUJuaDq9XOQQa1c3ACauc9oNo5COiUB3fwGBcdiEjOhwivBCk5HshQ9R8qXO2QXQ61gDeXjx8K9PHDhPt4rSLFidcUskg53FK18y7ut4tWvNs5ooMR8BFwtRP4RwCD4Ejhaofm8Ei42gn8I4WrHUp0h3fITsZHWaJ2kD5+tKVq513cbxdN7N3OMWFiPrZa7RxjUDvHJqB23gWqnWOATnlsB49x0YGI5Hyc8EqQkuPRDFX/8cLVDtnleAt4c/n48UAfP0G4j9cqUpx4TSGLlBMtVTvvwNaaYimK96QORsAnwdVOsXQSMAhOFq52aA5PhqudYulk4WqHEt2JHbKT8SmWqB2kj59qqdp5B6Z2ioEBLovaOS1MzKdXq53TDGrn9ATUzjtAtXMa0ClP7+AxLjoQkZzPEF4JUnI8laHqP1O42iG7nGkBby4fPxPo4yOF+3itIsWJ1xSySDnLUrXzNmytURXvds7uYAR8NlztKP9sYBCcI1zt0ByeA1c7yj9HuNqhRHdWh+xkfK4lagfp4+dZqnbehqkdldi7nVFhYj6/Wu2MMqid8xNQO28D1c4ooFOe38FjXHQgIjlfILwSpOR4HkPVf6FwtUN2udAC3lw+fiHQx0cL9/FaRYoTrylkkXKRpWrnLdxvF61QOxd3MAK+GK52Cv7FwCC4RLjaoTm8BK52Cv4lwtUOJbqLOmQn40stUTtIH7/MUrXzFu63iyamdi4PE/MV1WrncoPauSIBtfMWUO1cDnTKKzp4jIsORCTnK4VXgpQcL2Oo+q8SrnbILldZwJvLx68C+vjVwn28VpHixGsKWaRcY6naeRP3BWovivfaDkbA18LVjuddCwyC64SrHZrD6+Bqx/OuE652KNFd0yE7GV9vidpB+vgNlqqdN2Fqx8sZ4LKonRvDxHxTtdq50aB2bkpA7bwJVDs3Ap3ypg4e46IDEcn5ZuGVICXHGxiq/luEqx2yyy0W8Oby8VuAPn6rcB+vVaQ48ZpCFim3Wap23oCtNekKtXN7ByPg2+FqJ+3dDgyCO4SrHZrDO+BqJ+3dIVztUKK7rUN2Mr7TErWD9PG7LFU7b8DUTjoxtXN3mJjvqVY7dxvUzj0JqJ03gGrnbqBT3tPBY1x0ICI53yu8EqTkeBdD1X+fcLVDdrnPAt5cPn4f0MfvF+7jtYoUJ15TyCLlAUvVzuuwtcZXUbwPdjACfhCudnz1IDAIHhKudmgOH4KrHb+CtxOzmXgjEt0DHbKT8cOWqB2kjz9iqdp5HaZ2fMcAl0XtPBom5seq1c6jBrXzWAJq53Wg2nkU6JSPdfAYFx2ISM6PC68EKTk+wlD1PyFc7ZBdnrCAN5ePPwH08SeF+3itIsWJ1xSySHnKUrXzGmytyTlRvE93MAJ+Gq52cs7TwCB4RrjaoTl8Bq52cs4zwtUOJbqnOmQn42ctUTtIH3/OUrXzGkztZMsGuCxq5/kwMY+pVjvPG9TOmATUzmtAtfM80CnHdPAYFx2ISM4vCK8EKTk+x1D1vyhc7ZBdXrSAN5ePvwj08ZeE+3itIsWJ1xSySHnZUrXzKu4rBRVfoH6lgxHwK3C1Uyi9AgyCV4WrHZrDV+Fqp1B6VbjaoUT3cofsZPyaJWoH6eOvW6p2XsV9pSCxL1C/ESbmN6vVzhsGtfNmAmrnVaDaeQPolG928BgXHYhIzm8JrwQpOb7OUPW/LVztkF3etoA3l4+/DfTxd4T7eK0ixYnXFLJIeddStfMKbK1xK97tvNfBCPg9uNpxnfeAQfC+cLVDc/g+XO24zvvC1Q4lunc7ZCfjDyxRO0gf/9BStfMK7gvUib3b+ShMzB9Xq52PDGrn4wTUzitAtfMR0Ck/7uAxLjoQkZw/EV4JUnL8kKHq/1S42iG7fGoBby4f/xTo458J9/FaRYoTrylkkfK5pWrnZdxaU4zi/aKDEfAXcLXjFL8ABsFY4WqH5nAsXO04xbHC1Q4lus87ZCfjLy1RO0gf/8pStfMyTO04BQNcFrUzLkzMX1ernXEGtfN1AmoHuAKpcUCn/LqDx7joQERy/kZ4JUjJ8SuGqv9b4WqH7PKtBby5fPxboI9/J9zHaxUpTrymkEXK95aqnZdga022YifbDx2MgH+Aq51s6QdgEPwoXO3QHP4IVzvZ0o/C1Q4luu87ZCfjnyxRO0gf/9lStfMS7txOYjvZfgkT86/VaucXg9r5NQG18xJQ7fwCdMpfO3iMiw5EJOffhFeClBx/Zqj6fxeudsguv1vAm8vHfwf6+B/CfbxWkeLEawpZpPxpqdp5EbbWqIpvso3vYAQ8Hq52lBoPDIIJwtUOzeEEuNpRFbydmM3EG5Ho/uyQnYwnWqJ2kD7+l6Vq50XcTrbEvsnW0BnORWdDpbKh/1CtduiHuNXOi0C1QxzijtXllN06eYyLDkQk5+6d2OSDDjhKjn8xVP09OnkXLideU2SXHp3yeXP5eA+gjzcK9/FaRYoTrylkkdIE9Jsk1c4LuM0YFed2enYyAu7ZiR93JmBAcfGeqXPSBIPGZVEVlFAoICQnvV7gpNfV0JyRftnMnOgRNmlm8PEkE+oYpoTa0skIuIUhobYKT6jEu7WeUGFjtVmSUJF+2S48oZJN2i1PqM+34+YjirejkxFwB0OwdgCdrVN4cqY57GSQ952d9UQfd6zeliR6pI/3Ef6IhGzShyFe+gp/DEh5oi9TEcfll32BftlPuF/WymdOvKaQ+ay/cB8nG/dnEGh9wTVAV0Pj/LkZW7j2a5j0yo4T9/fNPPmoAYrTZX3P2i0yt0PC6wHa72bWfRbdZ9V9Nt1n132g7nPoPkj3OXUfrPsQ3efSfW7d59F9Xt3n031+3RfQfajuC+o+TPeFdF9Y90V0H677oro7uivdXd1Tuqer3/EOCN/nRu/NbLg3i+HerIZ7sxnuzW64N9Bwbw7DvUGGe3Ma7g023BtiuDeX4d7chnvzGO7Na7g3n+He/IZ7CxjuDTXcW9Bwb5jh3kKGewsb7i1iuDfccG9Rwz3HcE8Z7rmGeynDvXTn5HsH5gr/HBH+6cRrFUknblIfAFgguvYhzAwaizjOAhnrn/maNf5Ybjhfara4Y6X/nXs1e7yxnIgd1cA4Y7kVPqHmmPGxnCr/UoNmcKxseTJfVXPO2Fiewe/V4BkZyzPGkBoy/WPlasSjmmt6x8rVjG019/SN5U4hT6h5pmes3BRzjpp32scqTiV/qfmmdazcVHOhmn/axnKmIa+qBaZlLGeacrQaOvWxMtOY79WCUxsrPc1rhxo2xbHS5elYh9RCUxorN11rmlq49ljedK6PapEaY/nl6V5r1XDzWM4MrNtqUdNYzgzVAMqZfCw1g/WEUtVjBTNcmyi3cqxUjDpHpSJjueVYNZNKAx8mUN1I9eGQcLx0KGLcUNQ4ocgZHoqehUMRNCwURUNDkTR/KJrmDUXU3KGoGhKKrDlD0TVHKMJmD0XZrKFIo9qNakFqSb75ScPqz6DiJEamkxEwDY56YtgFPoNzKpUFTCrnmx+aQ8KIPYkRVPB2YrYkd9TjEkqQ2I76XBhgXvXTllzn5DvqvU7+HfW4TOKoHDCAPLBx0c5HQZMDBmMX7xw4GJNakVIwP/KDKF6/kxGwD1+R/MAHrkiLCV+RaA4Xg69IfrCYpStSCobbLxrgsqxIi4cBtkT1irS4YUVaIoEVKQVckRYHBtASTMZFv0RHcl4SmMwaGvCrZTZMQOiX6EgpsBQwmZnm0InXFNl4KYZKZilLKxkXln8KqSjepTsZAS8Nr2QKqaWBwT9CeCXzt9HhlUwhNYI5+BEJdCnhCXQZ8Bx2NfTCi/TxZYGxl2QF7MJwF1wDXJYKeLkwMS9fXQEvZ6iAl0+gAsatQI5aDuiUyzMZFx2ISM4rMFfATrymKDkuy1C9rSi8aiW7rGgBby4fXxHo4ysJ9/FaRQqi+EGNtTJ4wU5K7SjYWuOVo3hX6WQEvApc7XjlVYAGXFW42qE5XBWudrzyqsLVDiW6lTtlJ+PVwMm4q6E5I318dUvVjoLh9koGuCxqZ40wMa9ZrXbWMKidNRNQO7gVyFFrAJ1yTSbjogMRyXkt4ZUgJcfVGar+tYWrHbLL2hbw5vLxtYE+vo5wH69VpDjxmkIWKeta+m7Hga01bsUXM9brZAS8HlztuM56wCBYX7jaoTlcH652XGd94WqHEt26nbKT8QaWqB2kj29oqdpxYLhV2QCXRe1sFCbmjavVzkYGtbNxAmoHtwI5aiOgU27MZFx0ICI5byK8EqTkuCFD1b+pcLVDdtnUAt5cPr4p0Mc3E+7jtYoUJ15TyCJlc0vVzqKwtSaoUDtbdDIC3gKudgJnC2AQbClc7dAcbglXO4GzpXC1Q4lu807ZyXgrS9QO0se3tlTtLArDXUxM7eTDxFyoVjt5g9opJKB2cCuQo/JApywwGRcdiEjOReGVICXHrRmq/kC42iG7BBbw5vLxAOjjJeE+XqtIceI1hSxSypaqneGwtSZb8U2MbToZAW8DVztZtQ0wCLYVrnZoDreFq51sBW8nZjPxRiS6cqfsZLydJWoH6ePbW6p2hsNwZxP7lsoOYWL+X7Xa2cGgdv6XgNrBrUCO2gHolP9jMi46EJGcdxReCVJy3J6h6t9JuNohu+xkAW8uH98J6OM7C/fxWkWKE68pZJGyi6VqZxHcux0vinfXTkbAu+Lf7Xi7AoNgN+Fqh+ZwN/y7HW834WqHEt0unbKT8e6WqB2kj+9hqdpZBIY7yBngsqidPcPEvFe12tnToHb2SkDt4FYgR+0JdMq9mIyLDkQk572FV4KUHPdgqPr3Ea52yC77WMCby8f3Afr4vsJ9vFaR4sRrClmk7Gep2lkYttak/Sje/TsZAe8PVztpf39gEBwgXO3QHB4AVztp/wDhaocS3X6dspPxgZaoHaSPH2Sp2lkYhjvtGeCyqJ2Dw8R8SLXaOdigdg5JQO3gViBHHQx0ykOYjIsORCTnQ4VXgpQcD2Ko+g8TrnbILodZwJvLxw8D+vjhwn28VpHixGsKWaQcYanaWQi21hQqdrId2ckI+Ei42imoI4FBcJRwtUNzeBRc7RQqeDsxm4k3ItEd0Sk7GR9tidpB+vgxlqqdhWC4C4ntZDs2TMzHVaudYw1q57gE1A5uBXLUsUCnPI7JuOhARHI+XnglSMnxGIaq/wThaofscoIFvLl8/ASgj58o3MdrFSlOvKaQRcpJlqqdYTi1U4ziPbmTEfDJeLVTPBkYBKcIVzs0h6fg1U7xFOFqhxLdSZ2yk/GplqgdpI+fZqnaGYYriAsGuCxq5/QwMZ9RrXZON6idMxJQO7gVyFGnA53yDCbjogMRyflM4ZUgJcfTGKr+kcLVDtllpAW8uXx8JNDHzxLu47WKFCdeU8gi5WxL1c6CuJ1shSjeczoZAZ+D38lWOAcYBOcKVzs0h+fid7IVzhWudijRnd0pOxmfZ4naQfr4KEvVzoK4zU55A1wWtXN+mJgvqFY75xvUzgUJqB3cCuSo84FOeQGTcdGBiOR8ofBKkJLjKIaqf7RwtUN2GW0Bby4fHw308YuE+3itIsWJ1xSySLnYUrUzFLbWeBVfoL6kkxHwJXC14zmXAIPgUuFqh+bwUrja8ZxLhasdSnQXd8pOxpdZonaQPn65pWpnKAx3LrEvUF8RJuYrq9XOFQa1c2UCage3AjnqCqBTXslkXHQgIjlfJbwSpOR4OUPVf7VwtUN2udoC3lw+fjXQx68R7uO1ihQnXlPIIuVaS9XOAkxq57pORsDXMaid64BBcL1wtUNzeD2D2rleuNqhRHdtp+xkfIMlagfp4zdaqnYWsFDt3BQm5pur1c5NBrVzcwJqB7cCOeomoFPebInaQXK+RXglSMnxRoaq/1bhaofscqsFvLl8/Fagj98m3MdrFSlOvKaQRcrtlqqd+WFrTb7im2x3dDICvgOudvL+HcAguFO42qE5vBOudvL+ncLVDiW62ztlJ+O7LFE7SB+/21K1Mz8Mdz6xb7LdEybme6vVzj0GtXNvAmoHtwI56h6gU97LZFx0ICI53ye8EqTkeDdD1X+/cLVDdrnfAt5cPn4/0McfEO7jtYoUJ15TyCLlQUvVznw4tZOO4n2okxHwQ3i1k34IGAQPC1c7NIcP49VO+mHhaocS3YOdspPxI5aoHaSPP2qp2pkPVxCnDHBZ1M5jYWJ+vFrtPGZQO48noHZwK5CjHgM65eNMxkUHIpLzE8IrQUqOjzJU/U8KVztklyct4M3l408Cffwp4T5eq0hx4jWFLFKetlTtzAtba4KKdzvPdDICfgaudgL/GWAQPCtc7dAcPgtXO4H/rHC1Q4nu6U7Zyfg5S9QO0seft1TtzAvDHST2bmdMmJhfqFY7Ywxq54UE1A5uBXLUGKBTvsBkXHQgIjm/KLwSpOT4PEPV/5JwtUN2eckC3lw+/hLQx18W7uO1ihQnXlPIIuUVS9XOPLC1pliK4n21kxHwq3C1Uyy9CgyC14SrHZrD1+Bqp1h6TbjaoUT3SqfsZPy6JWoH6eNvWKp25oHhLgYGuCxq580wMb9VrXbeNKidtxJQO7gVyFFvAp3yLSbjogMRyflt4ZUgJcc3GKr+d4SrHbLLOxbw5vLxd4A+/q5wH69VpDjxmkIWKe9Zqnbmhq01quLdzvudjIDfh6sd5b8PDIIPhKsdmsMP4GpH+R8IVzuU6N7rlJ2MP7RE7SB9/CNL1c7cMNwqsXc7H4eJ+ZNqtfOxQe18koDawa1AjvoY6JSfMBkXHYhIzp8KrwQpOX7EUPV/JlztkF0+s4A3l49/BvTxz4X7eK0ixYnXFLJI+cJStTMXbK0pVKidsZ2MgMfC1U7BHwsMgi+Fqx2awy/haqfgfylc7VCi+6JTdjL+yhK1g/TxcZaqnblguAuJqZ2vw8T8TbXa+dqgdr5JQO3gViBHfQ10ym+YjIsORCTnb4VXgpQcxzFU/d8JVztkl+8s4M3l498Bffx74T5eq0hx4jWFLFJ+sFTtDIGtNZ4XxftjJyPgH+Fqx/N+BAbBT8LVDs3hT3C143k/CVc7lOh+6JSdjH+2RO0gffwXS9XOEBhuL2eAy6J2fg0T82/VaudXg9r5LQG1g1uBHPUr0Cl/YzIuOhCRnH8XXglScvyFoer/Q7jaIbv8YQFvLh//A+jjfwr38VpFihOvKWSRMt5StTMYttakK9TOhE5GwBPgaiftTQAGwUThaofmcCJc7aS9icLVDiW68Z2yk/FflqgdqI/3tlPtDIbZKp2Y2unWO/SH3g2Vyob+Q7XaoR/iVju4FchR3XrjnLJ7bx7jogMRyblHb2zyQQccJceG3viFobE378LlxGuK7NJoAW8uH28E+niTcB+vVaQ48ZpCFik9gX6TpNqZE7bW+CqKd6bejIBpcKza8dVMwCDoBQxOrjns1RutdvwK3k7MZuKNSHQ9e8tOxs3gZNzV0JyRPt5iqdqZE6Z2fMcAl0XttIaJua1a7bQa1E5bAmpnTqDaaQU6ZVtvHuOiAxHJuV14JUjJsYWh6u8QrnbILh0W8Oby8Q6gj3cK9/FaRYoTrylkkdLbUrUzCLbW5Jwo3j69GQH3gaudnNMHGAR9hasdmsO+cLWTc/oKVzuU6Hr3lp2M+1midpA+3t9StTMIpnayZQNcFrUzIEzMM1ernQEGtTNzAmpnEFDtDAA65cy9eYyLDkQk51mEV4KUHPszVP2zClc7ZJdZLeDN5eOzAn18NuE+XqtIceI1hSxSZrdU7cyB+0pBxReoB/ZmBDwQrnYKpYHAIJhDuNqhOZwDrnYKpTmEqx1KdLP3lp2MB1midpA+PqelamcO3EH2xL5APThMzEOq1c5gg9oZkoDamQOodgYDnXJIbx7jogMRyXku4ZUgJcc5Gar+uYWrHbLL3Bbw5vLxuYE+Po9wH69VpDjxmkIWKfNaqnYGwtYat+Ldzny9GQHPB1c7rjMfMAjmF652aA7nh6sd15lfuNqhRDdvb9nJeAFL1A7Sx4daqnYG4j5SnNi7nQXDxDysWu0saFA7wxJQOwOBamdBoFMO681jXHQgIjkvJLwSpOQ4lKHqX1i42iG7LGwBby4fXxjo44sI9/FaRYoTrylkkTLcUrUzO26tKUbxLtqbEfCicLXjFBcFBoEjXO3QHDpwteMUHeFqhxLd8N6yk7GyRO0gfdy1VO3MjvuiRMEAl0XtpMLEnK5WOymD2kknoHaAK5BKAZ0y3ZvHuOhARHLOCK8EKTm6DFV/VrjaIbtkLeDN5eNZoI/nhPt4rSLFidcUskjxLFU7s8HWmmzFTja/NyNgH652siUfGASLCVc7NIeLwdVOtrSYcLVDic7rLTsZL26J2kH6+BKWqp3ZcOd2EtvJtmSYmJeqVjtLGtTOUgmondmAamdJoFMu1ZvHuOhARHJeWnglSMlxCYaqf4RwtfO3XSzgzeXjI4A+voxwH69VpDjxmkIWKctaqnZmha01quKbbMv1ZgS8HFztKLUcMAiWF652aA6Xh6sdVcHbidlMvBGJbtnespPxCpaoHaSPr2ip2pkVt5PNMcBlUTsrhYl55Wq1s5JB7aycgNqZFah2VgI65cq9eYyLDkQk51WEV4KUHFdkqPpXFa52yC6rWsCby8dXBfr4asJ9vFaR4sRrClmkrG6p2pkF+CtSonjX6M0IeI3e+HHXFK5QiPeavSdNMGhcFlVBCWX13rKT3lqWqAqkX67NnOgRNlmbwceTTKgzMyXUdXozAl6HIaGuKzyhEu916wkVNtZ6liRUpF+uLzyhkk3WtzyhDgD+npgo3g16MwLegCFYNwA624bCkzPN4YYM8n5D4c/jbUj0G1mS6JE+vrHwRyRkk40Z4mUT4Y8BKU9swlTEcfnlJkC/3FS4X9bKZ068ppD5bDPhPk423oxBoCH9MMmC8IfmSWMpL+W6uRRh8gJHpYOi67luUEg7RSdfdEt+WvnltJtOFYNiQePPq7JTzhf9svfPWFG8m/dmBLy5IQjigt8cGPxbCC8IaQ63MARB3DncAvzcvrUhmRft0SBwYjYDXNT8ViiuLSP2g1cqQEOq6Av/KOjpxFycFufbcgZWx6lN+pbAYN4KGCDReaVxD5lBX1B67orKKTu+6+SdXDGbK/iBW/Dy5VQ5kwpSMzqvU3N25LxuzTSvW4fz2hj2pFdkJ2aLJs98uCIXKAY5EsaWDGXVlsIfMcxocDjTwTsuxqLwkpwcs8ggtwOmpBBMIdk68ZoqMM1FiWkuSjEWnqlh5vKLbgP+T3NKcSr42Hyg+wDZeYAWviJDLgXaWyHnkAqKpgazwmmYzjmYmk9Fx+TI36g5iRZY5SkpHCdeU0WmhFiegsKZyjBqav8OYS4zJIYe4MTQ1Rqn02bTU8jE5bxNb5kJBmmLqF9uE1moZ9Q+U5tzpH22jYylUikdG0FOlYNyKpPz3YLKprLZcrqcy3rpoJxJ54NcSaXzKdcv5Zyy8kqlXCZVzGXLflDMlqNJWwWpVDrwC0WVcbP5guMFqbxTTudSWvwGqVwQpLxsNp9KBVmv7PlasGoZ7DmZXM53sm7Kd7nss21EaaIWhak92YiOacuisJ2Ni8J2zIvCdgyLQqOQRaGmE+f+PpRTRiad7YUuCo1MSWd7wKIwtcd8SPvsIHRR4LLPDv+hx4//Cx8/7mh6/OjEazWf/SPfg8QdC/gok2V3Qdcc9rBkDuOOtZNwe1DA7MSwsO/MVOTszPhYdEemudiFaS52YXwsyuUXPYU/FuXygZkseCy6E8NjUaC91Uz1x6LV7e/8jZqTaOG3K6cC3okpIe7KqIAJ864MiaGXJY9FdwIWRbv1lplgejEprN0SeCyKtM/uQAU8E1ABc9lnd4N90Bu8kPbZgyl/7gGYh6k9qUHOw55M87DnNDwml7yQG+DC/DhaJOxlY5GwF3ORsBdDkdCcUJEQc3csNMntDRwLWSQ0My1Ce09DkRB3ly3SPvv0xi3syCKByz77MD5tSXf+o77Rn6VLwz5L5ymk7+wLy+1ehY1oXPrUHy3YczVM3kDz+m8ORa95g3rIx7gfulDpzhRMKMI01n7/HwXn/sDgZA5E9f9zIO6PDMR6xuTDeAA6Y6JfnmIzpve3DEBn4ANEZ2AHmoEPrGdgKwL7wHoGdtQcFhjqIK6Ha2gheDAOqGurQx3cWz7GQ+qR76hPmuRjPLRuKEe9Z4GhDrMlRR+OA5qx1aEOtyBFH2GLQx2JA5q11aGOtMChjrLFoY7GAc3Z6lBHW+BQx9jiUMfigHq2OtSxFjjUcbY41PE4oL6tDnW8BQ51gi0OdSIOaN5WhzrRAoc6yRaHOhkHtGCrQ51sgUOdYotDnYoDWrTVoU61wKFOs8WhTscBDWx1qNMtcKgzbHGoM3FAS7Y61JkWONTI+isNRy3YUz7Gs2yJ/LNhQJVjq0OdbUHkn2OLQ52Lcyhlq0Oda4FDnWeLQ43COZS1+2JGWeBQ59viUBfgHCplq0NdYIFDXWiLQ43GOVTaVocabYFDXWSLQ12Mcyhr9xldbIFDXWKLQ12Kcyhr9xldaoFDXWaLQ12Ocyhr9xldboFDXWGLQ12Jcyhr9xldaYFDXWWLQ12Ncyhr9xldbYFDXWOLQ12Lcyhr9xlda4FDXWeLQ12Pcyhr9xldb4FD3WCLQ92Icyhr9xndaIFD3WSLQ92Mcyhr9xndbIFD3WKLQ92Kcyhr9xndaoFD3WaLQ92Oc6iyrQ51uwUOdQcSI30as61h0jeBuhkM1x1MgOuLbU6s5rEZ7CALnOoQCzAeagHGwyzAeIQFGI+yAOMxFmA8zgKMJ1iA8SQLMJ5iAcbTLMB4hgUYR1qA8SwLMJ5jAcbzLMB4vgUYL7QA40UWYLzEAoyXWYDxCgswXmUBxmsswHidBRhvsADjTRZgvMUCjLdZgPEOBowNUIypbIOhYcZ2Fd/Yk37bO9msd3h9p764S/e7db9H93t1v0/3+3V/QPcHdX9I94d1f0T3R3V/TPfHdX8iHOTJ3uGgXb9LhgYdUnXvLsO9uw337jHcu9dw7z7DvfsN9x4w3HsyvBdt0/tLJafY1D+/GKBrrDgPvD0H+vvcKh5Mx3179BQIF/0KtKh9njLYB/pCQlVijzsPTwOTVnQenjbMA/oXOQBfAqingXP6DNOcPpOAbz0DnIdnmebh2QR8C/jyRj0LnNPnmOb0OW7f0vNwp9B5YPMjHU/AF2wVL8Lizt/zTH70fAI56nngPIxhmocxCeQo4EtHNQY4py8wzekLCfjWC8B5eJFpHl5MwLeAL4vVi8A5fYlpTl9KYP27S+g8sPmRjifgC/2KF+9x5+9lJj96OYEc9TJwHl5hmodXEshRwE0O6hXgnL7KNKevJuBbrwLn4TWmeXgtAd8Cbk5RrwHn9HWmOX09gfXvbqHzwOZHOp6AG4gqNvrEnb83mPzojQRy1BvAeXiTaR7eTCBHATdVqTeBc/oW05y+lYBvvQWch7eZ5uHtBHwLuBlOvQ2c03eY5vSdBNa/e4TOA5sf6XgCblis2FgYd/7eZfKjdxPIUe8C5+E9pnl4L4EcBdzEqd4Dzun7THP6fgK+9T5wHj5gmocPEvAt4OZb9QFwTj9kmtMPE1j/7hU6D2x+pOMJuEG6YiNz3Pn7iMmPPkogR30EnIePmebh4wRyFHDTuPoYOKefMM3pJwn41ifAefiUaR4+TcC3gJv91afAOf2MaU4/S2D9u0/oPLD5kY4n4IGMioMTcefvcyY/+jyBHPU5cB6+YJqHLxLIUcBDKuoL4JyOZZrTsQn41ljgPHzJNA9fJuBbwMNF6kvgnH7FNKdfJbD+3S90Htj8SMcT8ABYxUGtuPM3jsmPxiWQo8YB5+Frpnn4OoEcBTwUp74Gzuk3THP6TQK+9Q1wHr5lmodvE/At4GFG9S1wTr9jmtPvElj/HhA6D1HO3cCcHwRwLuT/GYsT50OWzOfDluB8xBKcj1qC8zFLcD5uCc4ngDjp/HV7Q+VHSXs3VDY0/jsZ5hmN8S4LMN5tAcZ7LMB4rwUY77MA4/0WYHyAKccjMKayHsu4XHjr4/63xsWN7bqMY6uunBCtVb7XFz/o/qPuP+n+s+6/6P6r7r/p/rvuf+j+p+7jdZ+g+0Td/6IB+jRUfqjm+96Tf7zmB8O9Hw33fjLc+9lw7xfDvV8N934z3PvLcI9I0D0q6Po2THoAEG3oZPp7b/HOqOj/ReeiW59//uxebXT6D9WVL/rJ1O+AJwr0dSIai/DGHavriUz3PnYoH1tw/mGJkvzTEpzjLcE5wRKcEy3BiciXBf/vqrriCWz10/G4+RP4REN9z2QbNGfgExL1gyWcgU9c1I+WcAY+wVE/WcIZ+ERI/WwJZ+ATJvWLJZyBT6zUr5ZwBj4BU78lxNmZsaa6Lv4Cvr3uAdQgUf0ZHRc8D11NNeCwqx4A/fn3r5Yrlf0o525gf28CcDY9mUXj7AnAmc07fimbzXHinAmAs1DI5vIlL8OJsxfC7sVsqZzKuZw4mwE485l0uZxJ5TlxtgBwZpRTyri5MifOVgBOv+Bksp5X5MTZBsCpyl4q8PMFTpztCLsXSk4xUD5h69cw+dfqo1+pj36dPvpV+ujX6KNfoY9+fT761fmmPpOuB/WY8evow/aGyJg9I9czRa57Ra6bI9ctkevWyHVb5Lo9vO7Qf3bS82jd++jeV/d+uvfXfUCffx7y0zz2aJi8oZ/BdDA9c23A4kyzja3+qdO65rbrNxbMrOdlFt1n1X226pcJ9B97Vd2bxXBvVsO92cJ70daEnawKo8ZNEDOjCsGyo2YBjUUcZ4WM9c98zQYMgiSDt7MevMbgnV3Py0Dd59B9UHXwzm4IyoGGe3MY7g1KIHg7gcE7OzB4BwKDdw5g8A6yNHh714PXGLxz6nkZTJWS7nNVB++chqAcbLg3xHBvrgSCtzcweOcEBu9gYPAOAQbvXJYGb5968BqDd249L/PoPq/u81UH79yGoJzHcG9ew735EgjePsDgnRsYvPMAg3deYPDOZ2nw9q0HrzF459fzsoDuQ3VfsDp45zcE5QKGe0MN9xZMIHj7AoN3fmDwLgAM3qHA4F3Q0uDtVw9eY/AO0/OykO4L675IdfAOMwTlQoZ7CxvuLZJA8PYDBu8wYPAuBAzehYHBu4ilwdu/HrzG4B2u52VR3R3dVXXwDjcE5aKGe47hnkogePsDg3c4MHgXBQavAwxeZWnwDqgHrzF4XT0vKd3Tumeqg9c1BGXKcC9tuJdJIHgHAIPXBQZvChi8aWDwZoBB0OVMoyNONWvLJD+YJXI9c+R6QOS6f+S6X+S6b+S6T+S6d+S6M3LdEbluj1y3Ra5bI9ctkevmyHWvyPVMkeuekeumyHVj5LpH5Lp75Lpb5Lohcv1X86TriZHrCZHr8ZHrPyPXf0Suf2+eFGcjQLatj1cfrz5efbz6ePXx6uPVx6uPJ388qgW3ap1UF24Zud4icr155HqzyPWmketNItcbR643ilxvGLneIHK9fuR6vcj1upHrdSLXa0eu14pcrxm5XiNyvXrkerXI9aqR61Ui1ytHrleKXK8YuV4hcr185Hq5yPWyketlItcjIteXt026vixyfWnk+pLI9cWR64si16Mj1xdGri+IXJ8fuR4VuT4vcn1u5PqcyPXZkeuzItcjI9dnRq7PiFyfHrk+LXJ9auT6lMj1yZHrkyLXJ0auT4hcHx+5Pi5yfWzk+pjI9dGR66/bJ12Pi1x/Fbn+MnI9NnL9ReT688j1Z5HrTyPXn0SuP45cfxS5/jBy/UHk+v3I9XuR63cj1+9Ert+OXL8VuX4zcv1G5Pr1yPVrketXI9evRK5fjly/FLl+MXL9QuR6TOT6+cj1gpHnQNFXqdFXrdFXsYtErqNvb6Jvd6Jvf1TkOvrAOPpAOfrAORO5jj6jij7Dij7jmi1yHd3+HN0eHd0+PShyHd1xGd2RGd2xOVfkOrrJK7oJLLpJbL7IdXRfSXTfSde+lBsb/mlZ/fec7p7uvu6L6b647kvovqTuS+m+ND0H0n0Z3ZfVfTndl9d9Bd1X1H0l3VfWfRXdV9V9Nd1X130N3dfUfS3d19Z9Hd3X1X093dfXfQPdN9R9I9031n0T3TfVfTPdN9d9C9231H0r3bfWPa97Qfei7oHuJd3Lum+j+7a6b6f79rrvoPv/dN9R951031n3XXTfVffddN9d9z1031P3vXTfW/d9dN9X9/1031/3A3Q/UPeDdD9Y90N0P1T3w3Q/XPcjdD9S96N0P1r3Y3Q/VvfjdD9e9xN0P1H3k3Q/WfdTdD9V99N0P133M3Q/U/eRup+l+9m6n6P7ubqfp/so3c/X/QLdL9R9tO4X6X6x7pfofqnul+l+ue5X6H6l7lfpfrXu1+h+re7X6X697jfofqPuN+l+s+636H6r7rfpfrvud+h+p+536X637vfofq/u9+l+v+4P6P6g7g/p/rDuj+j+qO6P6f647k/o/qTuT+n+tO7P6P6s7s/p/rzuY3R/QfcXdX9J95d1f0X3V3V/TffXdX9D9zd1f0v3t3V/R/d3dX9P9/d1/0D3D3X/SPePdf9E90/7JHt+pBtuLM4vlvGNXfVSYEh4/Zm2w+e6f6H7WN2/1P0r3cfp/rXu3+j+re7f6f697j/o/qPuP+n+s+6/6P6r7r/p/rvuf+j+p+7jdZ+g+0Td/9KdvgbWTffuuvfQvVH3pr4hmH9/hVSfScnu318HZLj3heHeWMO9Lw33vjLcG2e497Xh3jeGe98a7n1nuPe94d4Phns/Gu79ZLj3s+HeL4Z7vxru/Wa497vh3h+Ge38a7o033JtguDfRcO8vwz1ylup73Qz3uhvu9TDcazTcawrvRdtc4Z8jwj+deK0i6cT+dWV9cC+tPgeNRRy/gIz1z3yNjT+WG86X+jLuWOl/5159FW8sJ2JHNS7OWG6FT6ivZ3wsp8q/1DczOFa2PJmvqm9nbCzP4PfquxkZyzPGkPp++sfK1YhH9cP0jpWrGdvqx+kby51CnlA/Tc9YuSnmHPXztI9VnEr+Ur9M61i5qeZC9eu0jeVMQ15Vv03LWM405Wj1+9THykxjvld/TG2s9DSvHerPKY6VLk/HOqTGT2ms3HStaWpC7bG86Vwf1cQaY/nl6V5r1V/msZwZWLcV1TKTjeXMUA2guk0+lprBekJ1rx4rmOHaRPWoHCsVo85RjZGx3HKsmkk19cXuYCMd0yWiog0tVpv6omq9QEXx9uzLCJgG7141blzwPXEGVDMBJrWrGOeaQ8LYDTyHM4GDIKnPeuOCN2B9qhKdi15hgDVXP9noFRo2eq/ZoEDRn/rGZRJH9QIGUDPYuGjno6DpBQzGfz8HZumK1AjzIz+I4m3pywi4Bb4i+UELcEVqFb4i0Ry2wlckP2i1dEVqhOH2iwa4LCtSWxhg7dUrUpthRWpPYEVqBK5IbcAAamcyLioB/fvBPiDnDmAya2jAr5YzhQmoO9gHkVKgE5jMTHPoxGuKbNzJUMl0WlrJ9IDln0Iqird3X0bAveGVTCHVGxj8fYRXMjSHfeCVTCHVhzn4EQm0U3gC7Quew66GXniRPt4PGHtJVsA9YLgLrgEuSwXcP0zMA6or4P6GCnhAAhUwbgVyVH+gUw5gMi46EJGcZ2augJ14TVFy7MdQvc0ivGolu8xiAW8uH58F6OOzCvfxWkUKovhBjTUbeMFOSu10h601XjmKd/a+jIBnh6sdrzw70IADhasdmsOBcLXjlQcKVzuU6GbrKzsZzwFOxl0NzRnp44MsVTvdYbi9kgEui9qZM0zMg6vVzpwGtTM4AbWDW4EcNSfQKQczGRcdiEjOQ4RXgpQcBzFU/XMJVztkl7ks4M3l43MBfXxu4T5eq0hx4jWFLFLmsfTdTjfYWuM6Ubzz9mUEPC9c7bjOvMAgmE+42qE5nA+udlxnPuFqhxLdPH1lJ+P5LVE7SB9fwFK10w2GW5UNcFnUztAwMS9YrXaGGtTOggmoHdwK5KihQKdckMm46EBEch4mvBKk5LgAQ9W/kHC1Q3ZZyALeXD6+ENDHFxbu47WKFCdeU8giZRFL1U4DbK0JKtTO8L6MgIfD1U7gDAcGwaLC1Q7N4aJwtRM4iwpXO5ToFukrOxk7lqgdpI8rS9VOAwx3MTG144aJOVWtdlyD2kkloHZwK5CjXKBTppiMiw5EJOe08EqQkqNiqPozwtUO2SVjAW8uH88AfTwr3MdrFSlOvKaQRUrOUrXzF+z7Z9mKb2J4fRkBe3C1k1UeMAh84WqH5tCHq51sBW8nZjPxRiS6XF/Zyfj/tXcdUHIUR3v2knRJlwQIRM6Z3bu9RDyhiBLKQgKFi0IgJJBENvY5Yxsb2ziDbWwc8W8bZ5xzDjjnHMABbDDRYOy/W0zffltX0zt7W703jTXv1dvZ6Zrqr6uru6t6enpO9STakbTx0zyNdrDzTJd0dJVtL5XTw475DBrtnM5EO2eUIdqRG4HSmdMFjfKMVjeVK90QJct8ZsI9Qd05nubA6z8r4dGOrpezPCi3Kxs/S9DG+xJu41FOSrq0IyPppMzyNNr5j9hYM9SDeM9udQj4bPlnOz1nCzaC2QmPdrQOZ8s/2+mZnfBoR3d0s1qT3RnP8STakbTxuZ5GO/8Ri3aGuhm4TqKdeWHHPJ9GO/OYaGd+GaKd/whGO/MEjXJ+q5vKlW6IkmVekHBPUHeOcx14/eckPNrR9XKOB+V2ZePnCNr4woTbeJSTki7tyEg6KYs8jXaeFBtrsr2Id3GrQ8CLxaOdbO9iwUawJOHRjtbhEvFoJ9u7JOHRju7oFrUmuzNe6km0I2nj53oa7TwpFu1kexi4TqKdZWHHvJxGO8uYaGd5GaKdJwWjnWWCRrm81U3lSjdEyTKvSLgnqDvHcx14/SsTHu3oelnpQbld2fhKQRtflXAbj3JS0qUdGUknZbWn0c6/xcaagbyVbGtaHQJeIx7tDGTWCDaCtQmPdrQO14pHOwN55U6XeHDllujoVrcmuzM+z5NoR9LG13ka7fxbLNoZKNtKtvVhx3w+jXbWM9HO+WWIdv4tGO2sFzTK81vdVK50Q5Qs8wUJ9wR157jOgde/IeHRjq6XDR6U25WNbxC08Y0Jt/EoJyVd2pGRdFI2eRrtPCEX7Qwi3s2tDgFvlo92BjcLNoL+hEc7Wof98tHOYH/Cox3d0W1qTXZnPOBJtCNp44OeRjtPyEU7AwxcJ9HOUNgxD9NoZ4iJdobLEO08IRjtDAka5XCrm8qVboiSZR5JuCeoO8dBB17/loRHO7petnhQblc2vkXQxi9MuI1HOSnp0o6MpJOy1dNo53G5lWwDiPeiVoeAL5JfyTZwkWAjuDjh0Y7W4cXyK9kGLk54tKM7uq2tye6Mt3kS7Uja+CWeRjuPy61k62fgOol2tocd8w4a7Wxnop0dZYh2HheMdrYLGuWOVjeVK90QJct8acI9Qd05XuLA678s4dGOrpfLPCi3Kxu/TNDGdybcxqOclHRpR0bSSdnlabTzL7GxpidvB+rdrQ4B7xaPdnrSuwUbweUJj3a0Di8Xj3Z60pcnPNrRHd2u1mR3xld4Eu1I2viVnkY7/xKLdrrLtgP1VWHHfDWNdq5iop2ryxDt/Esw2rlK0CivbnVTudINUbLM1yTcE9Sd45UOvP5rEx7t6Hq51oNyu7LxawVt/BkJt/EoJyVd2pGRdFKu8zTaecxRtPPMVoeAn+kg2nmmYCN4VsKjHa3DZzmIdp6V8GhHd3TXtSa7Mx71JNqRtPFnexrtPOZhtPOcsGN+Lo12nsNEO88tQ7TzmGC08xxBo3yuJ9GOZJmfl3BPUHeOz3bg9T8/4dGOrpfne1BuVzb+fEEbf0HCbTzKSUmXdmQknZQXehrtPCo21vTn7cl2fatDwNeLRzv9vdcLNoIXJTza0Tp8kXi009/7ooRHO7qje2FrsjvjF3sS7Uja+Es8jXYeFYt2+su2J9sNYcf8Uhrt3MBEOy8tQ7TzqGC0c4OgUb601U3lSjdEyTK/LOGeoO4cX+LA678x4dGOrpcbPSi3Kxu/UdDGX55wG49yUtKlHRlJJ+UVnkY7j8hFO1nE+8pWh4BfKR/tZF8p2AhuSni0o3V4k3y0k70p4dGO7uhe0ZrszvhVnkQ7kjb+ak+jnUfkop0OBq6TaOc1Ycf8WhrtvIaJdl5bhmjnEcFo5zWCRvnaVjeVK90QJcv8uoR7grpzfLUDr//1CY92dL283oNyu7Lx1wva+BsSbuNRTkq6tCMj6aTc7Gm087Dc10Xznu3c0uoQ8C3i0c5Q7y2CjeCNCY92tA7fKB7tDPW+MeHRju7obm5Ndmf8Jk+iHUkbf7On0c7Dcl8XLduznVvDjvktNNq5lYl23lKGaOdhwWjnVkGjfEurm8qVboiSZX5rwj1B3Tm+2YHXf1vCox1dL7d5UG5XNn6boI2/LeE2HuWkpEs7MpJOyts9jXYeEhtrBocR7ztaHQJ+h3i0Mzj8DsFG8M6ERztah+8Uj3YGh9+Z8GhHd3Rvb012Z/wuT6IdSRt/t6fRzkNi0c7gEAPXSbRze9gxv4dGO7cz0c57yhDtPCQY7dwuaJTvaXVTudINUbLM/5dwT1B3ju924PW/N+HRjq6X93pQblc2/l5BG39fwm08yklJl3ZkJJ2U93sa7TwoNtZk8p7t3NHqEPAd4tFOpvcOwUbwgYRHO1qHHxCPdjK9H0h4tKM7uve3Jrsz/qAn0Y6kjX/I02jnQbFoJ1O2ZzsfDjvmj9Bo58NMtPORMkQ7DwpGOx8WNMqPtLqpXOmGKFnmjybcE9Sd44cceP0fS3i0o+vlYx6U25WNf0zQxu9MuI1HOSnp0o6MpJPycU+jnX/KfV00L9r5RKtDwJ8Qj3YGej8h2Ag+mfBoR+vwk+LRzkDvJxMe7eiO7uOtye6MP+VJtCNp45/2NNr5p9zXRcsW7Xwm7Jg/S6OdzzDRzmfLEO38UzDa+YygUX621U3lSjdEyTJ/LuGeoO4cP+3A6/98wqMdXS+f96Dcrmz884I2/oWE23iUk5Iu7chIOilf9DTaeUBuB+oexPulVoeAvyQe7fT0fEmwEXw54dGO1uGXxaOdnp4vJzza0R3dF1uT3Rl/xZNoR9LGv+pptPOAWLTT083AdRLtfC3smL9Oo52vMdHO18sQ7TwgGO18TdAov97qpnKlG6Jkmb+RcE9Qd45fdeD1fzPh0Y6ul296UG5XNv5NQRv/VsJtPMpJSZd2ZCSdlG97Gu3cLzbWZPOine+0OgT8HfFoJ9vzHcFGcFfCox2tw7vEo51sz10Jj3Z0R/ft1mR3xt/1JNqRtPHveRrt3C8W7WTLFu18P+yYf0Cjne8z0c4PyhDt3C8Y7Xxf0Ch/0OqmcqUbomSZf5hwT1B3jt9z4PX/KOHRjq6XH3lQblc2/iNBG/9xwm08yklJl3ZkJJ2Un3ga7fxDbKzpzSDen7Y6BPxT8WinN/NTwUbws4RHO1qHPxOPdnrzyp0u8eDKLdHR/aQ12Z3xzz2JdiRt/BeeRjv/EIt2etMMXCfRzi/DjvlXNNr5JRPt/KoM0c4/BKOdXwoa5a9a3VSudEOULPOvE+4J6s7xFw68/t8kPNrR9fIbD8rtysZ/I2jjv024jUc5KenSjoykk/I7T6Odv4uNNd1pxPv7VoeAfy8e7XSnfy/YCP6Q8GhH6/AP4tFOd/oPCY92dEf3u9Zkd8Z/9CTakbTxP3ka7fxdLNrpGmHgOol27g475ntotHM3E+3cU4Zo5++C0c7dgkZ5T6ubypVuiJJl/nPCPUHdOf7Jgdf/l4RHO7pe/uJBuV3Z+F8EbfyvCbfxKCclXdqRkXRS/uZptHOf3C4FeTtQ39vqEPC94tHOwPC9go3gvoRHO1qH94lHOwPD9yU82tEd3d9ak90Z/92TaEfSxv/habRzn9wuBWXbgfr+sGN+gEY79zPRzgNliHbuE4x27hc0ygda3VSudEOULPM/E+4J6s7xHw68/gcTHu3oennQg3K7svEHBW38oYTbeJSTki7tyEg6KQ97Gu3cKzbWtOc923mk1SHgR8Sjnfb0I4KN4NGERztah4+KRzvt6UcTHu3oju7h1mR3xo95Eu1I2vi/PI127pXbgbpsz3YeDzvmJ2i08zgT7TxRhmjnXsFo53FBo3yi1U3lSjdEyTL/O+GeoO4c/+XA638y4dGOrpcnPSi3Kxt/UtDG/5NwG49yUtKlHRlJJ+W/nkY7f5Mbawbz8LY5BKyFy0Y76UEtUwpjqi3Z0Y7WocYoG+0oA2hzO2hIdHT/bU12Z1zRJtsZm0O6zJI2XilY5nJGO38Ti3bSAwxcJ9FOVdgxV7cF+ZFNVdv4aEczuY52BEegTJWgUVa3ualc6YYoWeYa4c5HusHpzrGyTX5gmOJ44EqXdmR0vUzxoNyubHyKoI1PTbiNRzkp6dKOjKSTUitoN+WMdv4qNtZ05a1kq2tzCLhOPNrpGq4TbAT1CY92tA7rxaOdruH6hEc7uqOrbUt2Z9zgSbQjaeONnkY7f5V7b6dsK9mmhR1zE412pjHRTlMZop2/CkY70wSNsqnNTeVKN0TJMjcn3BPUnWOjA6+/JeHRjq6XFg/K7crGWwRtvDXhNh7lpKRLOzKSTkqbp9HOX8TGmkzenmzT2xwCni4e7WQy0wUbwT4Jj3a0DvcRj3YyeeVOl3hw5Zbo6Nrakt0Z7+tJtCNp4/t5Gu38RW4lW9n2ZJsRdsz702hnBhPt7F+GaOcvgtHODEGj3L/NTeVKN0TJMh+QcE9Qd477OfD6ZyY82tH1MtODcruy8ZmCNn5gwm08yklJl3ZkJJ2UgzyNdv4stxgj772dg9scAj64TV7uIQmPUHS5D2nLKVhIrpOoQncoB7Ulu9M71JOoQtIuD3Pc0UvUyWEObLycHeo9jjrUw9scAj7cQYd6RMI7VF3uI/Z2qGKyjvSkQ5W0y6MS3qHqOjnK8w717hY5fSDeo9scAj7aQWM9WtDYjkl456x1eIyD8P6YhM/H+9DRH+tJRy9p48clfIpE18lxDtrL8QmfBtT9xPGOnDhXdnm8oF2ekHC7jOrP0qUdGcn+7MSE27iu4xMdBGiSdmiwHR7+7nkNKtz0Yc9rUnBeCecVcJ6C8wDO/9uSO/8PnD8J5/+G8yfg/HE4/xecPwbnj8L5I3D+MJw/BOcPwvk/4fwBOL8fzv8B53+H8/vg/F44/xuc/xXO/wLnf4bze+D87pbc48k+GTtJy8obSBusxwHuY+H8GDg/Gs5PgvMT4fwEOD8ezjNwnobzU+D8ZDjvhPMsnHfAeTuc7w/nM+B8PzjfF84PgvMD4XwmnB8A54fB+aFwfgicHwznR8H5kXB+BJwfHp6bAe4k1QecrOgURWlFGUXtijoUZRV1KupS1K2oR1GvolMVnabodEVnKDpT0Vm6L1E0S9HZimYrmqNorqJ5iuYrWqDoHEULFS1StFjREkVLFZ2raJmi5YpWKFqpaJWi1YrWKFqr6DxF6xStV3S+ogsU6UB0WpA7UvC7X3i+QfFtVLRJ0WZF/YoGFA0qGlI0rGhE0RZFFyraqugiRRcr2qboEkXbFe1QdKmiyxTtVLSrLchfG6AzmkqubWSubWKubWau9TPXBphrg8y1IebaMHNthLm2hbl2IXNtK3PtIubaxcy1bcy1S5hr25lrO5hrlzLXLmOu7WSu7QqvaWNqCsqzUOa4wI2zKh5YCOLE2ZfdbaHCm/cqPA+npMLHQGpFT2VA6+PytgIMVxRiuLIQw1WFGK4uxHBNIYZrCzE8A6LEPYd0SHJdjZw7fZ1gWIc9nZZ7aAE9SEwHSmE/IQi8COlTgmU+0ZMyVwiW+SRPylwpWOaTy1TmdGlH5hRB/e1X6ccgnA78wJnxBGe7Jzg7PMGZDfzoOzoDub7jgepkP7qbqfq2e6vl67or8MMmuz3B2eMJzl5PcJ7qCc7TPMF5uic4z/AE55me4DzLE5x9nuCc5QnOsz3BOdsTnHM8wTnXE5zzPME53xOcCzzBeY4nOBd6gnORJzgXe4JziSc4l3qC81xPcC7zBOdyT3Cu8ATnSk9wrvIE52pPcK7xBOdaT3Ce5wnOdZ7gXO8JzvM9wXmBJzg3eIJzoyc4N3mCc7MnOPs9wTngCc5BT3AOeYJz2BOcI57g3OIJzgs9wbnVE5wXeYLzYk9wbvME5yWe4NzuCc4dnuC81BOcl3mCc6cnOHd5gnO3ME7pdZoba4JgpEa+3JcnvNybHJX7ioSXe7Ojcl8ZuGmPFcI4rxLU5dYaP8p8tUCZn9pBfSgzUuNHv3tN4AfOaz3B+QxPcF7nCc5neoLzWZ7gHPUE57M9wfkcT3A+1xOcz/ME5/M9wfkCT3C+0BOc13uC80We4HyxJzhf4gnOGzzB+VJPcL7ME5w3eoLz5Z7gfIUnOF/pCc6bPMH5Kk9wvtoTnK/xBOdrPcH5Ok9wvt4TnG/wBOfNnuC8xROcb/QE55s8wflmT3De6gnOt3iC862e4LzNE5xv8wTn2z3B+Q5PcL7TE5zv8gTnuz3BebsnON/jCc7/8wTnez3B+T5PcL7fE5x3eILzA57g/KAnOD/kCc4Pe4LzI57g/KgnOD/mCc47PcH5cU9wfsITnJ/0BOenPMH5aU9wfsYTnJ/1BOfnPMH5eU9wfsETnF/0BOeXHOGsEMb5ZZBV6vsxVzt6V6RSuMxfESzzzdPlZL1puh+2/dXAD5xf8wTn1z3B+Q1PcH7TE5zf8gTntz3B+R1PcN7lCc7veoLze57g/L4nOH/gCc4feoLzR57g/LEnOH/iCc6feoLzZ57g/LknOH/hCc5feoLzV57g/LUnOH/jCc7feoLzd57g/L0nOP/gCc4/CuOU3vtJf4/1Igd7P/3JUf1UCeO8W1iXUrLeIDhnfPP05NvgpQ5s8J7Ajz7iz57g/IsnOP/qCc6/eYLzXk9w3ucJzr97gvMfnuC83xOcD3iC85+e4HzQE5wPeYLzYU9wPuIJzkc9wfmYJzj/5QnOxz3B+YQnOP/tCc4nPcH5H09w/tcTnFqgDzhTnuCs8ARnpSc4qzzBWe0JzhpPcE7xBOdUT3DWeoKzzhOc9Z7gbPAEZ6MnOKd5grPJE5zNnuBs8QRnqyc42zzBOd0TnPt4gnNfT3Du5wnOGZ7g3N8TnAd4gnOmJzgP9ATnQZ7gPNgTnId4gvNQT3Ae5gnOwz3BeYQnOI/0BOdRnuA82hOcx3iC81hPcB7nCc7jPcF5gic4T/QE50me4DzZE5yneIIz7QnOjCc42z3B2eEJzqwnODs9wdnlCc5uT3D2eIKz1xOcp3qC8zRPcJ7uCc4zPMF5pic4z/IEZ58nOGd5gvNsT3DO9gTnHE9wzvUE5zxPcM73BOcCT3Ce4wnOhZ7gXOQJzsWe4FziCc6lnuA81xOcyzzBudwTnCs8wbnSE5yrPMG52hOcazzBudYTnOd5gnOdJzjXe4LzfE9wXuAJzg2e4NzoCc5NnuDc7AnOfk9wDniCc9ATnEOe4Bz2BOeIJzi3eILzQk9wbvUE50We4LzYE5zbPMF5iSc4t3uCc4cnOC/1BOdlnuDc6QnOXZ7g3O0Jzss9wXmFJziv9ATnVZ7gvNoTnNd4gvNaT3A+wxOc13mC85me4HyWJzhHPcH5bE9wPscTnM/1BOfzPMH5fE9wvsATnC/0BOf1nuB8kSc4X+wJzpd4gvMGT3C+1BOcL/ME542e4Hy5Jzhf4QnOV3qC8yZPcL7KE5yv9gTnazzB+VpPcL7OE5yv9wTnGzzBebMnOG/xBOcbPcH5Jk9wvtkTnLd6gvMtnuB8qyc4b/ME59s8wfl2T3C+wxOc73SEs0IY57sAZ0e6K5sd7m4fznRk+tPtvQM9nels50BXT6Yn09nTOdTe09Ex3JPt6e4d6O1O92ayHcOZkc7ejpFQ2O42P8r8bsEyP7vGTZkPFS7z7fn2mEmXcLymhuhvaML6y5zUNq4uMhOVdXIbU6/pick6pY21kfREZKV5WZnekeJlZdoibbenWFntbZZ20F2crA6brJ7sSDGysm0F2mc2vqzOtoJtvTOurK62GP1GOp6s7jiyMj3pOLJ64snKdHYXltUbV1ZP52AhWafGlzXU3m2XdVoxsno62m2yTi9OVsdwd7SsM4qV1ZPtjpJ1ZvGyerp7eFlnTUSWSuFk9U1MVm/XyHhZsyYoS+FKU1lnT1xWJtueL2t2KbI6htMoa05psjIj2ZysuaXK6uxtN7LmlS6rY/gpYZn5IrJGtLTMAiFZSlrmHAFZxrdbmC+rowRZmQCOQ8NfIztd2pF5T0quD+pqkeuDulvk+qCeFrk+qLdFrg86tUWuDzqtRa4POr1Frg86o0WuDzqzRa4POqtFrg/qa5Hrg2YJyDJ90Nktcn3Qoja5uG2xYNy2RDBuWyoYt50rGLctE4zblgvGbSsE47aVgnHbKsG4bbVg3LZGMG5bKxi3nScYt60TjNvWC8Zt5wvGbRc4mqs8NPwVkp35v5Rc/z+7Ra7/n9Mi1//PbZHr/+e1yPX/81vk+v8FLXL9/zktcv3/wha5/n9Ri1z/v7hFrv9f0iLX/y9tkev/z22R6/+Xtcj1/8tb5Pr/FS1y/f/KFrn+f1XxPnpkzLxaMGZeIxgzrxWMmc8TjJnXCcbM6wVj5vMFY+YLBGPmDYIx80bBmHmTYMy8WTBm7m/xw7d7r6BvNyDo2w0K+nZDgr7dsKBvNyLo220R9O0uFPTttgr6dhcJ+nYXC/p22wR9u0sEfbvtgr7dDkHf7lJB3+4yQd9up6Bvt0vQt9st6NtdLujbXSHo210p6NtdJejbXS3o210j6NtdK+jbPUPQt7tO0Ld7pqBv9yxB327UE9/ufYK+3bMFfbvnCPp2zxX07Z4n6Ns9X9C3e4Ggb/dCQd/uekHf7kWCvt2LBX27lwj6djcI+nYvFfTtXibo290o6Nu9XNC3e4Wgb/dKQd/uJkHf7lWCvt2rBX271wj6dq8V9O1eJ+jbvV7Qt3uDoG93s6Bvd4ugb/dGQd/uTYK+3Zs98e3eL+jb3Sro271F0Ld7q6Bvd5ugb/c2Qd/u7YK+3TsEfbt3Cvp27xL07d4t6NvdLujbvUfQt/s/Qd/uvYK+3fsEfbv3C/p2dwj6dh8Q9O0+KOjbfUjQt/uwoG/3EUHf7qOCvt3HBH27OwV9u48L+nafEPTtPino231K0Lf7tKBv9xlPfLs7BH27zwr6dp8T9O0+L+jbfUHQt/uioG/3JUHf7suCvt1XBH27rwr6dl8T9O2+LujbfUPQt/umoG/3LUHf7tuCvt13BH27uwR9u+8K+nbfE/Ttvi/o2/1A0Lf7oaBv9yNB3+7Hgr7dTwR9u58K+nY/E/Ttfi7o2/1C0Lf7paBv9ytPfLsPCPp2vxb07X4j6Nv9VtC3+52gb/d7Qd/uD4K+3R8Ffbs/Cfp2GwTfpdso+C7dJsF36TYLvkvXL/gu3YDgu3SDgu/SDQm+Szcs+C7diOAeKFsE90C5UHAPlK2Ce6BcJLgHysWCe6BsE9wD5RLBPVC2C+6BskNwD5RLBfdAuUxwD5Sdgnug7PJkT78PCu7pd7knZf6QYJmv8KTMHxYs85WelPkjgmW+ypMyf1SwzFd7UuaPCZb5Gk/KfKdgma/1pMwfFyzzM8pU5lJxfkVQf5/wZG/lTwrW83WO9hmW3vf6U57sz/1pT3B+xhOcn/UE5+c8wfl5T3B+wROcX/QE55c8wfllT3B+xROcX/UE59c8wfl1T3B+wxOc3/QE57c8wfltT3B+xxOcd3mC87ue4PyeJzi/7wnOH3iC84ee4PyRJzh/7AnOn3iC86ee4PyZJzh/7gnOX3iC85ee4PyVJzh/7QnO33iC87ee4PydJzh/7wnOP3iC84+e4PyTJzjv9gTnPZ7g/LMnOP/iCc6/eoLzb57gvNcTnPd5gvPvnuD8hyc47/cE5wOe4PynJzgf9ATnQ57gfNgTnI94gvNRT3A+5gnOf3mC83FPcD7hCc5/e4LzSU9w/scTnP/1BGdQ4QfOlCc4KzzBWekJzipPcFZ7grPGE5xTPME51ROctZ7grPMEZ70nOBs8wdnoCc5pnuBs8gRnsyc4WzzB2eoJzjZPcE73BOc+nuDc1xOc+3mCc4YnOPf3BOcBnuCc6QnOAz3BeZAnOA/2BOchnuA81BOch3mC83BPcB7hCc4jPcF5lCc4j/YE5zGe4DzWE5zHeYLzeE9wnuAJzhM9wXmSJzhP9gTnKZ7gTHuCM+MJznZPcHZ4gjPrCc5OT3B2eYKz2xOcPZ7g7PUE56me4DzNE5yne4LzDE9wnukJzrM8wdnnCc5ZnuA82xOcsz3BOccTnHM9wTnPE5zzPcG5wBOc53iCc6EnOBd5gnOxJziXeIJzqSc4z/UE5zJPcC73BOcKT3Cu9ATnKk9wrvYE5xpPcK71BOd5nuBc5wnO9Z7gPN8TnBd4gnODJzg3eoJzkyc4N3uCs98TnAOe4Bz0BOeQJziHPcE54gnOLZ7gvNATnFs9wXmRJzgv9gTnNk9wXuIJzu2e4NzhCc5LPcF5mSc4d3qCc5cnOHd7gvNyT3Be4QnOKz3BeZUnOK/2BOc1nuC81hOcz/AE53We4HymJzif5QnOUU9wPtsTnM/xBOdzPcH5PE9wPt8TnC/wBOcLPcF5vSc4X+QJzhd7gvMlnuC8wROcL/UE58s8wXmjJzhf7gnOV3iC85We4LzJE5yv8gTnqz3B+RpPcL7WE5yv8wTn6z3B+QZPcN7sCc5bPMH5Rk9wvskTnG/2BOetnuB8iyc43+oJzts8wfk2T3C+3ROc7/AE5zs9wfkuT3C+2xOct3uC8z2e4Pw/T3C+1xOc7/ME5/s9wXmHJzg/4AnOD3qC80Oe4PywJzg/4gnOj3qC82Oe4LzTE5wf9wTnJzzB+UlPcH7KE5yf9gTnZzzB+VlPcH7OE5yf9wTnFzzB+UVPcH7JE5xf9gTnVzzB+VVPcH7NE5xf9wTnNzzB+U1PcH7LE5zf9gTndzzBeZcnOL/rCc7veYLz+57g/IEnOH/oCc4feYLzx57g/IknOH/qCc6feYLz557g/IUnOH/pCc5feYLz157g/I0nOH/rCc7feYLz957g/IMnOP/oCc4/eYLzbk9w3uMJzj97gvMvnuD8qyOcFQRnR7ormx3ubh/OdGT60+29Az2d6WznQFdPpifT2dM51N7T0THck+3p7h3o7U73ZrIdw5mRzt6OkVD2MYJl/luZypwu7cjcWyGnv+va/KjnKkH93eeJbVcLlvnvnpS5RrDM//CkzFMEy3y/J2WeKljmBzwpc61gmf/pSZnrBMv8oCdlrhcs80OelLlBsMwPe1LmRsEyP+JJmacJlvlRT8rcJFjmxzwpc7Ngmf/lSZlbBMv8uCdlbhUs8xOelLlNsMz/9qTM0wXL/KQnZd5HsMz/8aTM+wqW+b+elHk/wTIHlX6UeYZgmVOelHl/wTJXeFLmAwTLXOlJmWcKlrnKkzIfKFjmak/KfJBgmWs8KfPBgmWe4kmZDxEs81RPynyoYJlrPSnzYYJlrvOkzIcLlrnekzIfIVjmBk/KfKRgmRs9KfNRgmWe5kmZjxYsc5NgmZWoPWt8/hQW+ARFJyo6SdHJik7ReSjKKGrXelCUVdSpqEtRt6IeRb2KTlV0mqLTFZ2h6ExFZ4XlnqXobEWzFc1RNFfRPEXzFS1QdI6ihYoWKVqsaImipYrOVbRM0XJFKxStVLRK0WpFaxStVXSeonWK1is6X9EFijYo2qhok6LNivoVDSgaVDSkaFjRiKItii5UtFXRRYouVrRN0SWKtivaoehSRZcp2qlol6Ldii5XdIWiKxVdpehqRdcoulbRMxRdp+iZip6laFTRsxU9R9FzFT1P0fMVvUDRCxVdr+hFil6s6CWKblD0UkUvU3SjopcreoWiVyq6SdGrFL1a0WsUvVbR6xS9XtEbFN2s6BZFb1T0JkVvVnSrorcoequi2xS9TdHbFb1D0TsVvUvRuxXdrug9iv5P0XsVvU/R+xXdoegDij6o6EOKPqzoI4o+quhjiu5U9HFFn1D0SUWfUvRpRZ9R9FlFn1P0eUVfUPRFRV9S9GVFX1H0VUVfU/R1Rd9Q9E1F31L0bUXfUXSXou8q+p6i7yv6gaIfKvqRoh8r+ominyr6maKfK/qFol8q+pWiXyv6jaLfKvqdot8r+oOiPyr6k6K7Fd2j6M+K/qLor4r+puheRfcp+ruifyi6X9EDiv6p6EFFDyl6WNEjih5V9Jiifyl6XNETiv6t6ElF/1H0X0W6gaUUVSiqVFSlqFpRjaIpiqYqqlVUp6heUYOiRkXTFDUpalbUoqhVUZui6Yr2UbSvov0UzVC0v6IDFM1UdKCigxQdrOgQRYcqOkzR4YqOUHSkoqMUHa3oGEXHKjpO0fGKTlB0oqKTFJ2s6BRFaUUZRe2KOhRlFXUq6lLUrahHUa+iUxWdpuh0RWcoOlPRWYr6FM1SdLai2YrmKJqraJ6i+YoWKDpH0UJFixQtVrRE0VJF5ypapmi5ohWKVipapWi1ojWK1io6T9E6ResVna/oAkUbFG1UtEnRZkX9igYUDSoaUjSsaETRFkUXKtqq6CJFFyvapugSRdsV7VB0qaLLFO1UtEvRbkWXK7pC0ZWKrlJ0taJrFF2r6BmKrlP0TEXPUjSq6NmKnqPouYqep+j5il6g6IWKrlf0IkUvVvQSRTcoeqmilym6UdHLFb1C0SsV3aToVYpereg1il6r6HWKXq/oDYpuVnSLojcqepOiNyu6VdFbFL1V0W2K3qbo7Yreoeidit6l6N2Kblf0HkX/p+i9it6n6P2K7lD0AUUfVPQhRR9W9BFFH1X0MUV3Kvq4ok8o+qSiTyn6tKLPKPqsos8p+ryiLyj6oqIvKfqyoq8o+qqiryn6uqJvKPqmom8p+rai7yi6S9F3FX1P0fcV/UDRDxX9SNGPFf1E0U8V/UzRzxX9QtEvFf1K0a8V/UbRbxX9TtHvFf1B0R8V/UnR3YruUfRnRX9R9FdFf1N0r6L7FP1d0T8U3a/oAUX/VPSgoocUPazoEUWPKnpM0b8UPa7oCUX/VvSkov8o+q8i7UykFFUoqlRUpahaUY2iKYqmKqpVVKeoXlGDokZF0xQ1KWpW1KKoVVGboumK9lG0r6L9FM1QtL+iAxTNVHSgooMUHazoEEWHKjpM0eGKjlB0pKKjFB2t6BhFxyo6TtHxik5QdKKikxSdrOgURWlFGUXtijoUZRV1KupS1K2oR1GvolMVnabodEVnKDpT0VmK+hTNUnS2otmK5iiaq2ieovmKFig6R9FCRYsULVa0RNFSRecqWqZouaIVilYqWqVotaI1itYqOk/ROkXrFZ2v6AJFGxRtVLRJ0WZF/YoGFA0qGlI0rGhE0RZFFyraqugiRRcr2qZIf69efwtef2ddf8Ncfx9cf3tbf9dafzNaf49Zf+tYf0dYf6NXf/9Wf1tWf7dVfxNVf29Uf8tTfydzVJH+vqP+dqL+LqH+5p/+np7+Vp3+Dpz+xpr+fpn+Npj+7pb+ppX+XpT+FpP+zpH+hpD+Po/+9o3+roz+Zov+Hor+1oj+jof+Rob+/oT+toP+boL+JoHe71/vpa/3qb9Vkd5fXe9drvcF13tu6/2s9V7Reh9mvcex3j9Y782r973Ve8rq/Vr1Xqh6n1G9h6feH1PvPan3ddR7Jur9CPVef3ofPb1Hnd7/Te+tpvct03uC6f229F5Wep+ozynS+xvpvYP0vjx6zxu9n4zeq0Xvg6L3GNH7d+i9MfS+E3pPB71fgt6LQL/nr9+h1++n63e/9XvV+p1l/T6wftdWv8eq3xHV71/qdxv1e4P6nTz9vpt+l0y/p/VbRfr9Iv3ujn4vRr9zov1d/a6Efg9Br/HX6+f12nS9Vluvg9ZrefXaVr3WU6991GsB9do4vVZMr53Sa4n02hq91kSvvdBrEfSzef2sWj+71c8y9bM9/axLP/vRz0L0swE9V67njvVcqp5b1HNteu5Jz8XouQkdq+vYVcdyOrbRvn7FUy5EoNcq6+OEIHeE3YvOYk+6Xtur17rqtZ96LaReG6jXyum1Y3otlV5bpNfa6LUnei2GXpugn9XrZ9f6Wa5+tqmf9elnX/pZkH42op8V6LlzPZes51b1XKOeeztU0WGKDlekY3cdy+rYTsc6ev38sYqOU3R8MP7Q47Q5poe/+/xx1v6XfeOdc5FvZvj7xtYrRo/Zrms2dwxa7rvIknaZJe0qS9qzLGkvsKS91JL2KkvazZa0t1rS3m1Ju8OS9jFL2mcsaZ8Pf3/0lRtu+M4/V92KaV8Ifw+uvGvWMwc+sRTTvhn+3nj41PS7bzv6x5j2i/B3zr8vnvujra95M6b90pL2K0vary1pv7Gk/daS9jtL2u8taX8Ifz925e//NWP3CRdi2h8taX+ypN1tSbvHkvZnS9r94S9XR+blIK58KUtahSWt0pJWZUmrtqQ1hGk/+cLvd64d+O0rMW1aKrrsTZa0ZktaiyWt1ZLWZkk7MEzj6uFES9lPsqSdbEk7xZKWtqRlLGmnW+rhLEvZ+yxpsyxpZ1vSZlvS5ljSlljqYYOl7BstaZssaZstaf2WtAFL2iWWerjUUvbLLGk7LWm7LGm7LWmXW9KeaamHl1nKfqMl7eWWtFdY0l5pSbvJkvYmSz28xVL2t1rSbrOkvc2S9nZL2jssae+31MNnLWX/nCXt85a0L1jSvmhJ+5Il7S5LPXzfUvYfWNJ+aEn7kSXtx5a0n1jSfmuph/stZX/AkvZPS9qDlrSHLGkPW9LMQxeuHiorosteZUmrtqTVWNKmWNKmWtJawjSuHg6riC774Za0IyxpR1rSjrKkHW1Jy1jqIWspe6clrcuS1m1J67Gk9VrSzrbUwwpL2Vda0lZZ0lZb0tZY0tZa0gYs9TBsKfuIJW2LJe1CS9pWS9pFlrRdlnp4rqXsz7OkPd+S9gJL2gstaddb0m6y1MNrLGV/rSXtdZa011vS3mBJu9mS9jZLPXzYUvaPWNI+akn7mCXtTkvaxy1pX7LUw1ctZf+aJe3rlrRvWNK+aUn7liXtR5Z6+JOl7Hdb0u6xpP3ZkvYXS9pfLWkPW+rhMUvZ/2VJe9yS9oQl7d+WtCdtY3/lU79cPexbGV32/SxpMyxp+1vSDrCkzbSkHR2mcfVwXGV02Y+3pJ1gSTvRknaSJe1kS1q3pR7mW8q+wJJ2jiVtoSVtkSVtsSVtraUe1lvKfr4l7QJL2gZL2kZL2iZL2oWWerjKUvarLWnXWNKutaQ9w5J2nSXteks9vMRS9hssaS+1pL3MknajJe3llrTXW+rh3Zay325Je48l7f8sae+1pL3PkvYxSz3caSn7xy1pn7CkfdKS9ilL2qctaZ8J06646eAX/6lrYd5zi8+GaX/YZ/nNz6w/9j+Y9t0wjXtO8kiY9uZ3H/yRmX+sWI9pj1nSzIM/Lq3CknZ0mLblmj81rLvtyzsx7ZQw7S0z+m+9+z+/rse0nqroMpwWpt30iu8uu+Xac/6GaXMt9y234FxpSVtrSVtnSeu3pA1a0i60pF1kSdtuSbvUknaVJe0aS9ozLGnPtKQ915L2fEvaj6ZEp/3EkvZbS9rvLWl/tKTdbUn7myXtPkvaPyxpD1jSHrakPWpJ+68lLTU1Oq3GkjbVknZc01O/Lzjin613vPt1R+WVodlSBkvaE5a0Jy1p1S3RaVMsaQ2WtGmWtFZL2nRL2oGWtIMtaYda0g63pB1jSTvOknZCmMb1u1da0q4O0775qru+8q7r+4cw7VrLfddZ7nuW5b7nWNKeZ5H5Ast911vue7Hlvpda0m60yHyF5b6bLPe92nLf6yxpb7DIvMVy35ss991que82S9rbLTLfabnv3Zb73mO5732WtDssMj9oue/Dlvs+arnv45a0T1pkftpy32ct933ect+XLGlfscj8muW+b1ju+5blvocs9+0/nb/PrPd6ZeNTv7Xhf7O4Sz8i0u5wX/g/XdqRqQW50vJ70l39tUH+IYy/oxZkOpDfbuRXuZGfDl2d4MLRfPkBybcx/A9LA8fuMWm4AHBrmDY1TDfnHeF5LZHnot4Rk7Te2hj8FVA2fcwedZF3Jm3kzwnlB2Kys0NG9lwn2J+yZ33McyN/rD+ZX7puMvSCkb2gdNnpKNnnONFLZkzvC53If6of1MciN/KzRv5iN/JHjPwlTuRnx+p3qRv8w0b+uSA/COTtc5kb/GPyl7vBP9YvrAjlu5C90o1uOo38VSA/JSa/fUz3q53I7xrTzxo38sf6nrVu5I/1Pee5kT9Wv+vcyO8y8te7kd9t5J/vRn6vkX+BG/mDRv4GN/LHfKqNbuSP9f2b3MgfGxs3O5HfPdb/9LuRP+b7DLiRP9b/DLqRP9b/DLmRP9Y/DLuRP9Z+R9zIHzDyt7iRP6QfwOnY1bzDw8X8cvl1pk08bWJvkwfmXQ3XBeOE/hTJLyDlDEj+dYHT+YlMiuRn8FD9mNjb6K6GwdrMpNE6rGHyqWHyaWbSqH9Qiqx+QVnrBGVtEpQlWcYNgrLOF5S1UVDWekFZqwRlSZZR0r4GBWVJtm1J3a8VlCVp9wOCstYIypK0ryFBWUkdO4xP6NbveGr+R8uc4kZ+h00XWCaTfyNgCCCd+w0C3kcyedUF430NFz4SVzbEH1XPVAel2AzKqmXSXNRptaXcNP8ofs6XNPxTLfKRvykYb8NTiS5q3eii3VZvUyFPk38DXB8aHrh8y+IdWwJyUN/Y6G1/wmfmhCuC8fqeEiErIP/3J9cqQR4eDVCGXVdvH1y6Y/fwrqDAYWvMbh+wZnrjdhYm/3J1FlUET5RRG91VM1ibg/ENigb5XGOrZvLhZG0RlLVKUNZmQVnnCcraKChrraCs8wVlSZZxvaCspNrXakFZ/YKyBgVlSdqXpL4uEJQlaV+SbWiToCxJm5DsV00w6zgI6qKTl3iYNHQuUyQNHdU5ozk+elSS/1gmLeNekEv5KB70m9DZi/IZ9OE4MMjUEn0Iyx8LPKYE+TqlZZoaoSuTzv0aWTTN5FWuCXeubFyQ1ByMt0sacHGyphQpazInCDgbb7Rg5cpBA2xb0Io6MfxTLbiQ/38lCJ1B+MyCwlKC0BnkWlQQWurkkMGpj2ZGlgmoaWyqj77wN13KkekcoGOZoOxBx/17N217eNCxEHVr0tD+6RhaB7LmjOan1cN9dGF0g0Vmo0XmNAvOJovMZkijsXoLpGG/Qw/ODzB1pvU3NZWTS/nMoXVi9Fk1GuSVpS+8ni7h6O5Jmz0Ng8pQfnUwHjvmX034zZuwdQS/qce+CeIc6e7PjHT0j/R39g8NZQf7W4l8fVSAnnARAefrmfscj3XtE/U5XPlrcfwp1GVDkGuL23b0D83uv3TX5dvMtktjEOmQi+pEcbTYtKmMmR+5RoeQCnKfGZI4U8X7KkOsiPmx8FcX/+HwnBt2zHpfzsU069S1jP8Q3IjVpmqbu4IyzJDVFOTrBu/l8C+PwI8yEH81kWH2q60Jcjdw76qgLqoi+DB/5OOeKeA9lcF4ndByVjL3UV7aRRhd1jP5mi6ikcjoC/+nSzuG6fCEBzc80SGomeAKgiD2EITvCxUTiuIQTIdOc78ZOqheGyAd+fcB+/ppTX5+rQyeOF2rPqj7h0MHbS9tgvm0AU8NyWe6YD7TgYeGTPsI5rMP8NBwe1/BfPYFHuPumPa5H6SZspr2uT+kCT5W6jdlPCAYf5i0mZA3takDIQ2HdXpw7dOUqdj2OQPSEBvKxPaJep0B6chvfEON5cCG/PxpOIfjm3kPpDIYX0/7BePLsl/Ay8Z7a5k0wTrPcnVOx4OZbvLujNNuMP86glV4fBpzGWcSPFQ/RbqMaAYofjoRZ3iQF4/pAAn5q8n/KLOK4zLWBuObiaCKh9yac7rfrcmmu438A93IH5tBOciN/B4j/2A38sdmaQ5xI7/XyD/UjfwuOhRsAFfNfCagkfAYHPow+Nx0UZl03C7T5F8XuHQZcl3mAQQP1U8F0c9hbvCMpIh8xHMYox9Tl4czaUbWEeF/dCOQ/zAoI/Ljubkfr60IK6yZyNSHCS1TTFolc83oV9vp4lBuE1MeOhZx9cYNdc3M/VSHuKccnUJoYMrGzWTStGmWtCamXDRU1Mcycl8LI1PrzXwWwGZDnG5sdXQYg6MpGK/Lw2PIsuV9BMOPMuaRvLEtHBFDli3vIxl+lDF3ND9vLOuRMWTZ8j6K4UcZC0neWNajYsiy5X00w48yFpG8saxHx5Bly/sYhh9lrCR5Y1mPiSHLlvexDD/KPDTIzxvLemwMWba8j2P4UeZMkjfiOi6GLFvexzP8KPMgkjfiOj6GLFveJzD8KPMQkjfiOiGGLFveJzL8KHMGyRtxnRhDli3vkxh+lHkgyRtxnRRDli3vkxl+lHkwyRtxnRxDli3vUxh+lLkfyRtxnRJDli3vNMOPMsx2I00MrnQMWba8Mww/ylhM8sayZmLIsuXdzvCjjNkkbyyrubeWwSLo/4/52x1Fli3L8HcAj8HbRMqD9zYG43WSIuXucFPu2HGPyb8ucFkPaWs9oH7oI4wsg7WZSaM+GVd/WSYfTtaRgrKOEpR1tKCsYwRlHSso6zhBWccLyjpBUNaJgrJOEpR1sqCsUwRlpQVltRNZ0vGT2TrOFj/R2IfyVTKyo/LG+44kMrg4io75RxYoD9VlhsmvNiL/vvB/uqQjM7YqVDLmQ7y2mI+bE6I6LHZOCO+3zQnRZRn4aJ3O3+AShMNIGq5uO5ykNTHl4pYPHEHScHWb0RvOCVWT8pjPRLp9JJtO09VfnK7KPw+dHk6R/IJgcueh6Twup4sjnOSdzcTVxRFEF4c70oWtb+fm5G39ETfHjI89twzvXrxjy9lXr+rfggvtsKlQOI2Ejz55PiwCVh/hO4L8N90fxYGy8KA4Ksl/yt9XgB/PG5jr+mgKoru+FEkLglw14DXblLzhq2XySQVSJtbdaeQf5UR+tsvIP9qJ/PYO2p1vDpWqu/w/hZXGDWG0S3GzUq49dvdq8q8Lxrc5F11KI8FD9UPD3WkM1mYmjdrRNCafaUw+zUwafXlworK49lMKro1CuPSxVlDWKkFZkmWUqsdAuIxrBGVJlnGDoKzNgrIuEJR1nqCsQUFZ5wvKkrQJyfYo2YYkbUJSX+sFZQ0IypLU/TpBWZK67xeUJakvyb5wtaAsSX0ltS+U1Jdkn/O/4DNJ2oTkuC2le31O48tScI2MysnaEsri5gvohhgYg+I8gYlRcUpUMiY08lvcyB+bJm9m9IhlMvlzSwZTEb9GFk0zedUF423FRTzNlc1mIziFTd9G42Q1FymrlklzUadNlnJj/o0WrFw5GolO4s5XGP4WCy7kb2LyNvcaHeLUvaAO2206xLZo8p/IhhhGbycRPrOMtCIYb4PNEbIC8v8kcq0y4DfEMPz1BCft5wwmir2G4Ud59K3MjWHlal0dEt7AbbpSD/K/Fr7+ZeqcLh3oC/+nSzqyHaYdHEf0g3nj8gDBucjYu/eb/OsIVld9p205pj7oXOQJDNZmJo3WIbdc8gQmn2YmjfpjpcjaIChrs6CsCwRlnScoa1BQ1vmCsiRtYqOgrFWCsiRtQlJf6wVlSeprnaAsKX3RcTNJtrpWUNbTvR710S8oS1JfkuPQakFZkvpK6jgkqS/J/l7SviT7HMn2KGkTkj6TlO71OZ1bKwXXiBAufdC5NcRJ59aOZcqjD7cxV25u7UQ38jtseuRe32pkdJCK+DWyaJrJqy4Yr3cX8SFXNsRvs1261L6UdmBk1TJpLur0eEu5Mf9S42Lu1U0u/jb8J1pwIT/3Kp+51+gQXxNwMbfG6RDbosl/InNrRm/HET46t4Y2eEKErID8p/NDUXNrdP3b90Llc+vuBPXLLmc2eXE709G1kfVQBtt8Lrc2sj5CFm78iV8iPyDgdfUTmCc8vCFfJreE1rbklmtDKINuGYBlwHvxvmqGdypJM7y/grIcFZYlzrpHR/YxGHcsMfmXa90jV6+c3XHzwIJ4Bmx2w/kqdN6Y1h32M7i9CfIfC2Wk/RL2k9Xk2t9CpTQH4/smur0J9yo+N5bsWZ9bkV+2ifokKLc5GK8bU78mH3z9xrRLjef+ivyy0H4F79XnB0I68lc15GQ+GMrktjGI2joiBfnhmvq5o/n8pj7N8xHKQ/s9w/8Y9BXHkn7vAKbMB1owG5m4MytiPneUx/AkGaccPWNgxymTF/cKFX39tNhXqI5h9BBnZz43/Uwm9istJv9y7cwXd7sQt/bx1OvohfotxGvq8ngmzcgyPh62IeQ/DsqI/Hhu7sdr08KKaw7G99m0H+b8XryG/fDUUC633QndQss2XqHcZuZ+qkPq93C/Jh96jebDYba1u4nmg7LQx8R6RT90NvDgGgOsD+w70Q5p32n4Z4bCdf99gsXXw7HtoEo7VrwXsVYT/nvqczIPJXaDawhMfXD1Q9d9HMDkmyK8QTB+LQw3HhmcNRH8TRHlOgZ0eggZE1EXXL02RWCoYsqlD1qvhv+ECdTrSZV2rLReaWxh+L8B9Zom9Yr6s9VrM0nDejU64sZcWufFjrl4/wGWfPYhaWg7Zgdn2+7QZizCMV5uLBqMPVab/OsIVldjNfe6OuqnPDHTYDrOGIR4HfuWHdy8G/UfzVwTtkduLq6C8OO5uR+vLQ4Ng/NHjHxJP6HcsmzztLSfn0V0gfaaivg1cuk1mz9P+wgX/os+6FzRcQwGOtaYfOg1mg/eb/i4dqKpL/yfLunoSHPPWATlZ7j5eEH57dwzHDn52bEtD+h6Sqybk+G6XB/W2RV3zDH51xGsrsackwkeqh+6JvAUBmszk0brkNtS7xQmn2YmjT77TYqs8wRlbRCUtVlQlqS+zheUtVFQ1npBWasEZUmWcZOgrKS2IUndrxWUJWn3A4Ky1gjKkrSvIUFZkvbVLyhrWFCWpN1L1qNk/yVZxhEhWfqc+vKl4NoihEsfkvqS9Cf+F8YhSbtPqv+1WlDWBYKy9vpfk2f3kr7J3jGtOFlJ9eWS2hdK+nKSfaFkPUrqK6n+F53rfDr6X+sEZUm2bck2JKkvyXFIsg0lVfeS/ZfkXFpS54Yk7UvS902qj5nUsYM+x5IYO7hnqEcAn9vnTOkOIz/tSL5NV1gmk795boTP2FMRv0YWTTN51RFZwmXL2MqG+G02hToo1T6NrFomzUWdnmwpN+Zf7LNAqXamzw8QlEX3PuLWQnDPQg1/muHn7KSJydvc6/bzV7n3s7i6xT7C5D+R97OM3lYTvoWjOT3QtnFKhKyA/F9NrlUG/PtZTcF4W2uOwGnypdds691OsOSzb4n57BszH5/LQ2WbdVa4V5hZm+R2nUlXj9t1Jp0j3DuXgvjbOR9CTn62kxtv5OR393A+iqB+BuJ8dg8/AyXX33Z1xPVpTP7l+uxeoU810nU+HQzWZiaN2iD3eb8OJh9O1ilCsvRBn1mVIus8QVlrBGUNCsqSLONaQVmrBGVJ2sRqQVlSNsH1qXttwi5ro6CsTYKyktq2JXUvqa91grIky3iBoCzJepS0+/WCsqTsXp/T+CEpNjEiKEvKJvT5Xv9rcmw1CJI51upzGiPv7QvtsrYIypLqc/Q5nYsoRVaDkCx9SLYhyT5ackxLql+Y1DEtibGVPiR9E8k2JKkvqT5679jx9Bg79CEZW0n2hf2CsvbOKUxeG5LUvWQZhwVlJTUektT9+YKy1grKSqqfs7efmDx/Ym8/MXm6T2o/Qf0vbs1MMyPL8NvWxOmD7jeCMfkpMWTZ8k4z/Chj3mh+3txaPZssW97cs2WUMXc0P28sq7m3lrmvL/xNl3R0ZBsZnCmSL9q64PP34RTJz+gIr2H+dQSrMJ6MrZ2gfiqIfrJu8AyliHzEk2X0Y+qyk0kzsrrC/7gXFPJnoYzIj+fmfry2T/VTv82MTNqGOpny4DWjX72vUlMot4g20D44kunoHO7uTHf1ZzuHujrah9q700PZzpFMpifT3pvt6egYGcz2DPW0d4y0d7cP0nUdBivm66iOs3HbgMm/LnDaJjM2m+PGCs7mzL3UFvSxYjTHV4wtSNoVh8vsh+iwr+1sDMbrltoZlk+wXtvj2pnJvy5wavcZW52hfqiddTFYm5m0NLkP67M8Ou8YmKjO007w2HWeFtD5UXBOx4tK5lpFhCx90HnbUmSdLyjrAkFZ5wnKWisoa5WgrEFBWZsEZUmWcY2gLMkybhCUtVlIlj6nz3eSYl+S7VHSviT7QklcGwVlSdr9090m9Dldv5UU+xoQkiVdRkm7XycoS9Lu+wVl7e0nnh5jh2QZhwVlSfkT+kiq7kcEZe1tQ8WNHfSZzN425KfuJWN3yRjZPA8zc0gNkNYX/qaLO4boBSP7qNJl06ODvkdcguyOdATuE+Vxt9M5O0HZ2VqmnoVkjxT6hs7t4XMOY5vdIU/UN3SOgHTkr5qSk/le8uyExt19ImXLjj1DxPfVU0F+3vvCdbk5zfZ0iuQXBPwcq8m/jmCVxZObY92X4KH6oXOs+zFYm5k0Wof7Mfnsx+TTzKTRvrUUWQOCstYIytokKGtIUNZ5grL6E4prraCsVYKyVicU16CgLEm7l8QlqfsLBGVJ1qOk7tcJypIs44iQLH1O94kvBdcWIVz6kNTXRkFZSW3bkmOH8SfMujj0H8330JqC8bZ0LMlvBqShfOOXzoR0ST/QyD/IjfyxfekODMbrGMtk8i/1O7SYV7m+z8yVzfYNTvxGOOogStaBRcqqZdJc1OlMS7kx/0YLVq4cM4hOuHy4GMXwH2zBhfymXaLtm3uNDg+BNOl1TlH1fTDkafKfyJ5+Rm+HEL55ozk9UN0fFCErIP8PIdcqQR4eRscYx+5LZE0jZYiq32bmfsMXJ7Z30w+098ftl0z+5YrtD4ipV6O7mQzWZiaNxvZc+5zJ5NPMpNHYvhRZA4Ky1gjK2iQoa0hQ1nmCsvoTimutoKxVgrJGhGTpcxqXlIJrixAufUjqa6OgLMn2OCgoS9LuJftCyXpcJyhLsh4l+y9JfW0WlLVaUJakviTbkKQ/IamvCwRl7e1XJ69fTaoPQL+hJOEDmNgN/f3pQX4axlT7kLR9IK2BYGlg7tOH4/mu9qTOd6EOUhG/RhZNo/Nd+7gpm3W+C/H/L813oa6l5rtK0QmNzRsYWba5s7h12xSMr09zr+M2NjZ3NiOI1hPmP5G5M6O34wjf3NGcHmjdzYyQFZD/x5FrhebOsE6bI3CafOk1ait4f4Mln/1LzGf/mPn4XJ5Ca6VeXMPnGbVWaj9IR/6f1eRkvrQmv4x4f2sQRJa/jaThd3PomI7zkobPtOkmSJNr05m00aWpTzxMWgvkXU/SWiENy02PSvIfy6T7iHtBLuWjeFCHiA1lYl1zeq0m/LfU5LCc3MDLTIFMxGnm9Q2/0WVNkCs38lAMhv9WwHBsAy+zKqJcTREyPwY2fFsNLzMI+DGKlquFlItiaCYYDP87oVyHQGNHHvMf+4IVo/nYWpm8gohr1DZaI9KKzRf1Y661xcg3xaRRW6L6xPujdE5tyfB/wGJLjQwG1Aet92kEA+VpIRgM/0cYDPrH9CGDOy69enb/pbsu3zYckKMKzmlXz1U1rYJGRk7UYdSg0ZrmQuWY/zYz4ZpjEHEtqtob4PrQ8Lbh3cMRCqogwuojMqsI+IP2peY+fbgdc+LvNWHyrwt4u+2TwZOh/bzBQ/VDn9s1M1g5/8hUrm2cp20NMdieydr6jmkxy9MQ5Ax71+4dO6NsDsdwzuYaIvJPMfcH5N4Uc00fuj1+LWyUtSRfYTsY2+engcHI+R4pkoblpbZC2xKmoa1UkTQcL6pJGo4tNSStDdKmkLTpkDaVpGFcXUvS8Pl/HZzTg/P1TJ3p/KamcnIpnzl0eX4aFkrf+3SLYaisimB8bKIP8x1IY/tu5pgG0waPiaurA/ucYTXh/yOM9Rnib+zD6GtfRl8UA/Jzc5pcf0rndLi8sa6MH+N2/jOn3wNBf1zZZkI68t9r0S83P2bTb6E5UjqfjDo9kMgqpN+5o0/9Jl2/D02ifrF9HUjSEDvt7zjd2+aDmy0YMJ/9S8xnfyYfm6xmRhbGCcoR3nrF8M6lO3aPbQlpRKJaA3JeS67Rpa3U9Z0WAZXGGtSPn0H+N5D/h5H/LQw+7jA48KBYKoPChzH1MV2F/oA29SwxdW5ow+HIdJd0Cg7vxSk4Y149wEfNuIfJE6/ZzNjwcfnQZeC9zH0pkoYYei0Y8H7DZ7q4UyFNrovLjnVxp4XyoqYzT4V05G+CeqddnLkHy384U36KAfmx3AYPp3tzbyOTdyri1+RDr9F6QQxHlimfo8PzJiaN2jqn51Mt+eD9p5apPM1lyqepTPk0likfuiT6NMF8TgMeM44Zezsd0mi/djrJh16z9Wunk/L0CJaH66cbGXyl5oO6oa/+nAFpOMYZHGcyOEwffxZcl37kjfkZvFQHJv86glUYz9jU2FkED9UPne7oY7A2M2lHwjmmYT59TD6crDMIhjPgvjLVX/tE6+8MN3is9XcGo9di6+9Eotc+J+XIZgyuWcH4w6SdDXlTW5gNadhW6MFNXfWF59pv6m7IyaV8FA/amMHWFIyvb+Sj9WKrq2bmfsNXG4zXiWB9dFC9Bkz550DeuFUfPTidG9xa50uL0DnqdQ5Jw3qfS9L6IG0eSZsFafPD86Yg2uZSJM2UkV6j9Yj3n00w4H2ljokcZs4uzyTlKdYuz2TysfXNEy0Ph9k2hk80HyxPH8mnTzCfPuCZRfLphvtwycslU3L34H0YI+K9Zlq5mvB/qD4n89JQpulLsD0L9iVj297PDcYfJm0e5E3bxnxIo3a2ANKobZwDaX1wTg+ufzK60P3TjiL6JxyHaD9j81cc+Xex/RWTf7n8lTMJnqi+huu/zb1ce+ok99l8/D43ZYytc5NfuXz8PoKH6ofq/GwGKzfGmO3pTF9jps5fBluRvXhKvmzsq8ynN6hfpY8FJG0Wk6bl71eXw4P4cDkVzuvS/tHwv6ssfWJXN9cnUvuc5yjvuPZJ+y/EY3DXMWlVJWAdGexJd6S7uoaGu7IDndmRFJFvsNJrdP5yPsOfYfiNrhe40XW7GTMqR3Py54Ne9VEFafNIWjWkGYx6THpRQz7++Y7wx9E/5t/M8C+EMhRTly5lYX8gIWvaBGW1BvntCfucpPllJ5E0tLmTSRq2p1NIGvpluNyGHoX8slcV4ZfheGXKZPSLuhfUbxfVYcDgQh1S/aIOqX5Rh1S/CyGtWP0aXRSrX7TR+SSt/GNc/HlWk39d4NIWcj4Y1y+gfqgPNp/B2syk4euCmIb5zGfy4WSZumwKxtctnQOZw+Qzx5IPN3/j1hay3VSXeHBtjcaY2NbQPujBtSdTpmLnFlHnBltTED1WpILxtmSzr2bmfsNn6gPLLVgf/bSfCpjyL4K8i51bNLiLnVtEvS4iaWibi0katp0lJA3taml43hTY7QrTTBnpNVqPeP85BAPel4r4NfnQazQfDjNnl/NIeYq1Sy7WsI0nEy0Ph5kbt0vNh/OVuX6p1HzQFheQfPrgPpxbfIDMLZr7cG4R76Wxs+G/BeYWHyJxtJv4qvi+hLaNxZBG7WwJpFHbWAppqHN6cP0TxnE7Jjgm0P5pr4/l3seaDee03Ur6WPS5TLE+1plMPknzsWxz9Xt9rL0+1l4fK9jrYxWZT5J9rI6puXvwvmJ9rOeDj9UVytzrY+UfqAvPfazhODaK+SfNx9KqN9subxnevezygW1bBxcNX71r1vahZf07d2/t3zZraGjn8K5dWBpqDbS01Aq4WU59fjJzXR9NQXQPaCuh7WmArWfmPEVOW7R3QH6UYXoWrhwLYsiy5c2NiihjHskbW+Y5MWTZ8l7I8KOMuaP5eWNZF5L7cBYc+TjZNG8bHhv+RQw/ylhowb8ohixb3osZfpSxaDQ/b9TP4hiybHkvYfhRxsrR/LyxrEvIfTgiIB8nOyrvRRFlQ8xLg+LKeC7DjyPUoUF+GbEc58aQZct7GcOPMmeSvBHXshiybHkvZ/hR5kEkb8S1nNy3HNKQL0o25m3DY8O/guFHHIdY8K+IIcuW90qGH2XOIHkjrpUxZNnyXsXwo0z6IiriWkXuWwVpyBclG/O24bHhX83wI46DLfjNvXE8N5Qp6CkNpUh+phx4DfMvl+cWtx4aiS7x3mYmjfo8XP2tZvLhZM0XlHWOoKwFgrIWCspaLChriaCspYKylgnKOldQ1nJBWaYPNX0a1ms7yYfz0RZb8sH76ewa3peK+DX50Gs0Hw5zodmRN5HZEWOD3OwI9v3VhH87zI68JZTJzZwZjJyeaRxYrJ65fMxYgzYs17d3jr2tgz6COUwajnO4IQU9uNkUg7vY2V7U6yqShv0MHa+x31hD0rDtrg3Pm4Lx+qV9Iuf34jWbHS8jGPC+UtsLh5mzS9ovF2uXS5h8XLd/OlO/RDAfLM9Sks9SwXzQFs8l+fTBfdiffZH0Z+a+qP6MblBr+NdCf/YVMtuL7WAy+xLaNji/xKStgTRqG2shDXVOD65/MroodrYX+2raP3FtojYYb3uT8UTd5F8XjG9zLmKGQvM7NGZYymDl2hMda7k5maVMPpysFQSDLeZzVH/tE60/1zEfV3+2mC9u/XURvS51Uo7sCB378aBjMpbNpKGPTucDA6IbPLBMxa4uQBsz2DhflI7rxT7Fxfvp6gJH/maG6jVgyo/zMcWuLpiov4l6pf0B1vtKkoZ2S8cBHGfN2Mb5m7QvK9bfxPvL5W/aVhdQ/7lYu7Q99XW1uqBcfm3S/M3a2tw9eF/c1QWGvw/8zYZQpulLsD0n1d+kdob+JrWNUvxNo4ti/U0ch0yZ3I6dne20Pw4YXDh3v5zBb9MFjo9/mWBfTftjbt6Ae7bVAee0HcbxHzuYctjatNtxNb7/b/KvC1zaTs5/XBZTr5ydLyM6xzQ6ZnLP9pYz+XCyaPu2+f+O4qVs3Poz+ZfL/+fmijoYvZbDvqPqeakFj5uxJ/fBq7jPVvXOrjXBeBvinllT3CtBvrkW1WcVuxYAZdC1QVE4o2RNdC2APujaIOyXlseQNdHn+PqYO5qfN5Z1RcR9lI/DUqjclDdgrhs/C+tiAeFdTnhRd/RZoSlPRQSG5ZCOtkfLkmL4OXlou1QefXscx2zz3xZ7rSS8+jDtHn27yeinTf51TLld9NPcs0PUD/ZDU4iuqc1g/XHr5PT5IqastH+Ki8nwr2H4UQbtnxD/mhiybHmvZfhRBu2f0L7MvTa7jGM3iIvGIRKy1grIMv4Tt2anORhfF6tJGsZONOY6j8Fn2vM6uD4Z7dnkX0ewumrP6wgeqh+uPXPzDHS8icOzDvI11zStj4nJ8J/P8KMM2p6xjs+PIcuW9wUMP8qg7Xk93G/uNeOpGTO3h/Ma2o+7KDyn8yvYHuI8r8Y5QtMetPydFvnrLPLXR8jXh9ktC+Vz7bkvyE/jnr1x7RnnjtCmrgS9XWvJd4El34WWfM1YhPKrSdp1gOHZFgyLLRiWWjAsC8bLNz4UNz+L6dxabvMfyx7lY9G1ZXMZfvRbjTxuLTldR4RjPh1jFzP5LGPKkiL/p0aUg+pe0jZofsY+TmbyqCa8N9bmcD8K81TIY2Tow+1bVfHHLJN/ueYK4r4vQt8K4+oX0+j6UO7dioVMPpys+YKyzPrQWiZN8BnmAH1TDg9u3rPYZ2YGd7HPzCTfuqVvw+J4wvVFpdoE3r+QYKDv83C/Jh96zWYv80h5uLdOUyQNy2N7h4zbiaCRua/U8iThTdkFgvmgLdK3T/vgPnxmdid5Zmbui/vMzPAfB8/MPkmemTl6u7/ovoS2DfQ147x1y/m59J06PLj+CXcMmOgaLdo/cW3C7Y6Y6c6447bJn9sh1cW4zb1jyvU1WvVmveGW4d2Lhq9e079t61D/7q07tq8Yvuzy4V27sRgouoopJq3+KpKd4aPThGbz3oqAP8q14UGx6rO5SSiDvurJufqTaMaxHzUm1Yw5N4RuQotpdBMXrv4WMPlwsuiyGZSdJfkUu3lPlsHseKPSojfvyZI0HObQPujBDQumTHs37xmrj72b9wTj9bt38578fPZu3jOxfCayeU8N+bjARDfvaYVQoTaU6XiTby8375nox1f6II32T/jBieWj+Wnch7xM2ixI6wvP8YMT3IeizEcjuQ+G4sddEdfJxB7wg5By9tAxRMdPkwfmPddR3nHarK0/Q9zcdGgpH55oHx4Y7OrvH+kYHEkP9o8MF9svG35uyifN8Lv17zv6TXvBD0/QLZWqIG0uSauGNIOR+/CEm3igoz+O/jH/ZoZ/HpRhImMs5oPtuxhZ5gMP2L/TDyRj30Tbopt+IH78Z/KvI1iF8YzFf9yHp7sZvRrdnc1gbQ6i++QUScN8zmby4WSZ8cJtHWWzXF8dkPKjjdKN67FtYr3RgxuDTZmKjctQz9T/RQy0ProJnqh6b2buN3xJ+2BKsXEZ+j3FxGWoV+qHoW1Svxo/xkB9YbR34xNy8x2YN7XVOPMdeD/9oCfno8Tpt7h8OMycXZ5GylOsXZ7G5GPr5ydaHg4zrXOJfLA85frIJ/XB++A+jMs2R3z0LW5cZvifqMvJHCR+OLaDyexLaNtAv5HaGc6pUNvA+QnUOT24/snoopS4jPZPe32fifs+ZzBYufY0G85pu61krtnaZl94XsukTabvQzeUL8X3MWUq1vdBe7X5Pi7GGMf9VdH1Ua4PgqNe6bwB2ibtd/AjCdQv6oM0+mwB9Ut9n2JjCryfjnl4X6ljK4eZs0v6ca9i7fIMJh/Xvs/T/cPjp8J96Pu8mfg+5j70ffBe6vsY/j+C7/PWssxBFt+X0LbB9e2cXxTnY+Fx+yeMh3eUGA9T7NUMby9JM7zvh/r6HZmDxnbRE+Sn9UDa6SStl8HEzV2jDNRJlM0tGc0vg+H/aIhb6/LxBl5mRWC3Y7f+x2Da4DmTKSMXE1UT/k9CGTPEXnBO1ug+XDkWVI06KU9G43iSLHs2drAHP+RL+9FKhp/Oe9s+6I464/o86p/2MrLQNzbzupNpA9hmomzgqzFtwOh1MmwA9RrHBpC/WBswOuNs4Cwi63RGFtpFEmzgdMgzygZ+ENMGjF4nwwZQr3FsAPmLtQGjM84GZhFZXDyMYwF9vmNk1zD8dLxC/l9DHR3SkI8Px1Rqvz2MbByXU0QGlqOeKUcjScN7tdzbq/Px94Vpd4NP8FhZ1hXktnLAV3E4nc8J8jEb/r8y7SJF7kF92fod7lkclps+j++DNLqmKynPDqjPG3e+z/bxYhrD4GsNfXBOj0LPKtoac3IpnznQNlMkT5NHVPvmfOk+kGtiITqv+yS0i6awUbld45BrF6Yuublo2m7y6j7EybWLuQX0FWctwlxGh9zchrnX8drTrkYGqzk426fz4Gj7tF2g7dN5cLR92mZwPRTqhB6F1rPGbRfGNlMkT5MHbSu0XfQxePH5CF2HNh3WoR1N2oWb199y7cLoNqpdLAzyMRv+GZZ2wb02xj1zpBiQn+sLbZ9pStrrgnTd3hJIo/OiuDaPzoviKz50XnQZpBX7+g++nhi3XRxN2gW3Zr8PrtnaxQKQW0PahdHdCdAuziDtAvsEF+3C1GVUu8B2g/ynWNqF5CfEuHaB/Sv91IEbfWUHGxms5uBsn776Jmn7Jg1fy0ed0INrF/g6fdx2cQZpF9xa+D64ZmsX54DcO8m2C0YfZ0O7WEXaBZbdRbsw23ZEtQu6bZbhn2dpF9x2XkvgGm0XhT4h1hee2z4h5lZfxW/zSbdRxW2Y6HgRd0t/+hr4WkhDndCDaxdGT8W0i1WkXXCf2euDa7Z2cS7IrY1oF+ugXVxcnnYxZMpm6jJuuzD8G4psF7bxgts2MW67MPc6bheJ+pyFScNtp8rRLi521C6+SD6xhOMu3T58acw8HW9BOkhtPar9LIN05N9taT+S22kWaj/m3snsb7jtPWl/cy2jL27+ewmURx9Vo07KM8zNf2O9VUO+hepIH8X2iXT7KRyTzyVptk9Q9TEy8VNqNOZ/IYxVr/ck5n/J3ph/7Phfiflf7yjm74hoF2+CdnGHJ+3irXvbxdjxv9Iu7nDULh6Y8tS5sbFZYdpHoF18lbSL2SDLRbvAZ4Z03SHmX034P25pF+Ye1NdZcI22C+4ZJJabrpOaBWl03w43+pJdR0efgeAzF/rcEO29j6Th/BfqhB5cuzB6KqZdfJW0i1kkD6wrfdB20c3g1XIvCduFqd9m4Ds2yE87DtIOCPLxHM/gQf56wn8CYOD4jbxqwv9dsP1DyDu6J8L9gu11wGA+CTBVMuU6kWA2/D+0tFdzD+rtGLhG2+tJDD+W2+BpInrDe2vJf1l9ZcbWEp3M6Ot4Bk814f9FzFiqGcqjj6pRJ+Vh1xJhvVVDvoXqSB+0Tk9m+LFujM6aCT/Wr0k7FtJOJGnYZo8jGJoZDHHX7ph7dVs+KezwuD6D9idoC7Q/OYHBg/y0PzkRMHD8Rl414b/P0p+4aR/pEVv7wHJFtY8HLP0JZ3tNcK1Y26P9CfY15t7aYLxduuhPTmH0dQKDp5rwPxazPzkOyqOPqlEn5WH7E6w32p/Y6kgftE5PYfhtfcYpkEb7DOxPTiJp2GaPJxiOYzDE7U/MvbotH0T6E+Q7muR5LJMnjqVzR5/6rWUwu5hLxD6nMhivzygfpy60Da59c37W/nCN2kKhftTm45l7HetrwKavY2Loq4XRF9e+66E8+qgadVKeQa59o23S9s3VKfIXW6dGZ83B+D7yOJKGbehYkk89kw+2J9qGsa7MvboN3x8WoA7SzW8pexkNDnQNZPV+RplsV0c2PdRK5OvD6K7eQf7Zzv7uwf7uTKY3mxnOZjrLnf/wQLa3e6B3sDM9lO7N9HaUO//u/h6Ve2+2P9uVHkx3d5U7//aenq7e9oF0tntocGQoW/byDwx1DaZ7OzJD/f3dqvg9ZS//0NBwJpvp7u0ZzmaHestvfz29yvBGhvszmUz7UHq43Pl3Dg30pLvb+3uHBruGOjoHC+Wv++W7gcfkb45KuE7vN9erGX6UQT8TVAn3V8fIu0Iw75Ql7+oi865h+FHGPJI37qFt7m1k8jEYaxmcgmNy7M+QmPzrCFZhPJli66GR6BLvbWbSsGxR9VfD5MPJSgnKqiLlQdlRbTWO3WB5J8NuzLVy2U0lwVPIbqoYrM3B+D7E7Fdv66OqmHzKJYvrV2lfxemm0pIPrSt9NDL3UZujOu0L/6dLO2J/esHkXxc4bQMZW/1xejW6q2awNgfj+z1qJ1yfWM3k44ss7Ods/R7t5wrZoxnvaRvXh/l8Hu1Lm4LouqH9O16vZmRXE/7LyfzpFFKOvvB/usSD+nmYl2M/oouOw3g0MuWm9T4V0mi91xLMmIa+M/0+CR6V5D/qYs+eQzGeN3I2kiJpNUw5TBqtd300B+PtnvovaPc1JA37tikkDe3e7HmdIjKDwO6rxB1XbT62ubcerk8ZzZe35xeuVYfnpj6mIj9Jq4W0qtFcvvqoC/9XQT4oy+CoJvw3hW3WPCOogXvM/c1M/jUk/zzczDXUM5VVyVwz/LqubggxRvmFWJ90jHbUB3WlSH5YDq5fqgvGtxsXY/QUgifK3rn+iLarqXDfitEcH02rZK5VRMiibaZUWRWCsioFZZk+qTbIL7M++sLfdHFHJ71QG1GGCcqnRy8dl/DgxiWuTaD+8EDcxe6Fh3VeR9KwDutJGo6bDSQN+wmDgevjqb3R9k+v2WIN6hvgfamIX5NPUCAfDnMTg4HaPDdeVljy4eIwW7w+0fIUG6NNNB/koXMVVYL5oC1OIfmgr4174X2RPAs09+HzMrx35WguHfm/35CT+RXiszsan7ppO8ODG4to20DfmNpZHcGMafi8uFi/2eii2L3w0G+eStLQXgxffTC+jn4IdXQ3qSNH/X2nwWd0zdkV5l9N+H9qeW7NjaU2P7yW4Z/K6I6LOcy9SR0fOdukNt1AMGNaI6TRPmoapKFO6FFoPI67LvXuiD7J5EH7JPrMuJrBi30d+vt0zom2p6pg/JhFx4cgQgY3XtI8uDmv+aP5aVUxsHFjTMBc47BVFsBWxWCjciss5YjKBzHZ5quojXPYnTyLbh/s7O/o7E0PDnd293d1l30twIjKdaQ73dk+lB1uH+ovlD8Xb+NaFX2YmB1jeuQ38qoJfypstHvWQpJ2XM3kp/laLXypiN89MphrVaP517hYH+dADL/Ju250PEaTVg9p1SSfhvA/6gtlGRzVhL8pFG7qBOctzP3NTP5TSf55uJlrdA6knuGvZ/h1/UwNMRq7xbJLzyPsyZPIx2sUm7GdqLlm7rkkN27Tfs+MR5yvrA86D234DwjxmPGfzqv2BSK6Yueha0kZpkAZOL+H7ldt+DuhDR/UmK8z7tksp08a93FzHU0Mbjp3Ue9Gf2PvQRlfB/1NxFof5OvI8B8V6qXQur8aKI8+qkadlCfLrfsz7XUPfsgXyxUEuXIjPx1XGxh+rBujs2bCT/0s/I+y0EefR7AaHdYEdn+cPhNKQx3RPUex3dQR7Fh2Oi9ZyeTLxdW1gHkJ6RP2xrk5Hoxzi3k+JNEPYfyyB9/oeFyT0W4xpqPtFttoJcNP222hdm7meJqD8XVJ7Zsba4ppM/qYR/JDezF1g20m6rlL1DzV8sacPKzHqHkqOgYa/gthDFxFxkDJZ5OF7JLWr8nP9CW0XfaF/9OlHbHXgZj864LApb+Tsdk/N5fj2H/I2sZFrj22BE/Nj9A6Q3xGFsbRi0af+uXsi/p7xa6Nw/vpM2+sY9uzctoPxHlWjvZeH9h99RSRFTUvSMeDuGtGqe97CbT7l5N2z62t4Novbffc2gqTxq2tMLZL5+H6wv/p0o4x2x2LtwNep+gbI//ljO9raw/cc0uKAfk535F7B2tsbQL5L6yvsVhhWgF9NRJ9Gf5nWPTFlX+KRV/TGP5Gi75Ql3gvzTuqLyqXLRbSLbVFw/+8mHHYVCiPPqpGnZSnk/Pn0Aerhnyj2gvyx6l/rr00E36sb66Pp3015ltP0rBvpv0/9vGmb8O+lJt7x/jO+G+zw0xqGT1I+hXYN0vL70kPd9LnM9J9k9u+r33AyJ/mBn/a2J3xw2lZTL7G5ow/hOcpwrMYeBYDD9ruEuBZEsGzFHiWRvCcCzznRvAsBx5cI4iYVwDPigg5K4FnZQTPKuBZFcGzGnhWR/CsBZ61wIOYzwOe8yLkrAOedRE864FnfQTP+cBzfgTPBuDZADyVwLMReDYCTwA8m4BnU0Rem4FncwRPP/D0R/AMAM9ABM8g8AwCD2IeAp6hCDnDwDMcwTMCPCMRPFuAZ0sEz4XAcyHwIOatwLM1Qs5FwHNRBM/FwHNxBM824NkWwXMJ8FwCPGg/24FnewTPDuDZEcGzG3h2Ezzcmiz6TT4X42FPOuu4v8+003UEAZTT5N3kJu/Y36Q2+dcFLsfW3JxGE8FD9YNzsXt4RnN4aFrV6Phy0OeqWL/aX10LfNS2GkkazuWZPtblO0k96c5hxz7IyCTaZPrpaJN0Xr1qdHw5irVJtC1qkzivY/ptbn3+dpKGcfYOkoZzFpeSNPTpLyNpOD+5k6RhXLeLpGEcaMYDjWEgyJ1fFJ6bOsK1QpXB+DGDzoWiXcm1z+5Ot+8kdqeL7fcqSRraWBXocy3Rj5sxNacfF/rX+mmLwG/O9WHW5wQBvw7G6MjorNzvAvWH/5P8LtD68Fy3Y9MHzB7NyZMcF4z8OSA/Fcj180b+XCf40+1G/jw38sfwzw/lB3Kyx3S/wA32DiP/HDfys+aZ6czQoOn6XJMn9xsE4/sOfdCxBP0hQbtMc/OW6DPo/81MOQyulsCNTuP6aSb/OoLVlZ/WQvBQ/dB1HK0M1mYmjdZvK5NPK5NPuWQ1BuPLP1Gbbg7G204zycdmc4hvMmzO5F8um+Pqz2ZzbQzWZiaN2kkbk08bk0+5ZNE2ZNK5X5MPvWaz7WJsDvFNhs2Z/Mtlc1z92WxuOoO1mUmjdjKdyWc6k0+5ZNE2ZNK5X5MPvWaz7WJsDvFNhs2Z/Mtlc1z92WxuHwZrM0nTh/FZU0xaJXOtosyyaBsy8rlfkw+9ZrPtYmwOdToZNmfyL5fNcfVns7l9GazNTBrtm/Zl8tmXyadcsmgbMuncr8mHXouybdRhbeC0HsfmevYl+ITkZ4z8/dzgH9vXYYYb+V10rh3LoudYPgnXNeH7vpXMvZWQjvw3V+Rkfia8xj3DoP2No/d1Y/c3Jv9y7avGvRuN+qH9TS2DlVtPSvsI7p1qbp1suWRx8/yl9jfcO05xbM7RmunYNmfyL5fNcfVns7k6Bmszk0bthFsrzr3jVC5Z3POjUm3Otm+bzeYcvTcQ2+boewOubY6rP5vN1TNYuXdkqJ1w79tw6znLJYt7LlmqzdneBbPZnMt3MYKgsM2Z/Mtlc1z92WyukcHazKRRO+HWkHPP6ssli3veXarNUdvBfPCZHvqSj8F1vA99SbyXvkdq+LvBl3wivMbtBTyNpOHz8BaShuufW0ka6rSNpOFzkekkDetyH5KGc9tTSRr6LbUkDceXOpLGvcfEvadB360vtl+riplPdYn5VMfMp7HEfBpj5jOtxHymxcyn1HGnKWY+LSXm0xIzn6kl5jM1Zj61JeZTGzOfuhLz2dtO97bTve3Uz3bK+c766At/0yUetmeabp81do/t95MiesJrmH8dwSqLx/6skVuf4Pa5WPfYtydtzxERr+NnJmP7i+zP5G2wmu8yoo+N/NNBh8iP5+Z+vHZeaBAGA85PG/nNTFo9wTcjGK9LvFYRIUsf9FnbXlnlkaXP8XkH1jnKQjszbUDHbHOJ7XDP0p225fb+2O+e0GfcjtZ5WJ9xc+tinPYt7f3tKSIf8XDP1bl+AOsO7QH7IuTfB8pI7Qftq5pcGwkrTNLmtZ1uDuU2MeVpJWUrdm0J3k916Oo5P53XQAx03Ch2TSC3pszperwCNsp9S8pmA9UWfq5va7TwH8DwT7Pwz2T4bd/pPpDhb7HwH8Tw2/YAOZjht+1pdQjDb9u77lCGn+vjTHs4DNLo+HA4XJ+M8cHkX0ewuhofDg/G6+4wRnf6/SVTx1uGdy/dsXt4F+JGWW+tyF3HdDwMD10blCL/K0naPoAVr8+IuL5/xPUDIq7PjLh+YMT1gyKuHxxx/RBy3aTR78xMIf8byH86Xhwa/uf0GhBeTs+crqXSA4eypdMDhp+711y32XYTc89hRBbtD+g1Oi7S+6PKYGvLht/2zT19bnxyrhxV5L6ovckrI2Tbvo3L6d+G2VbGQt+1nTeaX0bM19zr9v3HXNwd9ZzrxhRfJu45lz7MO2vVhP+1qZzMV6byy426p8+dqE7xHPPlsFD7xftNWn3MsuH9tGxvgLJlK/L5qwELJ7OZyKd7y+lj7miOh85v47cFOP4agtnwvznErMfVw8IbnX5bDHxcbt0d7rE3hWA2/LcB5iMreT0EQby2ya1Nw3IbPNwzVTq3XOjbZKad07xrguLKf7ulzpys84I6qwNMnL5qCWbD/z5LnXFrtWx1ZtufFvFwz57rLPfRtXW28qEM7htzdMwoZBvYVjGfuLZh+O9kbCOqT6G4FsTAwLUNiuFTFgzct3daGZkUM7fvtT6ne6cb/s8BhmM8aSNfmsQ2gnqnz5ho3vrAvmxKRN41EfxR5f+mpV9zsjck1Bm3TynqK2qf0rssdcbtu2irs0L7lNJ1M1hP9Dk0V2fYx9A6M/lE+Q+0zgz/jz2ss59PYp3ZvsOI2Ok8cwPkz/mPdF9fN/sY5Z4Xmrm86ohy416ryP8HRvfc3iu1UB59VI06KU9G4zgecNA6rYZ8sVxBEG/elNvjCOvG6IxbP7EvkcWNAWivpo+dTBtAG46ygX/EtAHce1kfVaNOysPaAOo1jg0gf7E2QN83QBuIs+c42gW1ATd7eOVsgNtTGTFjH438T8S0AdwjWh9Vo07Kw9oA6pXaANfv254nFNpTm+6Nj/ZB/bFC3yegNuBmX+2cDXDjMGKOGoenhEpK8liAeqU2wPkKtm9+FvIV6DsgaB/UX+PiSbQLagNu3sXJ2QD3jaspTNmo/9gW0wbK862c4vuBYr+Vw9kM1g3dI537TqptLEC7SIINcHEltYFDPOgHUK9xbMD2fYVCNkDHgmK/c2YbC9y8B5qzAW7uAzFHxf4nxLQBo9ekjQWcb24bCwrNz9BvLKB90HeiMVbE7xxEPYPAPPE5ibEV7llQNcg1z4LoO0y9UId9JK42PIWef3B7v8nVa3rE4DHP6tFOsX/F2Ab5z2TsNEXuCQL+OV+cNTu03EHAv7M1IyicdyVco/3A/iSfvvB/urRjTL/cGl0sG66bQ/55Fv1ya5Zs+uXWLGG5DR6jX9TpAURWIf3OHX3qt5a534V+Z4L+OP2i/pF/qUW/nL5s+uXWeGG5qX5R9zOJrEL6Nc8mapn7Xej3QNAfp1/UP/KvseiX05dNv9yaOCw31S/q/kAiq5B+zT6hSdfvxknUL44PBxJ8pm8eDDPR4+TryBoc7L/xW1EO9d1h0zfqI0rfF8b0y8ozV/fUt0ypX4a2XQ35RtlEsetQsW7oWhJsZzNIGj4XpraEtoBxDR2HXNgCN3ZUMOWgY8flntuCzd8KgnjjG9YNtQW0E/q+ELc/EGcLxs8vly1w7y/YbMHwP+d/zBY439NmC+jrHEDSuH17OFug72cm1RZu3GsLsW2hkqRx716j75Ai92GecWP3SpD7WHhO15S90RK7Gx6M3blY1O08Y2bsuT+u+akMxo+1dJ7R8L/V4jty8zHcGlKKAfm5ORru2T59X5TLeypcK0/sntMvF7tj2aJi99uLjN1t+i0Uu9N9YlCnNHYvpN+5o0/9uo3dc/rl/K86Bj/1vz5YZOxu02+h2J3q1xa7F9JveWL3nH65WKeOwU9jnU8UGVva9FsojqD6tcXuhfRLY3e834V+DwL9cfqlsbHh/4JFv5y+bPrl3v/DclP9ou4PIrJs+tXndG46qfr9xiTqF/V1EMFnxr67YG5kRmX+/Tg+0n3MsOzTYmAy9WLq62ByvS/8ny7tGPObD4HycrgOJvow/D9O1HNP3m9GO6iGfLFcQZArN/JTm+LeqcW6MTprJvw4vnP7/5g8OVui721j23dhC1jXnC3QtmH4/+CBLdi+Mc/1F9w+RHFsh7MFtBM6t4LvD9C9k9AW6B42jp6Bddj68QOZctB+/H7PbYHz9W22wNkO1g21BbQTOreCezbYbME8My+XLXAxlc0WDP+T/2O2UCjuo7aAfrNtXQS1BfRXzPv8jvcQts6zHchgpfNsdaHeC9kCPlvSR9Wok/Jki10rx82Z2NbK2WyHswUuRuW+00H36sNYylzDmGDOaH4avhdH+VEe9X/3hfoz78pw633xvdAZEXNx+qBzcfqg84CNEXLNNzBc2kh3T3rs29PGPo3N06MK0pH/0JAZ9Wt+q0rAOdLdnxnp6B/p7+wfGsoO9rcS+fow9ljvIP9sZ3/3YH93JtObzQxnM53lzn+4p3co3Tsy3J/JZNqH0sPlzr+/e7g329XRPtgx0tvfk+4plP/Y3PhoLh37PH1MCf/jd4GR38irJvwnh8y6XaRJv1rN5Kf5zrLwpSJ+98hgrlWN5l+rHR3Pj99RNvwm77rR8RhNWj2kYX+sj4bwP+oLZRkc1YT/dIjd9YHfPjb3NzP5TyX55+FmruF4QGVVMtcMv66fTtJvYNkFx8Cx/UVriHy8RrEZ23HSrgeyvd0DvYOdadW8M70dhdrVjjChlqRJ66mWKaeU/J5M+wD6EQ7wdxjf0I1+use+iVXpBn/arJs2c8VcWQL4NXz0HuQ5F3jOHc2XZXiWAc+yCDlrgGdNhJy1wLM2Qs4G4NkQIWcj8GyMkDMEPEMRcoaBZzhCzsXAc3GEnG3Asy1Czk7g2RkhZxfw7IqQczXwXB0h5xrguSZCzijwjEbIeTbwPDtCzguB54URcq4Hnusj5LwMeF4WIedG4LkxQs6rgefVEXJeAzyviZBzC/DcEiHnjcDzxgg5twHPbRFy3gY8b4uQczvw3B4h5z3A854IOR8Ang9EyPkg8HwwQs6dwHMnkWP6QSfjRDrb67af7U7T9RdYfpO3mz284u91bvKvC1yOabn9Hbn90rhnT9xcRoqkVY2OLwf1wbF+dcw7H/iobVUA3wo4XxfkY+DeneF8KlPH+N6bnP0O9DrdmyvdlebqoBr0p48qSKshaVgHU0Cf8wnf/s/O8VXE0HVluXWdyfS71XWmbLo+HnRN9wmpdqE7sFMXdaP6uvY2Bj/mpQ8T3wcBH0cb/Rk9YRxL42iMyatG8/MxMSvG0SjL4Kgm/MvD/9zchrm/mckfY02aF5c/jaO5+YVahl/rc2F4rmNFE2PNhvwl24ORP8eJ/HS7kT/XjfyxGHce6FJI9phu5rvB3mHkL3AjP6vtR/dNC2G+wZ0flvvmDPoe1A9z0fepMTS2HzbWHwQu/cKcH1ZoH9pyjKvax0gR+YinhtGP23E4971w7v1rg5V7rx35a0CHyI/n5n68dnn4azBw30mk7xPpw/QxKSatkrlWsVeWiCzaZ2E9oSxur0VtI0PhObefLN2/mmuv1RaMeD/6kfS+VMSvyYdeo/lwmG397UTzof0h5lPD5OPYX4/dr5v86wKX/WiuXy+0tyzt16e60U86TttCvFy/G7WXaFS/i++mFNPv3hD+2r5xHqd9m7z1oXX+gvCc2++R7uXG1Ru3b0wzcz/VIf1WA/dr8qHXaD4cZlu7m2g+tF3ow62Npjvd7oOT7uLegQoC2RhDy3S0Rqm70PtjN8N1TOPeGdQH/Q7A2Nw2yHxTeM59B6CapCGuKpKGNkf3N8axxNhdPVOOCqYcqO/J3FcRyxe1r+K7wl/dfpalcvx4TxDY5zApBuSn5daH0TG3/6stb5zTmzv61K/b/X9y+jXzKtURZaP7/xj+O8JfTr/cHhs2/TYz/Fhuuj8w6pR+L6KQfueMPvVby9zvQr9mfX6UflH/yH9n+Mvpl9OXTb8tDD+Wm+oXdU+/T1xIv2Zeppa534V+zbqOKP2i/pH/c+Evp19OXzb9ct/Tw3JT/aLu6bejCumXvkPo5vu8Of2adeRR+kX9I//Xwl9Ov5y+bPq1fSOY0y/qnn770KbfVDB+PxpH32Me973hKP2i/pH/u+Evp19OXzb92r5LyumX+75lXP3SPV6Sqt+fhr+ToV/U13SCz/gWvwp/tQ83P5V/P7dPJrevBp1nsbV1fVAf1vD/PvzVuloZoauKgNc/tQc339POzbXuy5QR62KfIL+Mhv8eKKOxh8nbp7trz76cawAHtbNqyBfLFQS5cnPfsKV6Qn6sG6OzZsKvz6nPy+3zim1o7uhTv277hJwNYB1XBuPbDO0TDP+D4W8hG8B3qvRRNeqkPKwNYKxCbYDrt2zfruVsBuuGfrMB7aOJyOJiArSLctsANy4g5qhx4b/hbyEbMHqdDBuwfbOBswHbNxsKjV1GZ9y7ZjQ24+JotAtqA25isy6rb8vFlnS8qw/1neSxwLbPky3e1kcc/xvrxuiMe/eUxo/cWIB2UW4b4OJzHAui4vP9YtqA0WvSxgLOBmxjQaE5BDoWYL3TGLfYsWAybADHgigbOCKmDSR1LOBswDYWFLIBOhbQuR+UVcnIwlhjLsFqdFgT2Odg6TzwyVBH21L5+PD5LbVf7plrnPl17Dvocy6cq+b0TeMrw98JZTDxVW0wfrxy8Qxzot83643ZNvB5lz6qRp2Uh20baG+0bZTz+2ZUFtc2uP7R1ja476XQtjHH0ja47/PZnlfiPIStHBVMOeI+a0v6O9rnhgKebu9oT/Y70lmlgK6R7nRn+1B2uH2ofzLfkV4fCtB2eQHp16qZ/DTfxRa+VMTvHhnMtarR/GtJf0f6wlBAkt+R7iftFssuNwZN7B1pYztJ2HvBrNH0+h3pdGen3+9I59a+VLqRP/aOtHmWGzU20/fI8B7tU5h9aPT5wXCPPug31jGNezfbpC0c5XHoYxGk0XfiFkMafbdoCaTRd4uWQtoUkobvek8lafiOdy1JWw5pdSRtBaTVk7SVkNZA0lZB2ti7OoG7GKEnne1xu0YlPdTG4KfzKW7ewcm9IzPHjfyM43dwOug7OMLyx95j2RHKoz68ydPUlcP+ajiO74T5l+t930LxjznXbdn0j1uGdy+7fGDb1sFFw1fvmrV9aFn/zt1b+7fNGhraObxrF5aG6wFpOh6Uh/JRfpdvoOvDyI77VrTht729g3i52Rr6Notk3vqYM5qfd8qSd3WReXNvCaGM2SRvbqVnJflP+TjZUXlXRZStEGZbGQut4J9Lyoj5xvkysC1vbrU+9xXZpmC8DumqIUdvaHUarLVFlq3QVzbpLCb3FQnuPuQLGL1FYeXegqCjhau33Gw6semw0JcuqA65L104Llu3DautbNxTuXpL2bivmjsuW48Nq61s3Iq0BkvZsNyNlvuQD3mmMLrBdE6vZbL9XptObDostALe9hRkWnnK1m/DaitboZl7WjZudbzjsg3YsNrKVmhlPS0bt/qBuw/5kGcKoxtM5/RaJtsftOnEpsNCTz2pDrnV89wTjhRJS5FyYxr6sFFvmurzqLdd0V+hb7DheMy9fV1H0ri+nz5txrqmb+bh2Mi9+VhP0rj+mD7BQ73jDh1Vo7n0JD0p2h3+n+wnRenw3O8Z3Wz33hld+2Ha3pzRnPy4M7rmHt0nmDatz5vhHn3MBdkpkjaPyddlmZVNdLrdZS49tvMS1zfT2clg4vlm6AUz83Yg0aOjcnbSsQQPbizBNk4P2kcibl2mw0Eu5aN5ov3SsY1bocONsxUWmWNPDYPkjyeHhf8nezxBu6wMxtcFxUX9L+QPmGupILoOaR6VjDzTHm3zhhQb174D5hqHrbIAtioGG5VbYSlHVD6IyWbjKZLGYdf1auxrr59gPTocj+Ptjvt61k+wxR7YD5h7uCdBxjegPkQTyNMH+glGtkvfS9lEl+M6y7QF9rFF6wG/qol6rg6i+7tqwmvewNJjYVuEvJqg8BhYGXGfeZrPPRcKBPXF4UgxOAr1WYn/okv4f7LH7J7w3PO+fXBv324/TN9OVwQEQeG+3dzD9e244sfMd+nzfUCePsq14sftjr65VS+OdjPL2nb03bvqxXp0mPG0HeyE84/RTlzFzXR8DIL89haQ/OsCt35IKhgfc3AxEq5K2S883zK8e9Hw1Wv6t20d6t+9dcf2FcOXXT68azcWA0VXMcVENSBPVPhm/lcwfHhM5jIVTm2Gv9hlKnh/nGUqE81bH3NG8/NOWfKOuwm94X+6LFOxlVFimYpt6qzUxz42956bNvPBXe4O/0+2u4xhEKZ55i6XbSqkyrF8N5uX81MhXJszNmxcZDw3mCY6XcK5L0Y2Tp/g4xiX46GxG9qPSOq9LYjuw4x7Z6Y3GuB8+47dW0euXnr5tm1bR7YODy3dsXsY1c0NIeaImqWl2WNx6X30MHw+dK0zwv+T3bWaGSzPu9ayvV/kyuV13cS5rpVr7rqpN8A5rv6Iut/xbHE2CbPFpqvXujGz6SpCW9G/fWjHJfO2Dm8boj0Yatd2+NBbmXmlye6tzByD571V2b4Y62i+rNvxukG2t+J2oDc2bOYr8bxUR9DxWpkuxzrsoMFuEIzvsR3tdJ/l+j5uHs7kX66vVXDvm3Bfq7DtmmLSqkbHl4PuNoD1i+s0uMkGup4GJ4/MXD23LsjYu5Z/DOR1bHjuODgZmMzgxFybMprTx1ikANeqQX979IP8JA13d6gazc9nol/bOzr8n+Sv7R0SntcHOa/nRJBH20qheWzzXOqpIHH2zuH+3XyISBelm4N+NigqRKTgohbmmP/VjPzAkheViXy+hJuZ8P9kO3DPD8/9duB6ev1+8O18oW7sRU2VhI/eg/fNBZ65ETxRM4LIMx945kfwLACeBRE85wDPORE8UY4p8iwCnkURPIuBZ3EEzxLgWRLBsxR4lkbwnAs850bwLAOeZRE8y4FneQTPCuBZEcGzEnhWRvCsAp5VETyrgWd1BM8a4FkTwbMWeNZG8JwHPOdF8KwDnnURPOuBZ30Ez/nAc34EzwXAc0EEzwbg2RDBsxF4NkbwbAKeTRE8m4FncwRPP/D0R/AMAM9ABM8g8AxG8AwBz1AEzzDwDEfwjADPSATPFuDZEsFzIfBcGMGzFXi2RvBcBDwXRfBcDDwXR/BsA55tETyXAM8lETzbgWd7BM8O4NkRwXMp8FwawXMZ8FwWwbMTeHZG8OwCnl0RPLuBZ3cEz+XAc3kEzxXAc0UEz5XAc2UEz1XAcxXhcRwQZt36Fh2dcRYYuXlC2dGVIvkFAT+xQT+v7GrqOkXyM3iofmwTGymSVjU6vhzcxAa+RHQe8HG2pQ+3jwm6e93aXSY9eXaXyTwd7Y6mVY2OL0exdsc9wtF8g3A+HJ677Qd7evdOjOX4oybGBsL/SZ4YOz88x3keN4uBM2Mvmj7LYAqc9itp6jdUBrl2zH3u2/VDC4PHtqIR8+cmy1MRv0YWTTN51QUux49cn2lbMYm65rb+pitFOVk1RcqazDpFXU90MzFubKHbhlZBGt1uFMcWoxMcW1JM3pVBft+LeGz4uXrmNjcz9zp+UNduG8exPkz+DXA+NDxw+ZbFO7YE5KgkejDl7CR8pg+tCMbbdk2ErID87yTXKkEeHj7M0T8v/L93tW3p8ve+eFz42PvisbxNx1lKRl8UNulxXhRORcjdu9w1Xt92VJjgd9/WXbYXb930Pe1le5MAn93Z3iTY+7wv/5zy7H3el39OefY+78s/pzx7n/fln1OeUp73VQaFn/fpdMfPfXrc9untGdtcj9sFz+3tKZJfEPg1l1Tsc5+4cyRzgI/aFo0fMEYw9ss9UzF2q+WfC3mtDvKx4z22+RiXvkxPumvA9RxtsYuR6Wd44tSdPq4FPqo7F/ES6s7RM7uMbcNIYytJf0ayNPyf5Gck88PzqGckmvrC6+nSjoznG6Zk3X4mKJs28ue7wT/2jOp3oTzupYTyjMvxn4vTcdlR3Gkdl8v/PC33fI97FjGF0Q+3GTndLcPYF36emPu4SAXhx3NzP14bCn+biUx9oC3TtErmGvZNG0nZuBei4tgRyo3zbK7Q2gg6/zkFMFN+lFdN+C8Of3X57wl4mVhXFTFkXgpYtofnnP9tyqD5risy78qIvK+GvHdFyEwVkEntJEqnFQSD4b8y/NX//xrkl597Dq3lXxvBpw9jvxwfNy/F6dNgrQx4X9+MV7b+eKJ2jmWmfZfLlwixf+DKTfPXVAdlqAzG90GUn7MplF9H+M39uGEx9q+mrqlNvSz81XV7fQSGIBhv1/qYM8pjqAn4doBtD/lvCH+xr+DqGO3a4G4KxuuLriGgfWBf+D9d4mHbBFFjfGXA66e6SP28Dsr9alJuzp/g1p0Z26kPxn9sIwhKb4soy+iAjtuYprG+EeSiTXNjuD5MX1JN+D8Q5GTeGp5zHzCrIWnYhgx+YzP4sREXvk8DU1asr/ogv6yG/x3hry7XfeE5F4vjh+j0UTXqpDwZnc/9gIPaQjXki+UKgvH9YBCMX69S6MNZ1A7xwzNRfSTK4vozzo+qJWVEnNjv0TZfD+Xi8jQ2beyuEe6XjI+oPnGcaGTwULv7OCmXiftx/Ktn5Bj+aUy++IEk6vNMI/lqHdek8mUWsg06pppy1kTwNxAMhv/TgIH6sthOK4PxNkg38Db8XwAsnwvPjW2h3aLvdVdE3lj+SqY8tvIjf31E+b8SjC+/W3ttz1C7Qf1yH4KidvMNwHxfhB5Qbym4RvugQh+9M3hsH73j6tbwYd1yHx+kY5OjPmK4kSlvQPA3MeU2afhBNZxno0cl+Y9l0vVVm8rJpXwUD+oa+ySqQ9Q71jn38c+ojztGtSFuzKFt6FdQPurj1kbgjMKH49ic0ad+uTmSOsBqfK2kr8m5O/w/2WtypPPPdvZ3D/Z3ZzK92cxwNtNZ7vzbe3q6etsH0tnuocGRoWxHufMf7ukdSveODPdnMpn2ofRwofy55wro3+rDPJvAZxfIjz4F8j9keBU9Ep7T51KYn+arTkXzpSJ+98hgrlWN5l/jnmngsx7Db/KuGx2P0aTVQ1o1yach/I/6QlkGRzXhrwgFjO0yCveY+5uZ/KeS/PNwM9fos556hr+e4df184SRF/5i2aXn0vfkSeTjNYrN2I6LdtWV7cr09PT3DHYNjvRmBwfifJjrd8Bj8g+CfN8c76dzR4b/4FSujI3hOffsNBWI6X/s48/VULYUk6ftWYYgnrG4qgZ0mGLypPGN4d83lY8L5xVpWVGOSZvK5Iv+BI0/ppJ8ubjK5FEXjLcHxMOt3ZHTbfu4HferI3SSsuAJArm2T+3/QNDh4TA+YJ+A+tR1fmgEnz5wbozyYZnG+sJAvj8Z7O0a6e3oGMh09A4N92a6CvUnm6DdY5p0v+t27XLXsN9rlzPt5Vq7jOt+bWuXo9YKVwJP1Fph5IlaK4w8UWuFkSdqrTDyRK0VRp6otcLIE7VWGHmi1gojT9RaYeSJWiuMPFFrhZEnaq0w8kStFUaeqLXCyBO1Vhh5otYKI0/UWmGd7nhd6WA51tdhGwuC8eNc0tavPN3XldKPSdExF9Nwjt/YLzfmG7vV8s+AvOYH+dhRnm3O0u3ayM7hcuxnsqeMozn5tF6rRvPzxjSsO9yTo53ox4WfgvpxoX+tH9u7fMYezDxHEPDzCUZHk7V29PTwf5LXjpp3uJ8Ga0fbHa8dzbhdO/qU76yP+W7kj619XeBG/lhscY4L+Zn02NrahW7wj8mn7wUKye8Z+2B82FC5L8KlyDn3JTzbfiW2sXqi+7Rw+XCYy732zdGeKWNr36YCTrqmgeafCvLnBugzLI6f+rVUfi3hN/fj/CX6iqZd0DWdLw5/Ne95ETK5MuoD+yJankqGJ2q9ck0EZjrnavg3hL8451QbjNeLpM9hMHPrs7DucA028vcDZvOuO9VDENj9WooB+bHcBg+3f00duQ/nzuhaEU42fYbMyaG2ybUBUz7sT40MU5d07UZf+D9d4mHkmefaOG9se45t+HcQXNOITm0609TI5IvrDYxO6PNzk++ej0gQGzLY6oPxbQnxuG0n6UG6JgGPRlIexE3XXVC90aOS/Mcyaf2ckMrJpXwUD+ppzOcPeHvvC/+nSzoy42wwqj+JssFnQFmPImXlYv5yrIGcncrXq20NpK0P0wft87h1Xlg3RmfNhB/rl/NPuL6K5sOtc6TjdNR6byOPPvO6PvzV8tal8vFxz3X0fWasjvOVZJyLto3d3DwOrrd7GZGLz/C4scrED9WEvyGVk/mK8JrLeYh0xHPSyog8EY+rj2dRm+HeU0A81GbeEOTXBff+RTUjx/Bz70eg/dPns1NJvjjucHpE356bGw4EdcnNI6ZI3o4+WtWbIvkFQby5YTfzYfa5YdRPmWKkHv2BIdOXYZ+DsT+3pyLaC+2X9GFiGH3v2+GeOP3SnNFcOvLfHuRkvis8594rwXdHaJ4VEXmaPpb78jmNkWnd6YPud6QPx+929dC+JerdDHyPB/nNeyhcnMO9e8DZJ8WA/Fhuw8+9/0TH9ULvPcwd5fOOGtejyn9nkCu/Gdfd+pK5OuN8SW4tLPUlPwWYaZ1xfpqtzgr5aQZPUzC+nug647jvqlCscevM8H8x/OXqzM07ULk6496BmsrohL6L8lXATOvM9k5EEBT/fhGtM279ftw6w/lxzCdunRn+7wS58vtSZ98HzOWuM7y/gdwXNQ+Jawgc6bTo+YKpJA3nTYp938KUqdj5AtTRWMwdjNclnWOxjWvcns62NmKbczT8f4Dy0TbiyH8YaAzG2zPVXwODnda1Poqtz6lQ3onWp61tRL0/U2x9cuNUnDnk+6F8ZarPfvrOVsDoj3tPi2vXk1Gf9SCf6onOAaSC8eNVnPrkfEXbumfD/ySUrzz1mZt35Pz7GqaMFHMqlcNsm3fE9dH6qBp1Uh523hH3bKiGfLFcQTC+rvRRbAxC5xa5+RRu3pE+7yu0tmnuaJBXxhSTD8bF3Lhv8ne8dm7c3kZcTI7502eSLTFtDOcz9FE16qQ8rI3hXBe1sbh7TFE9IT99VqqPZoaf7mUc1444m4yae6E2ZuaEk/4e5WGhgKfbe5S+vceYhPe9zLqaVJBv91Hve9H1Eob/rJBJt4NTImRGPd+m86+0jfdNUB/0MPKqoYwpJk/qlxj+blIuXOtCy0rHGOyfqgJ+3KXPt6eQfLnn2yaPqPex6NiWClzotn2cbqsjdJKy4AnE8OTexzJ4zgAdXkDGLHz+gP35rAg+feCcO+XDMpl7XL+3PB/a3zmAZw8vk9+edU0WvlTE7x4ZzLWq0fxrSX9veXUoIMnvLS8l4zSWXfo52Z48iXy8RrEZ23k67odQ7HuOt4bntSRNup5qmXJKye9Jd5btGy0pN/LTjtdNjL3naGKFqFhAjzGtcL5PkM9fKBah/pCL5+M9qpU5fl+n29X7OlcQ/biob9SPm/UJmW7b+zrceyUu+pI5LuRncntuP9tSV5K+fZx1L47svCeOj4T5l2vdC/cehG3di6P3VbtpbIB4uLUf3PpTGkNwc2jc3tYVhB/Pzf147ajwl9vnkdouN5+F19BfOoSUzdV7JZUkn0qBfKh96KMv/E2XdLSnm4PxbYHOt3H7n7tdq9Ue+z1nk39dMN5eXLRp25yoPmiduXlekov3uecG3HNzuvaZ1l0q4N8hQf6pUEbkx3NzP147Nfy1PYtIkbSAwRAE+W06S8qGfl2pbRpxmfp1vH4zTdtUEMj6G+7s8SlfMxXk6xvXoJ8N1zEt6hkMfc5n+OeDzLnheaF1kU0R9RbA/9qI/LA/pM8cFwGW9eG5fq5s1n5sGd69on/70I5L5m0d3jaUIjliDraDW6Wnj77wN13iwb0VQXt5N6ts4vfyJv+6YHwP4qKXj7sTNvdGmGQvjyuWcZSZMzpeNxSHsRfO+ukq1LieFNeD0yfNFUw+nJeBXwxYb8FaRdK40YNbATg26xmM1xPlM/XoaMfksdF6ojsmD4S/uld8IfDjPVhW2xtLEjsmu+0XchFLI6Mvrl+gbyRuZfTFzYbgyK6PqlEn5enROF4MOGgdVUO+xfQ/Nhugq5b10RyMr2+6UpbrC1JwzcyI2N5ai/pvezOukrmvGK9CH+ZpTBDwTz2MnidrdxXDkuTdVczXlHz4SvwLwv9Pt5UUSdqRGb9C9PLwvNCTzTdb+FIRv3tkMNeqRvOvJf3J5i3h/yQ/2TRfKkrik01jO9qul4cC/H6yly3bkz1HM9rtbmfwc0/26C5MAcmXe/vS3MPNAplVItr/Mr4rPhE0/QDdPUkfjp9uDTius0ySnm4FcrLHdrya6wb72I5m89zIH9vRbD7Id6EfRzumjT1Z3B3Ki7MbqqOdjzvi+BCYf7l2Q+WetHE7oOnYyzyZUrOF52wfGr5qeGhV/5YtW7dvWTk8uHN496xdK4fV5Z1YHMyigikuqgN56AR5ivzn+ALmnrjFs4WUKMOYqu3DiTZZtrwLPbCZTfJGU50ScR9n0hQLzce20ZzjBwvZuM2EbgzhqNkW/dFr7gUqOu1IH2bhue1j1pgPJyuOPcWVFbUYWB994W+6uKODXnD84l0vN31lDvpSHq0LetBQH3Hr32tALuWjeWI91ZE0bJN0Yy9scw0kjXuhluujqI3Qdkav2R42pggG2kdzvyafoEA+HGbbC1kpkoblqbDkwy3Cd/2Qtlwbh9aQfGoE8+E2n+EWkpjxcs8iZbgH78Mpc7x37mguHfnN5pVa5vLw3LH71s29GBmQctOXWjGNexTE9UHUNrhN2OL2T7jp/M0gl/LRcmD9080C0F7Gpm6C8XW0KfzVmC8Lzx339x0GH/diLlcm+pB8MMjp66PAj/cEgX38pxiQn5ZbH7aNd5I6PnK2SW2a+3gttxkF7aNw80rUCT0KjccfB7mUzxxom7RPMnnQPsn44FxbwcfEpq9L+mMJ8whlsh9LcGE6N/46noqKHX+MTXMH48d3F/FHJcET5ddwfqS5l/oI+pgzmuOjabaYtVyymoLx9U37Wk43lZZ8uGnGyVsUnu6Ma3NJXRRO5wvwXrohqz7mjOb4aJptbPVFlrlfH7aNALh40GaPxpfm4gYzRUv70mI2TuQ2MkDZdMHhW8Jftwus02k6dmBejv3+Li52MgcXe9N65zbL4WICWu9cTJBiMBTy+x8CuZTPHJyNpEga93ID57vSsSbF4LItXLYtv6tlZOqjL/xNl3ZkbB/fSBHMQcDP0cYZm1CGbT4Z46vJXrbB9SncImXOJqg+cRPlgPDrg/Y3hv9z4a+xA0dLa9n+hi5DLfSxkLmj+WUw/L8IfzXvF4N8nXEb1nD6pO3PFlcibjqn62hDwrE4fKKbPH4z/MU4fPKWRKazGod5c4/2z3vwQ75YriDIlRv5aR8RdyPKZsLP9dmcz4JzF7MJVm7z/amMfDr2/zj81bxm8wGuz68j2LHstmWVdKzglm5qLA+G546fS5Vt/o/6AWgHxfoBRhfF+gES/VAVyS8p7da2lFnygxr6MGM790ENat/cWFNMm9GHbbmzqRtsM1HzLtzzbn3foyAP6xH7d7yXjoGGf1oqJ/Px8JoLH7SQXdL6NflxrzFNRrxv8i/Xq0Sc/dteGHXkP2Rt4yLXHvWrR9OC8XXGvW6EMbNZNlXu146wjm0xUZxXkmxtvdALhSkii2vH3HhQaC2E6Yeo79sG7b4rPOfaL233tg8WcDE094oV9X3dvAaXs13udSDUKfrGyD8zLDz3DIprD+jb0fGJe9WG8x2NvrjXu9y+bpaLFaYV0FfU62aHW/TFld+2UW2h182ovrjXzShe85/ri8pli4V0S23R8B/P6Jbz56ZCefRRNeqkPJ2cP4c+WDXkG9VekD9O/XPtpZnwY31zfTztqzHfepKGfTPt/7GPxw3Qu4hOuL4b/TeXr+CcDn38mYBrDy+Tn+ZbYuFLRfzukcFcqxrNv5b0V3AWwjiojyS+gmM2bk7iKzjGdpKwueB+4bnnrwB17X0FyH6Y/nzOaL78gOTLrYs093BrHOaGaVMDeO03GP8qu8t6p+OTpN7aGPz0GUNL+F+Pu0eH51u3D+4cvmR4++5Zl16a98LBnpcQzFsHATno6pEU+V/B8OHhw0vF+4b/J3v1Dq5Y0wduY+mi55vuRn6am93dB86nk3Ki7fQJYTDyjB1UB+MP6n0ZXuqJp+TxZQJycF6YOdrC3+lwbZ8IrI5m29qNfEezVazN4Ewa/YyTqbsq5r5UxH+ur4riTVnkNjJpRqapK8RrymF6ZVxZa+RK6hKf7DiQP9Z/OFqp0sHZAt1CMgj4NkNHddqnCmPtH4v0AEMlyZNiRB7OfulYWkWuV8bg5ewXV5NRfPQ+uvKaXsMVx/Sg9YIrxTlZOHOK/FMIr6s6bGMwGez/D3vCf4qTjRkA",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "get_notes_internal",
        "get_collapse_hints",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "broadcast",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["broadcast"]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["public_dispatch"]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "ZY5bCsMgEEX3Mt9+RPNomq2EEkwyCYJoMFoo4t47lkCl/bnMHQ6XE2HFOeyTMps9YRgjaLtIr6yhFhOD2Smt1T6Vb6hy8PrDn4c0uZ5eOg8DF13fMkCz5vsmetrYlEZqvE7sj6/v4qIbzr9s06VHovqUTslZ42WzBbMUcv514I/n4eyCa3CYjQtZypG3TFQ0S9Nv",
      "brillig_names": ["sync_notes"]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "15261044312996284873": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 33
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["process_log"]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Benchmarking"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "notes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "data",
                    "type": {
                      "kind": "array",
                      "length": 2048,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Benchmarking::sha256_hash_2048_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "Benchmarking::sha256_hash_2048_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Benchmarking::create_note_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Benchmarking::create_note_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Benchmarking::broadcast_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Benchmarking::broadcast_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Benchmarking::increment_balance_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Benchmarking::increment_balance_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "index",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "Benchmarking::recreate_note_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Benchmarking::recreate_note_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::{\n    embedded_curve_ops::fixed_base_scalar_mul, field::bn254::decompose,\n    hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "105": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let mut parameter_index = 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_struct().map(|typ: (StructDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote { let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hasher.hash()); };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\ncomptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            )\n        };\n    }\n}\n"
    },
    "113": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{stub_registry, utils::transform_unconstrained};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n    let unconstrained_functions = m.functions().filter(|f: FunctionDefinition| {\n        f.is_unconstrained() & !f.has_named_attribute(\"test\") & !f.has_named_attribute(\"public\")\n    });\n    for f in unconstrained_functions {\n        transform_unconstrained(f);\n    }\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    let mut max_note_packed_len: u32 = 0;\n    if notes.len() > 0 {\n        max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (StructDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteInterface },\n                quote { get_note_type_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = note.compute_note_hash(storage_slot);\n                        let inner_nullifier = note.compute_nullifier_without_context(storage_slot, contract_address, nonce);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `process_private_note_log`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> pub Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n            ) -> pub Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_plaintext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_plaintext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_plaintext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (StructDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    quote {\n        unconstrained fn sync_notes() {\n            aztec::oracle::note_discovery::sync_notes();\n        }\n    }\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{note::note_getter_options::PropertySelector, prelude::Point};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, derive_generators, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (StructDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: StructDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteInterface` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteInterface for NoteStruct {\n///     fn get_note_type_id() -> Field {\n///         ...\n///     }\n///\n///     fn compute_note_hash(self, storage_slot: Field) -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: StructDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteInterface for $name {\n            fn get_note_type_id() -> Field {\n                $note_type_id\n            }\n\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(self.pack(), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n        }\n    }\n}\n\n/// Generates default `NoteInterface` implementation for a given partial note struct `s` and returns it as a quote.\n///\n/// impl NoteInterface for NoteStruct {\n///     fn get_note_type_id() -> Field {\n///         ...\n///     }\n///\n///     fn compute_note_hash(self, storage_slot: Field) -> Field {\n///         ...\n///     }\n/// }\n///\n/// # On differences from `generate_note_interface`\n/// We use multi-scalar multiplication (MSM) instead of Poseidon2 here since this is a partial note and therefore\n/// does require MSM's additive homomorphism property (the property is used to add to the commitment in public).\n/// We don't use this implementation for standard notes as well because Poseidon2 is significantly cheaper\n/// constraints-wise.\n///\n/// # On including length in note hash preimage\n/// For a given commitment C = a*G1 + b*G2 + c*G3 we take an x-coordinate of C.x and use it as the hash.\n/// However, due to elliptic curve symmetry about the x-axis, for any x-coordinate,\n/// there are two points with that x-coordinate. This means -C has the same hash (x-coord) as C,\n/// and the tuple [-a, -b, -c] produces the same hash as [a, b, c].\n///\n/// This property makes the hash trivially not collision resistant without including the length.\n/// By including the length l, the commitment becomes:\n/// C = a*G1 + b*G2 + c*G3 + l*G_len\n///\n/// Since -l would be -3 (an extraordinarily large number that cannot be a valid preimage length),\n/// including the length protects against these collisions.\ncomptime fn generate_note_interface_for_partial_note(\n    s: StructDefinition,\n    note_type_id: Field,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n) -> Quoted {\n    let name = s.name();\n\n    // First we compute quotes for MSM\n    // `compute_note_hash()` is computed over all the fields so we need to merge fixed and nullable.\n    let merged_fields = indexed_fixed_fields.append(indexed_nullable_fields);\n    // Now we prefix each of the merged fields with `self.` since they refer to the struct members here.\n    let prefixed_merged_fields = merged_fields.map(|(name, typ, index): (Quoted, Type, u32)| {\n        (quote { self.$name }, typ, index)\n    });\n    let (new_generators_list, new_scalars_list, _, new_aux_vars) =\n        generate_multi_scalar_mul(prefixed_merged_fields);\n\n    let (g_slot, g_len) = generate_fixed_generators();\n    let new_generators = new_generators_list.push_back(g_slot).push_back(g_len).join(quote {,});\n\n    let merged_fields_len = merged_fields.len() + 1; // +1 for the storage slot appended below\n    let new_scalars = new_scalars_list\n        .push_back(quote { std::hash::from_field_unsafe(storage_slot) })\n        .push_back(quote { std::hash::from_field_unsafe($merged_fields_len) })\n        .join(quote {,});\n\n    quote {\n        impl aztec::note::note_interface::NoteInterface for $name {\n            fn get_note_type_id() -> Field {\n                $note_type_id\n            }\n\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                $new_aux_vars\n                let point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$new_generators],\n                    [$new_scalars]\n                );\n                point.x\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: StructDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: StructDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Number of fixed generators used to ensure that we don't have a collision of indices in derive_generators(...) in\n/// the generate_multi_scalar_mul(...) function. If the indices collided this could result in a critical vulnerability\n/// (e.g. in case of G_slot collision with other another note field an attacker could move a note to an arbitrary\n/// slot).\nglobal NUM_FIXED_GENERATORS: u32 = 2;\n\n/// Generates G_slot and G_len generator point quotes.\ncomptime fn generate_fixed_generators() -> (Quoted, Quoted) {\n    let generators: [Point; NUM_FIXED_GENERATORS] =\n        derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n\n    let g_slot_x = generators[0].x;\n    let g_slot_y = generators[0].y;\n    let g_len_x = generators[1].x;\n    let g_len_y = generators[1].y;\n\n    let g_slot = quote {\n        aztec::protocol_types::point::Point { x: $g_slot_x, y: $g_slot_y, is_infinite: false }\n    };\n    let g_len = quote {\n        aztec::protocol_types::point::Point { x: $g_len_x, y: $g_len_y, is_infinite: false }\n    };\n\n    (g_slot, g_len)\n}\n\n/// Generates quotes necessary for multi-scalar multiplication of `indexed_fields` (indexed struct fields). Returns\n/// a tuple containing quotes for generators, scalars, arguments and auxiliary variables. For more info on what are\n/// auxiliary variables and how they are used, see `generate_serialize_to_fields` function.\n///\n/// Example return values:\n/// generators_list: [aztec::generators::Ga1, aztec::generators::Ga2, aztec::generators::Ga3, aztec::generators::Ga4]\n/// scalars_list: [\n///     std::hash::from_field_unsafe(amount.lo as Field),\n///     std::hash::from_field_unsafe(amount.hi as Field),\n///     std::hash::from_field_unsafe(npk_m_hash as Field),\n///     std::hash::from_field_unsafe(randomness as Field)\n/// ]\n/// args_list: [amount: U128, npk_m_hash: Field, randomness: Field]\n/// aux_vars: []\ncomptime fn generate_multi_scalar_mul(\n    indexed_fields: [(Quoted, Type, u32)],\n) -> ([Quoted], [Quoted], [Quoted], Quoted) {\n    let mut generators_list = &[];\n    let mut scalars_list = &[];\n    let mut args_list = &[];\n    let mut aux_vars_list = &[];\n    for i in 0..indexed_fields.len() {\n        // Destructure tuple containing:\n        // - field_name: the name of the struct field/member (as a Quoted type)\n        // - typ: the type of the struct field/member (as a Type)\n        // - field_start_index: index where this field starts in the serialized note array (as u32)\n        let (field_name, typ, field_start_index) = indexed_fields[i];\n        // We add NUM_FIXED_GENERATORS to the start index to avoid collision with fixed generators.\n        let start_generator_index = NUM_FIXED_GENERATORS + field_start_index;\n        let (serialization_fields, aux_vars) =\n            generate_serialize_to_fields(field_name, typ, &[], true);\n        for j in 0..serialization_fields.len() {\n            let serialization_field = serialization_fields[j];\n            let generator_index = start_generator_index + j;\n\n            let generators: [Point; 1] =\n                derive_generators(\"aztec_nr_generators\".as_bytes(), generator_index);\n            let generator_x = generators[0].x;\n            let generator_y = generators[0].y;\n\n            generators_list = generators_list.push_back(\n                quote {\n                aztec::protocol_types::point::Point { x: $generator_x, y: $generator_y, is_infinite: false }\n                },\n            );\n            scalars_list = scalars_list.push_back(\n                quote { std::hash::from_field_unsafe($serialization_field) },\n            );\n        }\n        args_list = args_list.push_back(quote { $field_name: $typ });\n        aux_vars_list = aux_vars_list.append(aux_vars);\n    }\n\n    let aux_vars = if aux_vars_list.len() > 0 {\n        let joint = aux_vars_list.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n    (generators_list, scalars_list, args_list, aux_vars)\n}\n\n/// TODO: The macros shouldn't have a hard-coded opinion of a log layout; not even for partial notes.\n/// Since partial notes are about to be refactored, I won't tackle it yet.\n//\n/// Generates setup payload for a given note struct `s`. The setup payload contains log plaintext and hiding point.\n///\n/// # On including length in note hash preimage\n/// The hiding point is computed as a multi-scalar multiplication that includes the length of the preimage\n/// to protect against collisions due to elliptic curve symmetry.\n///\n/// When computing a note hash in the partial notes flow, we take the hiding point, add the nullable fields to it\n/// in public and then we take the x-coordinate of the point and use it as the note hash. E.g. for a given commitment\n/// C = a*G1 + b*G2 + c*G3 we take an x-coordinate of C.x. However, due to elliptic curve symmetry about the x-axis,\n/// for any x-coordinate, there are two points with that x-coordinate. This means -C has the same hash (x-coord) as C,\n/// and the tuple [-a, -b, -c] produces the same hash as [a, b, c].\n///\n/// This property makes the hash trivially not collision resistant without including the length.\n/// By including the length l, the commitment becomes:\n/// C = a*G1 + b*G2 + c*G3 + l*G_len\n///\n/// Since -l would be -3 (an extraordinarily large number that cannot be a valid preimage length),\n/// including the length protects against these collisions.\n///\n/// # Example function output\n/// ```\n/// struct TokenNoteSetupPayload {\n///     log_plaintext: [u8; 160],\n///     hiding_point: aztec::protocol_types::point::Point\n/// }\n///\n/// impl TokenNoteSetupPayload {\n///     fn new(mut self, npk_m_hash: Field, randomness: Field, storage_slot: Field) -> TokenNoteSetupPayload {\n///         let hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n///             [\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... }\n///             ],\n///             [\n///                 std::hash::from_field_unsafe(npk_m_hash),\n///                 std::hash::from_field_unsafe(randomness),\n///                 std::hash::from_field_unsafe(storage_slot),\n///                 std::hash::from_field_unsafe(3)\n///             ]\n///         );\n///\n///         let let storage_slot_bytes = storage_slot.to_be_bytes();\n///         let let note_type_id_bytes = TokenNote::get_note_type_id().to_be_bytes();\n///\n///         for i in 0..32 {\n///             log_plaintext[i] = storage_slot_bytes[i];\n///             log_plaintext[32 + i] = note_type_id_bytes[i];\n///         }\n///\n///         let packed_note = [npk_m_hash as Field, randomness as Field];\n///\n///         for i in 0..packed_note.len() {\n///             let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n///             for j in 0..32 {\n///                 log_plaintext[64 + i * 32 + j] = bytes[j];\n///             }\n///         }\n///\n///         TokenNoteSetupPayload {\n///             log_plaintext,\n///             hiding_point\n///         }\n///     }\n///\n///     fn encrypt_log(self, context: &mut PrivateContext, recipient_keys: aztec::protocol_types::public_keys::PublicKeys, recipient: aztec::protocol_types::address::AztecAddress) -> [Field; 17] {\n///\n///         let encrypted_log_bytes: [u8; 513] = aztec::encrypted_logs::log_assembly_strategies::default_aes128::partial_note::::compute_partial_public_log_payload(\n///             context.this_address(),\n///             self.log_plaintext,\n///             recipient,\n///             sender\n///         );\n///\n///         aztec::utils::bytes::be_bytes_31_to_fields(encrypted_log_bytes)\n///     }\n///\n/// impl aztec::protocol_types::traits::Empty for TokenNoteSetupPayload {\n///     fn empty() -> Self {\n///         Self { log_plaintext: [0; 160], hiding_point: aztec::protocol_types::point::Point::empty() }\n///     }\n/// }\n/// ```\ncomptime fn generate_setup_payload(\n    s: StructDefinition,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n) -> (Quoted, Quoted) {\n    let name = s.name();\n    let setup_payload_name = f\"{name}SetupPayload\".quoted_contents();\n\n    // First we get the MSM related quotes\n    let (new_generators_list, new_scalars_list, new_args_list, new_aux_vars) =\n        generate_multi_scalar_mul(indexed_fixed_fields);\n    let new_args = &[quote {mut self}]\n        .append(new_args_list)\n        .push_back(quote { storage_slot: Field })\n        .join(quote {,});\n\n    let (g_slot, g_len) = generate_fixed_generators();\n    let new_generators = new_generators_list.push_back(g_slot).push_back(g_len).join(quote {,});\n    let merged_fields_len = indexed_fixed_fields.len() + indexed_nullable_fields.len() + 1; // +1 for storage_slot\n    let new_scalars = new_scalars_list\n        .push_back(quote { std::hash::from_field_unsafe(storage_slot) })\n        .push_back(quote { std::hash::from_field_unsafe($merged_fields_len) })\n        .join(quote {,});\n\n    // Then the log plaintext ones\n    let log_plaintext_length = indexed_fixed_fields.len() * 32 + 64;\n    let setup_log_plaintext: Quoted =\n        get_setup_log_plaintext_body(s, log_plaintext_length, indexed_nullable_fields);\n\n    // Then we compute values for `encrypt_log(...)` function.\n    // First, the length of the items that are broken into bytes:\n    let encrypted_log_bytes_length = 1 /* eph_pk_sign */\n        + 48 /* header_ciphertext */\n        + log_plaintext_length /* log_plaintext */\n        + 16\n        - (log_plaintext_length % 16); /* pkcs#7 aes padding */\n\n    // Each field contains 31 bytes so the length in fields is computed as ceil(encrypted_log_byte_length / 31)\n    // Recall: ceil(x / y) = (x + y - 1) // y (integer division).\n    let encrypted_log_fields_length = 1 /* tag */\n        + 1 /* eph_pk.x */\n        + (encrypted_log_bytes_length + 30) / 31;\n\n    (\n        quote {\n        pub struct $setup_payload_name {\n            pub log_plaintext: [u8; $log_plaintext_length],\n            pub hiding_point: aztec::protocol_types::point::Point\n        }\n\n        impl $setup_payload_name {\n            pub fn new($new_args) -> $setup_payload_name {\n                $new_aux_vars\n                let hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$new_generators],\n                    [$new_scalars]\n                );\n                $setup_log_plaintext\n\n                $setup_payload_name {\n                    log_plaintext,\n                    hiding_point\n                }\n            }\n\n            pub fn encrypt_log(self, context: &mut PrivateContext, recipient: aztec::protocol_types::address::AztecAddress, sender: aztec::protocol_types::address::AztecAddress) -> [Field; $encrypted_log_fields_length] {\n                aztec::encrypted_logs::log_assembly_strategies::default_aes128::partial_note::compute_partial_public_log_payload(\n                    context.this_address(),\n                    self.log_plaintext,\n                    recipient,\n                    sender,\n                )\n            }\n        }\n\n        impl aztec::protocol_types::traits::Empty for $setup_payload_name {\n            fn empty() -> Self {\n                Self { log_plaintext: [0; $log_plaintext_length], hiding_point: aztec::protocol_types::point::Point::empty() }\n            }\n        }\n    },\n        setup_payload_name,\n    )\n}\n\n/// Generates setup log plaintext for a given note struct `s`. The setup log plaintext is computed by serializing\n/// storage slot from target function arguments, note type id from the note struct `s` and the fixed fields. The fixed\n/// fields are obtained by passing the whole note struct to the `generate_serialize_to_fields(...)` function but omitting the\n/// nullable fields.\ncomptime fn get_setup_log_plaintext_body(\n    s: StructDefinition,\n    log_plaintext_length: u32,\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n) -> Quoted {\n    let name = s.name();\n\n    // Now we compute serialization of the fixed fields. We do that by passing the whole note struct\n    // to the generate_serialize_to_fields function but we omit the nullable fields.\n    let to_omit = indexed_nullable_fields.map(|(name, _, _): (Quoted, Type, u32)| name);\n    let (fields_list, aux_vars) =\n        generate_serialize_to_fields(quote { }, s.as_type(), to_omit, true);\n\n    // If there are `aux_vars` we need to join them with `;` and add a trailing `;` to the joined string.\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n    let fields = fields_list.join(quote {,});\n\n    quote {\n        let mut log_plaintext: [u8; $log_plaintext_length] = [0; $log_plaintext_length];\n\n        let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n        let note_type_id_bytes: [u8; 32] = $name::get_note_type_id().to_be_bytes();\n\n        for i in 0..32 {\n            log_plaintext[i] = storage_slot_bytes[i];\n            log_plaintext[32 + i] = note_type_id_bytes[i];\n        }\n\n        $aux_vars_for_serialization\n        let packed_note = [$fields];\n\n        for i in 0..packed_note.len() {\n            let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n            for j in 0..32 {\n                log_plaintext[64 + i * 32 + j] = bytes[j];\n            }\n        }\n    }\n}\n\n/// Generates finalization payload for a given note struct `s`. The finalization payload contains log and note hash.\n///\n/// Example:\n/// ```\n/// struct TokenNoteFinalizationPayload {\n///     context: &mut aztec::prelude::PublicContext,\n///     hiding_point_slot: Field,\n///     setup_log_slot: Field,\n///     public_values: [Field; 2]\n/// }\n///\n/// impl TokenNoteFinalizationPayload {\n///     fn new(mut self, context: &mut aztec::prelude::PublicContext, slot: Field, amount: U128) -> TokenNoteFinalizationPayload {\n///         self.context = context;\n///         self.hiding_point_slot = slot;\n///         self.setup_log_slot = slot + aztec::protocol_types::point::POINT_LENGTH as Field;\n///         self.public_values = [amount.lo as Field, amount.hi as Field];\n///         self\n///     }\n///\n///     fn emit(self) {\n///         self.emit_note_hash();\n///         self.emit_log();\n///     }\n///\n///     fn emit_note_hash(self) {\n///         let hiding_point: aztec::prelude::Point = self.context.storage_read(self.hiding_point_slot);\n///         assert(!aztec::protocol_types::traits::is_empty(hiding_point), \"transfer not prepared\");\n///\n///         let finalization_hiding_point = std::embedded_curve_ops::multi_scalar_mul([aztec::generators::Ga3, aztec::generators::Ga4], [std::hash::from_field_unsafe(self.public_values[0]), std::hash::from_field_unsafe(self.public_values[1])]) + hiding_point;\n///\n///         let note_hash = finalization_hiding_point.x;\n///\n///         self.context.push_note_hash(note_hash);\n///\n///         // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n///         // the writes\n///         // self.context.storage_write(self.hiding_point_slot, [0; aztec::protocol_types::point::POINT_LENGTH]);\n///     }\n///\n///     fn emit_log(self) {\n///         let setup_log_fields: [Field; 8] = self.context.storage_read(self.setup_log_slot);\n///\n///         let mut finalization_log = [0; 11];\n///\n///         for i in 0..setup_log_fields.len() {\n///             finalization_log[i + 1] = setup_log_fields[i];\n///         }\n///\n///         for i in 0..self.public_values.len() {\n///            finalization_log[i + 1 + 8] = self.public_values[j];\n///         }\n///\n///         finalization_log[0] = aztec::protocol_types::utils::field::field_from_bytes([\n///                 (2 >> 8) as u8, 2 as u8, 0,\n///                 (8 >> 8) as u8, 8 as u8, 0,\n///                 (91 >> 8) as u8, 91 as u8,\n///                ], true);\n///\n///         self.context.emit_public_log(finalization_log);\n///\n///         // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n///         // the writes\n///         // self.context.storage_write(self.setup_log_slot, [0; 8]);\n///     }\n/// }\n///\n/// impl aztec::protocol_types::traits::Empty for TokenNoteFinalizationPayload {\n///     fn empty() -> Self {\n///         Self { context: &mut aztec::prelude::PublicContext::empty(), hiding_point_slot: 0, setup_log_slot: 0, public_values: [0, 0] }\n///     }\n/// }\n/// ```\ncomptime fn generate_finalization_payload(\n    s: StructDefinition,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n) -> (Quoted, Quoted) {\n    let name = s.name();\n    let finalization_payload_name = f\"{name}FinalizationPayload\".quoted_contents();\n\n    // We compute serialization of the nullable fields which are to be emitted as a public log. We do that by\n    // passing the whole note struct to the `generate_serialize_to_fields(...)` function but we omit the fixed fields.\n    let to_omit = indexed_fixed_fields.map(|(name, _, _): (Quoted, Type, u32)| name);\n    let (nullable_fields_list, aux_vars) =\n        generate_serialize_to_fields(quote { }, s.as_type(), to_omit, true);\n\n    // If there are `aux_vars` we need to join them with `;` and add a trailing `;` to the joined string.\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    // We compute the log length and we concatenate the fields into a single quote.\n    let public_values_length = nullable_fields_list.len();\n    let nullable_fields = nullable_fields_list.join(quote {,});\n\n    // Now we compute quotes relevant to the multi-scalar multiplication.\n    // Note 1: We ignore the `scalars_list` and `aux_vars` return values because it's not used by the `emit_note_hash`\n    // function. Instead, we use `public_values` (defined on the finalization payload struct) and the scalar list\n    // is computed in the for-loop below.\n    // Note 2: The `args_list` is not used for note hash MSM but instead for the `new` function.\n    let (generators_list, _, args_list, _) = generate_multi_scalar_mul(indexed_nullable_fields);\n\n    // We generate scalars_list manually as we need it to refer self.public_values\n    let mut scalars_list: [Quoted] = &[];\n    for i in 0..public_values_length {\n        scalars_list =\n            scalars_list.push_back(quote { std::hash::from_field_unsafe(self.public_values[$i]) });\n    }\n\n    let generators = generators_list.join(quote {,});\n    let scalars = scalars_list.join(quote {,});\n    let args = args_list.join(quote {,});\n\n    // Then we compute values for `encrypt_log(...)` function\n    let setup_log_plaintext_length = indexed_fixed_fields.len() * 32 + 64;\n\n    let setup_log_bytes_length = 1 /* eph_pk_sign */\n        + 48 /* header_ciphertext */\n        + setup_log_plaintext_length /* log_plaintext */\n        + 16\n        - (setup_log_plaintext_length % 16); /* pkcs#7 aes padding */\n\n    // Each field contains 31 bytes so the length in fields is computed as ceil(encrypted_log_byte_length / 31)\n    // Recall: ceil(x / y) = (x + y - 1) // y (integer division).\n    let setup_log_fields_length = 1 /* tag */\n        + 1 /* eph_pk.x */\n        + (setup_log_bytes_length + 30) / 31;\n\n    let finalization_log_fields_length =\n        1 /* some length encodings (see below) */ + setup_log_fields_length + public_values_length;\n\n    (\n        quote {\n        pub struct $finalization_payload_name {\n            pub context: &mut aztec::prelude::PublicContext,\n            pub hiding_point_slot: Field,\n            pub setup_log_slot: Field,\n            pub public_values: [Field; $public_values_length],\n        }\n\n        impl $finalization_payload_name {\n            pub fn new(mut self, context: &mut aztec::prelude::PublicContext, slot: Field, $args) -> $finalization_payload_name {\n                self.context = context;\n\n                self.hiding_point_slot = slot;\n                self.setup_log_slot = slot + aztec::protocol_types::point::POINT_LENGTH as Field;\n\n                $aux_vars_for_serialization\n                self.public_values = [$nullable_fields];\n\n                self\n            }\n\n            pub fn emit(self) {\n                self.emit_note_hash();\n                self.emit_log();\n            }\n\n            pub fn emit_note_hash(self) {\n                // Read the hiding point from \"transient\" storage and check it's not empty to ensure the transfer was prepared\n                let hiding_point: aztec::prelude::Point = self.context.storage_read(self.hiding_point_slot);\n                assert(!aztec::protocol_types::traits::is_empty(hiding_point), \"transfer not prepared\");\n\n                let finalization_hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$generators],\n                    [$scalars]\n                ) + hiding_point;\n\n                let note_hash = finalization_hiding_point.x;\n\n                self.context.push_note_hash(note_hash);\n\n                // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n                // the writes\n                // TODO(#9376): Uncomment the following line.\n                // self.context.storage_write(self.hiding_point_slot, [0; aztec::protocol_types::point::POINT_LENGTH]);\n            }\n\n            pub fn emit_log(self) {\n                let max_log_len = aztec::protocol_types::constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS;\n                // Make sure we aren't overflowing the public log maximum\n                assert(\n                    $finalization_log_fields_length <= max_log_len,\n                    f\"finalization public log must not exceed {max_log_len} fields\",\n                );\n\n                // We load the setup log from storage\n                let setup_log_fields: [Field; $setup_log_fields_length] = self.context.storage_read(self.setup_log_slot);\n\n                // We append the public value to the log and emit it as unencrypted log\n                let mut finalization_log = [0; $finalization_log_fields_length];\n\n                // Populate the first field with number of public values and private values:\n                // Search the codebase for \"disgusting encoding\" to see other hardcoded instances of this encoding, that you might need to change if you ever find yourself here.\n                finalization_log[0] = aztec::protocol_types::utils::field::field_from_bytes([\n                    ($public_values_length >> 8) as u8,\n                    $public_values_length as u8,\n                    0,\n                    ($setup_log_fields_length >> 8) as u8,\n                    $setup_log_fields_length as u8,\n                ], true);\n                let mut offset = 1;\n\n                // Iterate over the partial log and copy it to the final log\n                for i in 0..setup_log_fields.len() {\n                    finalization_log[offset + i] = setup_log_fields[i];\n                }\n                offset += setup_log_fields.len();\n\n                // Iterate over the public values and append them to the log\n                for i in 0..self.public_values.len() {\n                    finalization_log[offset + i] = self.public_values[i];\n                }\n\n                // We emit the finalization log via the public logs stream\n                self.context.emit_public_log(finalization_log);\n\n                // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n                // the writes\n                // TODO(#9376): Uncomment the following line.\n                // self.context.storage_write(self.setup_log_slot, [0; $setup_log_field_length]);\n            }\n        }\n\n        impl aztec::protocol_types::traits::Empty for $finalization_payload_name {\n            fn empty() -> Self {\n                Self { context: &mut aztec::prelude::PublicContext::empty(), public_values: [0; $public_values_length], hiding_point_slot: 0, setup_log_slot: 0 }\n            }\n        }\n    },\n        finalization_payload_name,\n    )\n}\n\n/// Generates `PartialNote` implementation for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// impl PartialNote<TokenNoteSetupPayload, TokenNoteFinalizationPayload> for TokenNote {\n///     fn setup_payload() -> TokenNoteSetupPayload {\n///         TokenNoteSetupPayload::empty()\n///     }\n///\n///     fn finalization_payload() -> TokenNoteFinalizationPayload {\n///         TokenNoteFinalizationPayload::empty()\n///     }\n/// }\n/// ```\ncomptime fn generate_partial_note_impl(\n    s: StructDefinition,\n    setup_payload_name: Quoted,\n    finalization_payload_name: Quoted,\n) -> Quoted {\n    let name = s.name();\n    quote {\n        impl aztec::note::note_interface::PartialNote<$setup_payload_name, $finalization_payload_name> for $name {\n            fn setup_payload() -> $setup_payload_name {\n                $setup_payload_name::empty()\n            }\n\n            fn finalization_payload() -> $finalization_payload_name {\n                $finalization_payload_name::empty()\n            }\n        }\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: StructDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\n/// An example of a struct member occupying multiple fields is `amount` in `TokenNote` that uses `U128` type.\ncomptime fn index_note_fields(\n    s: StructDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - SetupPayload\n/// - FinalizationPayload\n/// - PartialNote trait implementation\n/// - NoteExport\n/// - NoteInterface trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\n///\n/// `nullable_fields` are a list of quotes passed in as varargs which are used to identify which fields/struct members\n/// in the partial note are nullable.\n#[varargs]\npub comptime fn partial_note(s: StructDefinition, nullable_fields: [Quoted]) -> Quoted {\n    // We separate struct members into fixed ones and nullable ones and we store info about the start index of each\n    // member in the packed note array.\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, nullable_fields);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let (setup_payload_impl, setup_payload_name) =\n        generate_setup_payload(s, indexed_fixed_fields, indexed_nullable_fields);\n    let (finalization_payload_impl, finalization_payload_name) =\n        generate_finalization_payload(s, indexed_fixed_fields, indexed_nullable_fields);\n    let note_interface_impl = generate_note_interface_for_partial_note(\n        s,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n    let partial_note_impl =\n        generate_partial_note_impl(s, setup_payload_name, finalization_payload_name);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $setup_payload_impl\n        $finalization_payload_impl\n        $note_interface_impl\n        $partial_note_impl\n        $packable_impl\n    }\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteInterface trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: StructDefinition) -> Quoted {\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note_custom_interface(s: StructDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/12012): This is broken\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n\n    quote {\n        $note_properties\n        $packable_impl\n    }\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: StructDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: StructDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_struct().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_struct().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_struct().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_struct().is_some() {\n        let (def, generics) = typ.as_struct().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_struct().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "119": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteInterface, NullifiableNote},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface + NullifiableNote + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteInterface + NullifiableNote,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = retrieved_note.note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "121": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means non-transient\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "123": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::Packable,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteInterface + NullifiableNote + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For non-transient notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request(...)` is siloed and kernels verify the siloing during note\n    // read request validation. For transient notes, however, we return an \"unsiloed\" hash, so we need to check\n    // that the contract address returned from the oracle matches. Since branching in circuits is expensive, we\n    // perform this check on all the note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface + NullifiableNote + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface + NullifiableNote + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes: BoundedVec<RetrievedNote<Note>, 16> = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // TODO: For non-transient notes, the contract address appears to be implicitly checked since we return\n            // a siloed note hash from the `compute_note_hash_for_read_request(...)` function. Investigate whether this\n            // check is needed for transient notes and if not, remove it.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            // We're not constraining note existence so we just drop the metadata\n            notes.push(notes_array[i].unwrap_unchecked().note);\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "129": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::{NoteInterface, NullifiableNote}, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface + NullifiableNote,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(retrieved_note.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteInterface,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    // If same tx note, read request always uses the normal note hash\n    if retrieved_note.note_hash_counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            retrieved_note.nonce,\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    if (retrieved_note.note_hash_counter != 0) & (retrieved_note.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(retrieved_note.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteInterface + NullifiableNote,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    compute_note_hash_for_nullify_internal(retrieved_note, note_hash_for_read_request)\n}\n"
    },
    "133": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "135": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "142": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "143": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emtitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_interface::NoteInterface, retrieved_note::RetrievedNote}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    traits::{Deserialize, FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\n) -> [Option<RetrievedNote<Note>>; S]\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote { note, contract_address, nonce, note_hash_counter };\n\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "148": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface + NullifiableNote + Eq + Packable<N>,\n{\n    // docs:start:insert\n    pub fn insert(self, note: Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface + NullifiableNote + Packable<N>,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "159": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "173": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "174": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "175": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "mod append;\nmod collapse;\nmod subarray;\nmod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "176": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "177": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "178": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "use crate::oracle::random::random;\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole bytes.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted into a Field. If the last chunk\n/// is less than 31 bytes long, then only the relevant bytes are considered.\n/// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\n/// Note: ceil(N / 31) = (N + 30) / 31\npub fn be_bytes_31_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = [0; (N + 30) / 31];\n\n    // There are N / 31 whole fields that can be populated.\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    // Note: if 31 divides N, then this loop does not execute.\n    // ceil(N/31) - floor(N/31) = 1, unless 31 divides N, in which case it's 0.\n    for _ in 0..((N + 30) / 31) - (N / 31) {\n        let mut final_field = 0;\n        let final_field_idx = fields.len() - 1;\n        let final_offset = final_field_idx * 31;\n        // N - ((N / 31) * 31) = N - floor(N/31) * 31 = the number of bytes to go in the final field.\n        for j in 0..N - ((N / 31) * 31) {\n            // Shift the existing value left by 8 bits and add the new byte\n            final_field = final_field * 256 + bytes[final_offset + j] as Field;\n        }\n\n        fields[final_field_idx] = final_field;\n    }\n\n    fields\n}\n\npub fn le_bytes_31_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = [0; (N + 30) / 31];\n\n    // There are N / 31 whole fields that can be populated.\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            let k = 31 - j - 1; // iterate in reverse.\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + k] as Field;\n        }\n        fields[i] = field;\n    }\n\n    // Note: if 31 divides N, then this loop does not execute.\n    // ceil(N/31) - floor(N/31) = 1, unless 31 divides N, in which case it's 0.\n    for _ in 0..((N + 30) / 31) - (N / 31) {\n        let mut final_field = 0;\n        let final_field_idx = fields.len() - 1;\n        let final_offset = final_field_idx * 31;\n        // N - ((N / 31) * 31) = N - floor(N/31) * 31 = the number of bytes to go in the final field.\n        for j in 0..N - ((N / 31) * 31) {\n            let k = (N - ((N / 31) * 31)) - j - 1; // iterate in reverse.\n            // Shift the existing value left by 8 bits and add the new byte\n            final_field = final_field * 256 + bytes[final_offset + k] as Field;\n        }\n        fields[final_field_idx] = final_field;\n    }\n\n    fields\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each input field must contain only 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte\n/// chunks are concatenated back together in the order of the original fields.\n///\n/// It appears that the original author of this function wants to give the caller some control\n/// over the number of bytes that are returned: the final field can be mapped to fewer than 31 bytes,\n/// based on the caller's choice of M.\n/// Given the input is N fields, and each field (except the last) is mapped to 31 bytes,\n/// we definitely need M > (N - 1) * 31 to cover those first (N - 1) fields. Hence the static assertion.\n/// TODO: this is the same as the \"le\" version of this function, save for the `field.to_be_bytes()` calls. I tried passing the conversion function in as a parameter, to reduce code duplication, but couldn't get it to work.\npub fn fields_to_be_bytes_31<let N: u32, let M: u32>(fields: [Field; N]) -> [u8; M] {\n    let mut bytes = [0; M];\n\n    std::static_assert(M > (N - 1) * 31, \"Not enough output bytes specified\");\n    // We make this assertion to keep the logic simpler:\n    std::static_assert(N * 31 >= M, \"Too many output bytes specified.\");\n\n    for i in 0..N - 1 {\n        let field = fields[i];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes[i * 31 + j] = field_as_bytes[j];\n        }\n    }\n\n    let final_field = fields[N - 1];\n    final_field.assert_max_bit_size::<8 * (M - ((N - 1) * 31))>();\n\n    let final_field_as_bytes: [u8; M - ((N - 1) * 31)] = final_field.to_be_bytes();\n\n    let start_index = (N - 1) * 31;\n    for j in 0..M - ((N - 1) * 31) {\n        bytes[start_index + j] = final_field_as_bytes[j];\n    }\n\n    bytes\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each input field must contain only 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 little-endian bytes, and the resulting 31-byte\n/// chunks are concatenated back together in the order of the original fields. You'll\n/// end up with quite a strange ordering of bytes if you use this particular function.\npub fn fields_to_le_bytes_31<let N: u32, let M: u32>(fields: [Field; N]) -> [u8; M] {\n    let mut bytes = [0; M];\n\n    std::static_assert(M > (N - 1) * 31, \"Not enough output bytes specified\");\n    // We make this assertion to keep the logic simpler:\n    std::static_assert(N * 31 >= M, \"Too many output bytes specified.\");\n\n    for i in 0..N - 1 {\n        let field = fields[i];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_le_bytes();\n\n        for j in 0..31 {\n            bytes[i * 31 + j] = field_as_bytes[j];\n        }\n    }\n\n    let final_field = fields[N - 1];\n    final_field.assert_max_bit_size::<8 * (M - ((N - 1) * 31))>();\n\n    let final_field_as_bytes: [u8; M - ((N - 1) * 31)] = final_field.to_le_bytes();\n\n    let start_index = (N - 1) * 31;\n    for j in 0..M - ((N - 1) * 31) {\n        bytes[start_index + j] = final_field_as_bytes[j];\n    }\n\n    bytes\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each field is converted to a 32-byte big-endian array.\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end,\n/// every 32 bytes. Be careful that such a gap doesn't leak information!\npub fn fields_to_be_bytes_32<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field = fields[i];\n        let field_as_bytes: [u8; 32] = field.to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\nunconstrained fn byte_to_bits(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Returns as many random bits as specified through N.\nunconstrained fn get_random_bits<let N: u32>() -> [u1; N] {\n    // Note: (N + 7) / 8 = ceil(N / 8)\n    let bytes = get_random_bytes::<(N + 7) / 8>();\n    let mut bits: [u1; N] = [0; N];\n    for i in 0..bytes.len() - 1 {\n        let mut byte = bytes[i];\n        for j in 0..8 {\n            let bit_idx = i * 8 + j;\n            bits[bit_idx] = (byte & 1) as u1;\n            byte >>= 1;\n        }\n    }\n\n    // N - ((N / 8) * 8) = N - floor(N/8) * 8 = the number of bits remaining.\n    let byte_idx = bytes.len() - 1;\n    let mut byte = bytes[byte_idx];\n    for j in 0..N - ((N / 8) * 8) {\n        let bit_idx = (byte_idx) * 8 + j;\n        bits[bit_idx] = (byte & 1) as u1;\n        byte >>= 1;\n    }\n\n    bits\n}\n\n/// Returns random bits, in chunks, according to the provided numeric generics.\nunconstrained fn get_chunks_of_random_bits<let NUM_CHUNKS: u32, let NUM_BITS: u32>() -> [[u1; NUM_BITS]; NUM_CHUNKS] {\n    let random_bits = get_random_bits::<NUM_CHUNKS * NUM_BITS>();\n    let mut chunks: [[u1; NUM_BITS]; NUM_CHUNKS] = [[0; NUM_BITS]; NUM_CHUNKS];\n    for i in 0..NUM_CHUNKS {\n        let mut chunk: [u1; NUM_BITS] = [0; NUM_BITS];\n        for j in 0..NUM_BITS {\n            chunk[j] = random_bits[i * NUM_BITS + j];\n        }\n        chunks[i] = chunk;\n    }\n    chunks\n}\n\n/**\n * Helper fn for be/le_bytes_to_padded_fields() fns.\n */\nfn pad_31_byte_fields_with_random_bits<let N: u32>(input: [Field; N]) -> [Field; N] {\n    // Safety: we can't constrain whether or not the returned bits are actually random;\n    // we can only rely on it being in the caller's best interest.\n    let chunks_of_random_bits = unsafe { get_chunks_of_random_bits::<((N + 30) / 31), 6>() };\n    let mut fields = input;\n    // We push the random bits to the \"big end\" of each field\n    let TWO_POW_248 = 0x100000000000000000000000000000000000000000000000000000000000000;\n    for i in 0..fields.len() {\n        let mut shift = TWO_POW_248;\n        for j in 0..5 {\n            fields[i] += shift * chunks_of_random_bits[i][j] as Field;\n            shift *= 2;\n        }\n\n        // This might overflow the field modulus, so we need to be careful.\n        // By this point, shift = 2 ^ 253, so will populate the 254th bit (counting from 1)\n        let field_with_254th_bit = fields[i] + shift * chunks_of_random_bits[i][6 - 1] as Field;\n\n        // Expensive comparison (one for each field), but it's important -- if we want to hide that we were\n        // working with bytes -- that we include the 254th random bit when it fits.\n        fields[i] = if (fields[i].lt(field_with_254th_bit)) {\n            field_with_254th_bit\n        } else {\n            fields[i]\n        };\n    }\n    fields\n}\n\n/**\n * The above functions be_bytes_31_to_fields and le_bytes_31_to_fields have a privacy-leakage problem:\n * they result in fields which are all 248-bits instead of 254-bits.\n * That means if the above functions are used to convert a ciphertext from bytes to\n * fields, it leaks (with very high probability) to all observers of the log that the\n * ciphertext was created with a \"bit twiddly\" encryption scheme like AES.\n * This reduces privacy sets for all apps.\n *\n * This function seeks to \"pad\" those remaining 6 bits with randomness, so that all\n * encrypted logs look even more similar (full fields of 254-bits of random-looking\n * information). Of course, this adds some extra constraints, unfortunately.\n */\npub fn le_bytes_to_padded_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = le_bytes_31_to_fields(input);\n    pad_31_byte_fields_with_random_bits(fields)\n}\n\npub fn be_bytes_to_padded_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = be_bytes_31_to_fields(input);\n    pad_31_byte_fields_with_random_bits(fields)\n}\n\nmod test {\n    use crate::utils::bytes::{\n        be_bytes_31_to_fields, fields_to_be_bytes_31, fields_to_le_bytes_31, le_bytes_31_to_fields,\n    };\n\n    // BE BYTES\n\n    #[test]\n    fn test_be_bytes_31_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = be_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_be_bytes_31() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_be_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_be_bytes_31() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_be_bytes_31(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_fewer_be_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_be_bytes_31(input);\n        println(f\"output: {output}\");\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_be_bytes_31_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = be_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_be_bytes_31() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_be_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_be_bytes_31_input_to_fields_and_back(input: [u8; 128]) {\n        let output = be_bytes_31_to_fields(input);\n        let input_back: [u8; 128] = fields_to_be_bytes_31(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_be_bytes_31_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_be_bytes_31(input);\n        let input_back = be_bytes_31_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_too_few_destination_be_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_be_bytes_31(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_be_bytes_31_value_too_large() {\n        let input = [2.pow_32(248)]; // this number is 1 bit larger than 31 bytes.\n        let _ignored_result: [u8; 31] = fields_to_be_bytes_31(input);\n    }\n\n    #[test]\n    fn test_fields_to_be_bytes_31_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_be_bytes_31(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n\n    // LE BYTES\n\n    #[test]\n    fn test_le_bytes_31_to_1_field() {\n        let input = [\n            31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10,\n            9, 8, 7, 6, 5, 4, 3, 2, 1,\n        ];\n        let output = le_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_le_bytes_31() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_le_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,\n                10, 9, 8, 7, 6, 5, 4, 3, 2, 1,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_le_bytes_31() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_le_bytes_31(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_fewer_le_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_le_bytes_31(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_le_bytes_31_to_2_fields() {\n        let input = [\n            59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38,\n            37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,\n            15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,\n        ];\n        let output = le_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n        assert_eq(output[1], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c);\n    }\n\n    #[test]\n    fn test_2_fields_to_le_bytes_31() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_le_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,\n                10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47,\n                46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 0, 0, 0,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_le_bytes_input_to_fields_and_back(input: [u8; 128]) {\n        let output = le_bytes_31_to_fields(input);\n        let input_back: [u8; 128] = fields_to_le_bytes_31(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_le_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_le_bytes_31(input);\n        let input_back = le_bytes_31_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_too_few_destination_le_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_le_bytes_31(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_le_bytes_31_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_le_bytes_31(input);\n    }\n\n    #[test]\n    fn test_fields_to_le_bytes_31_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_le_bytes_31(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "182": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "238": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "245": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "25": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "26": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// docs:start:sha256\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        // Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        // Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        // Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        // Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        // Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "262": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "263": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "264": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "277": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: U128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct U128 {\n///     lo: Field,\n///     hi: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: U128 {\n///         lo: fields[0],     // First field becomes low part of U128\n///         hi: fields[1],     // Second field becomes high part of U128\n///     },\n///     owner: AztecAddress {\n///         inner: fields[2],  // Third field becomes inner address\n///     },\n///     randomness: fields[3], // Fourth field as randomness\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that U128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        result = quote { Packable::unpack([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_struct().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_struct().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: U128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct U128 {\n///     lo: Field,\n///     hi: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_u128 }, U128, &[], false)\n/// // Returns:\n/// // ([`my_u128.lo`, `my_u128.hi`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct UintNote {\n///     value: U128,\n///     randomness: Field,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, UintNote, &[\\], false)\n/// // Returns:\n/// // ([`self.value.lo`, `self.value.hi`, `self.randomness`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - U128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: U128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let packed_struct = quote { let $packed_struct_name = $name.pack() };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_struct().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_struct().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: StructDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: StructDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: StructDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    (\n        quote {\n        impl Packable<$packed_len> for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: StructDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\n#[derive(Eq, Packable)]\npub struct ContainsU128 {\n    a: U128,\n    b: Field,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n\n#[test]\nfn contains_u128_test() {\n    let contains_u128 = ContainsU128 { a: U128::from_integer(5), b: 3 };\n    let packed = contains_u128.pack();\n    assert_eq(packed, [5, 3], \"Packed does not match the expected\");\n\n    let unpacked = ContainsU128::unpack(packed);\n    assert_eq(unpacked, contains_u128, \"Unpacked does not match the original\");\n}\n"
    },
    "279": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "280": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "289": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "300": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "319": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        // The below warning is due to visibility in noir stdlib.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "33": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "335": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "338": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "343": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "350": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "354": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/value-note/src/utils.nr",
      "source": "use crate::{filter::filter_notes_min_sum, value_note::{VALUE_NOTE_LEN, ValueNote}};\nuse dep::aztec::encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note;\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::prelude::{AztecAddress, NoteGetterOptions, PrivateContext, PrivateSet};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(\n    amount: Field,\n) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(\n        ValueNote::properties().value,\n        SortOrder.DESC,\n    )\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress, // docs:end:increment_args\n    sender: AztecAddress,\n) {\n    let note = ValueNote::new(amount, recipient);\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    // TODO: consider how to give devs choice over this `encode_and_encrypt_note` function. At the moment, it's hard-coded as one of many potential strategies.\n    balance.insert(note).emit(encode_and_encrypt_note(balance.context, recipient, sender));\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    sender: AztecAddress,\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, sender);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    sender: AztecAddress,\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, sender);\n\n    decremented\n}\n"
    },
    "355": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_interface::NullifiableNote, retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// TODO(#12008): Remove the need for the manual import of `Packable` trait here. This is a bug in macros.\nuse aztec::protocol_types::traits::Packable;\n\npub(crate) global VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n#[note]\n#[derive(Eq)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Field {\n        // We set the note_hash_counter to 0 as the note is assumed to be committed (and hence not transient).\n        let retrieved_note =\n            RetrievedNote { note: self, contract_address, nonce: note_nonce, note_hash_counter: 0 };\n        let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        ValueNote { value, owner, randomness }\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "51": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/benchmarking_contract/src/main.nr",
      "source": "// A contract used for running benchmarks.\n// We should try to change this contract as little as possible, since any modification\n// would alter the metrics we're capturing in the benchmarks, and we want to keep the\n// subject being tested as unmodified as possible so we can detect metric changes that\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Benchmarking {\n    use dep::aztec::prelude::{AztecAddress, Map, NoteGetterOptions, PrivateSet, PublicMutable};\n    use dep::value_note::{utils::increment, value_note::ValueNote};\n\n    use dep::aztec::macros::{functions::{private, public}, storage::storage};\n\n    #[storage]\n    struct Storage<Context> {\n        notes: Map<AztecAddress, PrivateSet<ValueNote, Context>, Context>,\n        balances: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n    }\n\n    // Creates a new value note for the target owner. Use this method to seed an initial set of notes.\n    #[private]\n    fn create_note(owner: AztecAddress, sender: AztecAddress, value: Field) {\n        // docs:start:increment_valuenote\n        increment(storage.notes.at(owner), value, owner, sender);\n        // docs:end:increment_valuenote\n    }\n    // Deletes a note at a specific index in the set and creates a new one with the same value.\n    // We explicitly pass in the note index so we can ensure we consume different notes when sending\n    // multiple txs that will land on the same block.\n    // See https://discourse.aztec.network/t/utxo-concurrency-issues-for-private-state/635\n    // by @rahul-kothari for a full explanation on why this is needed.\n    #[private]\n    fn recreate_note(owner: AztecAddress, sender: AztecAddress, index: u32) {\n        let owner_notes = storage.notes.at(owner);\n        let mut getter_options = NoteGetterOptions::new();\n        let notes = owner_notes.pop_notes(getter_options.set_limit(1).set_offset(index));\n        let note = notes.get(0);\n        increment(owner_notes, note.value, owner, sender);\n    }\n\n    // Reads and writes to public storage and enqueues a call to another public function.\n    #[public]\n    fn increment_balance(owner: AztecAddress, value: Field) {\n        let current = storage.balances.at(owner).read();\n        storage.balances.at(owner).write(current + value);\n        Benchmarking::at(context.this_address()).broadcast(owner).call(&mut context);\n    }\n\n    // Emits a public log.\n    #[public]\n    fn broadcast(owner: AztecAddress) {\n        context.emit_public_log(storage.balances.at(owner).read());\n    }\n\n    // Does a bunch of heavy compute\n    #[public]\n    fn sha256_hash_2048(data: [u8; 2048]) -> [u8; 32] {\n        sha256::sha256_var(data, data.len() as u64)\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, debug_log::debug_log,\n};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size and extra\n/// fields in the log (e.g. the combined log and note type ID).\n// TODO (#11634): we're assuming here that the entire log is plaintext, which is not true due to headers, encryption\n// padding, etc. Notes can't actually be this large.\npub global MAX_NOTE_PACKED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteInterface::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NullifiableNote::compute_nullifier_without_context\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let inner_nullifier = note.compute_nullifier_without_context(storage_slot, contract_address, nonce);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_note_type_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "76": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note #{}\",\n                    [(*i) as Field],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\"Completion log found for partial note #{}\", [(*i) as Field]);\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note {1}\",\n                    [discovered_notes.len() as Field, (*i) as Field],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "78": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's plaintext, searching for private notes or partial notes. Private notes result in nonce discovery\n/// being performed prior to delivery, which requires knowledge of the transaction hash in which the notes would've been\n/// created (typically the same transaction in which the log was emitted), along with the list of unique note hashes in\n/// said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // The first thing to do is to determine what type of private log we're processing. We currently just have two log\n    // types: 0 for private notes and 1 for partial notes. This will likely be expanded and improved upon in the future\n    // to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        process_private_note_log(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        panic(f\"Unknown log type id {log_type_id}\");\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other disimilar log types, such as events. Ideally we'd be able to leverage\n    // enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\nunconstrained fn process_private_note_log<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "79": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use std::hash::{from_field_unsafe as fr_to_fq_unsafe, sha256};\n\nuse dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "84": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::{be_bytes_31_to_fields, get_random_bytes}, point::get_sign_of_point},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\nuse std::aes128::aes128_encrypt;\n\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48; // contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\n\n/*\n * WHY IS THERE LOTS OF CODE DUPLICATION BETWEEN event.nr and note.nr?\n * It's because there are a few more optimisations that can be done for notes,\n * and so the stuff that looks like duplicated code currently, won't be\n * the same for long.\n * To modularise now feels premature, because we might get that modularisation wrong.\n * Much better (imo) to have a flattened templates for log assembly, because it\n * makes it much easier for us all to follow, it serves as a nice example for the\n * community to follow (if they wish to roll their own log layouts), and it gives\n * us more time to spot common patterns across all kinds of log layouts.\n */\n\n/*\n * LOG CONFIGURATION CHOICES:\n *\n * deliver_to: INPUT as recipient: AztecAddress\n * encrypt_with: aes128 CBC (Cipher Block Chaining)\n * shared_secret: ephemeral\n * shared_secret_randomness_extraction_hash: sha256\n * tag: true\n * tag_from: INPUT as sender: AztecAddress\n *\n * Note-specific:\n * derive_note_randomness_from_shared_secret: false\n *\n */\n\n/*\n * LOG LAYOUT CHOICE:\n *\n * Short explanation:\n * log = [tag, epk, header_ct=[[contract_address, ct_len], pkcs7_pad], ct=[[pt], pkcs7_pad], some bytes padding, some fields padding]\n *\n * Long explanation:\n * tag: Field\n * epk: [Field, u8]\n * header_ct: [[u8; 32], [u8; 2], [u8; 16]]\n * ct: [[u8; 2], [u8; x], [u8; y]]\n *\n * More precisely (in pseudocode):\n *\n * log = [\n *     tag: Field,\n *     Epk: Field,\n *\n *     le_bytes_31_to_fields(\n *\n *         log_bytes: [\n *             eph_pk_sign: [u8; 1],\n *\n *             header_ciphertext: aes_encrypt(\n *                 contract_address: [u8; 32],\n *                 ct_length: [u8; 2],\n *\n *                 // the aes128_encrypt fn automatically inserts padding:\n *                 header_pt_aes_padding: [u8; 14], // `16 - (input.len() % 16)`\n\n *             ): [u8; 48],\n *\n *             ciphertext: aes_encrypt(\n *                 final_pt: [\n *                     pt: {\n *                         note_bytes: {\n *                             storage_slot: [u8; 32],\n *                             note_type_id: [u8; 32],\n *                             ...note: [u8; N * 32],\n *                         }: [u8; N * 32 + 64],\n *                     }: [u8; N * 32 + 64],\n\n *                 ]: [u8; N * 32 + 64],\n *\n *                 // the aes128_encrypt fn automatically inserts padding:\n *                 pt_aes_padding: [u8; 16 - ( (|pt_length| + |pt|) % 16 )]\n *\n *             ): [u8; |pt| + |pt_aes_padding|]\n *                [u8; |ct|]\n *\n *             log_bytes_padding_to_mult_31: [u8; 31 * ceil((1 + 48 + |ct|)/31) - (1 + 48 + |ct|)],\n *                                           [u8; p]\n *\n *         ]: [u8; 1 + 48 + |ct| + p]\n *\n *     ): [Field; (1 + 48 + |ct| + p) / 31]\n *\n *     log_fields_padding: [Field; PRIVATE_LOG_SIZE_IN_FIELDS - 2 - (1 + 48 + |ct| + p) / 31],\n *\n * ]: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\n *\n *\n */\n\n/********************************************************/\n// Disgusting arithmetic on generics\n/********************************************************/\n\n// In this section, instead of initialising arrays with very complicated generic\n// arithmetic, such as:\n// let my_arr: [u8; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))] = [0; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))];\n//... we instead do the arithmetic a little bit at a time, so that the computation\n// can be audited and understood. Now, we can't do arithmetic on generics in the body\n// of a function, so we abusing functions in the following way:\n\n// |full_pt| = |pt| = (N * 32) + 64\nfn get_arr_of_size__full_plaintext<let PT: u32>() -> [u8; PT] {\n    [0; PT]\n}\n\n// |pt_aes_padding| = 16 - (|full_pt| % 16)\nfn get_arr_of_size__plaintext_aes_padding<let FULL_PT: u32>(\n    _full_pt: [u8; FULL_PT],\n) -> [u8; 16 - (FULL_PT % 16)] {\n    [0; 16 - (FULL_PT % 16)]\n}\n\n// |ct| = |full_pt| + |pt_aes_padding|\nfn get_arr_of_size__ciphertext<let FULL_PT: u32, let PT_AES_PADDING: u32>(\n    _full_pt: [u8; FULL_PT],\n    _pt_aes_padding: [u8; PT_AES_PADDING],\n) -> [u8; FULL_PT + PT_AES_PADDING] {\n    [0; FULL_PT + PT_AES_PADDING]\n}\n\n// Ok, so we have the following bytes:\n// eph_pk_sign, header_ciphertext, ciphertext:\n// Let lbwop = 1 + 48 + |ct| // aka log bytes without padding\nfn get_arr_of_size__log_bytes_without_padding<let CT: u32>(_ct: [u8; CT]) -> [u8; 1 + 48 + CT] {\n    [0; 1 + 48 + CT]\n}\n\n// Recall:\n//   lbwop := 1 + 48 + |ct| // aka log bytes without padding\n// We now want to pad b to the next multiple of 31, so as to \"fill\" fields.\n// Let p be that padding.\n// p = 31 * ceil(lbwop / 31) - lbwop\n//   = 31 * ((lbwop + 30) // 31) - lbwop\n//     (because ceil(x / y) = (x + y - 1) // y ).\nfn get_arr_of_size__log_bytes_padding<let LBWOP: u32>(\n    _lbwop: [u8; LBWOP],\n) -> [u8; (31 * ((LBWOP + 30) / 31)) - LBWOP] {\n    [0; (31 * ((LBWOP + 30) / 31)) - LBWOP]\n}\n\n// |log_bytes| = 1 + 48 + |ct| + p // aka log bytes (with padding)\n// Recall:\n//   lbwop := 1 + 48 + |ct|\n//   p is the padding\nfn get_arr_of_size__log_bytes<let LBWOP: u32, let P: u32>(\n    _lbwop: [u8; LBWOP],\n    _p: [u8; P],\n) -> [u8; LBWOP + P] {\n    [0; LBWOP + P]\n}\n\n// The return type is pasted from the LSP's expectation, because it was too difficult\n// to match its weird way of doing algebra. It doesn't know all rules of arithmetic.\n// PT is the plaintext length.\npub(crate) fn get_arr_of_size__log_bytes_padding__from_PT<let PT: u32>() -> [u8; ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49))] {\n    let full_pt = get_arr_of_size__full_plaintext::<PT>();\n    let pt_aes_padding = get_arr_of_size__plaintext_aes_padding(full_pt);\n    let ct = get_arr_of_size__ciphertext(full_pt, pt_aes_padding);\n    let lbwop = get_arr_of_size__log_bytes_without_padding(ct);\n    let p = get_arr_of_size__log_bytes_padding(lbwop);\n    p\n}\n\n// The return type is pasted from the LSP's expectation, because it was too difficult\n// to match its weird way of doing algebra. It doesn't know all rules of arithmetic.\npub(crate) fn get_arr_of_size__log_bytes__from_PT<let PT: u32>() -> [u8; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))] {\n    let full_pt = get_arr_of_size__full_plaintext::<PT>();\n    let pt_aes_padding = get_arr_of_size__plaintext_aes_padding(full_pt);\n    let ct = get_arr_of_size__ciphertext(full_pt, pt_aes_padding);\n    let lbwop = get_arr_of_size__log_bytes_without_padding(ct);\n    let p = get_arr_of_size__log_bytes_padding(lbwop);\n    let log_bytes = get_arr_of_size__log_bytes(lbwop, p);\n    log_bytes\n}\n\n/********************************************************/\n// End of disgusting arithmetic on generics\n/********************************************************/\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\n/// This particular log assembly strategy (AES 128) requires the note (and the\n/// note_id and the storage_slot) to be converted into bytes, because the aes function\n/// operates on bytes; not fields.\n/// NB: The extra `+ 64` bytes is for the note_id and the storage_slot of the note:\nfn compute_note_plaintext_for_this_strategy<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n) -> [u8; N * 32 + 64]\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n\n    // TODO(#10952): The following can be reduced to 7 bits\n    let note_type_id_bytes: [u8; 32] = Note::get_note_type_id().to_be_bytes();\n\n    // We combine all the bytes into plaintext_bytes:\n    let mut plaintext_bytes: [u8; N * 32 + 64] = [0; N * 32 + 64];\n    for i in 0..32 {\n        plaintext_bytes[i] = storage_slot_bytes[i];\n        plaintext_bytes[32 + i] = note_type_id_bytes[i];\n    }\n\n    for i in 0..packed_note.len() {\n        let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n        for j in 0..32 {\n            plaintext_bytes[64 + i * 32 + j] = bytes[j];\n        }\n    }\n\n    plaintext_bytes\n}\n\nfn compute_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient); // not to be confused with the tagging shared secret\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Compute the plaintext\n    // *****************************************************************************\n\n    let final_plaintext_bytes = compute_note_plaintext_for_this_strategy(note, storage_slot);\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(final_plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + ((N * 32) + 64) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address = context.this_address();\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 =\n        get_arr_of_size__log_bytes_padding__from_PT::<(N * 32) + 64>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<(N * 32) + 64>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    let log_bytes_as_fields = be_bytes_31_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // Safety: randomness cannot be constrained.\n        final_log[i] = unsafe { random() };\n    }\n\n    final_log\n}\n\nunconstrained fn compute_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    compute_log(context, note, storage_slot, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_log(*context, note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n// Important note: this function -- although called \"unconstrained\" -- the\n// function is not labelled as `unconstrained`, because we pass a reference to the\n// context.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let encrypted_log =\n            unsafe { compute_log_unconstrained(*context, note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\nmod test {\n    use crate::test::{helpers::test_environment::TestEnvironment, mocks::mock_note::MockNote};\n    use dep::protocol_types::address::AztecAddress;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n        let mut context = env.private();\n\n        // I'm not sure how to initialise an `env` or `context` with a consistent contract address for every run of this test; the value kept changing each time. So I'm going to overwrite it now:\n        context.inputs.call_context.contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        ); // This is an address copied to match the typescript one.\n\n        let storage_slot = 42;\n        let note = MockNote::new(1234).build_note();\n        let contract_address = context.this_address();\n\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = super::compute_note_plaintext_for_this_strategy(note, storage_slot);\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = super::compute_log(context, note, storage_slot, recipient, sender);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x0d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701fa7,\n            0x000194e6d7872db8f61e8e59f23580f4db45d13677f873ec473a409cf61fd04d,\n            0x00334e5fb6083721f3eb4eef500876af3c9acfab0a1cb1804b930606fdb0b283,\n            0x00af91db798fa320746831a59b74362dfd0cf9e7c239f6aad11a4b47d0d870ee,\n            0x00d25a054613a83be7be8512f2c09664bc4f7ab60a127b06584f476918581b8a,\n            0x003840d100d8c1d78d4b68b787ed353ebfb8cd2987503d3b472f614f25799a18,\n            0x003f38322629d401010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n}\n"
    },
    "90": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "99": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::embedded_curve_ops::multi_scalar_mul;\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    }
  }
}
