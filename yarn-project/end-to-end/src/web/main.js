/*! For license information please see main.js.LICENSE.txt */
var e,t,n={5949:(e,t,n)=>{var s=n(8662)();function i(e,t){if(e===t)return 0;for(var n=e.length,s=t.length,i=0,r=Math.min(n,s);i<r;++i)if(e[i]!==t[i]){n=e[i],s=t[i];break}return n<s?-1:s<n?1:0}function r(e){return n.g.Buffer&&"function"==typeof n.g.Buffer.isBuffer?n.g.Buffer.isBuffer(e):!(null==e||!e._isBuffer)}var a=n(2851),o=Object.prototype.hasOwnProperty,l=Array.prototype.slice,c="foo"===function(){}.name;function d(e){return Object.prototype.toString.call(e)}function u(e){return!r(e)&&"function"==typeof n.g.ArrayBuffer&&("function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):!!e&&(e instanceof DataView||!!(e.buffer&&e.buffer instanceof ArrayBuffer)))}var f=e.exports=b,h=/\s*function\s+([^\(\s]*)\s*/;function p(e){if(a.isFunction(e)){if(c)return e.name;var t=e.toString().match(h);return t&&t[1]}}function m(e,t){return"string"==typeof e?e.length<t?e:e.slice(0,t):e}function g(e){if(c||!a.isFunction(e))return a.inspect(e);var t=p(e);return"[Function"+(t?": "+t:"")+"]"}function _(e,t,n,s,i){throw new f.AssertionError({message:n,actual:e,expected:t,operator:s,stackStartFunction:i})}function b(e,t){e||_(e,!0,t,"==",f.ok)}function y(e,t,n,s){if(e===t)return!0;if(r(e)&&r(t))return 0===i(e,t);if(a.isDate(e)&&a.isDate(t))return e.getTime()===t.getTime();if(a.isRegExp(e)&&a.isRegExp(t))return e.source===t.source&&e.global===t.global&&e.multiline===t.multiline&&e.lastIndex===t.lastIndex&&e.ignoreCase===t.ignoreCase;if(null!==e&&"object"==typeof e||null!==t&&"object"==typeof t){if(u(e)&&u(t)&&d(e)===d(t)&&!(e instanceof Float32Array||e instanceof Float64Array))return 0===i(new Uint8Array(e.buffer),new Uint8Array(t.buffer));if(r(e)!==r(t))return!1;var o=(s=s||{actual:[],expected:[]}).actual.indexOf(e);return-1!==o&&o===s.expected.indexOf(t)||(s.actual.push(e),s.expected.push(t),function(e,t,n,s){if(null==e||null==t)return!1;if(a.isPrimitive(e)||a.isPrimitive(t))return e===t;if(n&&Object.getPrototypeOf(e)!==Object.getPrototypeOf(t))return!1;var i=A(e),r=A(t);if(i&&!r||!i&&r)return!1;if(i)return y(e=l.call(e),t=l.call(t),n);var o,c,d=v(e),u=v(t);if(d.length!==u.length)return!1;for(d.sort(),u.sort(),c=d.length-1;c>=0;c--)if(d[c]!==u[c])return!1;for(c=d.length-1;c>=0;c--)if(!y(e[o=d[c]],t[o],n,s))return!1;return!0}(e,t,n,s))}return n?e===t:e==t}function A(e){return"[object Arguments]"==Object.prototype.toString.call(e)}function w(e,t){if(!e||!t)return!1;if("[object RegExp]"==Object.prototype.toString.call(t))return t.test(e);try{if(e instanceof t)return!0}catch(e){}return!Error.isPrototypeOf(t)&&!0===t.call({},e)}function x(e,t,n,s){var i;if("function"!=typeof t)throw new TypeError('"block" argument must be a function');"string"==typeof n&&(s=n,n=null),i=function(e){var t;try{e()}catch(e){t=e}return t}(t),s=(n&&n.name?" ("+n.name+").":".")+(s?" "+s:"."),e&&!i&&_(i,n,"Missing expected exception"+s);var r="string"==typeof s,o=!e&&i&&!n;if((!e&&a.isError(i)&&r&&w(i,n)||o)&&_(i,n,"Got unwanted exception"+s),e&&i&&n&&!w(i,n)||!e&&i)throw i}f.AssertionError=function(e){this.name="AssertionError",this.actual=e.actual,this.expected=e.expected,this.operator=e.operator,e.message?(this.message=e.message,this.generatedMessage=!1):(this.message=function(e){return m(g(e.actual),128)+" "+e.operator+" "+m(g(e.expected),128)}(this),this.generatedMessage=!0);var t=e.stackStartFunction||_;if(Error.captureStackTrace)Error.captureStackTrace(this,t);else{var n=new Error;if(n.stack){var s=n.stack,i=p(t),r=s.indexOf("\n"+i);if(r>=0){var a=s.indexOf("\n",r+1);s=s.substring(a+1)}this.stack=s}}},a.inherits(f.AssertionError,Error),f.fail=_,f.ok=b,f.equal=function(e,t,n){e!=t&&_(e,t,n,"==",f.equal)},f.notEqual=function(e,t,n){e==t&&_(e,t,n,"!=",f.notEqual)},f.deepEqual=function(e,t,n){y(e,t,!1)||_(e,t,n,"deepEqual",f.deepEqual)},f.deepStrictEqual=function(e,t,n){y(e,t,!0)||_(e,t,n,"deepStrictEqual",f.deepStrictEqual)},f.notDeepEqual=function(e,t,n){y(e,t,!1)&&_(e,t,n,"notDeepEqual",f.notDeepEqual)},f.notDeepStrictEqual=function e(t,n,s){y(t,n,!0)&&_(t,n,s,"notDeepStrictEqual",e)},f.strictEqual=function(e,t,n){e!==t&&_(e,t,n,"===",f.strictEqual)},f.notStrictEqual=function(e,t,n){e===t&&_(e,t,n,"!==",f.notStrictEqual)},f.throws=function(e,t,n){x(!0,e,t,n)},f.doesNotThrow=function(e,t,n){x(!1,e,t,n)},f.ifError=function(e){if(e)throw e},f.strict=s((function e(t,n){t||_(t,!0,n,"==",e)}),f,{equal:f.strictEqual,deepEqual:f.deepStrictEqual,notEqual:f.notStrictEqual,notDeepEqual:f.notDeepStrictEqual}),f.strict.strict=f.strict;var v=Object.keys||function(e){var t=[];for(var n in e)o.call(e,n)&&t.push(n);return t}},9848:e=>{"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}},1601:e=>{e.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},2851:(e,t,n)=>{var s=/%[sdj%]/g;t.format=function(e){if(!g(e)){for(var t=[],n=0;n<arguments.length;n++)t.push(a(arguments[n]));return t.join(" ")}n=1;for(var i=arguments,r=i.length,o=String(e).replace(s,(function(e){if("%%"===e)return"%";if(n>=r)return e;switch(e){case"%s":return String(i[n++]);case"%d":return Number(i[n++]);case"%j":try{return JSON.stringify(i[n++])}catch(e){return"[Circular]"}default:return e}})),l=i[n];n<r;l=i[++n])p(l)||!y(l)?o+=" "+l:o+=" "+a(l);return o},t.deprecate=function(e,s){if(_(n.g.process))return function(){return t.deprecate(e,s).apply(this,arguments)};if(!0===process.noDeprecation)return e;var i=!1;return function(){if(!i){if(process.throwDeprecation)throw new Error(s);process.traceDeprecation?console.trace(s):console.error(s),i=!0}return e.apply(this,arguments)}};var i,r={};function a(e,n){var s={seen:[],stylize:l};return arguments.length>=3&&(s.depth=arguments[2]),arguments.length>=4&&(s.colors=arguments[3]),h(n)?s.showHidden=n:n&&t._extend(s,n),_(s.showHidden)&&(s.showHidden=!1),_(s.depth)&&(s.depth=2),_(s.colors)&&(s.colors=!1),_(s.customInspect)&&(s.customInspect=!0),s.colors&&(s.stylize=o),c(s,e,s.depth)}function o(e,t){var n=a.styles[t];return n?"["+a.colors[n][0]+"m"+e+"["+a.colors[n][1]+"m":e}function l(e,t){return e}function c(e,n,s){if(e.customInspect&&n&&x(n.inspect)&&n.inspect!==t.inspect&&(!n.constructor||n.constructor.prototype!==n)){var i=n.inspect(s,e);return g(i)||(i=c(e,i,s)),i}var r=function(e,t){if(_(t))return e.stylize("undefined","undefined");if(g(t)){var n="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(n,"string")}return m(t)?e.stylize(""+t,"number"):h(t)?e.stylize(""+t,"boolean"):p(t)?e.stylize("null","null"):void 0}(e,n);if(r)return r;var a=Object.keys(n),o=function(e){var t={};return e.forEach((function(e,n){t[e]=!0})),t}(a);if(e.showHidden&&(a=Object.getOwnPropertyNames(n)),w(n)&&(a.indexOf("message")>=0||a.indexOf("description")>=0))return d(n);if(0===a.length){if(x(n)){var l=n.name?": "+n.name:"";return e.stylize("[Function"+l+"]","special")}if(b(n))return e.stylize(RegExp.prototype.toString.call(n),"regexp");if(A(n))return e.stylize(Date.prototype.toString.call(n),"date");if(w(n))return d(n)}var y,v="",E=!1,M=["{","}"];return f(n)&&(E=!0,M=["[","]"]),x(n)&&(v=" [Function"+(n.name?": "+n.name:"")+"]"),b(n)&&(v=" "+RegExp.prototype.toString.call(n)),A(n)&&(v=" "+Date.prototype.toUTCString.call(n)),w(n)&&(v=" "+d(n)),0!==a.length||E&&0!=n.length?s<0?b(n)?e.stylize(RegExp.prototype.toString.call(n),"regexp"):e.stylize("[Object]","special"):(e.seen.push(n),y=E?function(e,t,n,s,i){for(var r=[],a=0,o=t.length;a<o;++a)z(t,String(a))?r.push(u(e,t,n,s,String(a),!0)):r.push("");return i.forEach((function(i){i.match(/^\d+$/)||r.push(u(e,t,n,s,i,!0))})),r}(e,n,s,o,a):a.map((function(t){return u(e,n,s,o,t,E)})),e.seen.pop(),function(e,t,n){return e.reduce((function(e,t){return t.indexOf("\n"),e+t.replace(/\u001b\[\d\d?m/g,"").length+1}),0)>60?n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1]:n[0]+t+" "+e.join(", ")+" "+n[1]}(y,v,M)):M[0]+v+M[1]}function d(e){return"["+Error.prototype.toString.call(e)+"]"}function u(e,t,n,s,i,r){var a,o,l;if((l=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?o=l.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):l.set&&(o=e.stylize("[Setter]","special")),z(s,i)||(a="["+i+"]"),o||(e.seen.indexOf(l.value)<0?(o=p(n)?c(e,l.value,null):c(e,l.value,n-1)).indexOf("\n")>-1&&(o=r?o.split("\n").map((function(e){return"  "+e})).join("\n").substr(2):"\n"+o.split("\n").map((function(e){return"   "+e})).join("\n")):o=e.stylize("[Circular]","special")),_(a)){if(r&&i.match(/^\d+$/))return o;(a=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+o}function f(e){return Array.isArray(e)}function h(e){return"boolean"==typeof e}function p(e){return null===e}function m(e){return"number"==typeof e}function g(e){return"string"==typeof e}function _(e){return void 0===e}function b(e){return y(e)&&"[object RegExp]"===v(e)}function y(e){return"object"==typeof e&&null!==e}function A(e){return y(e)&&"[object Date]"===v(e)}function w(e){return y(e)&&("[object Error]"===v(e)||e instanceof Error)}function x(e){return"function"==typeof e}function v(e){return Object.prototype.toString.call(e)}function E(e){return e<10?"0"+e.toString(10):e.toString(10)}t.debuglog=function(e){if(_(i)&&(i={NODE_ENV:"production"}.NODE_DEBUG||""),e=e.toUpperCase(),!r[e])if(new RegExp("\\b"+e+"\\b","i").test(i)){var n=process.pid;r[e]=function(){var s=t.format.apply(t,arguments);console.error("%s %d: %s",e,n,s)}}else r[e]=function(){};return r[e]},t.inspect=a,a.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},a.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.isArray=f,t.isBoolean=h,t.isNull=p,t.isNullOrUndefined=function(e){return null==e},t.isNumber=m,t.isString=g,t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=_,t.isRegExp=b,t.isObject=y,t.isDate=A,t.isError=w,t.isFunction=x,t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=n(1601);var M=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function z(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.log=function(){var e,n;console.log("%s - %s",(n=[E((e=new Date).getHours()),E(e.getMinutes()),E(e.getSeconds())].join(":"),[e.getDate(),M[e.getMonth()],n].join(" ")),t.format.apply(t,arguments))},t.inherits=n(9848),t._extend=function(e,t){if(!t||!y(t))return e;for(var n=Object.keys(t),s=n.length;s--;)e[n[s]]=t[n[s]];return e}},7322:(e,t)=>{t.byteLength=function(e){var t=o(e),n=t[0],s=t[1];return 3*(n+s)/4-s},t.toByteArray=function(e){var t,n,r=o(e),a=r[0],l=r[1],c=new i(function(e,t,n){return 3*(t+n)/4-n}(0,a,l)),d=0,u=l>0?a-4:a;for(n=0;n<u;n+=4)t=s[e.charCodeAt(n)]<<18|s[e.charCodeAt(n+1)]<<12|s[e.charCodeAt(n+2)]<<6|s[e.charCodeAt(n+3)],c[d++]=t>>16&255,c[d++]=t>>8&255,c[d++]=255&t;return 2===l&&(t=s[e.charCodeAt(n)]<<2|s[e.charCodeAt(n+1)]>>4,c[d++]=255&t),1===l&&(t=s[e.charCodeAt(n)]<<10|s[e.charCodeAt(n+1)]<<4|s[e.charCodeAt(n+2)]>>2,c[d++]=t>>8&255,c[d++]=255&t),c},t.fromByteArray=function(e){for(var t,s=e.length,i=s%3,r=[],a=16383,o=0,c=s-i;o<c;o+=a)r.push(l(e,o,o+a>c?c:o+a));return 1===i?(t=e[s-1],r.push(n[t>>2]+n[t<<4&63]+"==")):2===i&&(t=(e[s-2]<<8)+e[s-1],r.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"=")),r.join("")};for(var n=[],s=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0;a<64;++a)n[a]=r[a],s[r.charCodeAt(a)]=a;function o(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function l(e,t,s){for(var i,r,a=[],o=t;o<s;o+=3)i=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),a.push(n[(r=i)>>18&63]+n[r>>12&63]+n[r>>6&63]+n[63&r]);return a.join("")}s["-".charCodeAt(0)]=62,s["_".charCodeAt(0)]=63},8891:(e,t,n)=>{const s=n(7322),i=n(8239),r="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=l,t.SlowBuffer=function(e){return+e!=e&&(e=0),l.alloc(+e)},t.INSPECT_MAX_BYTES=50;const a=2147483647;function o(e){if(e>a)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,l.prototype),t}function l(e,t,n){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return u(e)}return c(e,t,n)}function c(e,t,n){if("string"==typeof e)return function(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!l.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const n=0|m(e,t);let s=o(n);const i=s.write(e,t);return i!==n&&(s=s.slice(0,i)),s}(e,t);if(ArrayBuffer.isView(e))return function(e){if(W(e,Uint8Array)){const t=new Uint8Array(e);return h(t.buffer,t.byteOffset,t.byteLength)}return f(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(W(e,ArrayBuffer)||e&&W(e.buffer,ArrayBuffer))return h(e,t,n);if("undefined"!=typeof SharedArrayBuffer&&(W(e,SharedArrayBuffer)||e&&W(e.buffer,SharedArrayBuffer)))return h(e,t,n);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const s=e.valueOf&&e.valueOf();if(null!=s&&s!==e)return l.from(s,t,n);const i=function(e){if(l.isBuffer(e)){const t=0|p(e.length),n=o(t);return 0===n.length||e.copy(n,0,0,t),n}return void 0!==e.length?"number"!=typeof e.length||V(e.length)?o(0):f(e):"Buffer"===e.type&&Array.isArray(e.data)?f(e.data):void 0}(e);if(i)return i;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return l.from(e[Symbol.toPrimitive]("string"),t,n);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function d(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function u(e){return d(e),o(e<0?0:0|p(e))}function f(e){const t=e.length<0?0:0|p(e.length),n=o(t);for(let s=0;s<t;s+=1)n[s]=255&e[s];return n}function h(e,t,n){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(n||0))throw new RangeError('"length" is outside of buffer bounds');let s;return s=void 0===t&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,t):new Uint8Array(e,t,n),Object.setPrototypeOf(s,l.prototype),s}function p(e){if(e>=a)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+a.toString(16)+" bytes");return 0|e}function m(e,t){if(l.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||W(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const n=e.length,s=arguments.length>2&&!0===arguments[2];if(!s&&0===n)return 0;let i=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":return Z(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return J(e).length;default:if(i)return s?-1:Z(e).length;t=(""+t).toLowerCase(),i=!0}}function g(e,t,n){let s=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return C(this,t,n);case"utf8":case"utf-8":return z(this,t,n);case"ascii":return F(this,t,n);case"latin1":case"binary":return k(this,t,n);case"base64":return M(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,t,n);default:if(s)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),s=!0}}function _(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function b(e,t,n,s,i){if(0===e.length)return-1;if("string"==typeof n?(s=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),V(n=+n)&&(n=i?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(i)return-1;n=e.length-1}else if(n<0){if(!i)return-1;n=0}if("string"==typeof t&&(t=l.from(t,s)),l.isBuffer(t))return 0===t.length?-1:y(e,t,n,s,i);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,s,i);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,s,i){let r,a=1,o=e.length,l=t.length;if(void 0!==s&&("ucs2"===(s=String(s).toLowerCase())||"ucs-2"===s||"utf16le"===s||"utf-16le"===s)){if(e.length<2||t.length<2)return-1;a=2,o/=2,l/=2,n/=2}function c(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}if(i){let s=-1;for(r=n;r<o;r++)if(c(e,r)===c(t,-1===s?0:r-s)){if(-1===s&&(s=r),r-s+1===l)return s*a}else-1!==s&&(r-=r-s),s=-1}else for(n+l>o&&(n=o-l),r=n;r>=0;r--){let n=!0;for(let s=0;s<l;s++)if(c(e,r+s)!==c(t,s)){n=!1;break}if(n)return r}return-1}function A(e,t,n,s){n=Number(n)||0;const i=e.length-n;s?(s=Number(s))>i&&(s=i):s=i;const r=t.length;let a;for(s>r/2&&(s=r/2),a=0;a<s;++a){const s=parseInt(t.substr(2*a,2),16);if(V(s))return a;e[n+a]=s}return a}function w(e,t,n,s){return X(Z(t,e.length-n),e,n,s)}function x(e,t,n,s){return X(function(e){const t=[];for(let n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,s)}function v(e,t,n,s){return X(J(t),e,n,s)}function E(e,t,n,s){return X(function(e,t){let n,s,i;const r=[];for(let a=0;a<e.length&&!((t-=2)<0);++a)n=e.charCodeAt(a),s=n>>8,i=n%256,r.push(i),r.push(s);return r}(t,e.length-n),e,n,s)}function M(e,t,n){return 0===t&&n===e.length?s.fromByteArray(e):s.fromByteArray(e.slice(t,n))}function z(e,t,n){n=Math.min(e.length,n);const s=[];let i=t;for(;i<n;){const t=e[i];let r=null,a=t>239?4:t>223?3:t>191?2:1;if(i+a<=n){let n,s,o,l;switch(a){case 1:t<128&&(r=t);break;case 2:n=e[i+1],128==(192&n)&&(l=(31&t)<<6|63&n,l>127&&(r=l));break;case 3:n=e[i+1],s=e[i+2],128==(192&n)&&128==(192&s)&&(l=(15&t)<<12|(63&n)<<6|63&s,l>2047&&(l<55296||l>57343)&&(r=l));break;case 4:n=e[i+1],s=e[i+2],o=e[i+3],128==(192&n)&&128==(192&s)&&128==(192&o)&&(l=(15&t)<<18|(63&n)<<12|(63&s)<<6|63&o,l>65535&&l<1114112&&(r=l))}}null===r?(r=65533,a=1):r>65535&&(r-=65536,s.push(r>>>10&1023|55296),r=56320|1023&r),s.push(r),i+=a}return function(e){const t=e.length;if(t<=B)return String.fromCharCode.apply(String,e);let n="",s=0;for(;s<t;)n+=String.fromCharCode.apply(String,e.slice(s,s+=B));return n}(s)}t.kMaxLength=a,l.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),l.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.byteOffset}}),l.poolSize=8192,l.from=function(e,t,n){return c(e,t,n)},Object.setPrototypeOf(l.prototype,Uint8Array.prototype),Object.setPrototypeOf(l,Uint8Array),l.alloc=function(e,t,n){return function(e,t,n){return d(e),e<=0?o(e):void 0!==t?"string"==typeof n?o(e).fill(t,n):o(e).fill(t):o(e)}(e,t,n)},l.allocUnsafe=function(e){return u(e)},l.allocUnsafeSlow=function(e){return u(e)},l.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==l.prototype},l.compare=function(e,t){if(W(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),W(t,Uint8Array)&&(t=l.from(t,t.offset,t.byteLength)),!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let n=e.length,s=t.length;for(let i=0,r=Math.min(n,s);i<r;++i)if(e[i]!==t[i]){n=e[i],s=t[i];break}return n<s?-1:s<n?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);let n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;const s=l.allocUnsafe(t);let i=0;for(n=0;n<e.length;++n){let t=e[n];if(W(t,Uint8Array))i+t.length>s.length?(l.isBuffer(t)||(t=l.from(t)),t.copy(s,i)):Uint8Array.prototype.set.call(s,t,i);else{if(!l.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(s,i)}i+=t.length}return s},l.byteLength=m,l.prototype._isBuffer=!0,l.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)_(this,t,t+1);return this},l.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)_(this,t,t+3),_(this,t+1,t+2);return this},l.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)_(this,t,t+7),_(this,t+1,t+6),_(this,t+2,t+5),_(this,t+3,t+4);return this},l.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?z(this,0,e):g.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){let e="";const n=t.INSPECT_MAX_BYTES;return e=this.toString("hex",0,n).replace(/(.{2})/g,"$1 ").trim(),this.length>n&&(e+=" ... "),"<Buffer "+e+">"},r&&(l.prototype[r]=l.prototype.inspect),l.prototype.compare=function(e,t,n,s,i){if(W(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),!l.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===s&&(s=0),void 0===i&&(i=this.length),t<0||n>e.length||s<0||i>this.length)throw new RangeError("out of range index");if(s>=i&&t>=n)return 0;if(s>=i)return-1;if(t>=n)return 1;if(this===e)return 0;let r=(i>>>=0)-(s>>>=0),a=(n>>>=0)-(t>>>=0);const o=Math.min(r,a),c=this.slice(s,i),d=e.slice(t,n);for(let e=0;e<o;++e)if(c[e]!==d[e]){r=c[e],a=d[e];break}return r<a?-1:a<r?1:0},l.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},l.prototype.indexOf=function(e,t,n){return b(this,e,t,n,!0)},l.prototype.lastIndexOf=function(e,t,n){return b(this,e,t,n,!1)},l.prototype.write=function(e,t,n,s){if(void 0===t)s="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)s=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(n)?(n>>>=0,void 0===s&&(s="utf8")):(s=n,n=void 0)}const i=this.length-t;if((void 0===n||n>i)&&(n=i),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");s||(s="utf8");let r=!1;for(;;)switch(s){case"hex":return A(this,e,t,n);case"utf8":case"utf-8":return w(this,e,t,n);case"ascii":case"latin1":case"binary":return x(this,e,t,n);case"base64":return v(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,e,t,n);default:if(r)throw new TypeError("Unknown encoding: "+s);s=(""+s).toLowerCase(),r=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const B=4096;function F(e,t,n){let s="";n=Math.min(e.length,n);for(let i=t;i<n;++i)s+=String.fromCharCode(127&e[i]);return s}function k(e,t,n){let s="";n=Math.min(e.length,n);for(let i=t;i<n;++i)s+=String.fromCharCode(e[i]);return s}function C(e,t,n){const s=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>s)&&(n=s);let i="";for(let s=t;s<n;++s)i+=q[e[s]];return i}function O(e,t,n){const s=e.slice(t,n);let i="";for(let e=0;e<s.length-1;e+=2)i+=String.fromCharCode(s[e]+256*s[e+1]);return i}function D(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function L(e,t,n,s,i,r){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<r)throw new RangeError('"value" argument is out of bounds');if(n+s>e.length)throw new RangeError("Index out of range")}function T(e,t,n,s,i){H(t,s,i,e,n,7);let r=Number(t&BigInt(4294967295));e[n++]=r,r>>=8,e[n++]=r,r>>=8,e[n++]=r,r>>=8,e[n++]=r;let a=Number(t>>BigInt(32)&BigInt(4294967295));return e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a,n}function S(e,t,n,s,i){H(t,s,i,e,n,7);let r=Number(t&BigInt(4294967295));e[n+7]=r,r>>=8,e[n+6]=r,r>>=8,e[n+5]=r,r>>=8,e[n+4]=r;let a=Number(t>>BigInt(32)&BigInt(4294967295));return e[n+3]=a,a>>=8,e[n+2]=a,a>>=8,e[n+1]=a,a>>=8,e[n]=a,n+8}function N(e,t,n,s,i,r){if(n+s>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function P(e,t,n,s,r){return t=+t,n>>>=0,r||N(e,0,n,4),i.write(e,t,n,s,23,4),n+4}function I(e,t,n,s,r){return t=+t,n>>>=0,r||N(e,0,n,8),i.write(e,t,n,s,52,8),n+8}l.prototype.slice=function(e,t){const n=this.length;(e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e);const s=this.subarray(e,t);return Object.setPrototypeOf(s,l.prototype),s},l.prototype.readUintLE=l.prototype.readUIntLE=function(e,t,n){e>>>=0,t>>>=0,n||D(e,t,this.length);let s=this[e],i=1,r=0;for(;++r<t&&(i*=256);)s+=this[e+r]*i;return s},l.prototype.readUintBE=l.prototype.readUIntBE=function(e,t,n){e>>>=0,t>>>=0,n||D(e,t,this.length);let s=this[e+--t],i=1;for(;t>0&&(i*=256);)s+=this[e+--t]*i;return s},l.prototype.readUint8=l.prototype.readUInt8=function(e,t){return e>>>=0,t||D(e,1,this.length),this[e]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(e,t){return e>>>=0,t||D(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(e,t){return e>>>=0,t||D(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(e,t){return e>>>=0,t||D(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(e,t){return e>>>=0,t||D(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readBigUInt64LE=K((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||R(e,this.length-8);const s=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,i=this[++e]+256*this[++e]+65536*this[++e]+n*2**24;return BigInt(s)+(BigInt(i)<<BigInt(32))})),l.prototype.readBigUInt64BE=K((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||R(e,this.length-8);const s=t*2**24+65536*this[++e]+256*this[++e]+this[++e],i=this[++e]*2**24+65536*this[++e]+256*this[++e]+n;return(BigInt(s)<<BigInt(32))+BigInt(i)})),l.prototype.readIntLE=function(e,t,n){e>>>=0,t>>>=0,n||D(e,t,this.length);let s=this[e],i=1,r=0;for(;++r<t&&(i*=256);)s+=this[e+r]*i;return i*=128,s>=i&&(s-=Math.pow(2,8*t)),s},l.prototype.readIntBE=function(e,t,n){e>>>=0,t>>>=0,n||D(e,t,this.length);let s=t,i=1,r=this[e+--s];for(;s>0&&(i*=256);)r+=this[e+--s]*i;return i*=128,r>=i&&(r-=Math.pow(2,8*t)),r},l.prototype.readInt8=function(e,t){return e>>>=0,t||D(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){e>>>=0,t||D(e,2,this.length);const n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt16BE=function(e,t){e>>>=0,t||D(e,2,this.length);const n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt32LE=function(e,t){return e>>>=0,t||D(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return e>>>=0,t||D(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readBigInt64LE=K((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||R(e,this.length-8);const s=this[e+4]+256*this[e+5]+65536*this[e+6]+(n<<24);return(BigInt(s)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),l.prototype.readBigInt64BE=K((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||R(e,this.length-8);const s=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(s)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+n)})),l.prototype.readFloatLE=function(e,t){return e>>>=0,t||D(e,4,this.length),i.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return e>>>=0,t||D(e,4,this.length),i.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return e>>>=0,t||D(e,8,this.length),i.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return e>>>=0,t||D(e,8,this.length),i.read(this,e,!1,52,8)},l.prototype.writeUintLE=l.prototype.writeUIntLE=function(e,t,n,s){e=+e,t>>>=0,n>>>=0,s||L(this,e,t,n,Math.pow(2,8*n)-1,0);let i=1,r=0;for(this[t]=255&e;++r<n&&(i*=256);)this[t+r]=e/i&255;return t+n},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(e,t,n,s){e=+e,t>>>=0,n>>>=0,s||L(this,e,t,n,Math.pow(2,8*n)-1,0);let i=n-1,r=1;for(this[t+i]=255&e;--i>=0&&(r*=256);)this[t+i]=e/r&255;return t+n},l.prototype.writeUint8=l.prototype.writeUInt8=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,1,255,0),this[t]=255&e,t+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigUInt64LE=K((function(e,t=0){return T(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeBigUInt64BE=K((function(e,t=0){return S(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeIntLE=function(e,t,n,s){if(e=+e,t>>>=0,!s){const s=Math.pow(2,8*n-1);L(this,e,t,n,s-1,-s)}let i=0,r=1,a=0;for(this[t]=255&e;++i<n&&(r*=256);)e<0&&0===a&&0!==this[t+i-1]&&(a=1),this[t+i]=(e/r|0)-a&255;return t+n},l.prototype.writeIntBE=function(e,t,n,s){if(e=+e,t>>>=0,!s){const s=Math.pow(2,8*n-1);L(this,e,t,n,s-1,-s)}let i=n-1,r=1,a=0;for(this[t+i]=255&e;--i>=0&&(r*=256);)e<0&&0===a&&0!==this[t+i+1]&&(a=1),this[t+i]=(e/r|0)-a&255;return t+n},l.prototype.writeInt8=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeInt16BE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeInt32LE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},l.prototype.writeInt32BE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigInt64LE=K((function(e,t=0){return T(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeBigInt64BE=K((function(e,t=0){return S(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeFloatLE=function(e,t,n){return P(this,e,t,!0,n)},l.prototype.writeFloatBE=function(e,t,n){return P(this,e,t,!1,n)},l.prototype.writeDoubleLE=function(e,t,n){return I(this,e,t,!0,n)},l.prototype.writeDoubleBE=function(e,t,n){return I(this,e,t,!1,n)},l.prototype.copy=function(e,t,n,s){if(!l.isBuffer(e))throw new TypeError("argument should be a Buffer");if(n||(n=0),s||0===s||(s=this.length),t>=e.length&&(t=e.length),t||(t=0),s>0&&s<n&&(s=n),s===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("Index out of range");if(s<0)throw new RangeError("sourceEnd out of bounds");s>this.length&&(s=this.length),e.length-t<s-n&&(s=e.length-t+n);const i=s-n;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,n,s):Uint8Array.prototype.set.call(e,this.subarray(n,s),t),i},l.prototype.fill=function(e,t,n,s){if("string"==typeof e){if("string"==typeof t?(s=t,t=0,n=this.length):"string"==typeof n&&(s=n,n=this.length),void 0!==s&&"string"!=typeof s)throw new TypeError("encoding must be a string");if("string"==typeof s&&!l.isEncoding(s))throw new TypeError("Unknown encoding: "+s);if(1===e.length){const t=e.charCodeAt(0);("utf8"===s&&t<128||"latin1"===s)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;let i;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(i=t;i<n;++i)this[i]=e;else{const r=l.isBuffer(e)?e:l.from(e,s),a=r.length;if(0===a)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(i=0;i<n-t;++i)this[i+t]=r[i%a]}return this};const Y={};function Q(e,t,n){Y[e]=class extends n{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function j(e){let t="",n=e.length;const s="-"===e[0]?1:0;for(;n>=s+4;n-=3)t=`_${e.slice(n-3,n)}${t}`;return`${e.slice(0,n)}${t}`}function H(e,t,n,s,i,r){if(e>n||e<t){const s="bigint"==typeof t?"n":"";let i;throw i=r>3?0===t||t===BigInt(0)?`>= 0${s} and < 2${s} ** ${8*(r+1)}${s}`:`>= -(2${s} ** ${8*(r+1)-1}${s}) and < 2 ** ${8*(r+1)-1}${s}`:`>= ${t}${s} and <= ${n}${s}`,new Y.ERR_OUT_OF_RANGE("value",i,e)}!function(e,t,n){U(t,"offset"),void 0!==e[t]&&void 0!==e[t+n]||R(t,e.length-(n+1))}(s,i,r)}function U(e,t){if("number"!=typeof e)throw new Y.ERR_INVALID_ARG_TYPE(t,"number",e)}function R(e,t,n){if(Math.floor(e)!==e)throw U(e,n),new Y.ERR_OUT_OF_RANGE(n||"offset","an integer",e);if(t<0)throw new Y.ERR_BUFFER_OUT_OF_BOUNDS;throw new Y.ERR_OUT_OF_RANGE(n||"offset",`>= ${n?1:0} and <= ${t}`,e)}Q("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),Q("ERR_INVALID_ARG_TYPE",(function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`}),TypeError),Q("ERR_OUT_OF_RANGE",(function(e,t,n){let s=`The value of "${e}" is out of range.`,i=n;return Number.isInteger(n)&&Math.abs(n)>2**32?i=j(String(n)):"bigint"==typeof n&&(i=String(n),(n>BigInt(2)**BigInt(32)||n<-(BigInt(2)**BigInt(32)))&&(i=j(i)),i+="n"),s+=` It must be ${t}. Received ${i}`,s}),RangeError);const G=/[^+/0-9A-Za-z-_]/g;function Z(e,t){let n;t=t||1/0;const s=e.length;let i=null;const r=[];for(let a=0;a<s;++a){if(n=e.charCodeAt(a),n>55295&&n<57344){if(!i){if(n>56319){(t-=3)>-1&&r.push(239,191,189);continue}if(a+1===s){(t-=3)>-1&&r.push(239,191,189);continue}i=n;continue}if(n<56320){(t-=3)>-1&&r.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320)}else i&&(t-=3)>-1&&r.push(239,191,189);if(i=null,n<128){if((t-=1)<0)break;r.push(n)}else if(n<2048){if((t-=2)<0)break;r.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;r.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;r.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return r}function J(e){return s.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(G,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function X(e,t,n,s){let i;for(i=0;i<s&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}function W(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function V(e){return e!=e}const q=function(){const e="0123456789abcdef",t=new Array(256);for(let n=0;n<16;++n){const s=16*n;for(let i=0;i<16;++i)t[s+i]=e[n]+e[i]}return t}();function K(e){return"undefined"==typeof BigInt?$:e}function $(){throw new Error("BigInt not supported")}},9343:(e,t,n)=>{var s=n(8897),i=n(8179),r=i(s("String.prototype.indexOf"));e.exports=function(e,t){var n=s(e,!!t);return"function"==typeof n&&r(e,".prototype.")>-1?i(n):n}},8179:(e,t,n)=>{var s=n(4499),i=n(8897),r=n(8973),a=n(1711),o=i("%Function.prototype.apply%"),l=i("%Function.prototype.call%"),c=i("%Reflect.apply%",!0)||s.call(l,o),d=n(7539),u=i("%Math.max%");e.exports=function(e){if("function"!=typeof e)throw new a("a function is required");var t=c(s,l,arguments);return r(t,1+u(0,e.length-(arguments.length-1)),!0)};var f=function(){return c(s,o,arguments)};d?d(e.exports,"apply",{value:f}):e.exports.apply=f},3156:e=>{var t=1e3,n=60*t,s=60*n,i=24*s,r=7*i;function a(e,t,n,s){var i=t>=1.5*n;return Math.round(e/n)+" "+s+(i?"s":"")}e.exports=function(e,o){o=o||{};var l,c,d=typeof e;if("string"===d&&e.length>0)return function(e){if(!((e=String(e)).length>100)){var a=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(a){var o=parseFloat(a[1]);switch((a[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*o;case"weeks":case"week":case"w":return o*r;case"days":case"day":case"d":return o*i;case"hours":case"hour":case"hrs":case"hr":case"h":return o*s;case"minutes":case"minute":case"mins":case"min":case"m":return o*n;case"seconds":case"second":case"secs":case"sec":case"s":return o*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return o;default:return}}}}(e);if("number"===d&&isFinite(e))return o.long?(l=e,(c=Math.abs(l))>=i?a(l,c,i,"day"):c>=s?a(l,c,s,"hour"):c>=n?a(l,c,n,"minute"):c>=t?a(l,c,t,"second"):l+" ms"):function(e){var r=Math.abs(e);return r>=i?Math.round(e/i)+"d":r>=s?Math.round(e/s)+"h":r>=n?Math.round(e/n)+"m":r>=t?Math.round(e/t)+"s":e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},7989:(e,t,n)=>{t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const n="color: "+this.color;t.splice(1,0,n,"color: inherit");let s=0,i=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(s++,"%c"===e&&(i=s))})),t.splice(i,0,n)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=function(){let e;try{e=t.storage.getItem("debug")}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e={NODE_ENV:"production"}.DEBUG),e},t.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=n(1236)(t);const{formatters:s}=e.exports;s.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},1236:(e,t,n)=>{e.exports=function(e){function t(e){let n,i,r,a=null;function o(...e){if(!o.enabled)return;const s=o,i=Number(new Date),r=i-(n||i);s.diff=r,s.prev=n,s.curr=i,n=i,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let a=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((n,i)=>{if("%%"===n)return"%";a++;const r=t.formatters[i];if("function"==typeof r){const t=e[a];n=r.call(s,t),e.splice(a,1),a--}return n})),t.formatArgs.call(s,e),(s.log||t.log).apply(s,e)}return o.namespace=e,o.useColors=t.useColors(),o.color=t.selectColor(e),o.extend=s,o.destroy=t.destroy,Object.defineProperty(o,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==a?a:(i!==t.namespaces&&(i=t.namespaces,r=t.enabled(e)),r),set:e=>{a=e}}),"function"==typeof t.init&&t.init(o),o}function s(e,n){const s=t(this.namespace+(void 0===n?":":n)+e);return s.log=this.log,s}function i(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){return e instanceof Error?e.stack||e.message:e},t.disable=function(){const e=[...t.names.map(i),...t.skips.map(i).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let n;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const s=("string"==typeof e?e:"").split(/[\s,]+/),i=s.length;for(n=0;n<i;n++)s[n]&&("-"===(e=s[n].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.slice(1)+"$")):t.names.push(new RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let n,s;for(n=0,s=t.skips.length;n<s;n++)if(t.skips[n].test(e))return!1;for(n=0,s=t.names.length;n<s;n++)if(t.names[n].test(e))return!0;return!1},t.humanize=n(3156),t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((n=>{t[n]=e[n]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return t.colors[Math.abs(n)%t.colors.length]},t.enable(t.load()),t}},9381:(e,t,n)=>{var s=n(7539),i=n(6296),r=n(1711),a=n(1399);e.exports=function(e,t,n){if(!e||"object"!=typeof e&&"function"!=typeof e)throw new r("`obj` must be an object or a function`");if("string"!=typeof t&&"symbol"!=typeof t)throw new r("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!=typeof arguments[3]&&null!==arguments[3])throw new r("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!=typeof arguments[4]&&null!==arguments[4])throw new r("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!=typeof arguments[5]&&null!==arguments[5])throw new r("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!=typeof arguments[6])throw new r("`loose`, if provided, must be a boolean");var o=arguments.length>3?arguments[3]:null,l=arguments.length>4?arguments[4]:null,c=arguments.length>5?arguments[5]:null,d=arguments.length>6&&arguments[6],u=!!a&&a(e,t);if(s)s(e,t,{configurable:null===c&&u?u.configurable:!c,enumerable:null===o&&u?u.enumerable:!o,value:n,writable:null===l&&u?u.writable:!l});else{if(!d&&(o||l||c))throw new i("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");e[t]=n}}},6041:e=>{e.exports=!1},7539:(e,t,n)=>{var s=n(8897)("%Object.defineProperty%",!0)||!1;if(s)try{s({},"a",{value:1})}catch(e){s=!1}e.exports=s},3841:e=>{e.exports=EvalError},219:e=>{e.exports=Error},6190:e=>{e.exports=RangeError},3950:e=>{e.exports=ReferenceError},6296:e=>{e.exports=SyntaxError},1711:e=>{e.exports=TypeError},3221:e=>{e.exports=URIError},7270:(e,t,n)=>{var s=n(9916),i=Object.prototype.toString,r=Object.prototype.hasOwnProperty;e.exports=function(e,t,n){if(!s(t))throw new TypeError("iterator must be a function");var a;arguments.length>=3&&(a=n),"[object Array]"===i.call(e)?function(e,t,n){for(var s=0,i=e.length;s<i;s++)r.call(e,s)&&(null==n?t(e[s],s,e):t.call(n,e[s],s,e))}(e,t,a):"string"==typeof e?function(e,t,n){for(var s=0,i=e.length;s<i;s++)null==n?t(e.charAt(s),s,e):t.call(n,e.charAt(s),s,e)}(e,t,a):function(e,t,n){for(var s in e)r.call(e,s)&&(null==n?t(e[s],s,e):t.call(n,e[s],s,e))}(e,t,a)}},5845:e=>{var t=Object.prototype.toString,n=Math.max,s=function(e,t){for(var n=[],s=0;s<e.length;s+=1)n[s]=e[s];for(var i=0;i<t.length;i+=1)n[i+e.length]=t[i];return n};e.exports=function(e){var i=this;if("function"!=typeof i||"[object Function]"!==t.apply(i))throw new TypeError("Function.prototype.bind called on incompatible "+i);for(var r,a=function(e,t){for(var n=[],s=1,i=0;s<e.length;s+=1,i+=1)n[i]=e[s];return n}(arguments),o=n(0,i.length-a.length),l=[],c=0;c<o;c++)l[c]="$"+c;if(r=Function("binder","return function ("+function(e,t){for(var n="",s=0;s<e.length;s+=1)n+=e[s],s+1<e.length&&(n+=",");return n}(l)+"){ return binder.apply(this,arguments); }")((function(){if(this instanceof r){var t=i.apply(this,s(a,arguments));return Object(t)===t?t:this}return i.apply(e,s(a,arguments))})),i.prototype){var d=function(){};d.prototype=i.prototype,r.prototype=new d,d.prototype=null}return r}},4499:(e,t,n)=>{var s=n(5845);e.exports=Function.prototype.bind||s},8897:(e,t,n)=>{var s,i=n(219),r=n(3841),a=n(6190),o=n(3950),l=n(6296),c=n(1711),d=n(3221),u=Function,f=function(e){try{return u('"use strict"; return ('+e+").constructor;")()}catch(e){}},h=Object.getOwnPropertyDescriptor;if(h)try{h({},"")}catch(e){h=null}var p=function(){throw new c},m=h?function(){try{return p}catch(e){try{return h(arguments,"callee").get}catch(e){return p}}}():p,g=n(4923)(),_=n(9372)(),b=Object.getPrototypeOf||(_?function(e){return e.__proto__}:null),y={},A="undefined"!=typeof Uint8Array&&b?b(Uint8Array):s,w={__proto__:null,"%AggregateError%":"undefined"==typeof AggregateError?s:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?s:ArrayBuffer,"%ArrayIteratorPrototype%":g&&b?b([][Symbol.iterator]()):s,"%AsyncFromSyncIteratorPrototype%":s,"%AsyncFunction%":y,"%AsyncGenerator%":y,"%AsyncGeneratorFunction%":y,"%AsyncIteratorPrototype%":y,"%Atomics%":"undefined"==typeof Atomics?s:Atomics,"%BigInt%":"undefined"==typeof BigInt?s:BigInt,"%BigInt64Array%":"undefined"==typeof BigInt64Array?s:BigInt64Array,"%BigUint64Array%":"undefined"==typeof BigUint64Array?s:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?s:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":i,"%eval%":eval,"%EvalError%":r,"%Float32Array%":"undefined"==typeof Float32Array?s:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?s:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?s:FinalizationRegistry,"%Function%":u,"%GeneratorFunction%":y,"%Int8Array%":"undefined"==typeof Int8Array?s:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?s:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?s:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":g&&b?b(b([][Symbol.iterator]())):s,"%JSON%":"object"==typeof JSON?JSON:s,"%Map%":"undefined"==typeof Map?s:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&g&&b?b((new Map)[Symbol.iterator]()):s,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?s:Promise,"%Proxy%":"undefined"==typeof Proxy?s:Proxy,"%RangeError%":a,"%ReferenceError%":o,"%Reflect%":"undefined"==typeof Reflect?s:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?s:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&g&&b?b((new Set)[Symbol.iterator]()):s,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?s:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":g&&b?b(""[Symbol.iterator]()):s,"%Symbol%":g?Symbol:s,"%SyntaxError%":l,"%ThrowTypeError%":m,"%TypedArray%":A,"%TypeError%":c,"%Uint8Array%":"undefined"==typeof Uint8Array?s:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?s:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?s:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?s:Uint32Array,"%URIError%":d,"%WeakMap%":"undefined"==typeof WeakMap?s:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?s:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?s:WeakSet};if(b)try{null.error}catch(e){var x=b(b(e));w["%Error.prototype%"]=x}var v=function e(t){var n;if("%AsyncFunction%"===t)n=f("async function () {}");else if("%GeneratorFunction%"===t)n=f("function* () {}");else if("%AsyncGeneratorFunction%"===t)n=f("async function* () {}");else if("%AsyncGenerator%"===t){var s=e("%AsyncGeneratorFunction%");s&&(n=s.prototype)}else if("%AsyncIteratorPrototype%"===t){var i=e("%AsyncGenerator%");i&&b&&(n=b(i.prototype))}return w[t]=n,n},E={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},M=n(4499),z=n(4313),B=M.call(Function.call,Array.prototype.concat),F=M.call(Function.apply,Array.prototype.splice),k=M.call(Function.call,String.prototype.replace),C=M.call(Function.call,String.prototype.slice),O=M.call(Function.call,RegExp.prototype.exec),D=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,L=/\\(\\)?/g,T=function(e,t){var n,s=e;if(z(E,s)&&(s="%"+(n=E[s])[0]+"%"),z(w,s)){var i=w[s];if(i===y&&(i=v(s)),void 0===i&&!t)throw new c("intrinsic "+e+" exists, but is not available. Please file an issue!");return{alias:n,name:s,value:i}}throw new l("intrinsic "+e+" does not exist!")};e.exports=function(e,t){if("string"!=typeof e||0===e.length)throw new c("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof t)throw new c('"allowMissing" argument must be a boolean');if(null===O(/^%?[^%]*%?$/,e))throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var n=function(e){var t=C(e,0,1),n=C(e,-1);if("%"===t&&"%"!==n)throw new l("invalid intrinsic syntax, expected closing `%`");if("%"===n&&"%"!==t)throw new l("invalid intrinsic syntax, expected opening `%`");var s=[];return k(e,D,(function(e,t,n,i){s[s.length]=n?k(i,L,"$1"):t||e})),s}(e),s=n.length>0?n[0]:"",i=T("%"+s+"%",t),r=i.name,a=i.value,o=!1,d=i.alias;d&&(s=d[0],F(n,B([0,1],d)));for(var u=1,f=!0;u<n.length;u+=1){var p=n[u],m=C(p,0,1),g=C(p,-1);if(('"'===m||"'"===m||"`"===m||'"'===g||"'"===g||"`"===g)&&m!==g)throw new l("property names with quotes must have matching quotes");if("constructor"!==p&&f||(o=!0),z(w,r="%"+(s+="."+p)+"%"))a=w[r];else if(null!=a){if(!(p in a)){if(!t)throw new c("base intrinsic for "+e+" exists, but the property is not available.");return}if(h&&u+1>=n.length){var _=h(a,p);a=(f=!!_)&&"get"in _&&!("originalValue"in _.get)?_.get:a[p]}else f=z(a,p),a=a[p];f&&!o&&(w[r]=a)}}return a}},1399:(e,t,n)=>{var s=n(8897)("%Object.getOwnPropertyDescriptor%",!0);if(s)try{s([],"length")}catch(e){s=null}e.exports=s},6900:(e,t,n)=>{var s=n(7539),i=function(){return!!s};i.hasArrayLengthDefineBug=function(){if(!s)return null;try{return 1!==s([],"length",{value:1}).length}catch(e){return!0}},e.exports=i},9372:e=>{var t={__proto__:null,foo:{}},n=Object;e.exports=function(){return{__proto__:t}.foo===t.foo&&!(t instanceof n)}},4923:(e,t,n)=>{var s="undefined"!=typeof Symbol&&Symbol,i=n(4361);e.exports=function(){return"function"==typeof s&&"function"==typeof Symbol&&"symbol"==typeof s("foo")&&"symbol"==typeof Symbol("bar")&&i()}},4361:e=>{e.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var e={},t=Symbol("test"),n=Object(t);if("string"==typeof t)return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;if("[object Symbol]"!==Object.prototype.toString.call(n))return!1;for(t in e[t]=42,e)return!1;if("function"==typeof Object.keys&&0!==Object.keys(e).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(e).length)return!1;var s=Object.getOwnPropertySymbols(e);if(1!==s.length||s[0]!==t)return!1;if(!Object.prototype.propertyIsEnumerable.call(e,t))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var i=Object.getOwnPropertyDescriptor(e,t);if(42!==i.value||!0!==i.enumerable)return!1}return!0}},1432:(e,t,n)=>{var s=n(4361);e.exports=function(){return s()&&!!Symbol.toStringTag}},6460:(e,t,n)=>{var s=t;s.utils=n(9566),s.common=n(2090),s.sha=n(1017),s.ripemd=n(7572),s.hmac=n(1912),s.sha1=s.sha.sha1,s.sha256=s.sha.sha256,s.sha224=s.sha.sha224,s.sha384=s.sha.sha384,s.sha512=s.sha.sha512,s.ripemd160=s.ripemd.ripemd160},2090:(e,t,n)=>{var s=n(9566),i=n(73);function r(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}t.BlockHash=r,r.prototype.update=function(e,t){if(e=s.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var n=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-n,e.length),0===this.pending.length&&(this.pending=null),e=s.join32(e,0,e.length-n,this.endian);for(var i=0;i<e.length;i+=this._delta32)this._update(e,i,i+this._delta32)}return this},r.prototype.digest=function(e){return this.update(this._pad()),i(null===this.pending),this._digest(e)},r.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,n=t-(e+this.padLength)%t,s=new Array(n+this.padLength);s[0]=128;for(var i=1;i<n;i++)s[i]=0;if(e<<=3,"big"===this.endian){for(var r=8;r<this.padLength;r++)s[i++]=0;s[i++]=0,s[i++]=0,s[i++]=0,s[i++]=0,s[i++]=e>>>24&255,s[i++]=e>>>16&255,s[i++]=e>>>8&255,s[i++]=255&e}else for(s[i++]=255&e,s[i++]=e>>>8&255,s[i++]=e>>>16&255,s[i++]=e>>>24&255,s[i++]=0,s[i++]=0,s[i++]=0,s[i++]=0,r=8;r<this.padLength;r++)s[i++]=0;return s}},1912:(e,t,n)=>{var s=n(9566),i=n(73);function r(e,t,n){if(!(this instanceof r))return new r(e,t,n);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(s.toArray(t,n))}e.exports=r,r.prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),i(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},r.prototype.update=function(e,t){return this.inner.update(e,t),this},r.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)}},7572:(e,t,n)=>{var s=n(9566),i=n(2090),r=s.rotl32,a=s.sum32,o=s.sum32_3,l=s.sum32_4,c=i.BlockHash;function d(){if(!(this instanceof d))return new d;c.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function u(e,t,n,s){return e<=15?t^n^s:e<=31?t&n|~t&s:e<=47?(t|~n)^s:e<=63?t&s|n&~s:t^(n|~s)}function f(e){return e<=15?0:e<=31?1518500249:e<=47?1859775393:e<=63?2400959708:2840853838}function h(e){return e<=15?1352829926:e<=31?1548603684:e<=47?1836072691:e<=63?2053994217:0}s.inherits(d,c),t.ripemd160=d,d.blockSize=512,d.outSize=160,d.hmacStrength=192,d.padLength=64,d.prototype._update=function(e,t){for(var n=this.h[0],s=this.h[1],i=this.h[2],c=this.h[3],d=this.h[4],b=n,y=s,A=i,w=c,x=d,v=0;v<80;v++){var E=a(r(l(n,u(v,s,i,c),e[p[v]+t],f(v)),g[v]),d);n=d,d=c,c=r(i,10),i=s,s=E,E=a(r(l(b,u(79-v,y,A,w),e[m[v]+t],h(v)),_[v]),x),b=x,x=w,w=r(A,10),A=y,y=E}E=o(this.h[1],i,w),this.h[1]=o(this.h[2],c,x),this.h[2]=o(this.h[3],d,b),this.h[3]=o(this.h[4],n,y),this.h[4]=o(this.h[0],s,A),this.h[0]=E},d.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"little"):s.split32(this.h,"little")};var p=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],m=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],g=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],_=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},1017:(e,t,n)=>{t.sha1=n(3897),t.sha224=n(422),t.sha256=n(6475),t.sha384=n(6251),t.sha512=n(714)},3897:(e,t,n)=>{var s=n(9566),i=n(2090),r=n(3085),a=s.rotl32,o=s.sum32,l=s.sum32_5,c=r.ft_1,d=i.BlockHash,u=[1518500249,1859775393,2400959708,3395469782];function f(){if(!(this instanceof f))return new f;d.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=new Array(80)}s.inherits(f,d),e.exports=f,f.blockSize=512,f.outSize=160,f.hmacStrength=80,f.padLength=64,f.prototype._update=function(e,t){for(var n=this.W,s=0;s<16;s++)n[s]=e[t+s];for(;s<n.length;s++)n[s]=a(n[s-3]^n[s-8]^n[s-14]^n[s-16],1);var i=this.h[0],r=this.h[1],d=this.h[2],f=this.h[3],h=this.h[4];for(s=0;s<n.length;s++){var p=~~(s/20),m=l(a(i,5),c(p,r,d,f),h,n[s],u[p]);h=f,f=d,d=a(r,30),r=i,i=m}this.h[0]=o(this.h[0],i),this.h[1]=o(this.h[1],r),this.h[2]=o(this.h[2],d),this.h[3]=o(this.h[3],f),this.h[4]=o(this.h[4],h)},f.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"big"):s.split32(this.h,"big")}},422:(e,t,n)=>{var s=n(9566),i=n(6475);function r(){if(!(this instanceof r))return new r;i.call(this),this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}s.inherits(r,i),e.exports=r,r.blockSize=512,r.outSize=224,r.hmacStrength=192,r.padLength=64,r.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h.slice(0,7),"big"):s.split32(this.h.slice(0,7),"big")}},6475:(e,t,n)=>{var s=n(9566),i=n(2090),r=n(3085),a=n(73),o=s.sum32,l=s.sum32_4,c=s.sum32_5,d=r.ch32,u=r.maj32,f=r.s0_256,h=r.s1_256,p=r.g0_256,m=r.g1_256,g=i.BlockHash,_=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function b(){if(!(this instanceof b))return new b;g.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=_,this.W=new Array(64)}s.inherits(b,g),e.exports=b,b.blockSize=512,b.outSize=256,b.hmacStrength=192,b.padLength=64,b.prototype._update=function(e,t){for(var n=this.W,s=0;s<16;s++)n[s]=e[t+s];for(;s<n.length;s++)n[s]=l(m(n[s-2]),n[s-7],p(n[s-15]),n[s-16]);var i=this.h[0],r=this.h[1],g=this.h[2],_=this.h[3],b=this.h[4],y=this.h[5],A=this.h[6],w=this.h[7];for(a(this.k.length===n.length),s=0;s<n.length;s++){var x=c(w,h(b),d(b,y,A),this.k[s],n[s]),v=o(f(i),u(i,r,g));w=A,A=y,y=b,b=o(_,x),_=g,g=r,r=i,i=o(x,v)}this.h[0]=o(this.h[0],i),this.h[1]=o(this.h[1],r),this.h[2]=o(this.h[2],g),this.h[3]=o(this.h[3],_),this.h[4]=o(this.h[4],b),this.h[5]=o(this.h[5],y),this.h[6]=o(this.h[6],A),this.h[7]=o(this.h[7],w)},b.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"big"):s.split32(this.h,"big")}},6251:(e,t,n)=>{var s=n(9566),i=n(714);function r(){if(!(this instanceof r))return new r;i.call(this),this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}s.inherits(r,i),e.exports=r,r.blockSize=1024,r.outSize=384,r.hmacStrength=192,r.padLength=128,r.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h.slice(0,12),"big"):s.split32(this.h.slice(0,12),"big")}},714:(e,t,n)=>{var s=n(9566),i=n(2090),r=n(73),a=s.rotr64_hi,o=s.rotr64_lo,l=s.shr64_hi,c=s.shr64_lo,d=s.sum64,u=s.sum64_hi,f=s.sum64_lo,h=s.sum64_4_hi,p=s.sum64_4_lo,m=s.sum64_5_hi,g=s.sum64_5_lo,_=i.BlockHash,b=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function y(){if(!(this instanceof y))return new y;_.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=b,this.W=new Array(160)}function A(e,t,n,s,i){var r=e&n^~e&i;return r<0&&(r+=4294967296),r}function w(e,t,n,s,i,r){var a=t&s^~t&r;return a<0&&(a+=4294967296),a}function x(e,t,n,s,i){var r=e&n^e&i^n&i;return r<0&&(r+=4294967296),r}function v(e,t,n,s,i,r){var a=t&s^t&r^s&r;return a<0&&(a+=4294967296),a}function E(e,t){var n=a(e,t,28)^a(t,e,2)^a(t,e,7);return n<0&&(n+=4294967296),n}function M(e,t){var n=o(e,t,28)^o(t,e,2)^o(t,e,7);return n<0&&(n+=4294967296),n}function z(e,t){var n=o(e,t,14)^o(e,t,18)^o(t,e,9);return n<0&&(n+=4294967296),n}function B(e,t){var n=a(e,t,1)^a(e,t,8)^l(e,t,7);return n<0&&(n+=4294967296),n}function F(e,t){var n=o(e,t,1)^o(e,t,8)^c(e,t,7);return n<0&&(n+=4294967296),n}function k(e,t){var n=o(e,t,19)^o(t,e,29)^c(e,t,6);return n<0&&(n+=4294967296),n}s.inherits(y,_),e.exports=y,y.blockSize=1024,y.outSize=512,y.hmacStrength=192,y.padLength=128,y.prototype._prepareBlock=function(e,t){for(var n=this.W,s=0;s<32;s++)n[s]=e[t+s];for(;s<n.length;s+=2){var i=(g=n[s-4],_=n[s-3],b=void 0,(b=a(g,_,19)^a(_,g,29)^l(g,_,6))<0&&(b+=4294967296),b),r=k(n[s-4],n[s-3]),o=n[s-14],c=n[s-13],d=B(n[s-30],n[s-29]),u=F(n[s-30],n[s-29]),f=n[s-32],m=n[s-31];n[s]=h(i,r,o,c,d,u,f,m),n[s+1]=p(i,r,o,c,d,u,f,m)}var g,_,b},y.prototype._update=function(e,t){this._prepareBlock(e,t);var n,s,i,o=this.W,l=this.h[0],c=this.h[1],h=this.h[2],p=this.h[3],_=this.h[4],b=this.h[5],y=this.h[6],B=this.h[7],F=this.h[8],k=this.h[9],C=this.h[10],O=this.h[11],D=this.h[12],L=this.h[13],T=this.h[14],S=this.h[15];r(this.k.length===o.length);for(var N=0;N<o.length;N+=2){var P=T,I=S,Y=(i=void 0,(i=a(n=F,s=k,14)^a(n,s,18)^a(s,n,9))<0&&(i+=4294967296),i),Q=z(F,k),j=A(F,0,C,0,D),H=w(0,k,0,O,0,L),U=this.k[N],R=this.k[N+1],G=o[N],Z=o[N+1],J=m(P,I,Y,Q,j,H,U,R,G,Z),X=g(P,I,Y,Q,j,H,U,R,G,Z);P=E(l,c),I=M(l,c),Y=x(l,0,h,0,_),Q=v(0,c,0,p,0,b);var W=u(P,I,Y,Q),V=f(P,I,Y,Q);T=D,S=L,D=C,L=O,C=F,O=k,F=u(y,B,J,X),k=f(B,B,J,X),y=_,B=b,_=h,b=p,h=l,p=c,l=u(J,X,W,V),c=f(J,X,W,V)}d(this.h,0,l,c),d(this.h,2,h,p),d(this.h,4,_,b),d(this.h,6,y,B),d(this.h,8,F,k),d(this.h,10,C,O),d(this.h,12,D,L),d(this.h,14,T,S)},y.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"big"):s.split32(this.h,"big")}},3085:(e,t,n)=>{var s=n(9566).rotr32;function i(e,t,n){return e&t^~e&n}function r(e,t,n){return e&t^e&n^t&n}function a(e,t,n){return e^t^n}t.ft_1=function(e,t,n,s){return 0===e?i(t,n,s):1===e||3===e?a(t,n,s):2===e?r(t,n,s):void 0},t.ch32=i,t.maj32=r,t.p32=a,t.s0_256=function(e){return s(e,2)^s(e,13)^s(e,22)},t.s1_256=function(e){return s(e,6)^s(e,11)^s(e,25)},t.g0_256=function(e){return s(e,7)^s(e,18)^e>>>3},t.g1_256=function(e){return s(e,17)^s(e,19)^e>>>10}},9566:(e,t,n)=>{var s=n(73),i=n(198);function r(e,t){return 55296==(64512&e.charCodeAt(t))&&!(t<0||t+1>=e.length)&&56320==(64512&e.charCodeAt(t+1))}function a(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function o(e){return 1===e.length?"0"+e:e}function l(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}t.inherits=i,t.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var n=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),i=0;i<e.length;i+=2)n.push(parseInt(e[i]+e[i+1],16))}else for(var s=0,i=0;i<e.length;i++){var a=e.charCodeAt(i);a<128?n[s++]=a:a<2048?(n[s++]=a>>6|192,n[s++]=63&a|128):r(e,i)?(a=65536+((1023&a)<<10)+(1023&e.charCodeAt(++i)),n[s++]=a>>18|240,n[s++]=a>>12&63|128,n[s++]=a>>6&63|128,n[s++]=63&a|128):(n[s++]=a>>12|224,n[s++]=a>>6&63|128,n[s++]=63&a|128)}else for(i=0;i<e.length;i++)n[i]=0|e[i];return n},t.toHex=function(e){for(var t="",n=0;n<e.length;n++)t+=o(e[n].toString(16));return t},t.htonl=a,t.toHex32=function(e,t){for(var n="",s=0;s<e.length;s++){var i=e[s];"little"===t&&(i=a(i)),n+=l(i.toString(16))}return n},t.zero2=o,t.zero8=l,t.join32=function(e,t,n,i){var r=n-t;s(r%4==0);for(var a=new Array(r/4),o=0,l=t;o<a.length;o++,l+=4){var c;c="big"===i?e[l]<<24|e[l+1]<<16|e[l+2]<<8|e[l+3]:e[l+3]<<24|e[l+2]<<16|e[l+1]<<8|e[l],a[o]=c>>>0}return a},t.split32=function(e,t){for(var n=new Array(4*e.length),s=0,i=0;s<e.length;s++,i+=4){var r=e[s];"big"===t?(n[i]=r>>>24,n[i+1]=r>>>16&255,n[i+2]=r>>>8&255,n[i+3]=255&r):(n[i+3]=r>>>24,n[i+2]=r>>>16&255,n[i+1]=r>>>8&255,n[i]=255&r)}return n},t.rotr32=function(e,t){return e>>>t|e<<32-t},t.rotl32=function(e,t){return e<<t|e>>>32-t},t.sum32=function(e,t){return e+t>>>0},t.sum32_3=function(e,t,n){return e+t+n>>>0},t.sum32_4=function(e,t,n,s){return e+t+n+s>>>0},t.sum32_5=function(e,t,n,s,i){return e+t+n+s+i>>>0},t.sum64=function(e,t,n,s){var i=e[t],r=s+e[t+1]>>>0,a=(r<s?1:0)+n+i;e[t]=a>>>0,e[t+1]=r},t.sum64_hi=function(e,t,n,s){return(t+s>>>0<t?1:0)+e+n>>>0},t.sum64_lo=function(e,t,n,s){return t+s>>>0},t.sum64_4_hi=function(e,t,n,s,i,r,a,o){var l=0,c=t;return l+=(c=c+s>>>0)<t?1:0,l+=(c=c+r>>>0)<r?1:0,e+n+i+a+(l+=(c=c+o>>>0)<o?1:0)>>>0},t.sum64_4_lo=function(e,t,n,s,i,r,a,o){return t+s+r+o>>>0},t.sum64_5_hi=function(e,t,n,s,i,r,a,o,l,c){var d=0,u=t;return d+=(u=u+s>>>0)<t?1:0,d+=(u=u+r>>>0)<r?1:0,d+=(u=u+o>>>0)<o?1:0,e+n+i+a+l+(d+=(u=u+c>>>0)<c?1:0)>>>0},t.sum64_5_lo=function(e,t,n,s,i,r,a,o,l,c){return t+s+r+o+c>>>0},t.rotr64_hi=function(e,t,n){return(t<<32-n|e>>>n)>>>0},t.rotr64_lo=function(e,t,n){return(e<<32-n|t>>>n)>>>0},t.shr64_hi=function(e,t,n){return e>>>n},t.shr64_lo=function(e,t,n){return(e<<32-n|t>>>n)>>>0}},4313:(e,t,n)=>{var s=Function.prototype.call,i=Object.prototype.hasOwnProperty,r=n(4499);e.exports=r.call(s,i)},8239:(e,t)=>{t.read=function(e,t,n,s,i){var r,a,o=8*i-s-1,l=(1<<o)-1,c=l>>1,d=-7,u=n?i-1:0,f=n?-1:1,h=e[t+u];for(u+=f,r=h&(1<<-d)-1,h>>=-d,d+=o;d>0;r=256*r+e[t+u],u+=f,d-=8);for(a=r&(1<<-d)-1,r>>=-d,d+=s;d>0;a=256*a+e[t+u],u+=f,d-=8);if(0===r)r=1-c;else{if(r===l)return a?NaN:1/0*(h?-1:1);a+=Math.pow(2,s),r-=c}return(h?-1:1)*a*Math.pow(2,r-s)},t.write=function(e,t,n,s,i,r){var a,o,l,c=8*r-i-1,d=(1<<c)-1,u=d>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,h=s?0:r-1,p=s?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,a=d):(a=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-a))<1&&(a--,l*=2),(t+=a+u>=1?f/l:f*Math.pow(2,1-u))*l>=2&&(a++,l/=2),a+u>=d?(o=0,a=d):a+u>=1?(o=(t*l-1)*Math.pow(2,i),a+=u):(o=t*Math.pow(2,u-1)*Math.pow(2,i),a=0));i>=8;e[n+h]=255&o,h+=p,o/=256,i-=8);for(a=a<<i|o,c+=i;c>0;e[n+h]=255&a,h+=p,a/=256,c-=8);e[n+h-p]|=128*m}},198:e=>{"function"==typeof Object.create?e.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:e.exports=function(e,t){if(t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}}},5456:(e,t,n)=>{var s=n(1432)(),i=n(9343)("Object.prototype.toString"),r=function(e){return!(s&&e&&"object"==typeof e&&Symbol.toStringTag in e)&&"[object Arguments]"===i(e)},a=function(e){return!!r(e)||null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Array]"!==i(e)&&"[object Function]"===i(e.callee)},o=function(){return r(arguments)}();r.isLegacyArguments=a,e.exports=o?r:a},9916:e=>{var t,n,s=Function.prototype.toString,i="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof i&&"function"==typeof Object.defineProperty)try{t=Object.defineProperty({},"length",{get:function(){throw n}}),n={},i((function(){throw 42}),null,t)}catch(e){e!==n&&(i=null)}else i=null;var r=/^\s*class\b/,a=function(e){try{var t=s.call(e);return r.test(t)}catch(e){return!1}},o=function(e){try{return!a(e)&&(s.call(e),!0)}catch(e){return!1}},l=Object.prototype.toString,c="function"==typeof Symbol&&!!Symbol.toStringTag,d=!(0 in[,]),u=function(){return!1};if("object"==typeof document){var f=document.all;l.call(f)===l.call(document.all)&&(u=function(e){if((d||!e)&&(void 0===e||"object"==typeof e))try{var t=l.call(e);return("[object HTMLAllCollection]"===t||"[object HTML document.all class]"===t||"[object HTMLCollection]"===t||"[object Object]"===t)&&null==e("")}catch(e){}return!1})}e.exports=i?function(e){if(u(e))return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;try{i(e,null,t)}catch(e){if(e!==n)return!1}return!a(e)&&o(e)}:function(e){if(u(e))return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;if(c)return o(e);if(a(e))return!1;var t=l.call(e);return!("[object Function]"!==t&&"[object GeneratorFunction]"!==t&&!/^\[object HTML/.test(t))&&o(e)}},6940:(e,t,n)=>{var s,i=Object.prototype.toString,r=Function.prototype.toString,a=/^\s*(?:function)?\*/,o=n(1432)(),l=Object.getPrototypeOf;e.exports=function(e){if("function"!=typeof e)return!1;if(a.test(r.call(e)))return!0;if(!o)return"[object GeneratorFunction]"===i.call(e);if(!l)return!1;if(void 0===s){var t=function(){if(!o)return!1;try{return Function("return function*() {}")()}catch(e){}}();s=!!t&&l(t)}return l(e)===s}},2116:(e,t,n)=>{var s=n(6059);e.exports=function(e){return!!s(e)}},4247:e=>{var t=1/0,n=9007199254740991,s=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=/^(?:0|[1-9]\d*)$/,l=parseInt,c=Object.prototype.toString,d=Math.ceil,u=Math.max;function f(e,t,n){var s=-1,i=e.length;t<0&&(t=-t>i?0:i+t),(n=n>i?i:n)<0&&(n+=i),i=t>n?0:n-t>>>0,t>>>=0;for(var r=Array(i);++s<i;)r[s]=e[s+t];return r}function h(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}e.exports=function(e,p,m){p=(m?function(e,t,s){if(!h(s))return!1;var i=typeof t;return!!("number"==i?function(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=n}(e.length)&&!function(e){var t=h(e)?c.call(e):"";return"[object Function]"==t||"[object GeneratorFunction]"==t}(e)}(s)&&function(e,t){return!!(t=null==t?n:t)&&("number"==typeof e||o.test(e))&&e>-1&&e%1==0&&e<t}(t,s.length):"string"==i&&t in s)&&function(e,t){return e===t||e!=e&&t!=t}(s[t],e)}(e,p,m):void 0===p)?1:u(function(e){var n=function(e){return e?(e=function(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==c.call(e)}(e))return NaN;if(h(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=h(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(s,"");var n=r.test(e);return n||a.test(e)?l(e.slice(2),n?2:8):i.test(e)?NaN:+e}(e))===t||e===-1/0?17976931348623157e292*(e<0?-1:1):e==e?e:0:0===e?e:0}(e),o=n%1;return n==n?o?n-o:n:0}(p),0);var g=e?e.length:0;if(!g||p<1)return[];for(var _=0,b=0,y=Array(d(g/p));_<g;)y[b++]=f(e,_,_+=p);return y}},7842:(e,t,n)=>{e=n.nmd(e);var s="__lodash_hash_undefined__",i=1,r=2,a=9007199254740991,o="[object Arguments]",l="[object Array]",c="[object AsyncFunction]",d="[object Boolean]",u="[object Date]",f="[object Error]",h="[object Function]",p="[object GeneratorFunction]",m="[object Map]",g="[object Number]",_="[object Null]",b="[object Object]",y="[object Promise]",A="[object Proxy]",w="[object RegExp]",x="[object Set]",v="[object String]",E="[object Undefined]",M="[object WeakMap]",z="[object ArrayBuffer]",B="[object DataView]",F=/^\[object .+?Constructor\]$/,k=/^(?:0|[1-9]\d*)$/,C={};C["[object Float32Array]"]=C["[object Float64Array]"]=C["[object Int8Array]"]=C["[object Int16Array]"]=C["[object Int32Array]"]=C["[object Uint8Array]"]=C["[object Uint8ClampedArray]"]=C["[object Uint16Array]"]=C["[object Uint32Array]"]=!0,C[o]=C[l]=C[z]=C[d]=C[B]=C[u]=C[f]=C[h]=C[m]=C[g]=C[b]=C[w]=C[x]=C[v]=C[M]=!1;var O="object"==typeof n.g&&n.g&&n.g.Object===Object&&n.g,D="object"==typeof self&&self&&self.Object===Object&&self,L=O||D||Function("return this")(),T=t&&!t.nodeType&&t,S=T&&e&&!e.nodeType&&e,N=S&&S.exports===T,P=N&&O.process,I=function(){try{return P&&P.binding&&P.binding("util")}catch(e){}}(),Y=I&&I.isTypedArray;function Q(e,t){for(var n=-1,s=null==e?0:e.length;++n<s;)if(t(e[n],n,e))return!0;return!1}function j(e){var t=-1,n=Array(e.size);return e.forEach((function(e,s){n[++t]=[s,e]})),n}function H(e){var t=-1,n=Array(e.size);return e.forEach((function(e){n[++t]=e})),n}var U,R,G,Z=Array.prototype,J=Function.prototype,X=Object.prototype,W=L["__core-js_shared__"],V=J.toString,q=X.hasOwnProperty,K=(U=/[^.]+$/.exec(W&&W.keys&&W.keys.IE_PROTO||""))?"Symbol(src)_1."+U:"",$=X.toString,ee=RegExp("^"+V.call(q).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),te=N?L.Buffer:void 0,ne=L.Symbol,se=L.Uint8Array,ie=X.propertyIsEnumerable,re=Z.splice,ae=ne?ne.toStringTag:void 0,oe=Object.getOwnPropertySymbols,le=te?te.isBuffer:void 0,ce=(R=Object.keys,G=Object,function(e){return R(G(e))}),de=Se(L,"DataView"),ue=Se(L,"Map"),fe=Se(L,"Promise"),he=Se(L,"Set"),pe=Se(L,"WeakMap"),me=Se(Object,"create"),ge=Ye(de),_e=Ye(ue),be=Ye(fe),ye=Ye(he),Ae=Ye(pe),we=ne?ne.prototype:void 0,xe=we?we.valueOf:void 0;function ve(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function Ee(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function Me(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function ze(e){var t=-1,n=null==e?0:e.length;for(this.__data__=new Me;++t<n;)this.add(e[t])}function Be(e){var t=this.__data__=new Ee(e);this.size=t.size}function Fe(e,t){for(var n=e.length;n--;)if(Qe(e[n][0],t))return n;return-1}function ke(e){return null==e?void 0===e?E:_:ae&&ae in Object(e)?function(e){var t=q.call(e,ae),n=e[ae];try{e[ae]=void 0;var s=!0}catch(e){}var i=$.call(e);return s&&(t?e[ae]=n:delete e[ae]),i}(e):function(e){return $.call(e)}(e)}function Ce(e){return Je(e)&&ke(e)==o}function Oe(e,t,n,s,a){return e===t||(null==e||null==t||!Je(e)&&!Je(t)?e!=e&&t!=t:function(e,t,n,s,a,c){var h=He(e),p=He(t),_=h?l:Pe(e),y=p?l:Pe(t),A=(_=_==o?b:_)==b,E=(y=y==o?b:y)==b,M=_==y;if(M&&Ue(e)){if(!Ue(t))return!1;h=!0,A=!1}if(M&&!A)return c||(c=new Be),h||Xe(e)?De(e,t,n,s,a,c):function(e,t,n,s,a,o,l){switch(n){case B:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case z:return!(e.byteLength!=t.byteLength||!o(new se(e),new se(t)));case d:case u:case g:return Qe(+e,+t);case f:return e.name==t.name&&e.message==t.message;case w:case v:return e==t+"";case m:var c=j;case x:var h=s&i;if(c||(c=H),e.size!=t.size&&!h)return!1;var p=l.get(e);if(p)return p==t;s|=r,l.set(e,t);var _=De(c(e),c(t),s,a,o,l);return l.delete(e),_;case"[object Symbol]":if(xe)return xe.call(e)==xe.call(t)}return!1}(e,t,_,n,s,a,c);if(!(n&i)){var F=A&&q.call(e,"__wrapped__"),k=E&&q.call(t,"__wrapped__");if(F||k){var C=F?e.value():e,O=k?t.value():t;return c||(c=new Be),a(C,O,n,s,c)}}return!!M&&(c||(c=new Be),function(e,t,n,s,r,a){var o=n&i,l=Le(e),c=l.length;if(c!=Le(t).length&&!o)return!1;for(var d=c;d--;){var u=l[d];if(!(o?u in t:q.call(t,u)))return!1}var f=a.get(e);if(f&&a.get(t))return f==t;var h=!0;a.set(e,t),a.set(t,e);for(var p=o;++d<c;){var m=e[u=l[d]],g=t[u];if(s)var _=o?s(g,m,u,t,e,a):s(m,g,u,e,t,a);if(!(void 0===_?m===g||r(m,g,n,s,a):_)){h=!1;break}p||(p="constructor"==u)}if(h&&!p){var b=e.constructor,y=t.constructor;b==y||!("constructor"in e)||!("constructor"in t)||"function"==typeof b&&b instanceof b&&"function"==typeof y&&y instanceof y||(h=!1)}return a.delete(e),a.delete(t),h}(e,t,n,s,a,c))}(e,t,n,s,Oe,a))}function De(e,t,n,s,a,o){var l=n&i,c=e.length,d=t.length;if(c!=d&&!(l&&d>c))return!1;var u=o.get(e);if(u&&o.get(t))return u==t;var f=-1,h=!0,p=n&r?new ze:void 0;for(o.set(e,t),o.set(t,e);++f<c;){var m=e[f],g=t[f];if(s)var _=l?s(g,m,f,t,e,o):s(m,g,f,e,t,o);if(void 0!==_){if(_)continue;h=!1;break}if(p){if(!Q(t,(function(e,t){if(i=t,!p.has(i)&&(m===e||a(m,e,n,s,o)))return p.push(t);var i}))){h=!1;break}}else if(m!==g&&!a(m,g,n,s,o)){h=!1;break}}return o.delete(e),o.delete(t),h}function Le(e){return function(e,t,n){var s=t(e);return He(e)?s:function(e,t){for(var n=-1,s=t.length,i=e.length;++n<s;)e[i+n]=t[n];return e}(s,n(e))}(e,We,Ne)}function Te(e,t){var n,s,i=e.__data__;return("string"==(s=typeof(n=t))||"number"==s||"symbol"==s||"boolean"==s?"__proto__"!==n:null===n)?i["string"==typeof t?"string":"hash"]:i.map}function Se(e,t){var n=function(e,t){return null==e?void 0:e[t]}(e,t);return function(e){return!(!Ze(e)||function(e){return!!K&&K in e}(e))&&(Re(e)?ee:F).test(Ye(e))}(n)?n:void 0}ve.prototype.clear=function(){this.__data__=me?me(null):{},this.size=0},ve.prototype.delete=function(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t},ve.prototype.get=function(e){var t=this.__data__;if(me){var n=t[e];return n===s?void 0:n}return q.call(t,e)?t[e]:void 0},ve.prototype.has=function(e){var t=this.__data__;return me?void 0!==t[e]:q.call(t,e)},ve.prototype.set=function(e,t){var n=this.__data__;return this.size+=this.has(e)?0:1,n[e]=me&&void 0===t?s:t,this},Ee.prototype.clear=function(){this.__data__=[],this.size=0},Ee.prototype.delete=function(e){var t=this.__data__,n=Fe(t,e);return!(n<0||(n==t.length-1?t.pop():re.call(t,n,1),--this.size,0))},Ee.prototype.get=function(e){var t=this.__data__,n=Fe(t,e);return n<0?void 0:t[n][1]},Ee.prototype.has=function(e){return Fe(this.__data__,e)>-1},Ee.prototype.set=function(e,t){var n=this.__data__,s=Fe(n,e);return s<0?(++this.size,n.push([e,t])):n[s][1]=t,this},Me.prototype.clear=function(){this.size=0,this.__data__={hash:new ve,map:new(ue||Ee),string:new ve}},Me.prototype.delete=function(e){var t=Te(this,e).delete(e);return this.size-=t?1:0,t},Me.prototype.get=function(e){return Te(this,e).get(e)},Me.prototype.has=function(e){return Te(this,e).has(e)},Me.prototype.set=function(e,t){var n=Te(this,e),s=n.size;return n.set(e,t),this.size+=n.size==s?0:1,this},ze.prototype.add=ze.prototype.push=function(e){return this.__data__.set(e,s),this},ze.prototype.has=function(e){return this.__data__.has(e)},Be.prototype.clear=function(){this.__data__=new Ee,this.size=0},Be.prototype.delete=function(e){var t=this.__data__,n=t.delete(e);return this.size=t.size,n},Be.prototype.get=function(e){return this.__data__.get(e)},Be.prototype.has=function(e){return this.__data__.has(e)},Be.prototype.set=function(e,t){var n=this.__data__;if(n instanceof Ee){var s=n.__data__;if(!ue||s.length<199)return s.push([e,t]),this.size=++n.size,this;n=this.__data__=new Me(s)}return n.set(e,t),this.size=n.size,this};var Ne=oe?function(e){return null==e?[]:(e=Object(e),function(t,n){for(var s=-1,i=null==t?0:t.length,r=0,a=[];++s<i;){var o=t[s];l=o,ie.call(e,l)&&(a[r++]=o)}var l;return a}(oe(e)))}:function(){return[]},Pe=ke;function Ie(e,t){return!!(t=null==t?a:t)&&("number"==typeof e||k.test(e))&&e>-1&&e%1==0&&e<t}function Ye(e){if(null!=e){try{return V.call(e)}catch(e){}try{return e+""}catch(e){}}return""}function Qe(e,t){return e===t||e!=e&&t!=t}(de&&Pe(new de(new ArrayBuffer(1)))!=B||ue&&Pe(new ue)!=m||fe&&Pe(fe.resolve())!=y||he&&Pe(new he)!=x||pe&&Pe(new pe)!=M)&&(Pe=function(e){var t=ke(e),n=t==b?e.constructor:void 0,s=n?Ye(n):"";if(s)switch(s){case ge:return B;case _e:return m;case be:return y;case ye:return x;case Ae:return M}return t});var je=Ce(function(){return arguments}())?Ce:function(e){return Je(e)&&q.call(e,"callee")&&!ie.call(e,"callee")},He=Array.isArray,Ue=le||function(){return!1};function Re(e){if(!Ze(e))return!1;var t=ke(e);return t==h||t==p||t==c||t==A}function Ge(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=a}function Ze(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)}function Je(e){return null!=e&&"object"==typeof e}var Xe=Y?function(e){return function(t){return e(t)}}(Y):function(e){return Je(e)&&Ge(e.length)&&!!C[ke(e)]};function We(e){return null!=(t=e)&&Ge(t.length)&&!Re(t)?function(e,t){var n=He(e),s=!n&&je(e),i=!n&&!s&&Ue(e),r=!n&&!s&&!i&&Xe(e),a=n||s||i||r,o=a?function(e,t){for(var n=-1,s=Array(e);++n<e;)s[n]=t(n);return s}(e.length,String):[],l=o.length;for(var c in e)!t&&!q.call(e,c)||a&&("length"==c||i&&("offset"==c||"parent"==c)||r&&("buffer"==c||"byteLength"==c||"byteOffset"==c)||Ie(c,l))||o.push(c);return o}(e):function(e){if(n=(t=e)&&t.constructor,t!==("function"==typeof n&&n.prototype||X))return ce(e);var t,n,s=[];for(var i in Object(e))q.call(e,i)&&"constructor"!=i&&s.push(i);return s}(e);var t}e.exports=function(e,t){return Oe(e,t)}},7563:(e,t,n)=>{var s="__lodash_hash_undefined__",i=9007199254740991,r="[object Arguments]",a="[object Function]",o="[object GeneratorFunction]",l=/^\[object .+?Constructor\]$/,c=/^(?:0|[1-9]\d*)$/,d="object"==typeof n.g&&n.g&&n.g.Object===Object&&n.g,u="object"==typeof self&&self&&self.Object===Object&&self,f=d||u||Function("return this")();function h(e,t){return!(!e||!e.length)&&function(e,t,n){if(t!=t)return function(e,t,n,s){for(var i=e.length,r=-1;++r<i;)if(t(e[r],r,e))return r;return-1}(e,g);for(var s=-1,i=e.length;++s<i;)if(e[s]===t)return s;return-1}(e,t)>-1}function p(e,t){for(var n=-1,s=e?e.length:0,i=Array(s);++n<s;)i[n]=t(e[n],n,e);return i}function m(e,t){for(var n=-1,s=t.length,i=e.length;++n<s;)e[i+n]=t[n];return e}function g(e){return e!=e}function _(e,t){return e.has(t)}function b(e,t){return function(n){return e(t(n))}}var y,A=Array.prototype,w=Function.prototype,x=Object.prototype,v=f["__core-js_shared__"],E=(y=/[^.]+$/.exec(v&&v.keys&&v.keys.IE_PROTO||""))?"Symbol(src)_1."+y:"",M=w.toString,z=x.hasOwnProperty,B=x.toString,F=RegExp("^"+M.call(z).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),k=f.Symbol,C=b(Object.getPrototypeOf,Object),O=x.propertyIsEnumerable,D=A.splice,L=k?k.isConcatSpreadable:void 0,T=Object.getOwnPropertySymbols,S=Math.max,N=G(f,"Map"),P=G(Object,"create");function I(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function Y(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function Q(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function j(e){var t=-1,n=e?e.length:0;for(this.__data__=new Q;++t<n;)this.add(e[t])}function H(e,t){for(var n,s,i=e.length;i--;)if((n=e[i][0])===(s=t)||n!=n&&s!=s)return i;return-1}function U(e,t,n,s,i){var r=-1,a=e.length;for(n||(n=X),i||(i=[]);++r<a;){var o=e[r];t>0&&n(o)?t>1?U(o,t-1,n,s,i):m(i,o):s||(i[i.length]=o)}return i}function R(e,t){var n,s,i=e.__data__;return("string"==(s=typeof(n=t))||"number"==s||"symbol"==s||"boolean"==s?"__proto__"!==n:null===n)?i["string"==typeof t?"string":"hash"]:i.map}function G(e,t){var n=function(e,t){return null==e?void 0:e[t]}(e,t);return function(e){if(!te(e)||E&&E in e)return!1;var t=ee(e)||function(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}(e)?F:l;return t.test(function(e){if(null!=e){try{return M.call(e)}catch(e){}try{return e+""}catch(e){}}return""}(e))}(n)?n:void 0}I.prototype.clear=function(){this.__data__=P?P(null):{}},I.prototype.delete=function(e){return this.has(e)&&delete this.__data__[e]},I.prototype.get=function(e){var t=this.__data__;if(P){var n=t[e];return n===s?void 0:n}return z.call(t,e)?t[e]:void 0},I.prototype.has=function(e){var t=this.__data__;return P?void 0!==t[e]:z.call(t,e)},I.prototype.set=function(e,t){return this.__data__[e]=P&&void 0===t?s:t,this},Y.prototype.clear=function(){this.__data__=[]},Y.prototype.delete=function(e){var t=this.__data__,n=H(t,e);return!(n<0||(n==t.length-1?t.pop():D.call(t,n,1),0))},Y.prototype.get=function(e){var t=this.__data__,n=H(t,e);return n<0?void 0:t[n][1]},Y.prototype.has=function(e){return H(this.__data__,e)>-1},Y.prototype.set=function(e,t){var n=this.__data__,s=H(n,e);return s<0?n.push([e,t]):n[s][1]=t,this},Q.prototype.clear=function(){this.__data__={hash:new I,map:new(N||Y),string:new I}},Q.prototype.delete=function(e){return R(this,e).delete(e)},Q.prototype.get=function(e){return R(this,e).get(e)},Q.prototype.has=function(e){return R(this,e).has(e)},Q.prototype.set=function(e,t){return R(this,e).set(e,t),this},j.prototype.add=j.prototype.push=function(e){return this.__data__.set(e,s),this},j.prototype.has=function(e){return this.__data__.has(e)};var Z=T?b(T,Object):oe,J=T?function(e){for(var t=[];e;)m(t,Z(e)),e=C(e);return t}:oe;function X(e){return K(e)||q(e)||!!(L&&e&&e[L])}function W(e,t){return!!(t=null==t?i:t)&&("number"==typeof e||c.test(e))&&e>-1&&e%1==0&&e<t}function V(e){if("string"==typeof e||function(e){return"symbol"==typeof e||ne(e)&&"[object Symbol]"==B.call(e)}(e))return e;var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}function q(e){return function(e){return ne(e)&&$(e)}(e)&&z.call(e,"callee")&&(!O.call(e,"callee")||B.call(e)==r)}var K=Array.isArray;function $(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=i}(e.length)&&!ee(e)}function ee(e){var t=te(e)?B.call(e):"";return t==a||t==o}function te(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function ne(e){return!!e&&"object"==typeof e}function se(e){return $(e)?function(e,t){var n=K(e)||q(e)?function(e,t){for(var n=-1,s=Array(e);++n<e;)s[n]=t(n);return s}(e.length,String):[],s=n.length,i=!!s;for(var r in e)!t&&!z.call(e,r)||i&&("length"==r||W(r,s))||n.push(r);return n}(e,!0):function(e){if(!te(e))return function(e){var t=[];if(null!=e)for(var n in Object(e))t.push(n);return t}(e);var t,n,s=(n=(t=e)&&t.constructor,t===("function"==typeof n&&n.prototype||x)),i=[];for(var r in e)("constructor"!=r||!s&&z.call(e,r))&&i.push(r);return i}(e)}var ie,re,ae=(ie=function(e,t){return null==e?{}:(t=p(U(t,1),V),function(e,t){return function(e,t,n){for(var s=-1,i=t.length,r={};++s<i;){var a=t[s],o=e[a];n(0,a)&&(r[a]=o)}return r}(e=Object(e),t,(function(t,n){return n in e}))}(e,function(e,t,n,s){var i=-1,r=h,a=!0,o=e.length,l=[],c=t.length;if(!o)return l;t.length>=200&&(r=_,a=!1,t=new j(t));e:for(;++i<o;){var d=e[i],u=d;if(d=0!==d?d:0,a&&u==u){for(var f=c;f--;)if(t[f]===u)continue e;l.push(d)}else r(t,u,s)||l.push(d)}return l}(function(e){return function(e,t,n){var s=t(e);return K(e)?s:m(s,n(e))}(e,se,J)}(e),t)))},re=S(void 0===re?ie.length-1:re,0),function(){for(var e=arguments,t=-1,n=S(e.length-re,0),s=Array(n);++t<n;)s[t]=e[re+t];t=-1;for(var i=Array(re+1);++t<re;)i[t]=e[t];return i[re]=s,function(e,t,n){switch(n.length){case 0:return e.call(t);case 1:return e.call(t,n[0]);case 2:return e.call(t,n[0],n[1]);case 3:return e.call(t,n[0],n[1],n[2])}return e.apply(t,n)}(ie,this,i)});function oe(){return[]}e.exports=ae},5732:e=>{var t=1/0,n=4294967295,s=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,l=Object.prototype.toString,c=Math.min;function d(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function u(e){return e}e.exports=function(e,f){if((e=function(e){var n=function(e){return e?(e=function(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==l.call(e)}(e))return NaN;if(d(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=d(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(s,"");var n=r.test(e);return n||a.test(e)?o(e.slice(2),n?2:8):i.test(e)?NaN:+e}(e))===t||e===-1/0?17976931348623157e292*(e<0?-1:1):e==e?e:0:0===e?e:0}(e),c=n%1;return n==n?c?n-c:n:0}(e))<1||e>9007199254740991)return[];var h=n,p=c(e,n);e-=n;for(var m=function(e,t){for(var n=-1,s=Array(e);++n<e;)s[n]=t(n);return s}(p,f="function"==typeof f?f:u);++h<e;)f(h);return m}},73:e=>{function t(e,t){if(!e)throw new Error(t||"Assertion failed")}e.exports=t,t.equal=function(e,t,n){if(e!=t)throw new Error(n||"Assertion failed: "+e+" != "+t)}},1895:(e,t,n)=>{var s;if(!Object.keys){var i=Object.prototype.hasOwnProperty,r=Object.prototype.toString,a=n(8825),o=Object.prototype.propertyIsEnumerable,l=!o.call({toString:null},"toString"),c=o.call((function(){}),"prototype"),d=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],u=function(e){var t=e.constructor;return t&&t.prototype===e},f={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},h=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!f["$"+e]&&i.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{u(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();s=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===r.call(e),s=a(e),o=t&&"[object String]"===r.call(e),f=[];if(!t&&!n&&!s)throw new TypeError("Object.keys called on a non-object");var p=c&&n;if(o&&e.length>0&&!i.call(e,0))for(var m=0;m<e.length;++m)f.push(String(m));if(s&&e.length>0)for(var g=0;g<e.length;++g)f.push(String(g));else for(var _ in e)p&&"prototype"===_||!i.call(e,_)||f.push(String(_));if(l)for(var b=function(e){if("undefined"==typeof window||!h)return u(e);try{return u(e)}catch(e){return!1}}(e),y=0;y<d.length;++y)b&&"constructor"===d[y]||!i.call(e,d[y])||f.push(d[y]);return f}}e.exports=s},3425:(e,t,n)=>{var s=Array.prototype.slice,i=n(8825),r=Object.keys,a=r?function(e){return r(e)}:n(1895),o=Object.keys;a.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return i(e)?o(s.call(e)):o(e)})}else Object.keys=a;return Object.keys||a},e.exports=a},8825:e=>{var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),s="[object Arguments]"===n;return s||(s="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),s}},8599:(e,t,n)=>{var s=n(3425),i=n(4361)(),r=n(9343),a=Object,o=r("Array.prototype.push"),l=r("Object.prototype.propertyIsEnumerable"),c=i?Object.getOwnPropertySymbols:null;e.exports=function(e,t){if(null==e)throw new TypeError("target must be an object");var n=a(e);if(1===arguments.length)return n;for(var r=1;r<arguments.length;++r){var d=a(arguments[r]),u=s(d),f=i&&(Object.getOwnPropertySymbols||c);if(f)for(var h=f(d),p=0;p<h.length;++p){var m=h[p];l(d,m)&&o(u,m)}for(var g=0;g<u.length;++g){var _=u[g];if(l(d,_)){var b=d[_];n[_]=b}}}return n}},8662:(e,t,n)=>{var s=n(8599);e.exports=function(){return Object.assign?function(){if(!Object.assign)return!1;for(var e="abcdefghijklmnopqrst",t=e.split(""),n={},s=0;s<t.length;++s)n[t[s]]=t[s];var i=Object.assign({},n),r="";for(var a in i)r+=a;return e!==r}()||function(){if(!Object.assign||!Object.preventExtensions)return!1;var e=Object.preventExtensions({1:2});try{Object.assign(e,"xy")}catch(t){return"y"===e[1]}return!1}()?s:Object.assign:s}},6350:e=>{e.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},8101:e=>{function t(e){try{return JSON.stringify(e)}catch(e){return'"[Circular]"'}}e.exports=function(e,n,s){var i=s&&s.stringify||t;if("object"==typeof e&&null!==e){var r=n.length+1;if(1===r)return e;var a=new Array(r);a[0]=i(e);for(var o=1;o<r;o++)a[o]=i(n[o]);return a.join(" ")}if("string"!=typeof e)return e;var l=n.length;if(0===l)return e;for(var c="",d=0,u=-1,f=e&&e.length||0,h=0;h<f;){if(37===e.charCodeAt(h)&&h+1<f){switch(u=u>-1?u:0,e.charCodeAt(h+1)){case 100:case 102:if(d>=l)break;if(null==n[d])break;u<h&&(c+=e.slice(u,h)),c+=Number(n[d]),u=h+2,h++;break;case 105:if(d>=l)break;if(null==n[d])break;u<h&&(c+=e.slice(u,h)),c+=Math.floor(Number(n[d])),u=h+2,h++;break;case 79:case 111:case 106:if(d>=l)break;if(void 0===n[d])break;u<h&&(c+=e.slice(u,h));var p=typeof n[d];if("string"===p){c+="'"+n[d]+"'",u=h+2,h++;break}if("function"===p){c+=n[d].name||"<anonymous>",u=h+2,h++;break}c+=i(n[d]),u=h+2,h++;break;case 115:if(d>=l)break;u<h&&(c+=e.slice(u,h)),c+=String(n[d]),u=h+2,h++;break;case 37:u<h&&(c+=e.slice(u,h)),c+="%",u=h+2,h++,d--}++d}++h}return-1===u?e:(u<f&&(c+=e.slice(u)),c)}},8973:(e,t,n)=>{var s=n(8897),i=n(9381),r=n(6900)(),a=n(1399),o=n(1711),l=s("%Math.floor%");e.exports=function(e,t){if("function"!=typeof e)throw new o("`fn` is not a function");if("number"!=typeof t||t<0||t>4294967295||l(t)!==t)throw new o("`length` must be a positive 32-bit integer");var n=arguments.length>2&&!!arguments[2],s=!0,c=!0;if("length"in e&&a){var d=a(e,"length");d&&!d.configurable&&(s=!1),d&&!d.writable&&(c=!1)}return(s||c||!n)&&(r?i(e,"length",t,!0,!0):i(e,"length",t)),e}},3322:(e,t,n)=>{t.vm=void 0;var s,i=n(8891),r=(s=n(1733))&&s.__esModule?s:{default:s},a=function(e){var t=e.allowedSizes,n=e.defaultSize,s=e.padding;return function e(){var a=this,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;if(!this||this.constructor!==e)return new e(o);if(t&&!t.includes(o))throw new Error("Unsupported hash length");var l=new r.default({capacity:o});return this.update=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf8";if(i.Buffer.isBuffer(e))return l.absorb(e),a;if("string"==typeof e)return a.update(i.Buffer.from(e,t));throw new TypeError("Not a string or buffer")},this.digest=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"binary",t="string"==typeof e?{format:e}:e,n=l.squeeze({buffer:t.buffer,padding:t.padding||s});return t.format&&"binary"!==t.format?n.toString(t.format):n},this.reset=function(){return l.reset(),a},this}},o=a({allowedSizes:[224,256,384,512],defaultSize:512,padding:1});t.vm=o;var l=a({allowedSizes:[224,256,384,512],defaultSize:512,padding:6});a({allowedSizes:[128,256],defaultSize:256,padding:31});var c=o;l.SHA3Hash=c},1733:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s,i=n(8891),r=(s=n(1356))&&s.__esModule?s:{default:s},a=function(e,t){for(var n=0;n<e.length;n+=8){var s=n/4;t[s]^=e[n+7]<<24|e[n+6]<<16|e[n+5]<<8|e[n+4],t[s+1]^=e[n+3]<<24|e[n+2]<<16|e[n+1]<<8|e[n]}return t},o=function(e,t){for(var n=0;n<t.length;n+=8){var s=n/4;t[n]=e[s+1],t[n+1]=e[s+1]>>>8,t[n+2]=e[s+1]>>>16,t[n+3]=e[s+1]>>>24,t[n+4]=e[s],t[n+5]=e[s]>>>8,t[n+6]=e[s]>>>16,t[n+7]=e[s]>>>24}return t};t.default=function(e){var t=this,n=e.capacity,s=e.padding,l=(0,r.default)(),c=n/8,d=200-n/4,u=0,f=new Uint32Array(50),h=i.Buffer.allocUnsafe(d);return this.absorb=function(e){for(var n=0;n<e.length;n++)h[u]=e[n],(u+=1)>=d&&(a(h,f),l(f),u=0);return t},this.squeeze=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={buffer:e.buffer||i.Buffer.allocUnsafe(c),padding:e.padding||s,queue:i.Buffer.allocUnsafe(h.length),state:new Uint32Array(f.length)};h.copy(t.queue);for(var n=0;n<f.length;n++)t.state[n]=f[n];t.queue.fill(0,u),t.queue[u]|=t.padding,t.queue[d-1]|=128,a(t.queue,t.state);for(var r=0;r<t.buffer.length;r+=d)l(t.state),o(t.state,t.buffer.slice(r,r+d));return t.buffer},this.reset=function(){return h.fill(0),f.fill(0),u=0,t},this}},737:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s,i=(s=n(1120))&&s.__esModule?s:{default:s};t.default=function(e){for(var t=e.A,n=e.C,s=0;s<25;s+=5){for(var r=0;r<5;r++)(0,i.default)(t,s+r)(n,r);for(var a=0;a<5;a++){var o=2*(s+a),l=(a+1)%5*2,c=(a+2)%5*2;t[o]^=~n[l]&n[c],t[o+1]^=~n[l+1]&n[c+1]}}}},1120:e=>{e.exports=function(e,t){return function(n,s){var i=2*s,r=2*t;n[i]=e[r],n[i+1]=e[r+1]}}},1356:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s=o(n(737)),i=o(n(9810)),r=o(n(3915)),a=o(n(8547));function o(e){return e&&e.__esModule?e:{default:e}}t.default=function(){var e=new Uint32Array(10),t=new Uint32Array(10),n=new Uint32Array(2);return function(o){for(var l=0;l<24;l++)(0,a.default)({A:o,C:e,D:t,W:n}),(0,r.default)({A:o,C:e,W:n}),(0,s.default)({A:o,C:e}),(0,i.default)({A:o,roundIndex:l});e.fill(0),t.fill(0),n.fill(0)}}},9810:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s,i=(s=n(1))&&s.__esModule?s:{default:s};t.default=function(e){var t=e.A,n=2*e.roundIndex;t[0]^=i.default[n],t[1]^=i.default[n+1]}},1:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=new Uint32Array([0,1,0,32898,2147483648,32906,2147483648,2147516416,0,32907,0,2147483649,2147483648,2147516545,2147483648,32777,0,138,0,136,0,2147516425,0,2147483658,0,2147516555,2147483648,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,0,32778,2147483648,2147483658,2147483648,2147516545,2147483648,32896,0,2147483649,2147483648,2147516424]);t.default=n},3915:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s=a(n(1795)),i=a(n(7997)),r=a(n(1120));function a(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.A,n=e.C,a=e.W;(0,r.default)(t,1)(a,0);for(var o=0,l=0,c=0,d=32,u=0;u<24;u++){var f=s.default[u],h=i.default[u];(0,r.default)(t,f)(n,0),o=a[0],l=a[1],d=32-h,a[c=h<32?0:1]=o<<h|l>>>d,a[(c+1)%2]=l<<h|o>>>d,(0,r.default)(a,0)(t,f),(0,r.default)(n,0)(a,0)}}},1795:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default=[10,7,11,17,18,3,5,16,8,21,24,4,15,23,19,13,12,2,20,14,22,9,6,1]},7997:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default=[1,3,6,10,15,21,28,36,45,55,2,14,27,41,56,8,25,43,62,18,39,61,20,44]},8547:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s,i=(s=n(1120))&&s.__esModule?s:{default:s};t.default=function(e){for(var t=e.A,n=e.C,s=e.D,r=e.W,a=0,o=0,l=0;l<5;l++){var c=2*l,d=2*(l+5),u=2*(l+10),f=2*(l+15),h=2*(l+20);n[c]=t[c]^t[d]^t[u]^t[f]^t[h],n[c+1]=t[c+1]^t[d+1]^t[u+1]^t[f+1]^t[h+1]}for(var p=0;p<5;p++){(0,i.default)(n,(p+1)%5)(r,0),a=r[0],o=r[1],r[0]=a<<1|o>>>31,r[1]=o<<1|a>>>31,s[2*p]=n[(p+4)%5*2]^r[0],s[2*p+1]=n[(p+4)%5*2+1]^r[1];for(var m=0;m<25;m+=5)t[2*(m+p)]^=s[2*p],t[2*(m+p)+1]^=s[2*p+1]}}},5171:e=>{e.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},1028:(e,t,n)=>{var s=n(5456),i=n(6940),r=n(6059),a=n(2116);function o(e){return e.call.bind(e)}var l="undefined"!=typeof BigInt,c="undefined"!=typeof Symbol,d=o(Object.prototype.toString),u=o(Number.prototype.valueOf),f=o(String.prototype.valueOf),h=o(Boolean.prototype.valueOf);if(l)var p=o(BigInt.prototype.valueOf);if(c)var m=o(Symbol.prototype.valueOf);function g(e,t){if("object"!=typeof e)return!1;try{return t(e),!0}catch(e){return!1}}function _(e){return"[object Map]"===d(e)}function b(e){return"[object Set]"===d(e)}function y(e){return"[object WeakMap]"===d(e)}function A(e){return"[object WeakSet]"===d(e)}function w(e){return"[object ArrayBuffer]"===d(e)}function x(e){return"undefined"!=typeof ArrayBuffer&&(w.working?w(e):e instanceof ArrayBuffer)}function v(e){return"[object DataView]"===d(e)}function E(e){return"undefined"!=typeof DataView&&(v.working?v(e):e instanceof DataView)}t.isArgumentsObject=s,t.isGeneratorFunction=i,t.isTypedArray=a,t.isPromise=function(e){return"undefined"!=typeof Promise&&e instanceof Promise||null!==e&&"object"==typeof e&&"function"==typeof e.then&&"function"==typeof e.catch},t.isArrayBufferView=function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):a(e)||E(e)},t.isUint8Array=function(e){return"Uint8Array"===r(e)},t.isUint8ClampedArray=function(e){return"Uint8ClampedArray"===r(e)},t.isUint16Array=function(e){return"Uint16Array"===r(e)},t.isUint32Array=function(e){return"Uint32Array"===r(e)},t.isInt8Array=function(e){return"Int8Array"===r(e)},t.isInt16Array=function(e){return"Int16Array"===r(e)},t.isInt32Array=function(e){return"Int32Array"===r(e)},t.isFloat32Array=function(e){return"Float32Array"===r(e)},t.isFloat64Array=function(e){return"Float64Array"===r(e)},t.isBigInt64Array=function(e){return"BigInt64Array"===r(e)},t.isBigUint64Array=function(e){return"BigUint64Array"===r(e)},_.working="undefined"!=typeof Map&&_(new Map),t.isMap=function(e){return"undefined"!=typeof Map&&(_.working?_(e):e instanceof Map)},b.working="undefined"!=typeof Set&&b(new Set),t.isSet=function(e){return"undefined"!=typeof Set&&(b.working?b(e):e instanceof Set)},y.working="undefined"!=typeof WeakMap&&y(new WeakMap),t.isWeakMap=function(e){return"undefined"!=typeof WeakMap&&(y.working?y(e):e instanceof WeakMap)},A.working="undefined"!=typeof WeakSet&&A(new WeakSet),t.isWeakSet=function(e){return A(e)},w.working="undefined"!=typeof ArrayBuffer&&w(new ArrayBuffer),t.isArrayBuffer=x,v.working="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView&&v(new DataView(new ArrayBuffer(1),0,1)),t.isDataView=E;var M="undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function z(e){return"[object SharedArrayBuffer]"===d(e)}function B(e){return void 0!==M&&(void 0===z.working&&(z.working=z(new M)),z.working?z(e):e instanceof M)}function F(e){return g(e,u)}function k(e){return g(e,f)}function C(e){return g(e,h)}function O(e){return l&&g(e,p)}function D(e){return c&&g(e,m)}t.isSharedArrayBuffer=B,t.isAsyncFunction=function(e){return"[object AsyncFunction]"===d(e)},t.isMapIterator=function(e){return"[object Map Iterator]"===d(e)},t.isSetIterator=function(e){return"[object Set Iterator]"===d(e)},t.isGeneratorObject=function(e){return"[object Generator]"===d(e)},t.isWebAssemblyCompiledModule=function(e){return"[object WebAssembly.Module]"===d(e)},t.isNumberObject=F,t.isStringObject=k,t.isBooleanObject=C,t.isBigIntObject=O,t.isSymbolObject=D,t.isBoxedPrimitive=function(e){return F(e)||k(e)||C(e)||O(e)||D(e)},t.isAnyArrayBuffer=function(e){return"undefined"!=typeof Uint8Array&&(x(e)||B(e))},["isProxy","isExternal","isModuleNamespaceObject"].forEach((function(e){Object.defineProperty(t,e,{enumerable:!1,value:function(){throw new Error(e+" is not supported in userland")}})}))},7877:(e,t,n)=>{var s=Object.getOwnPropertyDescriptors||function(e){for(var t=Object.keys(e),n={},s=0;s<t.length;s++)n[t[s]]=Object.getOwnPropertyDescriptor(e,t[s]);return n},i=/%[sdj%]/g;t.format=function(e){if(!b(e)){for(var t=[],n=0;n<arguments.length;n++)t.push(l(arguments[n]));return t.join(" ")}n=1;for(var s=arguments,r=s.length,a=String(e).replace(i,(function(e){if("%%"===e)return"%";if(n>=r)return e;switch(e){case"%s":return String(s[n++]);case"%d":return Number(s[n++]);case"%j":try{return JSON.stringify(s[n++])}catch(e){return"[Circular]"}default:return e}})),o=s[n];n<r;o=s[++n])g(o)||!w(o)?a+=" "+o:a+=" "+l(o);return a},t.deprecate=function(e,n){if("undefined"!=typeof process&&!0===process.noDeprecation)return e;if("undefined"==typeof process)return function(){return t.deprecate(e,n).apply(this,arguments)};var s=!1;return function(){if(!s){if(process.throwDeprecation)throw new Error(n);process.traceDeprecation?console.trace(n):console.error(n),s=!0}return e.apply(this,arguments)}};var r={},a=/^$/;if({NODE_ENV:"production"}.NODE_DEBUG){var o={NODE_ENV:"production"}.NODE_DEBUG;o=o.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),a=new RegExp("^"+o+"$","i")}function l(e,n){var s={seen:[],stylize:d};return arguments.length>=3&&(s.depth=arguments[2]),arguments.length>=4&&(s.colors=arguments[3]),m(n)?s.showHidden=n:n&&t._extend(s,n),y(s.showHidden)&&(s.showHidden=!1),y(s.depth)&&(s.depth=2),y(s.colors)&&(s.colors=!1),y(s.customInspect)&&(s.customInspect=!0),s.colors&&(s.stylize=c),u(s,e,s.depth)}function c(e,t){var n=l.styles[t];return n?"["+l.colors[n][0]+"m"+e+"["+l.colors[n][1]+"m":e}function d(e,t){return e}function u(e,n,s){if(e.customInspect&&n&&E(n.inspect)&&n.inspect!==t.inspect&&(!n.constructor||n.constructor.prototype!==n)){var i=n.inspect(s,e);return b(i)||(i=u(e,i,s)),i}var r=function(e,t){if(y(t))return e.stylize("undefined","undefined");if(b(t)){var n="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(n,"string")}return _(t)?e.stylize(""+t,"number"):m(t)?e.stylize(""+t,"boolean"):g(t)?e.stylize("null","null"):void 0}(e,n);if(r)return r;var a=Object.keys(n),o=function(e){var t={};return e.forEach((function(e,n){t[e]=!0})),t}(a);if(e.showHidden&&(a=Object.getOwnPropertyNames(n)),v(n)&&(a.indexOf("message")>=0||a.indexOf("description")>=0))return f(n);if(0===a.length){if(E(n)){var l=n.name?": "+n.name:"";return e.stylize("[Function"+l+"]","special")}if(A(n))return e.stylize(RegExp.prototype.toString.call(n),"regexp");if(x(n))return e.stylize(Date.prototype.toString.call(n),"date");if(v(n))return f(n)}var c,d="",w=!1,M=["{","}"];return p(n)&&(w=!0,M=["[","]"]),E(n)&&(d=" [Function"+(n.name?": "+n.name:"")+"]"),A(n)&&(d=" "+RegExp.prototype.toString.call(n)),x(n)&&(d=" "+Date.prototype.toUTCString.call(n)),v(n)&&(d=" "+f(n)),0!==a.length||w&&0!=n.length?s<0?A(n)?e.stylize(RegExp.prototype.toString.call(n),"regexp"):e.stylize("[Object]","special"):(e.seen.push(n),c=w?function(e,t,n,s,i){for(var r=[],a=0,o=t.length;a<o;++a)F(t,String(a))?r.push(h(e,t,n,s,String(a),!0)):r.push("");return i.forEach((function(i){i.match(/^\d+$/)||r.push(h(e,t,n,s,i,!0))})),r}(e,n,s,o,a):a.map((function(t){return h(e,n,s,o,t,w)})),e.seen.pop(),function(e,t,n){return e.reduce((function(e,t){return t.indexOf("\n"),e+t.replace(/\u001b\[\d\d?m/g,"").length+1}),0)>60?n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1]:n[0]+t+" "+e.join(", ")+" "+n[1]}(c,d,M)):M[0]+d+M[1]}function f(e){return"["+Error.prototype.toString.call(e)+"]"}function h(e,t,n,s,i,r){var a,o,l;if((l=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?o=l.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):l.set&&(o=e.stylize("[Setter]","special")),F(s,i)||(a="["+i+"]"),o||(e.seen.indexOf(l.value)<0?(o=g(n)?u(e,l.value,null):u(e,l.value,n-1)).indexOf("\n")>-1&&(o=r?o.split("\n").map((function(e){return"  "+e})).join("\n").slice(2):"\n"+o.split("\n").map((function(e){return"   "+e})).join("\n")):o=e.stylize("[Circular]","special")),y(a)){if(r&&i.match(/^\d+$/))return o;(a=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.slice(1,-1),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+o}function p(e){return Array.isArray(e)}function m(e){return"boolean"==typeof e}function g(e){return null===e}function _(e){return"number"==typeof e}function b(e){return"string"==typeof e}function y(e){return void 0===e}function A(e){return w(e)&&"[object RegExp]"===M(e)}function w(e){return"object"==typeof e&&null!==e}function x(e){return w(e)&&"[object Date]"===M(e)}function v(e){return w(e)&&("[object Error]"===M(e)||e instanceof Error)}function E(e){return"function"==typeof e}function M(e){return Object.prototype.toString.call(e)}function z(e){return e<10?"0"+e.toString(10):e.toString(10)}t.debuglog=function(e){if(e=e.toUpperCase(),!r[e])if(a.test(e)){var n=process.pid;r[e]=function(){var s=t.format.apply(t,arguments);console.error("%s %d: %s",e,n,s)}}else r[e]=function(){};return r[e]},t.inspect=l,l.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},l.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.types=n(1028),t.isArray=p,t.isBoolean=m,t.isNull=g,t.isNullOrUndefined=function(e){return null==e},t.isNumber=_,t.isString=b,t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=y,t.isRegExp=A,t.types.isRegExp=A,t.isObject=w,t.isDate=x,t.types.isDate=x,t.isError=v,t.types.isNativeError=v,t.isFunction=E,t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=n(5171);var B=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function F(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.log=function(){var e,n;console.log("%s - %s",(n=[z((e=new Date).getHours()),z(e.getMinutes()),z(e.getSeconds())].join(":"),[e.getDate(),B[e.getMonth()],n].join(" ")),t.format.apply(t,arguments))},t.inherits=n(198),t._extend=function(e,t){if(!t||!w(t))return e;for(var n=Object.keys(t),s=n.length;s--;)e[n[s]]=t[n[s]];return e};var k="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function C(e,t){if(!e){var n=new Error("Promise was rejected with a falsy value");n.reason=e,e=n}return t(e)}t.promisify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');if(k&&e[k]){var t;if("function"!=typeof(t=e[k]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(t,k,{value:t,enumerable:!1,writable:!1,configurable:!0}),t}function t(){for(var t,n,s=new Promise((function(e,s){t=e,n=s})),i=[],r=0;r<arguments.length;r++)i.push(arguments[r]);i.push((function(e,s){e?n(e):t(s)}));try{e.apply(this,i)}catch(e){n(e)}return s}return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),k&&Object.defineProperty(t,k,{value:t,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(t,s(e))},t.promisify.custom=k,t.callbackify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');function t(){for(var t=[],n=0;n<arguments.length;n++)t.push(arguments[n]);var s=t.pop();if("function"!=typeof s)throw new TypeError("The last argument must be of type Function");var i=this,r=function(){return s.apply(i,arguments)};e.apply(this,t).then((function(e){process.nextTick(r.bind(null,null,e))}),(function(e){process.nextTick(C.bind(null,e,r))}))}return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),Object.defineProperties(t,s(e)),t}},6059:(e,t,n)=>{var s=n(7270),i=n(2847),r=n(8179),a=n(9343),o=n(1399),l=a("Object.prototype.toString"),c=n(1432)(),d="undefined"==typeof globalThis?n.g:globalThis,u=i(),f=a("String.prototype.slice"),h=Object.getPrototypeOf,p=a("Array.prototype.indexOf",!0)||function(e,t){for(var n=0;n<e.length;n+=1)if(e[n]===t)return n;return-1},m={__proto__:null};s(u,c&&o&&h?function(e){var t=new d[e];if(Symbol.toStringTag in t){var n=h(t),s=o(n,Symbol.toStringTag);if(!s){var i=h(n);s=o(i,Symbol.toStringTag)}m["$"+e]=r(s.get)}}:function(e){var t=new d[e],n=t.slice||t.set;n&&(m["$"+e]=r(n))}),e.exports=function(e){if(!e||"object"!=typeof e)return!1;if(!c){var t=f(l(e),8,-1);return p(u,t)>-1?t:"Object"===t&&function(e){var t=!1;return s(m,(function(n,s){if(!t)try{n(e),t=f(s,1)}catch(e){}})),t}(e)}return o?function(e){var t=!1;return s(m,(function(n,s){if(!t)try{"$"+n(e)===s&&(t=f(s,1))}catch(e){}})),t}(e):null}},9331:()=>{},3023:()=>{},9813:()=>{},9777:()=>{},2847:(e,t,n)=>{var s=n(6350),i="undefined"==typeof globalThis?n.g:globalThis;e.exports=function(){for(var e=[],t=0;t<s.length;t++)"function"==typeof i[s[t]]&&(e[e.length]=s[t]);return e}},8968:(e,t,n)=>{const s=n(8101);e.exports=u;const i=function(){function e(e){return void 0!==e&&e}try{return"undefined"!=typeof globalThis||Object.defineProperty(Object.prototype,"globalThis",{get:function(){return delete Object.prototype.globalThis,this.globalThis=this},configurable:!0}),globalThis}catch(t){return e(self)||e(window)||e(this)||{}}}().console||{},r={mapHttpRequest:_,mapHttpResponse:_,wrapRequestSerializer:b,wrapResponseSerializer:b,wrapErrorSerializer:b,req:_,res:_,err:m,errWithCause:m};function a(e,t){return"silent"===e?1/0:t.levels.values[e]}const o=Symbol("pino.logFuncs"),l=Symbol("pino.hierarchy"),c={error:"log",fatal:"error",warn:"error",info:"log",debug:"log",trace:"log"};function d(e,t){const n={logger:t,parent:e[l]};t[l]=n}function u(e){(e=e||{}).browser=e.browser||{};const t=e.browser.transmit;if(t&&"function"!=typeof t.send)throw Error("pino: transmit option must have a send function");const n=e.browser.write||i;e.browser.write&&(e.browser.asObject=!0);const s=e.serializers||{},r=function(e,t){return Array.isArray(e)?e.filter((function(e){return"!stdSerializers.err"!==e})):!0===e&&Object.keys(t)}(e.browser.serialize,s);let l=e.browser.serialize;Array.isArray(e.browser.serialize)&&e.browser.serialize.indexOf("!stdSerializers.err")>-1&&(l=!1);const m=Object.keys(e.customLevels||{}),_=["error","fatal","warn","info","debug","trace"].concat(m);"function"==typeof n&&_.forEach((function(e){n[e]=n})),(!1===e.enabled||e.browser.disabled)&&(e.level="silent");const b=e.level||"info",A=Object.create(n);A.log||(A.log=y),function(e,t,n){const s={};t.forEach((e=>{s[e]=n[e]?n[e]:i[e]||i[c[e]||"log"]||y})),e[o]=s}(A,_,n),d({},A),Object.defineProperty(A,"levelVal",{get:function(){return a(this.level,this)}}),Object.defineProperty(A,"level",{get:function(){return this._level},set:function(e){if("silent"!==e&&!this.levels.values[e])throw Error("unknown level "+e);this._level=e,f(this,w,A,"error"),f(this,w,A,"fatal"),f(this,w,A,"warn"),f(this,w,A,"info"),f(this,w,A,"debug"),f(this,w,A,"trace"),m.forEach((e=>{f(this,w,A,e)}))}});const w={transmit:t,serialize:r,asObject:e.browser.asObject,formatters:e.browser.formatters,levels:_,timestamp:g(e),messageKey:e.messageKey||"msg",onChild:e.onChild||y};function x(n,i,a){if(!i)throw new Error("missing bindings for child Pino");a=a||{},r&&i.serializers&&(a.serializers=i.serializers);const o=a.serializers;if(r&&o){var l=Object.assign({},s,o),c=!0===e.browser.serialize?Object.keys(l):r;delete i.serializers,h([i],c,l,this._stdErrSerialize)}function u(e){this._childLevel=1+(0|e._childLevel),this.bindings=i,l&&(this.serializers=l,this._serialize=c),t&&(this._logEvent=p([].concat(e._logEvent.bindings,i)))}u.prototype=this;const f=new u(this);return d(this,f),f.child=function(...e){return x.call(this,n,...e)},f.level=a.level||this.level,n.onChild(f),f}return A.levels=function(e){const t=e.customLevels||{};return{values:Object.assign({},u.levels.values,t),labels:Object.assign({},u.levels.labels,function(e){const t={};return Object.keys(e).forEach((function(n){t[e[n]]=n})),t}(t))}}(e),A.level=b,A.setMaxListeners=A.getMaxListeners=A.emit=A.addListener=A.on=A.prependListener=A.once=A.prependOnceListener=A.removeListener=A.removeAllListeners=A.listeners=A.listenerCount=A.eventNames=A.write=A.flush=y,A.serializers=s,A._serialize=r,A._stdErrSerialize=l,A.child=function(...e){return x.call(this,w,...e)},t&&(A._logEvent=p()),A}function f(e,t,n,r){if(Object.defineProperty(e,r,{value:a(e.level,n)>a(r,n)?y:n[o][r],writable:!0,enumerable:!0,configurable:!0}),e[r]===y){if(!t.transmit)return;const s=a(t.transmit.level||e.level,n);if(a(r,n)<s)return}e[r]=function(e,t,n,r){return l=e[o][r],function(){const o=t.timestamp(),c=new Array(arguments.length),d=Object.getPrototypeOf&&Object.getPrototypeOf(this)===i?i:this;for(var u=0;u<c.length;u++)c[u]=arguments[u];var f=!1;if(t.serialize&&(h(c,this._serialize,this.serializers,this._stdErrSerialize),f=!0),t.asObject||t.formatters?l.call(d,function(e,t,n,i,r){const{level:a,log:o=(e=>e)}=r.formatters||{},l=n.slice();let c=l[0];const d={};if(i&&(d.time=i),a){const n=a(t,e.levels.values[t]);Object.assign(d,n)}else d.level=e.levels.values[t];let u=1+(0|e._childLevel);if(u<1&&(u=1),null!==c&&"object"==typeof c){for(;u--&&"object"==typeof l[0];)Object.assign(d,l.shift());c=l.length?s(l.shift(),l):void 0}else"string"==typeof c&&(c=s(l.shift(),l));return void 0!==c&&(d[r.messageKey]=c),o(d)}(this,r,c,o,t)):l.apply(d,c),t.transmit){const s=t.transmit.level||e._level,i=a(s,n),l=a(r,n);if(l<i)return;!function(e,t,n,s=!1){const i=t.send,r=t.ts,a=t.methodLevel,o=t.methodValue,l=t.val,c=e._logEvent.bindings;s||h(n,e._serialize||Object.keys(e.serializers),e.serializers,void 0===e._stdErrSerialize||e._stdErrSerialize),e._logEvent.ts=r,e._logEvent.messages=n.filter((function(e){return-1===c.indexOf(e)})),e._logEvent.level.label=a,e._logEvent.level.value=o,i(a,e._logEvent,l),e._logEvent=p(c)}(this,{ts:o,methodLevel:r,methodValue:l,transmitLevel:s,transmitValue:n.levels.values[t.transmit.level||e._level],send:t.transmit.send,val:a(e._level,n)},c,f)}};var l}(e,t,n,r);const c=function(e){const t=[];e.bindings&&t.push(e.bindings);let n=e[l];for(;n.parent;)n=n.parent,n.logger.bindings&&t.push(n.logger.bindings);return t.reverse()}(e);0!==c.length&&(e[r]=function(e,t){return function(){return t.apply(this,[...e,...arguments])}}(c,e[r]))}function h(e,t,n,s){for(const i in e)if(s&&e[i]instanceof Error)e[i]=u.stdSerializers.err(e[i]);else if("object"==typeof e[i]&&!Array.isArray(e[i])&&t)for(const s in e[i])t.indexOf(s)>-1&&s in n&&(e[i][s]=n[s](e[i][s]))}function p(e){return{ts:0,messages:[],bindings:e||[],level:{label:"",value:0}}}function m(e){const t={type:e.constructor.name,msg:e.message,stack:e.stack};for(const n in e)void 0===t[n]&&(t[n]=e[n]);return t}function g(e){return"function"==typeof e.timestamp?e.timestamp:!1===e.timestamp?A:w}function _(){return{}}function b(e){return e}function y(){}function A(){return!1}function w(){return Date.now()}u.levels={values:{fatal:60,error:50,warn:40,info:30,debug:20,trace:10},labels:{10:"trace",20:"debug",30:"info",40:"warn",50:"error",60:"fatal"}},u.stdSerializers=r,u.stdTimeFunctions=Object.assign({},{nullTime:A,epochTime:w,unixTime:function(){return Math.round(Date.now()/1e3)},isoTime:function(){return new Date(Date.now()).toISOString()}}),e.exports.default=u,e.exports.pino=u},6027:(e,t,n)=>{function s(e){return"string"==typeof e?{address:e,type:"json-rpc"}:e}n.d(t,{J:()=>s})},2894:(e,t,n)=>{n.d(t,{T:()=>C});var s=n(3021),i=n(7775),r=n(1542);function a(e){const t=(0,i.e)(e),n=[],a=e.length;for(let i=0;i<a;i++){const a=e[i];(0,s.WL)(a)||n.push((0,r.uT)(a,t))}return n}var o=n(6027);const l=[{inputs:[{components:[{name:"target",type:"address"},{name:"allowFailure",type:"bool"},{name:"callData",type:"bytes"}],name:"calls",type:"tuple[]"}],name:"aggregate3",outputs:[{components:[{name:"success",type:"bool"},{name:"returnData",type:"bytes"}],name:"returnData",type:"tuple[]"}],stateMutability:"view",type:"function"}],c="0x82ad56cb",d="0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe",u="0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe";var f=n(9302),h=n(1893),p=n(3329),m=n(8902),g=n(3686),_=n(7673),b=n(2142);const y="/docs/contract/encodeDeployData";function A(e){const{abi:t,args:n,bytecode:s}=e;if(!n||0===n.length)return s;const i=t.find((e=>"type"in e&&"constructor"===e.type));if(!i)throw new g.YW({docsPath:y});if(!("inputs"in i))throw new g.YF({docsPath:y});if(!i.inputs||0===i.inputs.length)throw new g.YF({docsPath:y});const r=(0,b.h)(i.inputs,n);return(0,_.aP)([s,r])}var w=n(2373),x=n(9042),v=n(7426),E=n(3594),M=n(5979),z=n(2545);const B=new Map;var F=n(6409),k=n(7338);async function C(e,t){const{account:s=e.account,batch:i=Boolean(e.batch?.multicall),blockNumber:r,blockTag:g="latest",accessList:_,blobs:b,code:y,data:C,factory:O,factoryData:D,gas:L,gasPrice:T,maxFeePerBlobGas:S,maxFeePerGas:N,maxPriorityFeePerGas:P,nonce:I,to:Y,value:Q,stateOverride:j,...H}=t,U=s?(0,o.J)(s):void 0;if(y&&(O||D))throw new f.C("Cannot provide both `code` & `factory`/`factoryData` as parameters.");if(y&&Y)throw new f.C("Cannot provide both `code` & `to` as parameters.");const R=y&&C,G=O&&D&&Y&&C,Z=R||G,J=R?function(e){const{code:t,data:n}=e;return A({abi:a(["constructor(bytes, bytes)"]),bytecode:d,args:[t,n]})}({code:y,data:C}):G?function(e){const{data:t,factory:n,factoryData:s,to:i}=e;return A({abi:a(["constructor(address, bytes, address, bytes)"]),bytecode:u,args:[i,t,n,s]})}({data:C,factory:O,factoryData:D,to:Y}):C;try{(0,k.c)(t);const n=(r?(0,x.cK)(r):void 0)||g,s=(0,F.yH)(j),a=e.chain?.formatters?.transactionRequest?.format,o=(a||z.Bv)({...(0,M.o)(H,{format:a}),from:U?.address,accessList:_,blobs:b,data:J,gas:L,gasPrice:T,maxFeePerBlobGas:S,maxFeePerGas:N,maxPriorityFeePerGas:P,nonce:I,to:Z?void 0:Y,value:Q});if(i&&function({request:e}){const{data:t,to:n,...s}=e;return!(!t||t.startsWith(c)||!n||Object.values(s).filter((e=>void 0!==e)).length>0)}({request:o})&&!s)try{return await async function(e,t){const{batchSize:n=1024,wait:s=0}="object"==typeof e.batch?.multicall?e.batch.multicall:{},{blockNumber:i,blockTag:r="latest",data:a,multicallAddress:o,to:c}=t;let d=o;if(!d){if(!e.chain)throw new h.YE;d=function({blockNumber:e,chain:t,contract:n}){const s=t?.contracts?.[n];if(!s)throw new h.rj({chain:t,contract:{name:n}});if(e&&s.blockCreated&&s.blockCreated>e)throw new h.rj({blockNumber:e,chain:t,contract:{name:n,blockCreated:s.blockCreated}});return s.address}({blockNumber:i,chain:e.chain,contract:"multicall3"})}const u=(i?(0,x.cK)(i):void 0)||r,{schedule:f}=function({fn:e,id:t,shouldSplitBatch:n,wait:s=0,sort:i}){const r=async()=>{const t=o();a();const n=t.map((({args:e})=>e));0!==n.length&&e(n).then((e=>{i&&Array.isArray(e)&&e.sort(i);for(let n=0;n<t.length;n++){const{resolve:s}=t[n];s?.([e[n],e])}})).catch((e=>{for(let n=0;n<t.length;n++){const{reject:s}=t[n];s?.(e)}}))},a=()=>B.delete(t),o=()=>B.get(t)||[],l=e=>B.set(t,[...o(),e]);return{flush:a,async schedule(e){const{promise:t,resolve:i,reject:a}=function(){let e=()=>{},t=()=>{};return{promise:new Promise(((n,s)=>{e=n,t=s})),resolve:e,reject:t}}(),c=n?.([...o().map((({args:e})=>e)),e]);return c&&r(),o().length>0?(l({args:e,resolve:i,reject:a}),t):(l({args:e,resolve:i,reject:a}),setTimeout(r,s),t)}}}({id:`${e.uid}.${u}`,wait:s,shouldSplitBatch(e){const t=e.reduce(((e,{data:t})=>e+(t.length-2)),0);return t>2*n},fn:async t=>{const n=t.map((e=>({allowFailure:!0,callData:e.data,target:e.to}))),s=(0,w.p)({abi:l,args:[n],functionName:"aggregate3"}),i=await e.request({method:"eth_call",params:[{data:s,to:d},u]});return(0,m.e)({abi:l,args:[n],functionName:"aggregate3",data:i||"0x"})}}),[{returnData:g,success:_}]=await f({data:a,to:c});if(!_)throw new p.$S({data:g});return"0x"===g?{data:void 0}:{data:g}}(e,{...o,blockNumber:r,blockTag:g})}catch(e){if(!(e instanceof h.YE||e instanceof h.rj))throw e}const d=await e.request({method:"eth_call",params:s?[o,n,s]:[o,n]});return"0x"===d?{data:void 0}:{data:d}}catch(s){const i=function(e){if(!(e instanceof f.C))return;const t=e.walk();return"object"==typeof t?.data?t.data?.data:t.data}(s),{offchainLookup:r,offchainLookupSignature:a}=await Promise.resolve().then(n.bind(n,4471));if(!1!==e.ccipRead&&i?.slice(0,10)===a&&Y)return{data:await r(e,{data:i,to:Y})};if(Z&&"0x101bb98d"===i?.slice(0,10))throw new p.Po({factory:O});throw function(e,{docsPath:t,...n}){const s=(()=>{const t=(0,E.l)(e,n);return t instanceof v.RM?e:t})();return new p.zX(s,{docsPath:t,...n})}(s,{...t,account:U,chain:e.chain})}}},1919:(e,t,n)=>{n.d(t,{J9:()=>r,Mc:()=>i,fD:()=>s});const s={1:"An `assert` condition failed.",17:"Arithmetic operation resulted in underflow or overflow.",18:"Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",33:"Attempted to convert to an invalid type.",34:"Attempted to access a storage byte array that is incorrectly encoded.",49:"Performed `.pop()` on an empty array",50:"Array index is out of bounds.",65:"Allocated too much memory or created an array which is too large.",81:"Attempted to call a zero-initialized variable of internal function type."},i={inputs:[{name:"message",type:"string"}],name:"Error",type:"error"},r={inputs:[{name:"reason",type:"uint256"}],name:"Panic",type:"error"}},6956:(e,t,n)=>{n.d(t,{eL:()=>s,sz:()=>i});const s={gwei:9,wei:18},i={ether:-9,wei:9}},3686:(e,t,n)=>{n.d(t,{Iy:()=>l,Iz:()=>_,MR:()=>b,M_:()=>g,Nc:()=>d,O:()=>c,Wq:()=>h,YE:()=>f,YF:()=>o,YW:()=>a,_z:()=>p,d_:()=>M,dm:()=>E,fo:()=>A,gH:()=>u,j:()=>v,kE:()=>m,l3:()=>w,nK:()=>x,nM:()=>y});var s=n(113),i=n(6420),r=n(9302);class a extends r.C{constructor({docsPath:e}){super(["A constructor was not found on the ABI.","Make sure you are using the correct ABI and that the constructor exists on it."].join("\n"),{docsPath:e,name:"AbiConstructorNotFoundError"})}}class o extends r.C{constructor({docsPath:e}){super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.","Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join("\n"),{docsPath:e,name:"AbiConstructorParamsNotFoundError"})}}r.C;class l extends r.C{constructor({data:e,params:t,size:n}){super([`Data size of ${n} bytes is too small for given parameters.`].join("\n"),{metaMessages:[`Params: (${(0,s.A)(t,{includeName:!0})})`,`Data:   ${e} (${n} bytes)`],name:"AbiDecodingDataSizeTooSmallError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=e,this.params=t,this.size=n}}class c extends r.C{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.',{name:"AbiDecodingZeroDataError"})}}class d extends r.C{constructor({expectedLength:e,givenLength:t,type:n}){super([`ABI encoding array length mismatch for type ${n}.`,`Expected length: ${e}`,`Given length: ${t}`].join("\n"),{name:"AbiEncodingArrayLengthMismatchError"})}}class u extends r.C{constructor({expectedSize:e,value:t}){super(`Size of bytes "${t}" (bytes${(0,i.E)(t)}) does not match expected size (bytes${e}).`,{name:"AbiEncodingBytesSizeMismatchError"})}}class f extends r.C{constructor({expectedLength:e,givenLength:t}){super(["ABI encoding params/values length mismatch.",`Expected length (params): ${e}`,`Given length (values): ${t}`].join("\n"),{name:"AbiEncodingLengthMismatchError"})}}r.C,r.C;class h extends r.C{constructor(e,{docsPath:t}){super([`Encoded error signature "${e}" not found on ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"),{docsPath:t,name:"AbiErrorSignatureNotFoundError"}),Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.signature=e}}class p extends r.C{constructor({docsPath:e}){super("Cannot extract event signature from empty topics.",{docsPath:e,name:"AbiEventSignatureEmptyTopicsError"})}}class m extends r.C{constructor(e,{docsPath:t}){super([`Encoded event signature "${e}" not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it.",`You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"),{docsPath:t,name:"AbiEventSignatureNotFoundError"})}}class g extends r.C{constructor(e,{docsPath:t}={}){super([`Event ${e?`"${e}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it."].join("\n"),{docsPath:t,name:"AbiEventNotFoundError"})}}class _ extends r.C{constructor(e,{docsPath:t}={}){super([`Function ${e?`"${e}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the function exists on it."].join("\n"),{docsPath:t,name:"AbiFunctionNotFoundError"})}}class b extends r.C{constructor(e,{docsPath:t}){super([`Function "${e}" does not contain any \`outputs\` on ABI.`,"Cannot decode function result without knowing what the parameter types are.","Make sure you are using the correct ABI and that the function exists on it."].join("\n"),{docsPath:t,name:"AbiFunctionOutputsNotFoundError"})}}r.C;class y extends r.C{constructor(e,t){super("Found ambiguous types in overloaded ABI items.",{metaMessages:[`\`${e.type}\` in \`${(0,s.B)(e.abiItem)}\`, and`,`\`${t.type}\` in \`${(0,s.B)(t.abiItem)}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."],name:"AbiItemAmbiguityError"})}}r.C;class A extends r.C{constructor({abiItem:e,data:t,params:n,size:i}){super([`Data size of ${i} bytes is too small for non-indexed event parameters.`].join("\n"),{metaMessages:[`Params: (${(0,s.A)(n,{includeName:!0})})`,`Data:   ${t} (${i} bytes)`],name:"DecodeLogDataMismatch"}),Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abiItem=e,this.data=t,this.params=n,this.size=i}}class w extends r.C{constructor({abiItem:e,param:t}){super([`Expected a topic for indexed event parameter${t.name?` "${t.name}"`:""} on event "${(0,s.B)(e,{includeName:!0})}".`].join("\n"),{name:"DecodeLogTopicsMismatch"}),Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abiItem=e}}class x extends r.C{constructor(e,{docsPath:t}){super([`Type "${e}" is not a valid encoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:t,name:"InvalidAbiEncodingType"})}}class v extends r.C{constructor(e,{docsPath:t}){super([`Type "${e}" is not a valid decoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:t,name:"InvalidAbiDecodingType"})}}class E extends r.C{constructor(e){super([`Value "${e}" is not a valid array.`].join("\n"),{name:"InvalidArrayError"})}}class M extends r.C{constructor(e){super([`"${e}" is not a valid definition type.`,'Valid types: "function", "event", "error"'].join("\n"),{name:"InvalidDefinitionTypeError"})}}r.C},5372:(e,t,n)=>{n.d(t,{M:()=>i});var s=n(9302);class i extends s.C{constructor({address:e}){super(`Address "${e}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."],name:"InvalidAddressError"})}}},9302:(e,t,n)=>{n.d(t,{C:()=>a});const s="2.22.8";let i=({docsBaseUrl:e,docsPath:t="",docsSlug:n})=>t?`${e??"https://viem.sh"}${t}${n?`#${n}`:""}`:void 0,r=`viem@${s}`;class a extends Error{constructor(e,t={}){const n=t.cause instanceof a?t.cause.details:t.cause?.message?t.cause.message:t.details,o=t.cause instanceof a&&t.cause.docsPath||t.docsPath,l=i?.({...t,docsPath:o});super([e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...l?[`Docs: ${l}`]:[],...n?[`Details: ${n}`]:[],...r?[`Version: ${r}`]:[]].join("\n"),t.cause?{cause:t.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=n,this.docsPath=o,this.metaMessages=t.metaMessages,this.name=t.name??this.name,this.shortMessage=e,this.version=s}walk(e){return o(this,e)}}function o(e,t){return t?.(e)?e:e&&"object"==typeof e&&"cause"in e&&void 0!==e.cause?o(e.cause,t):t?null:e}},1893:(e,t,n)=>{n.d(t,{EH:()=>r,YE:()=>o,jF:()=>a,rj:()=>i});var s=n(9302);class i extends s.C{constructor({blockNumber:e,chain:t,contract:n}){super(`Chain "${t.name}" does not support contract "${n.name}".`,{metaMessages:["This could be due to any of the following:",...e&&n.blockCreated&&n.blockCreated>e?[`- The contract "${n.name}" was not deployed until block ${n.blockCreated} (current block ${e}).`]:[`- The chain does not have the contract "${n.name}" configured.`]],name:"ChainDoesNotSupportContract"})}}class r extends s.C{constructor({chain:e,currentChainId:t}){super(`The current chain of the wallet (id: ${t}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`,{metaMessages:[`Current Chain ID:  ${t}`,`Expected Chain ID: ${e.id} – ${e.name}`],name:"ChainMismatchError"})}}class a extends s.C{constructor(){super(["No chain was provided to the request.","Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join("\n"),{name:"ChainNotFoundError"})}}class o extends s.C{constructor(){super("No chain was provided to the Client.",{name:"ClientChainNotConfiguredError"})}}s.C},3329:(e,t,n)=>{n.d(t,{zX:()=>_,bG:()=>b,M:()=>y,rR:()=>A,Po:()=>w,$S:()=>x});var s=n(6027),i=n(1919),r=n(8440),a=n(113),o=n(1501);function l({abiItem:e,args:t,includeFunctionName:n=!0,includeName:s=!1}){if("name"in e&&"inputs"in e&&e.inputs)return`${n?e.name:""}(${e.inputs.map(((e,n)=>`${s&&e.name?`${e.name}: `:""}${"object"==typeof t[n]?(0,o.A)(t[n]):t[n]}`)).join(", ")})`}var c=n(3856),d=n(3538),u=n(1892),f=n(3686),h=n(9302),p=n(373),m=n(7740),g=n(9197);class _ extends h.C{constructor(e,{account:t,docsPath:n,chain:i,data:r,gas:a,gasPrice:o,maxFeePerGas:l,maxPriorityFeePerGas:c,nonce:f,to:h,value:g,stateOverride:_}){const b=t?(0,s.J)(t):void 0;let y=(0,m.aO)({from:b?.address,to:h,value:void 0!==g&&`${(0,d.c)(g)} ${i?.nativeCurrency?.symbol||"ETH"}`,data:r,gas:a,gasPrice:void 0!==o&&`${(0,u.Q)(o)} gwei`,maxFeePerGas:void 0!==l&&`${(0,u.Q)(l)} gwei`,maxPriorityFeePerGas:void 0!==c&&`${(0,u.Q)(c)} gwei`,nonce:f});_&&(y+=`\n${(0,p.uj)(_)}`),super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Raw Call Arguments:",y].filter(Boolean),name:"CallExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}class b extends h.C{constructor(e,{abi:t,args:n,contractAddress:s,docsPath:i,functionName:r,sender:o}){const d=(0,c.iY)({abi:t,args:n,name:r}),u=d?l({abiItem:d,args:n,includeFunctionName:!1,includeName:!1}):void 0,f=d?(0,a.B)(d,{includeName:!0}):void 0,h=(0,m.aO)({address:s&&(0,g.R)(s),function:f,args:u&&"()"!==u&&`${[...Array(r?.length??0).keys()].map((()=>" ")).join("")}${u}`,sender:o});super(e.shortMessage||`An unknown error occurred while executing the contract function "${r}".`,{cause:e,docsPath:i,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],h&&"Contract Call:",h].filter(Boolean),name:"ContractFunctionExecutionError"}),Object.defineProperty(this,"abi",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"args",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"contractAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"formattedArgs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"functionName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sender",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abi=t,this.args=n,this.cause=e,this.contractAddress=s,this.functionName=r,this.sender=o}}class y extends h.C{constructor({abi:e,data:t,functionName:n,message:s}){let o,c,d,u,h;if(t&&"0x"!==t)try{c=(0,r.W)({abi:e,data:t});const{abiItem:n,errorName:s,args:o}=c;if("Error"===s)u=o[0];else if("Panic"===s){const[e]=o;u=i.fD[e]}else{const e=n?(0,a.B)(n,{includeName:!0}):void 0,t=n&&o?l({abiItem:n,args:o,includeFunctionName:!1,includeName:!1}):void 0;d=[e?`Error: ${e}`:"",t&&"()"!==t?`       ${[...Array(s?.length??0).keys()].map((()=>" ")).join("")}${t}`:""]}}catch(e){o=e}else s&&(u=s);o instanceof f.Wq&&(h=o.signature,d=[`Unable to decode signature "${h}" as it was not found on the provided ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${h}.`]),super(u&&"execution reverted"!==u||h?[`The contract function "${n}" reverted with the following ${h?"signature":"reason"}:`,u||h].join("\n"):`The contract function "${n}" reverted.`,{cause:o,metaMessages:d,name:"ContractFunctionRevertedError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"reason",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=c,this.reason=u,this.signature=h}}class A extends h.C{constructor({functionName:e}){super(`The contract function "${e}" returned no data ("0x").`,{metaMessages:["This could be due to any of the following:",`  - The contract does not have the function "${e}",`,"  - The parameters passed to the contract function may be invalid, or","  - The address is not a contract."],name:"ContractFunctionZeroDataError"})}}class w extends h.C{constructor({factory:e}){super("Deployment for counterfactual contract call failed"+(e?` for factory "${e}".`:""),{metaMessages:["Please ensure:","- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).","- The `factoryData` is a valid encoded function call for contract deployment function on the factory."],name:"CounterfactualDeploymentFailedError"})}}class x extends h.C{constructor({data:e,message:t}){super(t||"",{name:"RawContractError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=e}}},4112:(e,t,n)=>{n.d(t,{B4:()=>i,SK:()=>r,hX:()=>a});var s=n(9302);class i extends s.C{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class r extends s.C{constructor({length:e,position:t}){super(`Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`,{name:"PositionOutOfBoundsError"})}}class a extends s.C{constructor({count:e,limit:t}){super(`Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`,{name:"RecursiveReadLimitExceededError"})}}},7834:(e,t,n)=>{n.d(t,{Fl:()=>r,NV:()=>a,ii:()=>i});var s=n(9302);class i extends s.C{constructor({offset:e,position:t,size:n}){super(`Slice ${"start"===t?"starting":"ending"} at offset "${e}" is out-of-bounds (size: ${n}).`,{name:"SliceOffsetOutOfBoundsError"})}}class r extends s.C{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,{name:"SizeExceedsPaddingSizeError"})}}class a extends s.C{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${t} ${n} long, but is ${e} ${n} long.`,{name:"InvalidBytesLengthError"})}}},9699:(e,t,n)=>{n.d(t,{Ty:()=>i,u:()=>a,xO:()=>r});var s=n(9302);class i extends s.C{constructor({max:e,min:t,signed:n,size:s,value:i}){super(`Number "${i}" is not in safe ${s?`${8*s}-bit ${n?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`,{name:"IntegerOutOfRangeError"})}}class r extends s.C{constructor(e){super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,{name:"InvalidBytesBooleanError"})}}s.C,s.C;class a extends s.C{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`,{name:"SizeOverflowError"})}}},7426:(e,t,n)=>{n.d(t,{A7:()=>r,BG:()=>a,Fo:()=>h,K0:()=>l,Oh:()=>c,RM:()=>g,jj:()=>o,k5:()=>u,lN:()=>m,lY:()=>f,uC:()=>p,vW:()=>d});var s=n(1892),i=n(9302);class r extends i.C{constructor({cause:e,message:t}={}){const n=t?.replace("execution reverted: ","")?.replace("execution reverted","");super(`Execution reverted ${n?`with reason: ${n}`:"for an unknown reason"}.`,{cause:e,name:"ExecutionRevertedError"})}}Object.defineProperty(r,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(r,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/execution reverted/});class a extends i.C{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${(0,s.Q)(t)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:e,name:"FeeCapTooHighError"})}}Object.defineProperty(a,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});class o extends i.C{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${(0,s.Q)(t)}`:""} gwei) cannot be lower than the block base fee.`,{cause:e,name:"FeeCapTooLowError"})}}Object.defineProperty(o,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/});class l extends i.C{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}is higher than the next one expected.`,{cause:e,name:"NonceTooHighError"})}}Object.defineProperty(l,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too high/});class c extends i.C{constructor({cause:e,nonce:t}={}){super([`Nonce provided for the transaction ${t?`(${t}) `:""}is lower than the current nonce of the account.`,"Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"),{cause:e,name:"NonceTooLowError"})}}Object.defineProperty(c,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too low|transaction already imported|already known/});class d extends i.C{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}exceeds the maximum allowed nonce.`,{cause:e,name:"NonceMaxValueError"})}}Object.defineProperty(d,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce has max value/});class u extends i.C{constructor({cause:e}={}){super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"),{cause:e,metaMessages:["This error could arise when the account does not have enough funds to:"," - pay for the total gas fee,"," - pay for the value to send."," ","The cost of the transaction is calculated as `gas * gas fee + value`, where:"," - `gas` is the amount of gas needed for transaction to execute,"," - `gas fee` is the gas fee,"," - `value` is the amount of ether to send to the recipient."],name:"InsufficientFundsError"})}}Object.defineProperty(u,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/insufficient funds|exceeds transaction sender account balance/});class f extends i.C{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction exceeds the limit allowed for the block.`,{cause:e,name:"IntrinsicGasTooHighError"})}}Object.defineProperty(f,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too high|gas limit reached/});class h extends i.C{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction is too low.`,{cause:e,name:"IntrinsicGasTooLowError"})}}Object.defineProperty(h,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too low/});class p extends i.C{constructor({cause:e}){super("The transaction type is not supported for this chain.",{cause:e,name:"TransactionTypeNotSupportedError"})}}Object.defineProperty(p,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/transaction type not valid/});class m extends i.C{constructor({cause:e,maxPriorityFeePerGas:t,maxFeePerGas:n}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${t?` = ${(0,s.Q)(t)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n?` = ${(0,s.Q)(n)} gwei`:""}).`].join("\n"),{cause:e,name:"TipAboveFeeCapError"})}}Object.defineProperty(m,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});class g extends i.C{constructor({cause:e}){super(`An error occurred while executing: ${e?.shortMessage}`,{cause:e,name:"UnknownNodeError"})}}},6809:(e,t,n)=>{n.d(t,{Ci:()=>a,J8:()=>o});var s=n(1501),i=n(9302),r=n(9197);class a extends i.C{constructor({body:e,cause:t,details:n,headers:i,status:a,url:o}){super("HTTP request failed.",{cause:t,details:n,metaMessages:[a&&`Status: ${a}`,`URL: ${(0,r.I)(o)}`,e&&`Request body: ${(0,s.A)(e)}`].filter(Boolean),name:"HttpRequestError"}),Object.defineProperty(this,"body",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"status",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.body=e,this.headers=i,this.status=a,this.url=o}}i.C;class o extends i.C{constructor({body:e,error:t,url:n}){super("RPC Request failed.",{cause:t,details:t.message,metaMessages:[`URL: ${(0,r.I)(n)}`,`Request body: ${(0,s.A)(e)}`],name:"RpcRequestError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.code=t.code,this.data=t.data}}i.C,i.C},373:(e,t,n)=>{n.d(t,{Hi:()=>i,ft:()=>r,uj:()=>o});var s=n(9302);class i extends s.C{constructor({address:e}){super(`State for account "${e}" is set multiple times.`,{name:"AccountStateConflictError"})}}class r extends s.C{constructor(){super("state and stateDiff are set on the same account.",{name:"StateAssignmentConflictError"})}}function a(e){return e.reduce(((e,{slot:t,value:n})=>`${e}        ${t}: ${n}\n`),"")}function o(e){return e.reduce(((e,{address:t,...n})=>{let s=`${e}    ${t}:\n`;return n.nonce&&(s+=`      nonce: ${n.nonce}\n`),n.balance&&(s+=`      balance: ${n.balance}\n`),n.code&&(s+=`      code: ${n.code}\n`),n.state&&(s+="      state:\n",s+=a(n.state)),n.stateDiff&&(s+="      stateDiff:\n",s+=a(n.stateDiff)),s}),"  State Override:\n").slice(0,-1)}},7740:(e,t,n)=>{n.d(t,{$s:()=>c,Vg:()=>l,aO:()=>a,n3:()=>o});var s=n(3538),i=n(1892),r=n(9302);function a(e){const t=Object.entries(e).map((([e,t])=>void 0===t||!1===t?null:[e,t])).filter(Boolean),n=t.reduce(((e,[t])=>Math.max(e,t.length)),0);return t.map((([e,t])=>`  ${`${e}:`.padEnd(n+1)}  ${t}`)).join("\n")}class o extends r.C{constructor(){super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.","Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join("\n"),{name:"FeeConflictError"})}}r.C;class l extends r.C{constructor({transaction:e}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",a(e),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- an EIP-7702 Transaction with `authorizationList`, or","- a Legacy Transaction with `gasPrice`"],name:"InvalidSerializableTransactionError"})}}r.C,r.C,r.C;class c extends r.C{constructor(e,{account:t,docsPath:n,chain:r,data:o,gas:l,gasPrice:c,maxFeePerGas:d,maxPriorityFeePerGas:u,nonce:f,to:h,value:p}){const m=a({chain:r&&`${r?.name} (id: ${r?.id})`,from:t?.address,to:h,value:void 0!==p&&`${(0,s.c)(p)} ${r?.nativeCurrency?.symbol||"ETH"}`,data:o,gas:l,gasPrice:void 0!==c&&`${(0,i.Q)(c)} gwei`,maxFeePerGas:void 0!==d&&`${(0,i.Q)(d)} gwei`,maxPriorityFeePerGas:void 0!==u&&`${(0,i.Q)(u)} gwei`,nonce:f});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Request Arguments:",m].filter(Boolean),name:"TransactionExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}r.C,r.C,r.C},9197:(e,t,n)=>{n.d(t,{I:()=>i,R:()=>s});const s=e=>e,i=e=>e},663:(e,t,n)=>{n.d(t,{n:()=>_});var s=n(3686),i=n(3887),r=n(9804),a=n(6420),o=n(5355);function l(e,{dir:t="left"}={}){let n="string"==typeof e?e.replace("0x",""):e,s=0;for(let e=0;e<n.length-1&&"0"===n["left"===t?e:n.length-e-1].toString();e++)s++;return n="left"===t?n.slice(s):n.slice(0,n.length-s),"string"==typeof e?(1===n.length&&"right"===t&&(n=`${n}0`),`0x${n.length%2==1?`0${n}`:n}`):n}var c=n(9699),d=n(5261),u=n(9042);function f(e,t={}){void 0!==t.size&&(0,d.Sl)(e,{size:t.size});const n=(0,u.My)(e,t);return(0,d.uU)(n,t)}function h(e,t={}){let n=e;if(void 0!==t.size&&((0,d.Sl)(n,{size:t.size}),n=l(n)),n.length>1||n[0]>1)throw new c.xO(n);return Boolean(n[0])}function p(e,t={}){void 0!==t.size&&(0,d.Sl)(e,{size:t.size});const n=(0,u.My)(e,t);return(0,d.ME)(n,t)}var m=n(3588),g=n(2142);function _(e,t){const n="string"==typeof t?(0,m.aT)(t):t,i=(0,r.l)(n);if(0===(0,a.E)(n)&&e.length>0)throw new s.O;if((0,a.E)(t)&&(0,a.E)(t)<32)throw new s.Iy({data:"string"==typeof t?t:(0,u.My)(t),params:e,size:(0,a.E)(t)});let o=0;const l=[];for(let t=0;t<e.length;++t){const n=e[t];i.setPosition(o);const[s,r]=b(i,n,{staticPosition:0});o+=r,l.push(s)}return l}function b(e,t,{staticPosition:n}){const r=(0,g.k)(t.type);if(r){const[s,i]=r;return function(e,t,{length:n,staticPosition:s}){if(!n){const n=s+p(e.readBytes(A)),i=n+y;e.setPosition(n);const r=p(e.readBytes(y)),a=w(t);let o=0;const l=[];for(let n=0;n<r;++n){e.setPosition(i+(a?32*n:o));const[s,r]=b(e,t,{staticPosition:i});o+=r,l.push(s)}return e.setPosition(s+32),[l,32]}if(w(t)){const i=s+p(e.readBytes(A)),r=[];for(let s=0;s<n;++s){e.setPosition(i+32*s);const[n]=b(e,t,{staticPosition:i});r.push(n)}return e.setPosition(s+32),[r,32]}let i=0;const r=[];for(let a=0;a<n;++a){const[n,a]=b(e,t,{staticPosition:s+i});i+=a,r.push(n)}return[r,i]}(e,{...t,type:i},{length:s,staticPosition:n})}if("tuple"===t.type)return function(e,t,{staticPosition:n}){const s=0===t.components.length||t.components.some((({name:e})=>!e)),i=s?[]:{};let r=0;if(w(t)){const a=n+p(e.readBytes(A));for(let n=0;n<t.components.length;++n){const o=t.components[n];e.setPosition(a+r);const[l,c]=b(e,o,{staticPosition:a});r+=c,i[s?n:o?.name]=l}return e.setPosition(n+32),[i,32]}for(let a=0;a<t.components.length;++a){const o=t.components[a],[l,c]=b(e,o,{staticPosition:n});i[s?a:o?.name]=l,r+=c}return[i,r]}(e,t,{staticPosition:n});if("address"===t.type)return function(e){const t=e.readBytes(32);return[(0,i.o)((0,u.My)((0,o.A1)(t,-20))),32]}(e);if("bool"===t.type)return function(e){return[h(e.readBytes(32),{size:32}),32]}(e);if(t.type.startsWith("bytes"))return function(e,t,{staticPosition:n}){const[s,i]=t.type.split("bytes");if(!i){const t=p(e.readBytes(32));e.setPosition(n+t);const s=p(e.readBytes(32));if(0===s)return e.setPosition(n+32),["0x",32];const i=e.readBytes(s);return e.setPosition(n+32),[(0,u.My)(i),32]}return[(0,u.My)(e.readBytes(Number.parseInt(i),32)),32]}(e,t,{staticPosition:n});if(t.type.startsWith("uint")||t.type.startsWith("int"))return function(e,t){const n=t.type.startsWith("int"),s=Number.parseInt(t.type.split("int")[1]||"256"),i=e.readBytes(32);return[s>48?f(i,{signed:n}):p(i,{signed:n}),32]}(e,t);if("string"===t.type)return function(e,{staticPosition:t}){const n=t+p(e.readBytes(32));e.setPosition(n);const s=p(e.readBytes(32));if(0===s)return e.setPosition(t+32),["",32];const i=function(e,t={}){let n=e;return void 0!==t.size&&((0,d.Sl)(n,{size:t.size}),n=l(n,{dir:"right"})),(new TextDecoder).decode(n)}(l(e.readBytes(s,32)));return e.setPosition(t+32),[i,32]}(e,{staticPosition:n});throw new s.j(t.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const y=32,A=32;function w(e){const{type:t}=e;if("string"===t)return!0;if("bytes"===t)return!0;if(t.endsWith("[]"))return!0;if("tuple"===t)return e.components?.some(w);const n=(0,g.k)(e.type);return!(!n||!w({...e,type:n[1]}))}},8440:(e,t,n)=>{n.d(t,{W:()=>c});var s=n(1919),i=n(3686),r=n(5355),a=n(5561),o=n(663),l=n(113);function c(e){const{abi:t,data:n}=e,c=(0,r.di)(n,0,4);if("0x"===c)throw new i.O;const d=[...t||[],s.Mc,s.J9].find((e=>"error"===e.type&&c===(0,a.V)((0,l.B)(e))));if(!d)throw new i.Wq(c,{docsPath:"/docs/contract/decodeErrorResult"});return{abiItem:d,args:"inputs"in d&&d.inputs&&d.inputs.length>0?(0,o.n)(d.inputs,(0,r.di)(n,4)):void 0,errorName:d.name}}},8902:(e,t,n)=>{n.d(t,{e:()=>o});var s=n(3686),i=n(663),r=n(3856);const a="/docs/contract/decodeFunctionResult";function o(e){const{abi:t,args:n,functionName:o,data:l}=e;let c=t[0];if(o){const e=(0,r.iY)({abi:t,args:n,name:o});if(!e)throw new s.Iz(o,{docsPath:a});c=e}if("function"!==c.type)throw new s.Iz(void 0,{docsPath:a});if(!c.outputs)throw new s.MR(c.name,{docsPath:a});const d=(0,i.n)(c.outputs,l);return d&&d.length>1?d:d&&1===d.length?d[0]:void 0}},2142:(e,t,n)=>{n.d(t,{h:()=>p,k:()=>_});var s=n(3686),i=n(5372),r=n(9302),a=n(9699),o=n(7283),l=n(7673),c=n(5916),d=n(6420),u=n(5355),f=n(9042);const h=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function p(e,t){if(e.length!==t.length)throw new s.YE({expectedLength:e.length,givenLength:t.length});const n=function({params:e,values:t}){const n=[];for(let s=0;s<e.length;s++)n.push(m({param:e[s],value:t[s]}));return n}({params:e,values:t}),i=g(n);return 0===i.length?"0x":i}function m({param:e,value:t}){const n=_(e.type);if(n){const[i,r]=n;return function(e,{length:t,param:n}){const i=null===t;if(!Array.isArray(e))throw new s.dm(e);if(!i&&e.length!==t)throw new s.Nc({expectedLength:t,givenLength:e.length,type:`${n.type}[${t}]`});let r=!1;const a=[];for(let t=0;t<e.length;t++){const s=m({param:n,value:e[t]});s.dynamic&&(r=!0),a.push(s)}if(i||r){const e=g(a);if(i){const t=(0,f.cK)(a.length,{size:32});return{dynamic:!0,encoded:a.length>0?(0,l.xW)([t,e]):t}}if(r)return{dynamic:!0,encoded:e}}return{dynamic:!1,encoded:(0,l.xW)(a.map((({encoded:e})=>e)))}}(t,{length:i,param:{...e,type:r}})}if("tuple"===e.type)return function(e,{param:t}){let n=!1;const s=[];for(let i=0;i<t.components.length;i++){const r=t.components[i],a=m({param:r,value:e[Array.isArray(e)?i:r.name]});s.push(a),a.dynamic&&(n=!0)}return{dynamic:n,encoded:n?g(s):(0,l.xW)(s.map((({encoded:e})=>e)))}}(t,{param:e});if("address"===e.type)return function(e){if(!(0,o.P)(e))throw new i.M({address:e});return{dynamic:!1,encoded:(0,c.db)(e.toLowerCase())}}(t);if("bool"===e.type)return function(e){if("boolean"!=typeof e)throw new r.C(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:(0,c.db)((0,f.$P)(e))}}(t);if(e.type.startsWith("uint")||e.type.startsWith("int")){const n=e.type.startsWith("int"),[,,s="256"]=h.exec(e.type)??[];return function(e,{signed:t,size:n=256}){if("number"==typeof n){const s=2n**(BigInt(n)-(t?1n:0n))-1n,i=t?-s-1n:0n;if(e>s||e<i)throw new a.Ty({max:s.toString(),min:i.toString(),signed:t,size:n/8,value:e.toString()})}return{dynamic:!1,encoded:(0,f.cK)(e,{size:32,signed:t})}}(t,{signed:n,size:Number(s)})}if(e.type.startsWith("bytes"))return function(e,{param:t}){const[,n]=t.type.split("bytes"),i=(0,d.E)(e);if(!n){let t=e;return i%32!=0&&(t=(0,c.db)(t,{dir:"right",size:32*Math.ceil((e.length-2)/2/32)})),{dynamic:!0,encoded:(0,l.xW)([(0,c.db)((0,f.cK)(i,{size:32})),t])}}if(i!==Number.parseInt(n))throw new s.gH({expectedSize:Number.parseInt(n),value:e});return{dynamic:!1,encoded:(0,c.db)(e,{dir:"right"})}}(t,{param:e});if("string"===e.type)return function(e){const t=(0,f.i3)(e),n=Math.ceil((0,d.E)(t)/32),s=[];for(let e=0;e<n;e++)s.push((0,c.db)((0,u.di)(t,32*e,32*(e+1)),{dir:"right"}));return{dynamic:!0,encoded:(0,l.xW)([(0,c.db)((0,f.cK)((0,d.E)(t),{size:32})),...s])}}(t);throw new s.nK(e.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function g(e){let t=0;for(let n=0;n<e.length;n++){const{dynamic:s,encoded:i}=e[n];t+=s?32:(0,d.E)(i)}const n=[],s=[];let i=0;for(let r=0;r<e.length;r++){const{dynamic:a,encoded:o}=e[r];a?(n.push((0,f.cK)(t+i,{size:32})),s.push(o),i+=(0,d.E)(o)):n.push(o)}return(0,l.xW)([...n,...s])}function _(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}},2373:(e,t,n)=>{n.d(t,{p:()=>d});var s=n(7673),i=n(2142),r=n(3686),a=n(5561),o=n(113),l=n(3856);const c="/docs/contract/encodeFunctionData";function d(e){const{args:t}=e,{abi:n,functionName:d}=1===e.abi.length&&e.functionName?.startsWith("0x")?e:function(e){const{abi:t,args:n,functionName:s}=e;let i=t[0];if(s){const e=(0,l.iY)({abi:t,args:n,name:s});if(!e)throw new r.Iz(s,{docsPath:c});i=e}if("function"!==i.type)throw new r.Iz(void 0,{docsPath:c});return{abi:[i],functionName:(0,a.V)((0,o.B)(i))}}(e),u=n[0],f=d,h="inputs"in u&&u.inputs?(0,i.h)(u.inputs,t??[]):void 0;return(0,s.aP)([f,h??"0x"])}},113:(e,t,n)=>{n.d(t,{A:()=>r,B:()=>i});var s=n(3686);function i(e,{includeName:t=!1}={}){if("function"!==e.type&&"event"!==e.type&&"error"!==e.type)throw new s.d_(e.type);return`${e.name}(${r(e.inputs,{includeName:t})})`}function r(e,{includeName:t=!1}={}){return e?e.map((e=>function(e,{includeName:t}){return e.type.startsWith("tuple")?`(${r(e.components,{includeName:t})})${e.type.slice(5)}`:e.type+(t&&e.name?` ${e.name}`:"")}(e,{includeName:t}))).join(t?", ":","):""}},3856:(e,t,n)=>{n.d(t,{iY:()=>l});var s=n(3686),i=n(2768),r=n(7283),a=n(643),o=n(5561);function l(e){const{abi:t,args:n=[],name:r}=e,l=(0,i.q)(r,{strict:!1}),u=t.filter((e=>l?"function"===e.type?(0,o.V)(e)===r:"event"===e.type&&(0,a.h)(e)===r:"name"in e&&e.name===r));if(0===u.length)return;if(1===u.length)return u[0];let f;for(const e of u)if("inputs"in e)if(n&&0!==n.length){if(e.inputs&&0!==e.inputs.length&&e.inputs.length===n.length&&n.every(((t,n)=>{const s="inputs"in e&&e.inputs[n];return!!s&&c(t,s)}))){if(f&&"inputs"in f&&f.inputs){const t=d(e.inputs,f.inputs,n);if(t)throw new s.nM({abiItem:e,type:t[0]},{abiItem:f,type:t[1]})}f=e}}else if(!e.inputs||0===e.inputs.length)return e;return f||u[0]}function c(e,t){const n=typeof e,s=t.type;switch(s){case"address":return(0,r.P)(e,{strict:!1});case"bool":return"boolean"===n;case"function":case"string":return"string"===n;default:return"tuple"===s&&"components"in t?Object.values(t.components).every(((t,n)=>c(Object.values(e)[n],t))):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(s)?"number"===n||"bigint"===n:/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(s)?"string"===n||e instanceof Uint8Array:!!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(s)&&Array.isArray(e)&&e.every((e=>c(e,{...t,type:s.replace(/(\[[0-9]{0,}\])$/,"")})))}}function d(e,t,n){for(const s in e){const i=e[s],a=t[s];if("tuple"===i.type&&"tuple"===a.type&&"components"in i&&"components"in a)return d(i.components,a.components,n[s]);const o=[i.type,a.type];if(o.includes("address")&&o.includes("bytes20")||(o.includes("address")&&o.includes("string")||o.includes("address")&&o.includes("bytes"))&&(0,r.P)(n[s],{strict:!1}))return o}}},3887:(e,t,n)=>{n.d(t,{o:()=>a});var s=n(3588),i=n(2610);const r=new(n(645).A)(8192);function a(e,t){if(r.has(`${e}.${t}`))return r.get(`${e}.${t}`);const n=t?`${t}${e.toLowerCase()}`:e.substring(2).toLowerCase(),a=(0,i.S)((0,s.Af)(n),"bytes"),o=(t?n.substring(`${t}0x`.length):n).split("");for(let e=0;e<40;e+=2)a[e>>1]>>4>=8&&o[e]&&(o[e]=o[e].toUpperCase()),(15&a[e>>1])>=8&&o[e+1]&&(o[e+1]=o[e+1].toUpperCase());const l=`0x${o.join("")}`;return r.set(`${e}.${t}`,l),l}},7283:(e,t,n)=>{n.d(t,{P:()=>o});var s=n(645),i=n(3887);const r=/^0x[a-fA-F0-9]{40}$/,a=new s.A(8192);function o(e,t){const{strict:n=!0}=t??{},s=`${e}.${n}`;if(a.has(s))return a.get(s);const o=!(!r.test(e)||e.toLowerCase()!==e&&n&&(0,i.o)(e)!==e);return a.set(s,o),o}},6907:(e,t,n)=>{n.d(t,{h:()=>r});var s=n(5372),i=n(7283);function r(e,t){if(!(0,i.P)(e,{strict:!1}))throw new s.M({address:e});if(!(0,i.P)(t,{strict:!1}))throw new s.M({address:t});return e.toLowerCase()===t.toLowerCase()}},4471:(e,t,n)=>{n.d(t,{offchainLookup:()=>b,offchainLookupSignature:()=>g});var s=n(2894),i=n(1501),r=n(9302),a=n(9197);class o extends r.C{constructor({callbackSelector:e,cause:t,data:n,extraData:s,sender:i,urls:r}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",r&&["  Gateway URL(s):",...r.map((e=>`    ${(0,a.I)(e)}`))],`  Sender: ${i}`,`  Data: ${n}`,`  Callback selector: ${e}`,`  Extra data: ${s}`].flat(),name:"OffchainLookupError"})}}class l extends r.C{constructor({result:e,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${(0,a.I)(t)}`,`Response: ${(0,i.A)(e)}`],name:"OffchainLookupResponseMalformedError"})}}class c extends r.C{constructor({sender:e,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${e}`],name:"OffchainLookupSenderMismatchError"})}}var d=n(6809),u=n(8440),f=n(2142),h=n(6907),p=n(7673),m=n(2768);const g="0x556f1830",_={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function b(e,{blockNumber:t,blockTag:n,data:i,to:r}){const{args:a}=(0,u.W)({data:i,abi:[_]}),[l,d,m,g,b]=a,{ccipRead:A}=e,w=A&&"function"==typeof A?.request?A.request:y;try{if(!(0,h.h)(r,l))throw new c({sender:l,to:r});const i=await w({data:m,sender:l,urls:d}),{data:a}=await(0,s.T)(e,{blockNumber:t,blockTag:n,data:(0,p.xW)([g,(0,f.h)([{type:"bytes"},{type:"bytes"}],[i,b])]),to:r});return a}catch(e){throw new o({callbackSelector:g,cause:e,data:i,extraData:b,sender:l,urls:d})}}async function y({data:e,sender:t,urls:n}){let s=new Error("An unknown error occurred.");for(let r=0;r<n.length;r++){const a=n[r],o=a.includes("{data}")?"GET":"POST",c="POST"===o?{data:e,sender:t}:void 0,u="POST"===o?{"Content-Type":"application/json"}:{};try{const n=await fetch(a.replace("{sender}",t).replace("{data}",e),{body:JSON.stringify(c),headers:u,method:o});let r;if(r=n.headers.get("Content-Type")?.startsWith("application/json")?(await n.json()).data:await n.text(),!n.ok){s=new d.Ci({body:c,details:r?.error?(0,i.A)(r.error):n.statusText,headers:n.headers,status:n.status,url:a});continue}if(!(0,m.q)(r)){s=new l({result:r,url:a});continue}return r}catch(e){s=new d.Ci({body:c,details:e.message,url:a})}}throw s}},9804:(e,t,n)=>{n.d(t,{l:()=>r});var s=n(4112);const i={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new s.hX({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new s.SK({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new s.B4({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new s.B4({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const n=t??this.position;return this.assertPosition(n+e-1),this.bytes.subarray(n,n+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,255&e),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const n=this.inspectBytes(e);return this.position+=t??e,n},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function r(e,{recursiveReadLimit:t=8192}={}){const n=Object.create(i);return n.bytes=e,n.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=t,n}},7673:(e,t,n)=>{function s(e){return"string"==typeof e[0]?i(e):function(e){let t=0;for(const n of e)t+=n.length;const n=new Uint8Array(t);let s=0;for(const t of e)n.set(t,s),s+=t.length;return n}(e)}function i(e){return`0x${e.reduce(((e,t)=>e+t.replace("0x","")),"")}`}n.d(t,{aP:()=>i,xW:()=>s})},2768:(e,t,n)=>{function s(e,{strict:t=!0}={}){return!!e&&"string"==typeof e&&(t?/^0x[0-9a-fA-F]*$/.test(e):e.startsWith("0x"))}n.d(t,{q:()=>s})},5916:(e,t,n)=>{n.d(t,{db:()=>r,eV:()=>i});var s=n(7834);function i(e,{dir:t,size:n=32}={}){return"string"==typeof e?r(e,{dir:t,size:n}):function(e,{dir:t,size:n=32}={}){if(null===n)return e;if(e.length>n)throw new s.Fl({size:e.length,targetSize:n,type:"bytes"});const i=new Uint8Array(n);for(let s=0;s<n;s++){const r="right"===t;i[r?s:n-s-1]=e[r?s:e.length-s-1]}return i}(e,{dir:t,size:n})}function r(e,{dir:t,size:n=32}={}){if(null===n)return e;const i=e.replace("0x","");if(i.length>2*n)throw new s.Fl({size:Math.ceil(i.length/2),targetSize:n,type:"hex"});return`0x${i["right"===t?"padEnd":"padStart"](2*n,"0")}`}},6420:(e,t,n)=>{n.d(t,{E:()=>i});var s=n(2768);function i(e){return(0,s.q)(e,{strict:!1})?Math.ceil((e.length-2)/2):e.length}},5355:(e,t,n)=>{n.d(t,{A1:()=>c,di:()=>a});var s=n(7834),i=n(2768),r=n(6420);function a(e,t,n,{strict:s}={}){return(0,i.q)(e,{strict:!1})?function(e,t,n,{strict:s}={}){o(e,t);const i=`0x${e.replace("0x","").slice(2*(t??0),2*(n??e.length))}`;return s&&l(i,t,n),i}(e,t,n,{strict:s}):c(e,t,n,{strict:s})}function o(e,t){if("number"==typeof t&&t>0&&t>(0,r.E)(e)-1)throw new s.ii({offset:t,position:"start",size:(0,r.E)(e)})}function l(e,t,n){if("number"==typeof t&&"number"==typeof n&&(0,r.E)(e)!==n-t)throw new s.ii({offset:n,position:"end",size:(0,r.E)(e)})}function c(e,t,n,{strict:s}={}){o(e,t);const i=e.slice(t,n);return s&&l(i,t,n),i}},5261:(e,t,n)=>{n.d(t,{ME:()=>o,Sl:()=>r,uU:()=>a});var s=n(9699),i=n(6420);function r(e,{size:t}){if((0,i.E)(e)>t)throw new s.u({givenSize:(0,i.E)(e),maxSize:t})}function a(e,t={}){const{signed:n}=t;t.size&&r(e,{size:t.size});const s=BigInt(e);if(!n)return s;const i=(e.length-2)/2;return s<=(1n<<8n*BigInt(i)-1n)-1n?s:s-BigInt(`0x${"f".padStart(2*i,"f")}`)-1n}function o(e,t={}){return Number(a(e,t))}},3588:(e,t,n)=>{n.d(t,{Af:()=>h,ZJ:()=>c,aT:()=>f});var s=n(9302),i=n(2768),r=n(5916),a=n(5261),o=n(9042);const l=new TextEncoder;function c(e,t={}){return"number"==typeof e||"bigint"==typeof e?function(e,t){return f((0,o.cK)(e,t))}(e,t):"boolean"==typeof e?function(e,t={}){const n=new Uint8Array(1);return n[0]=Number(e),"number"==typeof t.size?((0,a.Sl)(n,{size:t.size}),(0,r.eV)(n,{size:t.size})):n}(e,t):(0,i.q)(e)?f(e,t):h(e,t)}const d={zero:48,nine:57,A:65,F:70,a:97,f:102};function u(e){return e>=d.zero&&e<=d.nine?e-d.zero:e>=d.A&&e<=d.F?e-(d.A-10):e>=d.a&&e<=d.f?e-(d.a-10):void 0}function f(e,t={}){let n=e;t.size&&((0,a.Sl)(n,{size:t.size}),n=(0,r.eV)(n,{dir:"right",size:t.size}));let i=n.slice(2);i.length%2&&(i=`0${i}`);const o=i.length/2,l=new Uint8Array(o);for(let e=0,t=0;e<o;e++){const n=u(i.charCodeAt(t++)),r=u(i.charCodeAt(t++));if(void 0===n||void 0===r)throw new s.C(`Invalid byte sequence ("${i[t-2]}${i[t-1]}" in "${i}").`);l[e]=16*n+r}return l}function h(e,t={}){const n=l.encode(e);return"number"==typeof t.size?((0,a.Sl)(n,{size:t.size}),(0,r.eV)(n,{dir:"right",size:t.size})):n}},9042:(e,t,n)=>{n.d(t,{$P:()=>l,My:()=>c,cK:()=>d,i3:()=>f,nj:()=>o});var s=n(9699),i=n(5916),r=n(5261);const a=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function o(e,t={}){return"number"==typeof e||"bigint"==typeof e?d(e,t):"string"==typeof e?f(e,t):"boolean"==typeof e?l(e,t):c(e,t)}function l(e,t={}){const n=`0x${Number(e)}`;return"number"==typeof t.size?((0,r.Sl)(n,{size:t.size}),(0,i.eV)(n,{size:t.size})):n}function c(e,t={}){let n="";for(let t=0;t<e.length;t++)n+=a[e[t]];const s=`0x${n}`;return"number"==typeof t.size?((0,r.Sl)(s,{size:t.size}),(0,i.eV)(s,{dir:"right",size:t.size})):s}function d(e,t={}){const{signed:n,size:r}=t,a=BigInt(e);let o;r?o=n?(1n<<8n*BigInt(r)-1n)-1n:2n**(8n*BigInt(r))-1n:"number"==typeof e&&(o=BigInt(Number.MAX_SAFE_INTEGER));const l="bigint"==typeof o&&n?-o-1n:0;if(o&&a>o||a<l){const t="bigint"==typeof e?"n":"";throw new s.Ty({max:o?`${o}${t}`:void 0,min:`${l}${t}`,signed:n,size:r,value:`${e}${t}`})}const c=`0x${(n&&a<0?(1n<<BigInt(8*r))+BigInt(a):a).toString(16)}`;return r?(0,i.eV)(c,{size:r}):c}const u=new TextEncoder;function f(e,t={}){return c(u.encode(e),t)}},3594:(e,t,n)=>{n.d(t,{l:()=>r});var s=n(9302),i=n(7426);function r(e,t){const n=(e.details||"").toLowerCase(),r=e instanceof s.C?e.walk((e=>e?.code===i.A7.code)):e;return r instanceof s.C?new i.A7({cause:e,message:r.details}):i.A7.nodeMessage.test(n)?new i.A7({cause:e,message:e.details}):i.BG.nodeMessage.test(n)?new i.BG({cause:e,maxFeePerGas:t?.maxFeePerGas}):i.jj.nodeMessage.test(n)?new i.jj({cause:e,maxFeePerGas:t?.maxFeePerGas}):i.K0.nodeMessage.test(n)?new i.K0({cause:e,nonce:t?.nonce}):i.Oh.nodeMessage.test(n)?new i.Oh({cause:e,nonce:t?.nonce}):i.vW.nodeMessage.test(n)?new i.vW({cause:e,nonce:t?.nonce}):i.k5.nodeMessage.test(n)?new i.k5({cause:e}):i.lY.nodeMessage.test(n)?new i.lY({cause:e,gas:t?.gas}):i.Fo.nodeMessage.test(n)?new i.Fo({cause:e,gas:t?.gas}):i.uC.nodeMessage.test(n)?new i.uC({cause:e}):i.lN.nodeMessage.test(n)?new i.lN({cause:e,maxFeePerGas:t?.maxFeePerGas,maxPriorityFeePerGas:t?.maxPriorityFeePerGas}):new i.RM({cause:e})}},5979:(e,t,n)=>{function s(e,{format:t}){if(!t)return{};const n={};return function t(s){const i=Object.keys(s);for(const r of i)r in e&&(n[r]=e[r]),s[r]&&"object"==typeof s[r]&&!Array.isArray(s[r])&&t(s[r])}(t(e||{})),n}n.d(t,{o:()=>s})},2545:(e,t,n)=>{n.d(t,{Bv:()=>r});var s=n(9042);const i={legacy:"0x0",eip2930:"0x1",eip1559:"0x2",eip4844:"0x3",eip7702:"0x4"};function r(e){const t={};return void 0!==e.authorizationList&&(t.authorizationList=e.authorizationList.map((e=>({address:e.contractAddress,r:e.r,s:e.s,chainId:(0,s.cK)(e.chainId),nonce:(0,s.cK)(e.nonce),...void 0!==e.yParity?{yParity:(0,s.cK)(e.yParity)}:{},...void 0!==e.v&&void 0===e.yParity?{v:(0,s.cK)(e.v)}:{}})))),void 0!==e.accessList&&(t.accessList=e.accessList),void 0!==e.blobVersionedHashes&&(t.blobVersionedHashes=e.blobVersionedHashes),void 0!==e.blobs&&("string"!=typeof e.blobs[0]?t.blobs=e.blobs.map((e=>(0,s.My)(e))):t.blobs=e.blobs),void 0!==e.data&&(t.data=e.data),void 0!==e.from&&(t.from=e.from),void 0!==e.gas&&(t.gas=(0,s.cK)(e.gas)),void 0!==e.gasPrice&&(t.gasPrice=(0,s.cK)(e.gasPrice)),void 0!==e.maxFeePerBlobGas&&(t.maxFeePerBlobGas=(0,s.cK)(e.maxFeePerBlobGas)),void 0!==e.maxFeePerGas&&(t.maxFeePerGas=(0,s.cK)(e.maxFeePerGas)),void 0!==e.maxPriorityFeePerGas&&(t.maxPriorityFeePerGas=(0,s.cK)(e.maxPriorityFeePerGas)),void 0!==e.nonce&&(t.nonce=(0,s.cK)(e.nonce)),void 0!==e.to&&(t.to=e.to),void 0!==e.type&&(t.type=i[e.type]),void 0!==e.value&&(t.value=(0,s.cK)(e.value)),t}},2610:(e,t,n)=>{n.d(t,{S:()=>B});var s=n(8113);const i=BigInt(2**32-1),r=BigInt(32);function a(e,t=!1){return t?{h:Number(e&i),l:Number(e>>r&i)}:{h:0|Number(e>>r&i),l:0|Number(e&i)}}function o(e,t=!1){let n=new Uint32Array(e.length),s=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:r,l:o}=a(e[i],t);[n[i],s[i]]=[r,o]}return[n,s]}var l=n(4611);const c=[],d=[],u=[],f=BigInt(0),h=BigInt(1),p=BigInt(2),m=BigInt(7),g=BigInt(256),_=BigInt(113);for(let e=0,t=h,n=1,s=0;e<24;e++){[n,s]=[s,(2*n+3*s)%5],c.push(2*(5*s+n)),d.push((e+1)*(e+2)/2%64);let i=f;for(let e=0;e<7;e++)t=(t<<h^(t>>m)*_)%g,t&p&&(i^=h<<(h<<BigInt(e))-h);u.push(i)}const[b,y]=o(u,!0),A=(e,t,n)=>n>32?((e,t,n)=>t<<n-32|e>>>64-n)(e,t,n):((e,t,n)=>e<<n|t>>>32-n)(e,t,n),w=(e,t,n)=>n>32?((e,t,n)=>e<<n-32|t>>>64-n)(e,t,n):((e,t,n)=>t<<n|e>>>32-n)(e,t,n);class x extends l.Vw{constructor(e,t,n,i=!1,r=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=i,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,s.Fe)(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,l.DH)(this.state)}keccak(){l.qv||(0,l.Fc)(this.state32),function(e,t=24){const n=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let t=0;t<10;t++)n[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const s=(t+8)%10,i=(t+2)%10,r=n[i],a=n[i+1],o=A(r,a,1)^n[s],l=w(r,a,1)^n[s+1];for(let n=0;n<50;n+=10)e[t+n]^=o,e[t+n+1]^=l}let t=e[2],i=e[3];for(let n=0;n<24;n++){const s=d[n],r=A(t,i,s),a=w(t,i,s),o=c[n];t=e[o],i=e[o+1],e[o]=r,e[o+1]=a}for(let t=0;t<50;t+=10){for(let s=0;s<10;s++)n[s]=e[t+s];for(let s=0;s<10;s++)e[t+s]^=~n[(s+2)%10]&n[(s+4)%10]}e[0]^=b[s],e[1]^=y[s]}n.fill(0)}(this.state32,this.rounds),l.qv||(0,l.Fc)(this.state32),this.posOut=0,this.pos=0}update(e){(0,s.CC)(this);const{blockLen:t,state:n}=this,i=(e=(0,l.ZJ)(e)).length;for(let s=0;s<i;){const r=Math.min(t-this.pos,i-s);for(let t=0;t<r;t++)n[this.pos++]^=e[s++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:s}=this;e[n]^=t,128&t&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){(0,s.CC)(this,!1),(0,s.DO)(e),this.finish();const t=this.state,{blockLen:n}=this;for(let s=0,i=e.length;s<i;){this.posOut>=n&&this.keccak();const r=Math.min(n-this.posOut,i-s);e.set(t.subarray(this.posOut,this.posOut+r),s),this.posOut+=r,s+=r}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return(0,s.Fe)(e),this.xofInto(new Uint8Array(e))}digestInto(e){if((0,s.Ht)(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:s,rounds:i,enableXOF:r}=this;return e||(e=new x(t,n,s,r,i)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=i,e.suffix=n,e.outputLen=s,e.enableXOF=r,e.destroyed=this.destroyed,e}}const v=((e,t,n)=>(0,l.ld)((()=>new x(t,e,n))))(1,136,32);var E=n(2768),M=n(3588),z=n(9042);function B(e,t){const n=t||"hex",s=v((0,E.q)(e,{strict:!1})?(0,M.ZJ)(e):e);return"bytes"===n?s:(0,z.nj)(s)}},643:(e,t,n)=>{n.d(t,{h:()=>s});const s=n(4436).k},5561:(e,t,n)=>{n.d(t,{V:()=>r});var s=n(5355),i=n(4436);const r=e=>(0,s.di)((0,i.k)(e),0,4)},4436:(e,t,n)=>{n.d(t,{k:()=>f});var s=n(3588),i=n(2610);const r=e=>(0,i.S)((0,s.ZJ)(e));var a=n(8537);const o=/^tuple(?<array>(\[(\d*)\])*)$/;function l(e){let t=e.type;if(o.test(e.type)&&"components"in e){t="(";const n=e.components.length;for(let s=0;s<n;s++)t+=l(e.components[s]),s<n-1&&(t+=", ");const s=(0,a.Yv)(o,e.type);return t+=`)${s?.array??""}`,l({...e,type:t})}return"indexed"in e&&e.indexed&&(t=`${t} indexed`),e.name?`${t} ${e.name}`:t}function c(e){let t="";const n=e.length;for(let s=0;s<n;s++)t+=l(e[s]),s!==n-1&&(t+=", ");return t}var d=n(9302);const u=e=>{var t;return function(e){let t=!0,n="",s=0,i="",r=!1;for(let a=0;a<e.length;a++){const o=e[a];if(["(",")",","].includes(o)&&(t=!0),"("===o&&s++,")"===o&&s--,t)if(0!==s)" "!==o?(i+=o,n+=o):","!==e[a-1]&&","!==n&&",("!==n&&(n="",t=!1);else if(" "===o&&["event","function",""].includes(i))i="";else if(i+=o,")"===o){r=!0;break}}if(!r)throw new d.C("Unable to normalize signature.");return i}("string"==typeof e?e:"function"===(t=e).type?`function ${t.name}(${c(t.inputs)})${t.stateMutability&&"nonpayable"!==t.stateMutability?` ${t.stateMutability}`:""}${t.outputs?.length?` returns (${c(t.outputs)})`:""}`:"event"===t.type?`event ${t.name}(${c(t.inputs)})`:"error"===t.type?`error ${t.name}(${c(t.inputs)})`:"constructor"===t.type?`constructor(${c(t.inputs)})${"payable"===t.stateMutability?" payable":""}`:"fallback"===t.type?"fallback() external"+("payable"===t.stateMutability?" payable":""):"receive() external payable")};function f(e){return t=u(e),r(t);var t}},645:(e,t,n)=>{n.d(t,{A:()=>s});class s extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const t=super.get(e);return super.has(e)&&void 0!==t&&(this.delete(e),super.set(e,t)),t}set(e,t){if(super.set(e,t),this.maxSize&&this.size>this.maxSize){const e=this.keys().next().value;e&&this.delete(e)}return this}}},6409:(e,t,n)=>{n.d(t,{yH:()=>d});var s=n(5372),i=n(7834),r=n(373),a=n(7283),o=n(9042);function l(e){if(e&&0!==e.length)return e.reduce(((e,{slot:t,value:n})=>{if(66!==t.length)throw new i.NV({size:t.length,targetSize:66,type:"hex"});if(66!==n.length)throw new i.NV({size:n.length,targetSize:66,type:"hex"});return e[t]=n,e}),{})}function c(e){const{balance:t,nonce:n,state:s,stateDiff:i,code:a}=e,c={};if(void 0!==a&&(c.code=a),void 0!==t&&(c.balance=(0,o.cK)(t)),void 0!==n&&(c.nonce=(0,o.cK)(n)),void 0!==s&&(c.state=l(s)),void 0!==i){if(c.state)throw new r.ft;c.stateDiff=l(i)}return c}function d(e){if(!e)return;const t={};for(const{address:n,...i}of e){if(!(0,a.P)(n,{strict:!1}))throw new s.M({address:n});if(t[n])throw new r.Hi({address:n});t[n]=c(i)}return t}},1501:(e,t,n)=>{n.d(t,{A:()=>s});const s=(e,t,n)=>JSON.stringify(e,((e,n)=>{const s="bigint"==typeof n?n.toString():n;return"function"==typeof t?t(e,s):s}),n)},7338:(e,t,n)=>{n.d(t,{c:()=>c});var s=n(6027);const i=2n**256n-1n;var r=n(5372),a=n(7426),o=n(7740),l=n(7283);function c(e){const{account:t,gasPrice:n,maxFeePerGas:c,maxPriorityFeePerGas:d,to:u}=e,f=t?(0,s.J)(t):void 0;if(f&&!(0,l.P)(f.address))throw new r.M({address:f.address});if(u&&!(0,l.P)(u))throw new r.M({address:u});if(void 0!==n&&(void 0!==c||void 0!==d))throw new o.n3;if(c&&c>i)throw new a.BG({maxFeePerGas:c});if(d&&c&&d>c)throw new a.lN({maxFeePerGas:c,maxPriorityFeePerGas:d})}},3538:(e,t,n)=>{n.d(t,{c:()=>r});var s=n(6956),i=n(6473);function r(e,t="wei"){return(0,i.J)(e,s.eL[t])}},1892:(e,t,n)=>{n.d(t,{Q:()=>r});var s=n(6956),i=n(6473);function r(e,t="wei"){return(0,i.J)(e,s.sz[t])}},6473:(e,t,n)=>{function s(e,t){let n=e.toString();const s=n.startsWith("-");s&&(n=n.slice(1)),n=n.padStart(t,"0");let[i,r]=[n.slice(0,n.length-t),n.slice(n.length-t)];return r=r.replace(/(0+)$/,""),`${s?"-":""}${i||"0"}${r?`.${r}`:""}`}n.d(t,{J:()=>s})},1979:(e,t,n)=>{n.d(t,{secp256k1:()=>Qe});var s={};function i(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function r(e,...t){if(!((n=e)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function a(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}n.r(s),n.d(s,{aK:()=>R,e8:()=>F,DO:()=>B,dJ:()=>G,OG:()=>Z,My:()=>C,bytesToNumberBE:()=>N,lX:()=>P,Id:()=>j,fg:()=>W,qj:()=>Q,hexToBytes:()=>S,r4:()=>U,aY:()=>z,x:()=>K,lq:()=>I,z:()=>Y,zW:()=>O,Q5:()=>q});const o="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,l=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),c=(e,t)=>e<<32-t|e>>>t;function d(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),r(e),e}class u{clone(){return this._cloneInto()}}function f(e){const t=t=>e().update(d(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function h(e=32){if(o&&"function"==typeof o.getRandomValues)return o.getRandomValues(new Uint8Array(e));if(o&&"function"==typeof o.randomBytes)return o.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}const p=(e,t,n)=>e&t^e&n^t&n;class m extends u{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=l(this.buffer)}update(e){a(this);const{view:t,buffer:n,blockLen:s}=this,i=(e=d(e)).length;for(let r=0;r<i;){const a=Math.min(s-this.pos,i-r);if(a!==s)n.set(e.subarray(r,r+a),this.pos),this.pos+=a,r+=a,this.pos===s&&(this.process(t,0),this.pos=0);else{const t=l(e);for(;s<=i-r;r+=s)this.process(t,r)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){a(this),function(e,t){r(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>s-o&&(this.process(n,0),o=0);for(let e=o;e<s;e++)t[e]=0;!function(e,t,n,s){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,s);const i=BigInt(32),r=BigInt(4294967295),a=Number(n>>i&r),o=Number(n&r),l=s?4:0,c=s?0:4;e.setUint32(t+l,a,s),e.setUint32(t+c,o,s)}(n,s-8,BigInt(8*this.length),i),this.process(n,0);const c=l(e),d=this.outputLen;if(d%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=d/4,f=this.get();if(u>f.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<u;e++)c.setUint32(4*e,f[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:i,destroyed:r,pos:a}=this;return e.length=s,e.pos=a,e.finished=i,e.destroyed=r,s%t&&e.buffer.set(n),e}}const g=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),b=new Uint32Array(64);class y extends m{constructor(){super(64,32,8,!1),this.A=0|_[0],this.B=0|_[1],this.C=0|_[2],this.D=0|_[3],this.E=0|_[4],this.F=0|_[5],this.G=0|_[6],this.H=0|_[7]}get(){const{A:e,B:t,C:n,D:s,E:i,F:r,G:a,H:o}=this;return[e,t,n,s,i,r,a,o]}set(e,t,n,s,i,r,a,o){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|s,this.E=0|i,this.F=0|r,this.G=0|a,this.H=0|o}process(e,t){for(let n=0;n<16;n++,t+=4)b[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=b[e-15],n=b[e-2],s=c(t,7)^c(t,18)^t>>>3,i=c(n,17)^c(n,19)^n>>>10;b[e]=i+b[e-7]+s+b[e-16]|0}let{A:n,B:s,C:i,D:r,E:a,F:o,G:l,H:d}=this;for(let e=0;e<64;e++){const t=d+(c(a,6)^c(a,11)^c(a,25))+((u=a)&o^~u&l)+g[e]+b[e]|0,f=(c(n,2)^c(n,13)^c(n,22))+p(n,s,i)|0;d=l,l=o,o=a,a=r+t|0,r=i,i=s,s=n,n=t+f|0}var u;n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,r=r+this.D|0,a=a+this.E|0,o=o+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,s,i,r,a,o,l,d)}roundClean(){b.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const A=f((()=>new y));class w extends u{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,function(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");i(e.outputLen),i(e.blockLen)}(e);const n=d(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,r=new Uint8Array(s);r.set(n.length>s?e.create().update(n).digest():n);for(let e=0;e<r.length;e++)r[e]^=54;this.iHash.update(r),this.oHash=e.create();for(let e=0;e<r.length;e++)r[e]^=106;this.oHash.update(r),r.fill(0)}update(e){return a(this),this.iHash.update(e),this}digestInto(e){a(this),r(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:r,outputLen:a}=this;return e.finished=s,e.destroyed=i,e.blockLen=r,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const x=(e,t,n)=>new w(e,t).update(n).digest();x.create=(e,t)=>new w(e,t);const v=BigInt(0),E=BigInt(1),M=BigInt(2);function z(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function B(e){if(!z(e))throw new Error("Uint8Array expected")}function F(e,t){if("boolean"!=typeof t)throw new Error(e+" boolean expected, got "+t)}const k=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function C(e){B(e);let t="";for(let n=0;n<e.length;n++)t+=k[e[n]];return t}function O(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function D(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?v:BigInt("0x"+e)}const L={_0:48,_9:57,A:65,F:70,a:97,f:102};function T(e){return e>=L._0&&e<=L._9?e-L._0:e>=L.A&&e<=L.F?e-(L.A-10):e>=L.a&&e<=L.f?e-(L.a-10):void 0}function S(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(n);for(let t=0,i=0;t<n;t++,i+=2){const n=T(e.charCodeAt(i)),r=T(e.charCodeAt(i+1));if(void 0===n||void 0===r){const t=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+i)}s[t]=16*n+r}return s}function N(e){return D(C(e))}function P(e){return B(e),D(C(Uint8Array.from(e).reverse()))}function I(e,t){return S(e.toString(16).padStart(2*t,"0"))}function Y(e,t){return I(e,t).reverse()}function Q(e,t,n){let s;if("string"==typeof t)try{s=S(t)}catch(t){throw new Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!z(t))throw new Error(e+" must be hex string or Uint8Array");s=Uint8Array.from(t)}const i=s.length;if("number"==typeof n&&i!==n)throw new Error(e+" of length "+n+" expected, got "+i);return s}function j(...e){let t=0;for(let n=0;n<e.length;n++){const s=e[n];B(s),t+=s.length}const n=new Uint8Array(t);for(let t=0,s=0;t<e.length;t++){const i=e[t];n.set(i,s),s+=i.length}return n}const H=e=>"bigint"==typeof e&&v<=e;function U(e,t,n){return H(e)&&H(t)&&H(n)&&t<=e&&e<n}function R(e,t,n,s){if(!U(t,n,s))throw new Error("expected valid "+e+": "+n+" <= n < "+s+", got "+t)}function G(e){let t;for(t=0;e>v;e>>=E,t+=1);return t}const Z=e=>(M<<BigInt(e-1))-E,J=e=>new Uint8Array(e),X=e=>Uint8Array.from(e);function W(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let s=J(e),i=J(e),r=0;const a=()=>{s.fill(1),i.fill(0),r=0},o=(...e)=>n(i,s,...e),l=(e=J())=>{i=o(X([0]),e),s=o(),0!==e.length&&(i=o(X([1]),e),s=o())},c=()=>{if(r++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){s=o();const t=s.slice();n.push(t),e+=s.length}return j(...n)};return(e,t)=>{let n;for(a(),l(e);!(n=t(c()));)l();return a(),n}}const V={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||z(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function q(e,t,n={}){const s=(t,n,s)=>{const i=V[n];if("function"!=typeof i)throw new Error("invalid validator function");const r=e[t];if(!(s&&void 0===r||i(r,e)))throw new Error("param "+String(t)+" is invalid. Expected "+n+", got "+r)};for(const[e,n]of Object.entries(t))s(e,n,!1);for(const[e,t]of Object.entries(n))s(e,t,!0);return e}function K(e){const t=new WeakMap;return(n,...s)=>{const i=t.get(n);if(void 0!==i)return i;const r=e(n,...s);return t.set(n,r),r}}const $=BigInt(0),ee=BigInt(1),te=BigInt(2),ne=BigInt(3),se=BigInt(4),ie=BigInt(5),re=BigInt(8);function ae(e,t){const n=e%t;return n>=$?n:t+n}function oe(e,t,n){if(t<$)throw new Error("invalid exponent, negatives unsupported");if(n<=$)throw new Error("invalid modulus");if(n===ee)return $;let s=ee;for(;t>$;)t&ee&&(s=s*e%n),e=e*e%n,t>>=ee;return s}function le(e,t,n){let s=e;for(;t-- >$;)s*=s,s%=n;return s}function ce(e,t){if(e===$)throw new Error("invert: expected non-zero number");if(t<=$)throw new Error("invert: expected positive modulus, got "+t);let n=ae(e,t),s=t,i=$,r=ee,a=ee,o=$;for(;n!==$;){const e=s/n,t=s%n,l=i-a*e,c=r-o*e;s=n,n=t,i=a,r=o,a=l,o=c}if(s!==ee)throw new Error("invert: does not exist");return ae(i,t)}const de=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ue(e,t){const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function fe(e,t,n=!1,s={}){if(e<=$)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:r}=ue(e,t);if(r>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const o=Object.freeze({ORDER:e,BITS:i,BYTES:r,MASK:Z(i),ZERO:$,ONE:ee,create:t=>ae(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return $<=t&&t<e},is0:e=>e===$,isOdd:e=>(e&ee)===ee,neg:t=>ae(-t,e),eql:(e,t)=>e===t,sqr:t=>ae(t*t,e),add:(t,n)=>ae(t+n,e),sub:(t,n)=>ae(t-n,e),mul:(t,n)=>ae(t*n,e),pow:(e,t)=>function(e,t,n){if(n<$)throw new Error("invalid exponent, negatives unsupported");if(n===$)return e.ONE;if(n===ee)return t;let s=e.ONE,i=t;for(;n>$;)n&ee&&(s=e.mul(s,i)),i=e.sqr(i),n>>=ee;return s}(o,e,t),div:(t,n)=>ae(t*ce(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>ce(t,e),sqrt:s.sqrt||(t=>(a||(a=function(e){if(e%se===ne){const t=(e+ee)/se;return function(e,n){const s=e.pow(n,t);if(!e.eql(e.sqr(s),n))throw new Error("Cannot find square root");return s}}if(e%re===ie){const t=(e-ie)/re;return function(e,n){const s=e.mul(n,te),i=e.pow(s,t),r=e.mul(n,i),a=e.mul(e.mul(r,te),i),o=e.mul(r,e.sub(a,e.ONE));if(!e.eql(e.sqr(o),n))throw new Error("Cannot find square root");return o}}return function(e){const t=(e-ee)/te;let n,s,i;for(n=e-ee,s=0;n%te===$;n/=te,s++);for(i=te;i<e&&oe(i,t,e)!==e-ee;i++)if(i>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===s){const t=(e+ee)/se;return function(e,n){const s=e.pow(n,t);if(!e.eql(e.sqr(s),n))throw new Error("Cannot find square root");return s}}const r=(n+ee)/te;return function(e,a){if(e.pow(a,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let o=s,l=e.pow(e.mul(e.ONE,i),n),c=e.pow(a,r),d=e.pow(a,n);for(;!e.eql(d,e.ONE);){if(e.eql(d,e.ZERO))return e.ZERO;let t=1;for(let n=e.sqr(d);t<o&&!e.eql(n,e.ONE);t++)n=e.sqr(n);const n=e.pow(l,ee<<BigInt(o-t-1));l=e.sqr(n),c=e.mul(c,n),d=e.mul(d,l),o=t}return c}}(e)}(e)),a(o,t))),invertBatch:e=>function(e,t){const n=new Array(t.length),s=t.reduce(((t,s,i)=>e.is0(s)?t:(n[i]=t,e.mul(t,s))),e.ONE),i=e.inv(s);return t.reduceRight(((t,s,i)=>e.is0(s)?t:(n[i]=e.mul(t,n[i]),e.mul(t,s))),i),n}(o,e),cmov:(e,t,n)=>n?t:e,toBytes:e=>n?Y(e,r):I(e,r),fromBytes:e=>{if(e.length!==r)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+e.length);return n?P(e):N(e)}});return Object.freeze(o)}function he(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function pe(e){const t=he(e);return t+Math.ceil(t/2)}const me=BigInt(0),ge=BigInt(1);function _e(e,t){const n=t.negate();return e?n:t}function be(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function ye(e,t){return be(e,t),{windows:Math.ceil(t/e)+1,windowSize:2**(e-1)}}const Ae=new WeakMap,we=new WeakMap;function xe(e){return we.get(e)||1}function ve(e){return q(e.Fp,de.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),q(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ue(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function Ee(e){void 0!==e.lowS&&F("lowS",e.lowS),void 0!==e.prehash&&F("prehash",e.prehash)}const{bytesToNumberBE:Me,hexToBytes:ze}=s,Be={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(e,t)=>{const{Err:n}=Be;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(1&t.length)throw new n("tlv.encode: unpadded data");const s=t.length/2,i=O(s);if(i.length/2&128)throw new n("tlv.encode: long form length too big");const r=s>127?O(i.length/2|128):"";return O(e)+r+i+t},decode(e,t){const{Err:n}=Be;let s=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[s++]!==e)throw new n("tlv.decode: wrong tlv");const i=t[s++];let r=0;if(128&i){const e=127&i;if(!e)throw new n("tlv.decode(long): indefinite length not supported");if(e>4)throw new n("tlv.decode(long): byte length is too big");const a=t.subarray(s,s+e);if(a.length!==e)throw new n("tlv.decode: length bytes not complete");if(0===a[0])throw new n("tlv.decode(long): zero leftmost byte");for(const e of a)r=r<<8|e;if(s+=e,r<128)throw new n("tlv.decode(long): not minimal encoding")}else r=i;const a=t.subarray(s,s+r);if(a.length!==r)throw new n("tlv.decode: wrong value length");return{v:a,l:t.subarray(s+r)}}},_int:{encode(e){const{Err:t}=Be;if(e<Fe)throw new t("integer: negative integers are not allowed");let n=O(e);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=Be;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return Me(e)}},toSig(e){const{Err:t,_int:n,_tlv:s}=Be,i="string"==typeof e?ze(e):e;B(i);const{v:r,l:a}=s.decode(48,i);if(a.length)throw new t("invalid signature: left bytes after parsing");const{v:o,l}=s.decode(2,r),{v:c,l:d}=s.decode(2,l);if(d.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(o),s:n.decode(c)}},hexFromSig(e){const{_tlv:t,_int:n}=Be,s=t.encode(2,n.encode(e.r))+t.encode(2,n.encode(e.s));return t.encode(48,s)}},Fe=BigInt(0),ke=BigInt(1),Ce=(BigInt(2),BigInt(3));function Oe(e){const t=function(e){const t=ve(e);q(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:s,a:i}=t;if(n){if(!s.eql(i,s.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:n}=t,s=fe(t.n,t.nBitLength),i=t.toBytes||((e,t,s)=>{const i=t.toAffine();return j(Uint8Array.from([4]),n.toBytes(i.x),n.toBytes(i.y))}),r=t.fromBytes||(e=>{const t=e.subarray(1);return{x:n.fromBytes(t.subarray(0,n.BYTES)),y:n.fromBytes(t.subarray(n.BYTES,2*n.BYTES))}});function a(e){const{a:s,b:i}=t,r=n.sqr(e),a=n.mul(r,e);return n.add(n.add(a,n.mul(e,s)),i)}if(!n.eql(n.sqr(t.Gy),a(t.Gx)))throw new Error("bad generator point: equation left != right");function o(e){const{allowedPrivateKeyLengths:n,nByteLength:s,wrapPrivateKey:i,n:r}=t;if(n&&"bigint"!=typeof e){if(z(e)&&(e=C(e)),"string"!=typeof e||!n.includes(e.length))throw new Error("invalid private key");e=e.padStart(2*s,"0")}let a;try{a="bigint"==typeof e?e:N(Q("private key",e,s))}catch(t){throw new Error("invalid private key, expected hex or "+s+" bytes, got "+typeof e)}return i&&(a=ae(a,r)),R("private key",a,ke,r),a}function l(e){if(!(e instanceof u))throw new Error("ProjectivePoint expected")}const c=K(((e,t)=>{const{px:s,py:i,pz:r}=e;if(n.eql(r,n.ONE))return{x:s,y:i};const a=e.is0();null==t&&(t=a?n.ONE:n.inv(r));const o=n.mul(s,t),l=n.mul(i,t),c=n.mul(r,t);if(a)return{x:n.ZERO,y:n.ZERO};if(!n.eql(c,n.ONE))throw new Error("invZ was invalid");return{x:o,y:l}})),d=K((e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.py))return;throw new Error("bad point: ZERO")}const{x:s,y:i}=e.toAffine();if(!n.isValid(s)||!n.isValid(i))throw new Error("bad point: x or y not FE");const r=n.sqr(i),o=a(s);if(!n.eql(r,o))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class u{constructor(e,t,s){if(this.px=e,this.py=t,this.pz=s,null==e||!n.isValid(e))throw new Error("x required");if(null==t||!n.isValid(t))throw new Error("y required");if(null==s||!n.isValid(s))throw new Error("z required");Object.freeze(this)}static fromAffine(e){const{x:t,y:s}=e||{};if(!e||!n.isValid(t)||!n.isValid(s))throw new Error("invalid affine point");if(e instanceof u)throw new Error("projective point not allowed");const i=e=>n.eql(e,n.ZERO);return i(t)&&i(s)?u.ZERO:new u(t,s,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(t[n]))).map(u.fromAffine)}static fromHex(e){const t=u.fromAffine(r(Q("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return u.BASE.multiply(o(e))}static msm(e,t){return function(e,t,n,s){if(function(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach(((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)}))}(n,e),function(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach(((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)}))}(s,t),n.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const i=e.ZERO,r=G(BigInt(n.length)),a=r>12?r-3:r>4?r-2:r?2:1,o=(1<<a)-1,l=new Array(o+1).fill(i);let c=i;for(let e=Math.floor((t.BITS-1)/a)*a;e>=0;e-=a){l.fill(i);for(let t=0;t<s.length;t++){const i=s[t],r=Number(i>>BigInt(e)&BigInt(o));l[r]=l[r].add(n[t])}let t=i;for(let e=l.length-1,n=i;e>0;e--)n=n.add(l[e]),t=t.add(n);if(c=c.add(t),0!==e)for(let e=0;e<a;e++)c=c.double()}return c}(u,s,e,t)}_setWindowSize(e){h.setWindowSize(this,e)}assertValidity(){d(this)}hasEvenY(){const{y:e}=this.toAffine();if(n.isOdd)return!n.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){l(e);const{px:t,py:s,pz:i}=this,{px:r,py:a,pz:o}=e,c=n.eql(n.mul(t,o),n.mul(r,i)),d=n.eql(n.mul(s,o),n.mul(a,i));return c&&d}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:e,b:s}=t,i=n.mul(s,Ce),{px:r,py:a,pz:o}=this;let l=n.ZERO,c=n.ZERO,d=n.ZERO,f=n.mul(r,r),h=n.mul(a,a),p=n.mul(o,o),m=n.mul(r,a);return m=n.add(m,m),d=n.mul(r,o),d=n.add(d,d),l=n.mul(e,d),c=n.mul(i,p),c=n.add(l,c),l=n.sub(h,c),c=n.add(h,c),c=n.mul(l,c),l=n.mul(m,l),d=n.mul(i,d),p=n.mul(e,p),m=n.sub(f,p),m=n.mul(e,m),m=n.add(m,d),d=n.add(f,f),f=n.add(d,f),f=n.add(f,p),f=n.mul(f,m),c=n.add(c,f),p=n.mul(a,o),p=n.add(p,p),f=n.mul(p,m),l=n.sub(l,f),d=n.mul(p,h),d=n.add(d,d),d=n.add(d,d),new u(l,c,d)}add(e){l(e);const{px:s,py:i,pz:r}=this,{px:a,py:o,pz:c}=e;let d=n.ZERO,f=n.ZERO,h=n.ZERO;const p=t.a,m=n.mul(t.b,Ce);let g=n.mul(s,a),_=n.mul(i,o),b=n.mul(r,c),y=n.add(s,i),A=n.add(a,o);y=n.mul(y,A),A=n.add(g,_),y=n.sub(y,A),A=n.add(s,r);let w=n.add(a,c);return A=n.mul(A,w),w=n.add(g,b),A=n.sub(A,w),w=n.add(i,r),d=n.add(o,c),w=n.mul(w,d),d=n.add(_,b),w=n.sub(w,d),h=n.mul(p,A),d=n.mul(m,b),h=n.add(d,h),d=n.sub(_,h),h=n.add(_,h),f=n.mul(d,h),_=n.add(g,g),_=n.add(_,g),b=n.mul(p,b),A=n.mul(m,A),_=n.add(_,b),b=n.sub(g,b),b=n.mul(p,b),A=n.add(A,b),g=n.mul(_,A),f=n.add(f,g),g=n.mul(w,A),d=n.mul(y,d),d=n.sub(d,g),g=n.mul(y,_),h=n.mul(w,h),h=n.add(h,g),new u(d,f,h)}subtract(e){return this.add(e.negate())}is0(){return this.equals(u.ZERO)}wNAF(e){return h.wNAFCached(this,e,u.normalizeZ)}multiplyUnsafe(e){const{endo:s,n:i}=t;R("scalar",e,Fe,i);const r=u.ZERO;if(e===Fe)return r;if(this.is0()||e===ke)return this;if(!s||h.hasPrecomputes(this))return h.wNAFCachedUnsafe(this,e,u.normalizeZ);let{k1neg:a,k1:o,k2neg:l,k2:c}=s.splitScalar(e),d=r,f=r,p=this;for(;o>Fe||c>Fe;)o&ke&&(d=d.add(p)),c&ke&&(f=f.add(p)),p=p.double(),o>>=ke,c>>=ke;return a&&(d=d.negate()),l&&(f=f.negate()),f=new u(n.mul(f.px,s.beta),f.py,f.pz),d.add(f)}multiply(e){const{endo:s,n:i}=t;let r,a;if(R("scalar",e,ke,i),s){const{k1neg:t,k1:i,k2neg:o,k2:l}=s.splitScalar(e);let{p:c,f:d}=this.wNAF(i),{p:f,f:p}=this.wNAF(l);c=h.constTimeNegate(t,c),f=h.constTimeNegate(o,f),f=new u(n.mul(f.px,s.beta),f.py,f.pz),r=c.add(f),a=d.add(p)}else{const{p:t,f:n}=this.wNAF(e);r=t,a=n}return u.normalizeZ([r,a])[0]}multiplyAndAddUnsafe(e,t,n){const s=u.BASE,i=(e,t)=>t!==Fe&&t!==ke&&e.equals(s)?e.multiply(t):e.multiplyUnsafe(t),r=i(this,t).add(i(e,n));return r.is0()?void 0:r}toAffine(e){return c(this,e)}isTorsionFree(){const{h:e,isTorsionFree:n}=t;if(e===ke)return!0;if(n)return n(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:n}=t;return e===ke?this:n?n(u,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return F("isCompressed",e),this.assertValidity(),i(u,this,e)}toHex(e=!0){return F("isCompressed",e),C(this.toRawBytes(e))}}u.BASE=new u(t.Gx,t.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const f=t.nBitLength,h=(p=u,m=t.endo?Math.ceil(f/2):f,{constTimeNegate:_e,hasPrecomputes:e=>1!==xe(e),unsafeLadder(e,t,n=p.ZERO){let s=e;for(;t>me;)t&ge&&(n=n.add(s)),s=s.double(),t>>=ge;return n},precomputeWindow(e,t){const{windows:n,windowSize:s}=ye(t,m),i=[];let r=e,a=r;for(let e=0;e<n;e++){a=r,i.push(a);for(let e=1;e<s;e++)a=a.add(r),i.push(a);r=a.double()}return i},wNAF(e,t,n){const{windows:s,windowSize:i}=ye(e,m);let r=p.ZERO,a=p.BASE;const o=BigInt(2**e-1),l=2**e,c=BigInt(e);for(let e=0;e<s;e++){const s=e*i;let d=Number(n&o);n>>=c,d>i&&(d-=l,n+=ge);const u=s,f=s+Math.abs(d)-1,h=e%2!=0,p=d<0;0===d?a=a.add(_e(h,t[u])):r=r.add(_e(p,t[f]))}return{p:r,f:a}},wNAFUnsafe(e,t,n,s=p.ZERO){const{windows:i,windowSize:r}=ye(e,m),a=BigInt(2**e-1),o=2**e,l=BigInt(e);for(let e=0;e<i;e++){const i=e*r;if(n===me)break;let c=Number(n&a);if(n>>=l,c>r&&(c-=o,n+=ge),0===c)continue;let d=t[i+Math.abs(c)-1];c<0&&(d=d.negate()),s=s.add(d)}return s},getPrecomputes(e,t,n){let s=Ae.get(t);return s||(s=this.precomputeWindow(t,e),1!==e&&Ae.set(t,n(s))),s},wNAFCached(e,t,n){const s=xe(e);return this.wNAF(s,this.getPrecomputes(s,e,n),t)},wNAFCachedUnsafe(e,t,n,s){const i=xe(e);return 1===i?this.unsafeLadder(e,t,s):this.wNAFUnsafe(i,this.getPrecomputes(i,e,n),t,s)},setWindowSize(e,t){be(t,m),we.set(e,t),Ae.delete(e)}});var p,m;return{CURVE:t,ProjectivePoint:u,normPrivateKeyToScalar:o,weierstrassEquation:a,isWithinCurveOrder:function(e){return U(e,ke,t.n)}}}function De(e){const t=function(e){const t=ve(e);return q(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:n,n:s}=t,i=n.BYTES+1,r=2*n.BYTES+1;function a(e){return ae(e,s)}function o(e){return ce(e,s)}const{ProjectivePoint:l,normPrivateKeyToScalar:c,weierstrassEquation:d,isWithinCurveOrder:u}=Oe({...t,toBytes(e,t,s){const i=t.toAffine(),r=n.toBytes(i.x),a=j;return F("isCompressed",s),s?a(Uint8Array.from([t.hasEvenY()?2:3]),r):a(Uint8Array.from([4]),r,n.toBytes(i.y))},fromBytes(e){const t=e.length,s=e[0],a=e.subarray(1);if(t!==i||2!==s&&3!==s){if(t===r&&4===s)return{x:n.fromBytes(a.subarray(0,n.BYTES)),y:n.fromBytes(a.subarray(n.BYTES,2*n.BYTES))};throw new Error("invalid Point, expected length of "+i+", or uncompressed "+r+", got "+t)}{const e=N(a);if(!U(e,ke,n.ORDER))throw new Error("Point is not on curve");const t=d(e);let i;try{i=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~s)!=((i&ke)===ke)&&(i=n.neg(i)),{x:e,y:i}}}}),f=e=>C(I(e,t.nByteLength));function h(e){return e>s>>ke}const p=(e,t,n)=>N(e.slice(t,n));class m{constructor(e,t,n){this.r=e,this.s=t,this.recovery=n,this.assertValidity()}static fromCompact(e){const n=t.nByteLength;return e=Q("compactSignature",e,2*n),new m(p(e,0,n),p(e,n,2*n))}static fromDER(e){const{r:t,s:n}=Be.toSig(Q("DER",e));return new m(t,n)}assertValidity(){R("r",this.r,ke,s),R("s",this.s,ke,s)}addRecoveryBit(e){return new m(this.r,this.s,e)}recoverPublicKey(e){const{r:s,s:i,recovery:r}=this,c=y(Q("msgHash",e));if(null==r||![0,1,2,3].includes(r))throw new Error("recovery id invalid");const d=2===r||3===r?s+t.n:s;if(d>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const u=1&r?"03":"02",h=l.fromHex(u+f(d)),p=o(d),m=a(-c*p),g=a(i*p),_=l.BASE.multiplyAndAddUnsafe(h,m,g);if(!_)throw new Error("point at infinify");return _.assertValidity(),_}hasHighS(){return h(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return S(this.toDERHex())}toDERHex(){return Be.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return S(this.toCompactHex())}toCompactHex(){return f(this.r)+f(this.s)}}const g={isValidPrivateKey(e){try{return c(e),!0}catch(e){return!1}},normPrivateKeyToScalar:c,randomPrivateKey:()=>{const e=pe(t.n);return function(e,t,n=!1){const s=e.length,i=he(t),r=pe(t);if(s<16||s<r||s>1024)throw new Error("expected "+r+"-1024 bytes of input, got "+s);const a=ae(n?N(e):P(e),t-ee)+ee;return n?Y(a,i):I(a,i)}(t.randomBytes(e),t.n)},precompute:(e=8,t=l.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function _(e){const t=z(e),n="string"==typeof e,s=(t||n)&&e.length;return t?s===i||s===r:n?s===2*i||s===2*r:e instanceof l}const b=t.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const n=N(e),s=8*e.length-t.nBitLength;return s>0?n>>BigInt(s):n},y=t.bits2int_modN||function(e){return a(b(e))},A=Z(t.nBitLength);function w(e){return R("num < 2^"+t.nBitLength,e,Fe,A),I(e,t.nByteLength)}const x={lowS:t.lowS,prehash:!1},v={lowS:t.lowS,prehash:!1};return l.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return l.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,n=!0){if(_(e))throw new Error("first arg must be private key");if(!_(t))throw new Error("second arg must be public key");return l.fromHex(t).multiply(c(e)).toRawBytes(n)},sign:function(e,s,i=x){const{seed:r,k2sig:d}=function(e,s,i=x){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{hash:r,randomBytes:d}=t;let{lowS:f,prehash:p,extraEntropy:g}=i;null==f&&(f=!0),e=Q("msgHash",e),Ee(i),p&&(e=Q("prehashed msgHash",r(e)));const _=y(e),A=c(s),v=[w(A),w(_)];if(null!=g&&!1!==g){const e=!0===g?d(n.BYTES):g;v.push(Q("extraEntropy",e))}const E=j(...v),M=_;return{seed:E,k2sig:function(e){const t=b(e);if(!u(t))return;const n=o(t),s=l.BASE.multiply(t).toAffine(),i=a(s.x);if(i===Fe)return;const r=a(n*a(M+i*A));if(r===Fe)return;let c=(s.x===i?0:2)|Number(s.y&ke),d=r;return f&&h(r)&&(d=function(e){return h(e)?a(-e):e}(r),c^=1),new m(i,d,c)}}}(e,s,i),f=t;return W(f.hash.outputLen,f.nByteLength,f.hmac)(r,d)},verify:function(e,n,s,i=v){const r=e;n=Q("msgHash",n),s=Q("publicKey",s);const{lowS:c,prehash:d,format:u}=i;if(Ee(i),"strict"in i)throw new Error("options.strict was renamed to lowS");if(void 0!==u&&"compact"!==u&&"der"!==u)throw new Error("format must be compact or der");const f="string"==typeof r||z(r),h=!f&&!u&&"object"==typeof r&&null!==r&&"bigint"==typeof r.r&&"bigint"==typeof r.s;if(!f&&!h)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let p,g;try{if(h&&(p=new m(r.r,r.s)),f){try{"compact"!==u&&(p=m.fromDER(r))}catch(e){if(!(e instanceof Be.Err))throw e}p||"der"===u||(p=m.fromCompact(r))}g=l.fromHex(s)}catch(e){return!1}if(!p)return!1;if(c&&p.hasHighS())return!1;d&&(n=t.hash(n));const{r:_,s:b}=p,A=y(n),w=o(b),x=a(A*w),E=a(_*w),M=l.BASE.multiplyAndAddUnsafe(g,x,E)?.toAffine();return!!M&&a(M.x)===_},ProjectivePoint:l,Signature:m,utils:g}}function Le(e){return{hash:e,hmac:(t,...n)=>x(e,t,function(...e){let t=0;for(let n=0;n<e.length;n++){const s=e[n];r(s),t+=s.length}const n=new Uint8Array(t);for(let t=0,s=0;t<e.length;t++){const i=e[t];n.set(i,s),s+=i.length}return n}(...n)),randomBytes:h}}BigInt(4);const Te=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Se=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ne=BigInt(1),Pe=BigInt(2),Ie=(e,t)=>(e+t/Pe)/t;const Ye=fe(Te,void 0,void 0,{sqrt:function(e){const t=Te,n=BigInt(3),s=BigInt(6),i=BigInt(11),r=BigInt(22),a=BigInt(23),o=BigInt(44),l=BigInt(88),c=e*e*e%t,d=c*c*e%t,u=le(d,n,t)*d%t,f=le(u,n,t)*d%t,h=le(f,Pe,t)*c%t,p=le(h,i,t)*h%t,m=le(p,r,t)*p%t,g=le(m,o,t)*m%t,_=le(g,l,t)*g%t,b=le(_,o,t)*m%t,y=le(b,n,t)*d%t,A=le(y,a,t)*p%t,w=le(A,s,t)*c%t,x=le(w,Pe,t);if(!Ye.eql(Ye.sqr(x),e))throw new Error("Cannot find square root");return x}}),Qe=function(e,t){const n=t=>De({...e,...Le(t)});return Object.freeze({...n(t),create:n})}({a:BigInt(0),b:BigInt(7),Fp:Ye,n:Se,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=Se,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),s=-Ne*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),r=n,a=BigInt("0x100000000000000000000000000000000"),o=Ie(r*e,t),l=Ie(-s*e,t);let c=ae(e-o*n-l*i,t),d=ae(-o*s-l*r,t);const u=c>a,f=d>a;if(u&&(c=t-c),f&&(d=t-d),c>a||d>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:u,k1:c,k2neg:f,k2:d}}}},A);BigInt(0),Qe.ProjectivePoint},8113:(e,t,n)=>{function s(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function i(e,...t){if(!((n=e)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function r(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function a(e,t){i(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}n.d(t,{CC:()=>r,DO:()=>i,Fe:()=>s,Ht:()=>a})},4611:(e,t,n)=>{n.d(t,{DH:()=>i,Fc:()=>c,O8:()=>r,Ow:()=>a,Vw:()=>u,ZJ:()=>d,ld:()=>f,qv:()=>o});var s=n(8113);const i=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),r=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),a=(e,t)=>e<<32-t|e>>>t,o=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])(),l=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;function c(e){for(let t=0;t<e.length;t++)e[t]=l(e[t])}function d(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),(0,s.DO)(e),e}class u{clone(){return this._cloneInto()}}function f(e){const t=t=>e().update(d(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}},5190:(e,t,n)=>{n.d(t,{C:()=>s});class s extends Error{constructor(e,t={}){const n=t.cause instanceof s?t.cause.details:t.cause?.message?t.cause.message:t.details,i=t.cause instanceof s&&t.cause.docsPath||t.docsPath;super([e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...i?[`Docs: https://abitype.dev${i}`]:[],...n?[`Details: ${n}`]:[],"Version: abitype@1.0.7"].join("\n")),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiTypeError"}),t.cause&&(this.cause=t.cause),this.details=n,this.docsPath=i,this.metaMessages=t.metaMessages,this.shortMessage=e}}},1266:(e,t,n)=>{n.d(t,{UG:()=>r,zz:()=>i});var s=n(5190);s.C;class i extends s.C{constructor({type:e}){super("Unknown type.",{metaMessages:[`Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownTypeError"})}}class r extends s.C{constructor({type:e}){super("Unknown type.",{metaMessages:[`Type "${e}" is not a valid ABI type.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSolidityTypeError"})}}},4246:(e,t,n)=>{n.d(t,{A9:()=>i,NO:()=>o,Pj:()=>l,dV:()=>r,nx:()=>c,zd:()=>a});var s=n(5190);s.C;class i extends s.C{constructor({params:e}){super("Failed to parse ABI parameters.",{details:`parseAbiParameters(${JSON.stringify(e,null,2)})`,docsPath:"/api/human#parseabiparameters-1"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiParametersError"})}}class r extends s.C{constructor({param:e}){super("Invalid ABI parameter.",{details:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParameterError"})}}class a extends s.C{constructor({param:e,name:t}){super("Invalid ABI parameter.",{details:e,metaMessages:[`"${t}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SolidityProtectedKeywordError"})}}class o extends s.C{constructor({param:e,type:t,modifier:n}){super("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${n}" not allowed${t?` in "${t}" type`:""}.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidModifierError"})}}class l extends s.C{constructor({param:e,type:t,modifier:n}){super("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${n}" not allowed${t?` in "${t}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${n}" was given.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidFunctionModifierError"})}}class c extends s.C{constructor({abiParameter:e}){super("Invalid ABI parameter.",{details:JSON.stringify(e,null,2),metaMessages:["ABI parameter type is invalid."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiTypeParameterError"})}}},5297:(e,t,n)=>{n.d(t,{X9:()=>a,s7:()=>i,x8:()=>r});var s=n(5190);class i extends s.C{constructor({signature:e,type:t}){super(`Invalid ${t} signature.`,{details:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSignatureError"})}}class r extends s.C{constructor({signature:e}){super("Unknown signature.",{details:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSignatureError"})}}class a extends s.C{constructor({signature:e}){super("Invalid struct signature.",{details:e,metaMessages:["No properties exist."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStructSignatureError"})}}},3021:(e,t,n)=>{n.d(t,{Dv:()=>v,FO:()=>m,Ji:()=>u,Rv:()=>l,WL:()=>p,Yo:()=>b,ej:()=>f,fC:()=>E,iB:()=>c,kz:()=>a,l9:()=>_,pc:()=>r,sP:()=>x,v7:()=>M,v8:()=>A});var s=n(8537);const i=/^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;function r(e){return i.test(e)}function a(e){return(0,s.Yv)(i,e)}const o=/^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;function l(e){return o.test(e)}function c(e){return(0,s.Yv)(o,e)}const d=/^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;function u(e){return d.test(e)}function f(e){return(0,s.Yv)(d,e)}const h=/^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;function p(e){return h.test(e)}function m(e){return(0,s.Yv)(h,e)}const g=/^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;function _(e){return g.test(e)}function b(e){return(0,s.Yv)(g,e)}const y=/^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;function A(e){return y.test(e)}const w=/^receive\(\) external payable$/;function x(e){return w.test(e)}const v=new Set(["memory","indexed","storage","calldata"]),E=new Set(["indexed"]),M=new Set(["calldata","memory","storage"])},7775:(e,t,n)=>{n.d(t,{e:()=>u});var s=n(8537),i=n(1266),r=n(4246),a=n(5297),o=n(5190);class l extends o.C{constructor({type:e}){super("Circular reference detected.",{metaMessages:[`Struct "${e}" is a circular reference.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"CircularReferenceError"})}}var c=n(3021),d=n(1542);function u(e){const t={},n=e.length;for(let s=0;s<n;s++){const n=e[s];if(!(0,c.WL)(n))continue;const i=(0,c.FO)(n);if(!i)throw new a.s7({signature:n,type:"struct"});const r=i.properties.split(";"),o=[],l=r.length;for(let e=0;e<l;e++){const t=r[e].trim();if(!t)continue;const n=(0,d.Pj)(t,{type:"struct"});o.push(n)}if(!o.length)throw new a.X9({signature:n});t[i.name]=o}const s={},i=Object.entries(t),r=i.length;for(let e=0;e<r;e++){const[n,r]=i[e];s[n]=h(r,t)}return s}const f=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;function h(e,t,n=new Set){const a=[],o=e.length;for(let c=0;c<o;c++){const o=e[c];if(s.wj.test(o.type))a.push(o);else{const e=(0,s.Yv)(f,o.type);if(!e?.type)throw new r.nx({abiParameter:o});const{array:c,type:u}=e;if(u in t){if(n.has(u))throw new l({type:u});a.push({...o,type:`tuple${c??""}`,components:h(t[u]??[],t,new Set([...n,u]))})}else{if(!(0,d._o)(u))throw new i.zz({type:u});a.push(o)}}}return a}},1542:(e,t,n)=>{n.d(t,{_o:()=>_,Pj:()=>m,uT:()=>u,NV:()=>g});var s=n(8537),i=n(1266),r=n(4246),a=n(5297),o=n(5190);class l extends o.C{constructor({current:e,depth:t}){super("Unbalanced parentheses.",{metaMessages:[`"${e.trim()}" has too many ${t>0?"opening":"closing"} parentheses.`],details:`Depth "${t}"`}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParenthesisError"})}}const c=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]);var d=n(3021);function u(e,t={}){if((0,d.Ji)(e)){const n=(0,d.ej)(e);if(!n)throw new a.s7({signature:e,type:"function"});const s=g(n.parameters),i=[],r=s.length;for(let e=0;e<r;e++)i.push(m(s[e],{modifiers:d.v7,structs:t,type:"function"}));const o=[];if(n.returns){const e=g(n.returns),s=e.length;for(let n=0;n<s;n++)o.push(m(e[n],{modifiers:d.v7,structs:t,type:"function"}))}return{name:n.name,type:"function",stateMutability:n.stateMutability??"nonpayable",inputs:i,outputs:o}}if((0,d.Rv)(e)){const n=(0,d.iB)(e);if(!n)throw new a.s7({signature:e,type:"event"});const s=g(n.parameters),i=[],r=s.length;for(let e=0;e<r;e++)i.push(m(s[e],{modifiers:d.fC,structs:t,type:"event"}));return{name:n.name,type:"event",inputs:i}}if((0,d.pc)(e)){const n=(0,d.kz)(e);if(!n)throw new a.s7({signature:e,type:"error"});const s=g(n.parameters),i=[],r=s.length;for(let e=0;e<r;e++)i.push(m(s[e],{structs:t,type:"error"}));return{name:n.name,type:"error",inputs:i}}if((0,d.l9)(e)){const n=(0,d.Yo)(e);if(!n)throw new a.s7({signature:e,type:"constructor"});const s=g(n.parameters),i=[],r=s.length;for(let e=0;e<r;e++)i.push(m(s[e],{structs:t,type:"constructor"}));return{type:"constructor",stateMutability:n.stateMutability??"nonpayable",inputs:i}}if((0,d.v8)(e))return{type:"fallback"};if((0,d.sP)(e))return{type:"receive",stateMutability:"payable"};throw new a.x8({signature:e})}const f=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,h=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,p=/^u?int$/;function m(e,t){const n=function(e,t,n){let s="";if(n)for(const e of Object.entries(n)){if(!e)continue;let t="";for(const n of e[1])t+=`[${n.type}${n.name?`:${n.name}`:""}]`;s+=`(${e[0]}{${t}})`}return t?`${t}:${e}${s}`:e}(e,t?.type,t?.structs);if(c.has(n))return c.get(n);const a=s.wj.test(e),o=(0,s.Yv)(a?h:f,e);if(!o)throw new r.dV({param:e});if(o.name&&function(e){return"address"===e||"bool"===e||"function"===e||"string"===e||"tuple"===e||s.BD.test(e)||s.Ge.test(e)||b.test(e)}(o.name))throw new r.zd({param:e,name:o.name});const l=o.name?{name:o.name}:{},u="indexed"===o.modifier?{indexed:!0}:{},y=t?.structs??{};let A,w={};if(a){A="tuple";const e=g(o.type),t=[],n=e.length;for(let s=0;s<n;s++)t.push(m(e[s],{structs:y}));w={components:t}}else if(o.type in y)A="tuple",w={components:y[o.type]};else if(p.test(o.type))A=`${o.type}256`;else if(A=o.type,"struct"!==t?.type&&!_(A))throw new i.UG({type:A});if(o.modifier){if(!t?.modifiers?.has?.(o.modifier))throw new r.NO({param:e,type:t?.type,modifier:o.modifier});if(d.v7.has(o.modifier)&&!function(e,t){return t||"bytes"===e||"string"===e||"tuple"===e}(A,!!o.array))throw new r.Pj({param:e,type:t?.type,modifier:o.modifier})}const x={type:`${A}${o.array??""}`,...l,...u,...w};return c.set(n,x),x}function g(e,t=[],n="",s=0){const i=e.trim().length;for(let r=0;r<i;r++){const i=e[r],a=e.slice(r+1);switch(i){case",":return 0===s?g(a,[...t,n.trim()]):g(a,t,`${n}${i}`,s);case"(":return g(a,t,`${n}${i}`,s+1);case")":return g(a,t,`${n}${i}`,s-1);default:return g(a,t,`${n}${i}`,s)}}if(""===n)return t;if(0!==s)throw new l({current:n,depth:s});return t.push(n.trim()),t}function _(e){return"address"===e||"bool"===e||"function"===e||"string"===e||s.BD.test(e)||s.Ge.test(e)}const b=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/},8537:(e,t,n)=>{function s(e,t){const n=e.exec(t);return n?.groups}n.d(t,{BD:()=>i,Ge:()=>r,Yv:()=>s,wj:()=>a});const i=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,r=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,a=/^\(.+?\).*?$/}},s={};function i(e){var t=s[e];if(void 0!==t)return t.exports;var r=s[e]={id:e,loaded:!1,exports:{}};return n[e](r,r.exports,i),r.loaded=!0,r.exports}t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,i.t=function(n,s){if(1&s&&(n=this(n)),8&s)return n;if("object"==typeof n&&n){if(4&s&&n.__esModule)return n;if(16&s&&"function"==typeof n.then)return n}var r=Object.create(null);i.r(r);var a={};e=e||[null,t({}),t([]),t(t)];for(var o=2&s&&n;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>a[e]=()=>n[e]));return a.default=()=>n,i.d(r,a),r},i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var r={};(()=>{i.d(r,{wC:()=>Gc,hp:()=>gh.Buffer,QM:()=>Zh,NZ:()=>Ay,pF:()=>yy,Fr:()=>si,cY:()=>lA,_5:()=>aA,b$:()=>oA,dP:()=>iy,dB:()=>zb,cg:()=>ky,RQ:()=>cA,BJ:()=>tA,ZI:()=>rA});var e={};i.r(e),i.d(e,{DO:()=>Sl,OG:()=>Xl,My:()=>Pl,bytesToNumberBE:()=>Hl,lX:()=>Ul,Id:()=>Jl,fg:()=>ql,qj:()=>Zl,hexToBytes:()=>jl,aY:()=>Tl,lq:()=>Rl,z:()=>Gl,Q5:()=>$l});var t,n,s={742:(e,t)=>{t.byteLength=function(e){var t=o(e),n=t[0],s=t[1];return 3*(n+s)/4-s},t.toByteArray=function(e){var t,n,r=o(e),a=r[0],l=r[1],c=new i(function(e,t,n){return 3*(t+n)/4-n}(0,a,l)),d=0,u=l>0?a-4:a;for(n=0;n<u;n+=4)t=s[e.charCodeAt(n)]<<18|s[e.charCodeAt(n+1)]<<12|s[e.charCodeAt(n+2)]<<6|s[e.charCodeAt(n+3)],c[d++]=t>>16&255,c[d++]=t>>8&255,c[d++]=255&t;return 2===l&&(t=s[e.charCodeAt(n)]<<2|s[e.charCodeAt(n+1)]>>4,c[d++]=255&t),1===l&&(t=s[e.charCodeAt(n)]<<10|s[e.charCodeAt(n+1)]<<4|s[e.charCodeAt(n+2)]>>2,c[d++]=t>>8&255,c[d++]=255&t),c},t.fromByteArray=function(e){for(var t,s=e.length,i=s%3,r=[],a=16383,o=0,c=s-i;o<c;o+=a)r.push(l(e,o,o+a>c?c:o+a));return 1===i?(t=e[s-1],r.push(n[t>>2]+n[t<<4&63]+"==")):2===i&&(t=(e[s-2]<<8)+e[s-1],r.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"=")),r.join("")};for(var n=[],s=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0;a<64;++a)n[a]=r[a],s[r.charCodeAt(a)]=a;function o(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function l(e,t,s){for(var i,r,a=[],o=t;o<s;o+=3)i=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),a.push(n[(r=i)>>18&63]+n[r>>12&63]+n[r>>6&63]+n[63&r]);return a.join("")}s["-".charCodeAt(0)]=62,s["_".charCodeAt(0)]=63},764:(e,t,n)=>{const s=n(742),i=n(645),r="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.lW=l,t.h2=50;const a=2147483647;function o(e){if(e>a)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,l.prototype),t}function l(e,t,n){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return u(e)}return c(e,t,n)}function c(e,t,n){if("string"==typeof e)return function(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!l.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const n=0|m(e,t);let s=o(n);const i=s.write(e,t);return i!==n&&(s=s.slice(0,i)),s}(e,t);if(ArrayBuffer.isView(e))return function(e){if(W(e,Uint8Array)){const t=new Uint8Array(e);return h(t.buffer,t.byteOffset,t.byteLength)}return f(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(W(e,ArrayBuffer)||e&&W(e.buffer,ArrayBuffer))return h(e,t,n);if("undefined"!=typeof SharedArrayBuffer&&(W(e,SharedArrayBuffer)||e&&W(e.buffer,SharedArrayBuffer)))return h(e,t,n);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const s=e.valueOf&&e.valueOf();if(null!=s&&s!==e)return l.from(s,t,n);const i=function(e){if(l.isBuffer(e)){const t=0|p(e.length),n=o(t);return 0===n.length||e.copy(n,0,0,t),n}return void 0!==e.length?"number"!=typeof e.length||V(e.length)?o(0):f(e):"Buffer"===e.type&&Array.isArray(e.data)?f(e.data):void 0}(e);if(i)return i;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return l.from(e[Symbol.toPrimitive]("string"),t,n);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function d(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function u(e){return d(e),o(e<0?0:0|p(e))}function f(e){const t=e.length<0?0:0|p(e.length),n=o(t);for(let s=0;s<t;s+=1)n[s]=255&e[s];return n}function h(e,t,n){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(n||0))throw new RangeError('"length" is outside of buffer bounds');let s;return s=void 0===t&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,t):new Uint8Array(e,t,n),Object.setPrototypeOf(s,l.prototype),s}function p(e){if(e>=a)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+a.toString(16)+" bytes");return 0|e}function m(e,t){if(l.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||W(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const n=e.length,s=arguments.length>2&&!0===arguments[2];if(!s&&0===n)return 0;let i=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":return Z(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return J(e).length;default:if(i)return s?-1:Z(e).length;t=(""+t).toLowerCase(),i=!0}}function g(e,t,n){let s=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return C(this,t,n);case"utf8":case"utf-8":return z(this,t,n);case"ascii":return F(this,t,n);case"latin1":case"binary":return k(this,t,n);case"base64":return M(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,t,n);default:if(s)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),s=!0}}function _(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function b(e,t,n,s,i){if(0===e.length)return-1;if("string"==typeof n?(s=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),V(n=+n)&&(n=i?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(i)return-1;n=e.length-1}else if(n<0){if(!i)return-1;n=0}if("string"==typeof t&&(t=l.from(t,s)),l.isBuffer(t))return 0===t.length?-1:y(e,t,n,s,i);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,s,i);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,s,i){let r,a=1,o=e.length,l=t.length;if(void 0!==s&&("ucs2"===(s=String(s).toLowerCase())||"ucs-2"===s||"utf16le"===s||"utf-16le"===s)){if(e.length<2||t.length<2)return-1;a=2,o/=2,l/=2,n/=2}function c(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}if(i){let s=-1;for(r=n;r<o;r++)if(c(e,r)===c(t,-1===s?0:r-s)){if(-1===s&&(s=r),r-s+1===l)return s*a}else-1!==s&&(r-=r-s),s=-1}else for(n+l>o&&(n=o-l),r=n;r>=0;r--){let n=!0;for(let s=0;s<l;s++)if(c(e,r+s)!==c(t,s)){n=!1;break}if(n)return r}return-1}function A(e,t,n,s){n=Number(n)||0;const i=e.length-n;s?(s=Number(s))>i&&(s=i):s=i;const r=t.length;let a;for(s>r/2&&(s=r/2),a=0;a<s;++a){const s=parseInt(t.substr(2*a,2),16);if(V(s))return a;e[n+a]=s}return a}function w(e,t,n,s){return X(Z(t,e.length-n),e,n,s)}function x(e,t,n,s){return X(function(e){const t=[];for(let n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,s)}function v(e,t,n,s){return X(J(t),e,n,s)}function E(e,t,n,s){return X(function(e,t){let n,s,i;const r=[];for(let a=0;a<e.length&&!((t-=2)<0);++a)n=e.charCodeAt(a),s=n>>8,i=n%256,r.push(i),r.push(s);return r}(t,e.length-n),e,n,s)}function M(e,t,n){return 0===t&&n===e.length?s.fromByteArray(e):s.fromByteArray(e.slice(t,n))}function z(e,t,n){n=Math.min(e.length,n);const s=[];let i=t;for(;i<n;){const t=e[i];let r=null,a=t>239?4:t>223?3:t>191?2:1;if(i+a<=n){let n,s,o,l;switch(a){case 1:t<128&&(r=t);break;case 2:n=e[i+1],128==(192&n)&&(l=(31&t)<<6|63&n,l>127&&(r=l));break;case 3:n=e[i+1],s=e[i+2],128==(192&n)&&128==(192&s)&&(l=(15&t)<<12|(63&n)<<6|63&s,l>2047&&(l<55296||l>57343)&&(r=l));break;case 4:n=e[i+1],s=e[i+2],o=e[i+3],128==(192&n)&&128==(192&s)&&128==(192&o)&&(l=(15&t)<<18|(63&n)<<12|(63&s)<<6|63&o,l>65535&&l<1114112&&(r=l))}}null===r?(r=65533,a=1):r>65535&&(r-=65536,s.push(r>>>10&1023|55296),r=56320|1023&r),s.push(r),i+=a}return function(e){const t=e.length;if(t<=B)return String.fromCharCode.apply(String,e);let n="",s=0;for(;s<t;)n+=String.fromCharCode.apply(String,e.slice(s,s+=B));return n}(s)}l.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),l.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.byteOffset}}),l.poolSize=8192,l.from=function(e,t,n){return c(e,t,n)},Object.setPrototypeOf(l.prototype,Uint8Array.prototype),Object.setPrototypeOf(l,Uint8Array),l.alloc=function(e,t,n){return function(e,t,n){return d(e),e<=0?o(e):void 0!==t?"string"==typeof n?o(e).fill(t,n):o(e).fill(t):o(e)}(e,t,n)},l.allocUnsafe=function(e){return u(e)},l.allocUnsafeSlow=function(e){return u(e)},l.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==l.prototype},l.compare=function(e,t){if(W(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),W(t,Uint8Array)&&(t=l.from(t,t.offset,t.byteLength)),!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let n=e.length,s=t.length;for(let i=0,r=Math.min(n,s);i<r;++i)if(e[i]!==t[i]){n=e[i],s=t[i];break}return n<s?-1:s<n?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);let n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;const s=l.allocUnsafe(t);let i=0;for(n=0;n<e.length;++n){let t=e[n];if(W(t,Uint8Array))i+t.length>s.length?(l.isBuffer(t)||(t=l.from(t)),t.copy(s,i)):Uint8Array.prototype.set.call(s,t,i);else{if(!l.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(s,i)}i+=t.length}return s},l.byteLength=m,l.prototype._isBuffer=!0,l.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)_(this,t,t+1);return this},l.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)_(this,t,t+3),_(this,t+1,t+2);return this},l.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)_(this,t,t+7),_(this,t+1,t+6),_(this,t+2,t+5),_(this,t+3,t+4);return this},l.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?z(this,0,e):g.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){let e="";const n=t.h2;return e=this.toString("hex",0,n).replace(/(.{2})/g,"$1 ").trim(),this.length>n&&(e+=" ... "),"<Buffer "+e+">"},r&&(l.prototype[r]=l.prototype.inspect),l.prototype.compare=function(e,t,n,s,i){if(W(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),!l.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===s&&(s=0),void 0===i&&(i=this.length),t<0||n>e.length||s<0||i>this.length)throw new RangeError("out of range index");if(s>=i&&t>=n)return 0;if(s>=i)return-1;if(t>=n)return 1;if(this===e)return 0;let r=(i>>>=0)-(s>>>=0),a=(n>>>=0)-(t>>>=0);const o=Math.min(r,a),c=this.slice(s,i),d=e.slice(t,n);for(let e=0;e<o;++e)if(c[e]!==d[e]){r=c[e],a=d[e];break}return r<a?-1:a<r?1:0},l.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},l.prototype.indexOf=function(e,t,n){return b(this,e,t,n,!0)},l.prototype.lastIndexOf=function(e,t,n){return b(this,e,t,n,!1)},l.prototype.write=function(e,t,n,s){if(void 0===t)s="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)s=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(n)?(n>>>=0,void 0===s&&(s="utf8")):(s=n,n=void 0)}const i=this.length-t;if((void 0===n||n>i)&&(n=i),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");s||(s="utf8");let r=!1;for(;;)switch(s){case"hex":return A(this,e,t,n);case"utf8":case"utf-8":return w(this,e,t,n);case"ascii":case"latin1":case"binary":return x(this,e,t,n);case"base64":return v(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,e,t,n);default:if(r)throw new TypeError("Unknown encoding: "+s);s=(""+s).toLowerCase(),r=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const B=4096;function F(e,t,n){let s="";n=Math.min(e.length,n);for(let i=t;i<n;++i)s+=String.fromCharCode(127&e[i]);return s}function k(e,t,n){let s="";n=Math.min(e.length,n);for(let i=t;i<n;++i)s+=String.fromCharCode(e[i]);return s}function C(e,t,n){const s=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>s)&&(n=s);let i="";for(let s=t;s<n;++s)i+=q[e[s]];return i}function O(e,t,n){const s=e.slice(t,n);let i="";for(let e=0;e<s.length-1;e+=2)i+=String.fromCharCode(s[e]+256*s[e+1]);return i}function D(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function L(e,t,n,s,i,r){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<r)throw new RangeError('"value" argument is out of bounds');if(n+s>e.length)throw new RangeError("Index out of range")}function T(e,t,n,s,i){H(t,s,i,e,n,7);let r=Number(t&BigInt(4294967295));e[n++]=r,r>>=8,e[n++]=r,r>>=8,e[n++]=r,r>>=8,e[n++]=r;let a=Number(t>>BigInt(32)&BigInt(4294967295));return e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a,n}function S(e,t,n,s,i){H(t,s,i,e,n,7);let r=Number(t&BigInt(4294967295));e[n+7]=r,r>>=8,e[n+6]=r,r>>=8,e[n+5]=r,r>>=8,e[n+4]=r;let a=Number(t>>BigInt(32)&BigInt(4294967295));return e[n+3]=a,a>>=8,e[n+2]=a,a>>=8,e[n+1]=a,a>>=8,e[n]=a,n+8}function N(e,t,n,s,i,r){if(n+s>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function P(e,t,n,s,r){return t=+t,n>>>=0,r||N(e,0,n,4),i.write(e,t,n,s,23,4),n+4}function I(e,t,n,s,r){return t=+t,n>>>=0,r||N(e,0,n,8),i.write(e,t,n,s,52,8),n+8}l.prototype.slice=function(e,t){const n=this.length;(e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e);const s=this.subarray(e,t);return Object.setPrototypeOf(s,l.prototype),s},l.prototype.readUintLE=l.prototype.readUIntLE=function(e,t,n){e>>>=0,t>>>=0,n||D(e,t,this.length);let s=this[e],i=1,r=0;for(;++r<t&&(i*=256);)s+=this[e+r]*i;return s},l.prototype.readUintBE=l.prototype.readUIntBE=function(e,t,n){e>>>=0,t>>>=0,n||D(e,t,this.length);let s=this[e+--t],i=1;for(;t>0&&(i*=256);)s+=this[e+--t]*i;return s},l.prototype.readUint8=l.prototype.readUInt8=function(e,t){return e>>>=0,t||D(e,1,this.length),this[e]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(e,t){return e>>>=0,t||D(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(e,t){return e>>>=0,t||D(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(e,t){return e>>>=0,t||D(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(e,t){return e>>>=0,t||D(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readBigUInt64LE=K((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||R(e,this.length-8);const s=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,i=this[++e]+256*this[++e]+65536*this[++e]+n*2**24;return BigInt(s)+(BigInt(i)<<BigInt(32))})),l.prototype.readBigUInt64BE=K((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||R(e,this.length-8);const s=t*2**24+65536*this[++e]+256*this[++e]+this[++e],i=this[++e]*2**24+65536*this[++e]+256*this[++e]+n;return(BigInt(s)<<BigInt(32))+BigInt(i)})),l.prototype.readIntLE=function(e,t,n){e>>>=0,t>>>=0,n||D(e,t,this.length);let s=this[e],i=1,r=0;for(;++r<t&&(i*=256);)s+=this[e+r]*i;return i*=128,s>=i&&(s-=Math.pow(2,8*t)),s},l.prototype.readIntBE=function(e,t,n){e>>>=0,t>>>=0,n||D(e,t,this.length);let s=t,i=1,r=this[e+--s];for(;s>0&&(i*=256);)r+=this[e+--s]*i;return i*=128,r>=i&&(r-=Math.pow(2,8*t)),r},l.prototype.readInt8=function(e,t){return e>>>=0,t||D(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){e>>>=0,t||D(e,2,this.length);const n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt16BE=function(e,t){e>>>=0,t||D(e,2,this.length);const n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt32LE=function(e,t){return e>>>=0,t||D(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return e>>>=0,t||D(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readBigInt64LE=K((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||R(e,this.length-8);const s=this[e+4]+256*this[e+5]+65536*this[e+6]+(n<<24);return(BigInt(s)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),l.prototype.readBigInt64BE=K((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||R(e,this.length-8);const s=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(s)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+n)})),l.prototype.readFloatLE=function(e,t){return e>>>=0,t||D(e,4,this.length),i.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return e>>>=0,t||D(e,4,this.length),i.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return e>>>=0,t||D(e,8,this.length),i.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return e>>>=0,t||D(e,8,this.length),i.read(this,e,!1,52,8)},l.prototype.writeUintLE=l.prototype.writeUIntLE=function(e,t,n,s){e=+e,t>>>=0,n>>>=0,s||L(this,e,t,n,Math.pow(2,8*n)-1,0);let i=1,r=0;for(this[t]=255&e;++r<n&&(i*=256);)this[t+r]=e/i&255;return t+n},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(e,t,n,s){e=+e,t>>>=0,n>>>=0,s||L(this,e,t,n,Math.pow(2,8*n)-1,0);let i=n-1,r=1;for(this[t+i]=255&e;--i>=0&&(r*=256);)this[t+i]=e/r&255;return t+n},l.prototype.writeUint8=l.prototype.writeUInt8=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,1,255,0),this[t]=255&e,t+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigUInt64LE=K((function(e,t=0){return T(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeBigUInt64BE=K((function(e,t=0){return S(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeIntLE=function(e,t,n,s){if(e=+e,t>>>=0,!s){const s=Math.pow(2,8*n-1);L(this,e,t,n,s-1,-s)}let i=0,r=1,a=0;for(this[t]=255&e;++i<n&&(r*=256);)e<0&&0===a&&0!==this[t+i-1]&&(a=1),this[t+i]=(e/r|0)-a&255;return t+n},l.prototype.writeIntBE=function(e,t,n,s){if(e=+e,t>>>=0,!s){const s=Math.pow(2,8*n-1);L(this,e,t,n,s-1,-s)}let i=n-1,r=1,a=0;for(this[t+i]=255&e;--i>=0&&(r*=256);)e<0&&0===a&&0!==this[t+i+1]&&(a=1),this[t+i]=(e/r|0)-a&255;return t+n},l.prototype.writeInt8=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeInt16BE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeInt32LE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},l.prototype.writeInt32BE=function(e,t,n){return e=+e,t>>>=0,n||L(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigInt64LE=K((function(e,t=0){return T(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeBigInt64BE=K((function(e,t=0){return S(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeFloatLE=function(e,t,n){return P(this,e,t,!0,n)},l.prototype.writeFloatBE=function(e,t,n){return P(this,e,t,!1,n)},l.prototype.writeDoubleLE=function(e,t,n){return I(this,e,t,!0,n)},l.prototype.writeDoubleBE=function(e,t,n){return I(this,e,t,!1,n)},l.prototype.copy=function(e,t,n,s){if(!l.isBuffer(e))throw new TypeError("argument should be a Buffer");if(n||(n=0),s||0===s||(s=this.length),t>=e.length&&(t=e.length),t||(t=0),s>0&&s<n&&(s=n),s===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("Index out of range");if(s<0)throw new RangeError("sourceEnd out of bounds");s>this.length&&(s=this.length),e.length-t<s-n&&(s=e.length-t+n);const i=s-n;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,n,s):Uint8Array.prototype.set.call(e,this.subarray(n,s),t),i},l.prototype.fill=function(e,t,n,s){if("string"==typeof e){if("string"==typeof t?(s=t,t=0,n=this.length):"string"==typeof n&&(s=n,n=this.length),void 0!==s&&"string"!=typeof s)throw new TypeError("encoding must be a string");if("string"==typeof s&&!l.isEncoding(s))throw new TypeError("Unknown encoding: "+s);if(1===e.length){const t=e.charCodeAt(0);("utf8"===s&&t<128||"latin1"===s)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;let i;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(i=t;i<n;++i)this[i]=e;else{const r=l.isBuffer(e)?e:l.from(e,s),a=r.length;if(0===a)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(i=0;i<n-t;++i)this[i+t]=r[i%a]}return this};const Y={};function Q(e,t,n){Y[e]=class extends n{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function j(e){let t="",n=e.length;const s="-"===e[0]?1:0;for(;n>=s+4;n-=3)t=`_${e.slice(n-3,n)}${t}`;return`${e.slice(0,n)}${t}`}function H(e,t,n,s,i,r){if(e>n||e<t){const s="bigint"==typeof t?"n":"";let i;throw i=r>3?0===t||t===BigInt(0)?`>= 0${s} and < 2${s} ** ${8*(r+1)}${s}`:`>= -(2${s} ** ${8*(r+1)-1}${s}) and < 2 ** ${8*(r+1)-1}${s}`:`>= ${t}${s} and <= ${n}${s}`,new Y.ERR_OUT_OF_RANGE("value",i,e)}!function(e,t,n){U(t,"offset"),void 0!==e[t]&&void 0!==e[t+n]||R(t,e.length-(n+1))}(s,i,r)}function U(e,t){if("number"!=typeof e)throw new Y.ERR_INVALID_ARG_TYPE(t,"number",e)}function R(e,t,n){if(Math.floor(e)!==e)throw U(e,n),new Y.ERR_OUT_OF_RANGE(n||"offset","an integer",e);if(t<0)throw new Y.ERR_BUFFER_OUT_OF_BOUNDS;throw new Y.ERR_OUT_OF_RANGE(n||"offset",`>= ${n?1:0} and <= ${t}`,e)}Q("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),Q("ERR_INVALID_ARG_TYPE",(function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`}),TypeError),Q("ERR_OUT_OF_RANGE",(function(e,t,n){let s=`The value of "${e}" is out of range.`,i=n;return Number.isInteger(n)&&Math.abs(n)>2**32?i=j(String(n)):"bigint"==typeof n&&(i=String(n),(n>BigInt(2)**BigInt(32)||n<-(BigInt(2)**BigInt(32)))&&(i=j(i)),i+="n"),s+=` It must be ${t}. Received ${i}`,s}),RangeError);const G=/[^+/0-9A-Za-z-_]/g;function Z(e,t){let n;t=t||1/0;const s=e.length;let i=null;const r=[];for(let a=0;a<s;++a){if(n=e.charCodeAt(a),n>55295&&n<57344){if(!i){if(n>56319){(t-=3)>-1&&r.push(239,191,189);continue}if(a+1===s){(t-=3)>-1&&r.push(239,191,189);continue}i=n;continue}if(n<56320){(t-=3)>-1&&r.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320)}else i&&(t-=3)>-1&&r.push(239,191,189);if(i=null,n<128){if((t-=1)<0)break;r.push(n)}else if(n<2048){if((t-=2)<0)break;r.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;r.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;r.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return r}function J(e){return s.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(G,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function X(e,t,n,s){let i;for(i=0;i<s&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}function W(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function V(e){return e!=e}const q=function(){const e="0123456789abcdef",t=new Array(256);for(let n=0;n<16;++n){const s=16*n;for(let i=0;i<16;++i)t[s+i]=e[n]+e[i]}return t}();function K(e){return"undefined"==typeof BigInt?$:e}function $(){throw new Error("BigInt not supported")}},227:(e,t,n)=>{t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const n="color: "+this.color;t.splice(1,0,n,"color: inherit");let s=0,i=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(s++,"%c"===e&&(i=s))})),t.splice(i,0,n)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=function(){let e;try{e=t.storage.getItem("debug")}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e={NODE_ENV:"production"}.DEBUG),e},t.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=n(447)(t);const{formatters:s}=e.exports;s.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},447:(e,t,n)=>{e.exports=function(e){function t(e){let n,i,r,a=null;function o(...e){if(!o.enabled)return;const s=o,i=Number(new Date),r=i-(n||i);s.diff=r,s.prev=n,s.curr=i,n=i,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let a=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((n,i)=>{if("%%"===n)return"%";a++;const r=t.formatters[i];if("function"==typeof r){const t=e[a];n=r.call(s,t),e.splice(a,1),a--}return n})),t.formatArgs.call(s,e),(s.log||t.log).apply(s,e)}return o.namespace=e,o.useColors=t.useColors(),o.color=t.selectColor(e),o.extend=s,o.destroy=t.destroy,Object.defineProperty(o,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==a?a:(i!==t.namespaces&&(i=t.namespaces,r=t.enabled(e)),r),set:e=>{a=e}}),"function"==typeof t.init&&t.init(o),o}function s(e,n){const s=t(this.namespace+(void 0===n?":":n)+e);return s.log=this.log,s}function i(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){return e instanceof Error?e.stack||e.message:e},t.disable=function(){const e=[...t.names.map(i),...t.skips.map(i).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let n;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const s=("string"==typeof e?e:"").split(/[\s,]+/),i=s.length;for(n=0;n<i;n++)s[n]&&("-"===(e=s[n].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.slice(1)+"$")):t.names.push(new RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let n,s;for(n=0,s=t.skips.length;n<s;n++)if(t.skips[n].test(e))return!1;for(n=0,s=t.names.length;n<s;n++)if(t.names[n].test(e))return!0;return!1},t.humanize=n(824),t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((n=>{t[n]=e[n]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return t.colors[Math.abs(n)%t.colors.length]},t.enable(t.load()),t}},645:(e,t)=>{t.read=function(e,t,n,s,i){var r,a,o=8*i-s-1,l=(1<<o)-1,c=l>>1,d=-7,u=n?i-1:0,f=n?-1:1,h=e[t+u];for(u+=f,r=h&(1<<-d)-1,h>>=-d,d+=o;d>0;r=256*r+e[t+u],u+=f,d-=8);for(a=r&(1<<-d)-1,r>>=-d,d+=s;d>0;a=256*a+e[t+u],u+=f,d-=8);if(0===r)r=1-c;else{if(r===l)return a?NaN:1/0*(h?-1:1);a+=Math.pow(2,s),r-=c}return(h?-1:1)*a*Math.pow(2,r-s)},t.write=function(e,t,n,s,i,r){var a,o,l,c=8*r-i-1,d=(1<<c)-1,u=d>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,h=s?0:r-1,p=s?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,a=d):(a=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-a))<1&&(a--,l*=2),(t+=a+u>=1?f/l:f*Math.pow(2,1-u))*l>=2&&(a++,l/=2),a+u>=d?(o=0,a=d):a+u>=1?(o=(t*l-1)*Math.pow(2,i),a+=u):(o=t*Math.pow(2,u-1)*Math.pow(2,i),a=0));i>=8;e[n+h]=255&o,h+=p,o/=256,i-=8);for(a=a<<i|o,c+=i;c>0;e[n+h]=255&a,h+=p,a/=256,c-=8);e[n+h-p]|=128*m}},824:e=>{var t=1e3,n=60*t,s=60*n,i=24*s,r=7*i;function a(e,t,n,s){var i=t>=1.5*n;return Math.round(e/n)+" "+s+(i?"s":"")}e.exports=function(e,o){o=o||{};var l,c,d=typeof e;if("string"===d&&e.length>0)return function(e){if(!((e=String(e)).length>100)){var a=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(a){var o=parseFloat(a[1]);switch((a[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*o;case"weeks":case"week":case"w":return o*r;case"days":case"day":case"d":return o*i;case"hours":case"hour":case"hrs":case"hr":case"h":return o*s;case"minutes":case"minute":case"mins":case"min":case"m":return o*n;case"seconds":case"second":case"secs":case"sec":case"s":return o*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return o;default:return}}}}(e);if("number"===d&&isFinite(e))return o.long?(l=e,(c=Math.abs(l))>=i?a(l,c,i,"day"):c>=s?a(l,c,s,"hour"):c>=n?a(l,c,n,"minute"):c>=t?a(l,c,t,"second"):l+" ms"):function(e){var r=Math.abs(e);return r>=i?Math.round(e/i)+"d":r>=s?Math.round(e/s)+"h":r>=n?Math.round(e/n)+"m":r>=t?Math.round(e/t)+"s":e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},477:e=>{e.exports=function(e,t,n,s){var i=self||window;try{try{var r;try{r=new i.Blob([e])}catch(t){(r=new(i.BlobBuilder||i.WebKitBlobBuilder||i.MozBlobBuilder||i.MSBlobBuilder)).append(e),r=r.getBlob()}var a=i.URL||i.webkitURL,o=a.createObjectURL(r),l=new i[t](o,n);return a.revokeObjectURL(o),l}catch(s){return new i[t]("data:application/javascript,".concat(encodeURIComponent(e)),n)}}catch(e){if(!s)throw Error("Inline worker is not supported");return new i[t](s,n)}}}},a={};function o(e){var t=a[e];if(void 0!==t)return t.exports;var n=a[e]={exports:{}};return s[e](n,n.exports,o),n.exports}o.m=s,o.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return o.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;o.t=function(n,s){if(1&s&&(n=this(n)),8&s)return n;if("object"==typeof n&&n){if(4&s&&n.__esModule)return n;if(16&s&&"function"==typeof n.then)return n}var i=Object.create(null);o.r(i);var r={};e=e||[null,t({}),t([]),t(t)];for(var a=2&s&&n;"object"==typeof a&&!~e.indexOf(a);a=t(a))Object.getOwnPropertyNames(a).forEach((e=>r[e]=()=>n[e]));return r.default=()=>n,o.d(i,r),i}})(),o.d=(e,t)=>{for(var n in t)o.o(t,n)&&!o.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o.f={},o.e=e=>Promise.all(Object.keys(o.f).reduce(((t,n)=>(o.f[n](e,t),t)),[])),o.u=e=>e+".index.js",o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),t={},n="@aztec/bb.js:",o.l=(e,s,i,r)=>{if(t[e])t[e].push(s);else{var a,l;if(void 0!==i)for(var c=document.getElementsByTagName("script"),d=0;d<c.length;d++){var u=c[d];if(u.getAttribute("src")==e||u.getAttribute("data-webpack")==n+i){a=u;break}}a||(l=!0,(a=document.createElement("script")).type="module",a.charset="utf-8",a.timeout=120,o.nc&&a.setAttribute("nonce",o.nc),a.setAttribute("data-webpack",n+i),a.src=e),t[e]=[s];var f=(n,s)=>{a.onerror=a.onload=null,clearTimeout(h);var i=t[e];if(delete t[e],a.parentNode&&a.parentNode.removeChild(a),i&&i.forEach((e=>e(s))),n)return n(s)},h=setTimeout(f.bind(null,void 0,{type:"timeout",target:a}),12e4);a.onerror=f.bind(null,a.onerror),a.onload=f.bind(null,a.onload),l&&document.head.appendChild(a)}},o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;if(!(e="file:///mnt/user-data/sean/docs/aztec-spare/barretenberg/ts/dest/browser/index.js"))throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),o.p=e})(),(()=>{var e={179:0};o.f.j=(t,n)=>{var s=o.o(e,t)?e[t]:void 0;if(0!==s)if(s)n.push(s[2]);else{var i=new Promise(((n,i)=>s=e[t]=[n,i]));n.push(s[2]=i);var r=o.p+o.u(t),a=new Error;o.l(r,(n=>{if(o.o(e,t)&&(0!==(s=e[t])&&(e[t]=void 0),s)){var i=n&&("load"===n.type?"missing":n.type),r=n&&n.target&&n.target.src;a.message="Loading chunk "+t+" failed.\n("+i+": "+r+")",a.name="ChunkLoadError",a.type=i,a.request=r,s[1](a)}}),"chunk-"+t,t)}};var t=(t,n)=>{var s,i,[r,a,l]=n,c=0;if(r.some((t=>0!==e[t]))){for(s in a)o.o(a,s)&&(o.m[s]=a[s]);l&&l(o)}for(t&&t(n);c<r.length;c++)i=r[c],o.o(e,i)&&e[i]&&e[i][0](),e[i]=0},n=globalThis.webpackChunk_aztec_bb_js=globalThis.webpackChunk_aztec_bb_js||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})();var l={};(()=>{o.d(l,{Dv:()=>vi,Zh:()=>zi,AL:()=>ki,tD:()=>js,i2:()=>c,Fr:()=>q,pS:()=>d,ld:()=>D,yh:()=>xi,_7:()=>wi,H2:()=>Ss,ly:()=>Ts});class e{constructor(e){this.numPoints=e}async init(){await this.downloadG1Data(),await this.downloadG2Data()}async downloadG1Data(){if(0===this.numPoints)return this.data=new Uint8Array([]);const e=64*this.numPoints-1,t=await fetch("https://aztec-ignition.s3.amazonaws.com/MAIN%20IGNITION/flat/g1.dat",{headers:{Range:`bytes=0-${e}`},cache:"force-cache"});return this.data=new Uint8Array(await t.arrayBuffer())}async downloadG2Data(){const e=await fetch("https://aztec-ignition.s3.amazonaws.com/MAIN%20IGNITION/flat/g2.dat",{cache:"force-cache"});return this.g2Data=new Uint8Array(await e.arrayBuffer())}getG1Data(){return this.data}getG2Data(){return this.g2Data}}class t{constructor(e){this.numPoints=e}async init(){await this.downloadG1Data()}async downloadG1Data(){if(0===this.numPoints)return this.data=new Uint8Array([]);const e=64*this.numPoints-1,t=await fetch("https://aztec-ignition.s3.amazonaws.com/TEST%20GRUMPKIN/monomial/transcript00.dat",{headers:{Range:`bytes=28-${e}`},cache:"force-cache"});return this.data=new Uint8Array(await t.arrayBuffer())}getG1Data(){return this.data}}function n(e){return new Promise(((t,n)=>{e.oncomplete=e.onsuccess=()=>t(e.result),e.onabort=e.onerror=()=>n(e.error)}))}let s;function i(){return s||(s=function(e,t){const s=indexedDB.open("keyval-store");s.onupgradeneeded=()=>s.result.createObjectStore(t);const i=n(s);return(e,n)=>i.then((s=>n(s.transaction(t,e).objectStore(t))))}(0,"keyval")),s}function r(e,t=i()){return t("readonly",(t=>n(t.get(e))))}function a(e,t,s=i()){return s("readwrite",(s=>(s.put(t,e),n(s.transaction))))}class c{constructor(e){this.numPoints=e}static async new(e){const t=new c(e);return await t.init(),t}async init(){const t=await r("g1Data"),n=await r("g2Data"),s=new e(this.numPoints),i=64*this.numPoints;!t||t.length<i?(this.g1Data=await s.downloadG1Data(),await a("g1Data",this.g1Data)):this.g1Data=t,n?this.g2Data=n:(this.g2Data=await s.downloadG2Data(),await a("g2Data",this.g2Data))}getG1Data(){return this.g1Data}getG2Data(){return this.g2Data}}class d{constructor(e){this.numPoints=e}static async new(e){const t=new d(e);return await t.init(),t}async init(){const e=await r("grumpkinG1Data"),n=new t(this.numPoints),s=64*this.numPoints;!e||e.length<s?(this.g1Data=await n.downloadG1Data(),await a("grumpkinG1Data",this.g1Data)):this.g1Data=e}getG1Data(){return this.g1Data}}const u=Symbol("Comlink.proxy"),f=Symbol("Comlink.endpoint"),h=Symbol("Comlink.releaseProxy"),p=Symbol("Comlink.finalizer"),m=Symbol("Comlink.thrown"),g=e=>"object"==typeof e&&null!==e||"function"==typeof e,_=new Map([["proxy",{canHandle:e=>g(e)&&e[u],serialize(e){const{port1:t,port2:n}=new MessageChannel;return b(e,t),[n,[n]]},deserialize:e=>(e.start(),A(e))}],["throw",{canHandle:e=>g(e)&&m in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function b(e,t=globalThis,n=["*"]){t.addEventListener("message",(function s(i){if(!i||!i.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,i.origin))return void console.warn(`Invalid origin '${i.origin}' for comlink proxy`);const{id:r,type:a,path:o}=Object.assign({path:[]},i.data),l=(i.data.argumentList||[]).map(C);let c;try{const t=o.slice(0,-1).reduce(((e,t)=>e[t]),e),n=o.reduce(((e,t)=>e[t]),e);switch(a){case"GET":c=n;break;case"SET":t[o.slice(-1)[0]]=C(i.data.value),c=!0;break;case"APPLY":c=n.apply(t,l);break;case"CONSTRUCT":c=F(new n(...l));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;b(e,n),c=function(e,t){return B.set(e,t),e}(t,[t])}break;case"RELEASE":c=void 0;break;default:return}}catch(e){c={value:e,[m]:0}}Promise.resolve(c).catch((e=>({value:e,[m]:0}))).then((n=>{const[i,o]=k(n);t.postMessage(Object.assign(Object.assign({},i),{id:r}),o),"RELEASE"===a&&(t.removeEventListener("message",s),y(t),p in e&&"function"==typeof e[p]&&e[p]())})).catch((e=>{const[n,s]=k({value:new TypeError("Unserializable return value"),[m]:0});t.postMessage(Object.assign(Object.assign({},n),{id:r}),s)}))})),t.start&&t.start()}function y(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function A(e,t){return M(e,[],t)}function w(e){if(e)throw new Error("Proxy has been released and is not useable")}function x(e){return O(e,{type:"RELEASE"}).then((()=>{y(e)}))}const v=new WeakMap,E="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(v.get(e)||0)-1;v.set(e,t),0===t&&x(e)}));function M(e,t=[],n=function(){}){let s=!1;const i=new Proxy(n,{get(n,r){if(w(s),r===h)return()=>{!function(e){E&&E.unregister(e)}(i),x(e),s=!0};if("then"===r){if(0===t.length)return{then:()=>i};const n=O(e,{type:"GET",path:t.map((e=>e.toString()))}).then(C);return n.then.bind(n)}return M(e,[...t,r])},set(n,i,r){w(s);const[a,o]=k(r);return O(e,{type:"SET",path:[...t,i].map((e=>e.toString())),value:a},o).then(C)},apply(n,i,r){w(s);const a=t[t.length-1];if(a===f)return O(e,{type:"ENDPOINT"}).then(C);if("bind"===a)return M(e,t.slice(0,-1));const[o,l]=z(r);return O(e,{type:"APPLY",path:t.map((e=>e.toString())),argumentList:o},l).then(C)},construct(n,i){w(s);const[r,a]=z(i);return O(e,{type:"CONSTRUCT",path:t.map((e=>e.toString())),argumentList:r},a).then(C)}});return function(e,t){const n=(v.get(t)||0)+1;v.set(t,n),E&&E.register(e,t,e)}(i,e),i}function z(e){const t=e.map(k);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const B=new WeakMap;function F(e){return Object.assign(e,{[u]:!0})}function k(e){for(const[t,n]of _)if(n.canHandle(e)){const[s,i]=n.serialize(e);return[{type:"HANDLER",name:t,value:s},i]}return[{type:"RAW",value:e},B.get(e)||[]]}function C(e){switch(e.type){case"HANDLER":return _.get(e.name).deserialize(e.value);case"RAW":return e.value}}function O(e,t,n){return new Promise((s=>{const i=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===i&&(e.removeEventListener("message",t),s(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:i},t),n)}))}class D extends Uint8Array{}function L(e,t=4){const n=new Uint8Array(t);return new DataView(n.buffer).setUint32(n.byteLength-4,e,!1),n}function T(e,t=4){const n=new Uint8Array(t);return new DataView(n.buffer).setInt32(n.byteLength-4,e,!1),n}function S(e){const t=e.reduce(((e,t)=>e+t.length),0),n=new Uint8Array(t);let s=0;for(const t of e)n.set(t,s),s+=t.length;return n}function N(e){return S([T(e.length),e])}function P(e){return Array.isArray(e)?S([L((t=e.map(P)).length),...t.flat()]):e instanceof D?e:e instanceof Uint8Array?N(e):"boolean"==typeof e?function(e){const t=new Uint8Array(1);return t[0]=e?1:0,t}(e):"number"==typeof e?L(e):"bigint"==typeof e?function(e,t=32){const n=new Uint8Array(t);for(let s=0;s<t;s++)n[t-s-1]=Number(e>>BigInt(8*s)&0xffn);return n}(e):"string"==typeof e?N((new TextEncoder).encode(e)):e.toBuffer();var t}class I{constructor(e,t=0){this.buffer=e,this.index=t}static asReader(e){return e instanceof I?e:new I(e)}readNumber(){const e=new DataView(this.buffer.buffer,this.buffer.byteOffset+this.index,4);return this.index+=4,e.getUint32(0,!1)}readBoolean(){return this.index+=1,Boolean(this.buffer.at(this.index-1))}readBytes(e){return this.index+=e,this.buffer.slice(this.index-e,this.index)}readNumberVector(){return this.readVector({fromBuffer:e=>e.readNumber()})}readVector(e){const t=this.readNumber(),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.fromBuffer(this);return n}readArray(e,t){const n=new Array(e);for(let s=0;s<e;s++)n[s]=t.fromBuffer(this);return n}readObject(e){return e.fromBuffer(this)}peekBytes(e){return this.buffer.subarray(this.index,e?this.index+e:void 0)}readString(){return(new TextDecoder).decode(this.readBuffer())}readBuffer(){const e=this.readNumber();return this.readBytes(e)}readMap(e){const t=this.readNumber(),n={};for(let s=0;s<t;s++){const t=this.readString(),s=this.readObject(e);n[t]=s}return n}}function Y(){return{SIZE_IN_BYTES:1,fromBuffer:e=>I.asReader(e).readBoolean()}}function Q(){return{SIZE_IN_BYTES:4,fromBuffer:e=>I.asReader(e).readNumber()}}function j(e){return{fromBuffer:t=>I.asReader(t).readVector(e)}}function H(){return{fromBuffer:e=>I.asReader(e).readBuffer()}}function U(){return{fromBuffer:e=>I.asReader(e).readString()}}class R{constructor(e){this.value=e}static fromBuffer(e){return new this(I.asReader(e).readBytes(this.SIZE_IN_BYTES))}toBuffer(){return this.value}}R.SIZE_IN_BYTES=4;const G=e=>{const t="undefined"!=typeof window&&window.crypto?window.crypto:"undefined"!=typeof globalThis&&globalThis.crypto?globalThis.crypto:void 0;if(!t)throw new Error("randomBytes UnsupportedEnvironment");const n=new Uint8Array(e),s=65536;if(e>s)for(let i=0;i<e;i+=s)t.getRandomValues(n.subarray(i,i+s));else t.getRandomValues(n);return n};function Z(e){e=new Uint8Array(e);let t=BigInt(0);const n=new DataView(e.buffer);for(let s=0;s<e.byteLength;s++)t=(t<<BigInt(8))+BigInt(n.getUint8(s));return t}function J(e,t=32){const n=new Uint8Array(t),s=new DataView(n.buffer);for(let n=0;n<t;n++)s.setUint8(t-n-1,Number(e&BigInt(255))),e>>=BigInt(8);return n}var X,W,V=o(764).lW;class q{constructor(e){const t="bigint"==typeof e?e:Z(e);if(t>X.MAX_VALUE)throw new Error(`Value 0x${t.toString(16)} is greater or equal to field modulus.`);this.value="bigint"==typeof e?J(e):e}static random(){return new this(Z(G(64))%X.MODULUS)}static fromBuffer(e){return new this(I.asReader(e).readBytes(this.SIZE_IN_BYTES))}static fromBufferReduce(e){return new this(Z(I.asReader(e).readBytes(this.SIZE_IN_BYTES))%X.MODULUS)}static fromString(e){return this.fromBuffer(V.from(e.replace(/^0x/i,""),"hex"))}toBuffer(){return this.value}toString(){return"0x"+this.toBuffer().reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}equals(e){return this.value.every(((t,n)=>t===e.value[n]))}isZero(){return this.value.every((e=>0===e))}}X=q,q.ZERO=new X(0n),q.MODULUS=0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001n,q.MAX_VALUE=X.MODULUS-1n,q.SIZE_IN_BYTES=32;class K{constructor(e){if(this.value=e,e>W.MAX_VALUE)throw new Error(`Fq out of range ${e}.`)}static random(){return new this(Z(G(64))%W.MODULUS)}static fromBuffer(e){return new this(Z(I.asReader(e).readBytes(this.SIZE_IN_BYTES)))}static fromBufferReduce(e){return new this(Z(I.asReader(e).readBytes(this.SIZE_IN_BYTES))%q.MODULUS)}static fromString(e){return this.fromBuffer(V.from(e.replace(/^0x/i,""),"hex"))}toBuffer(){return J(this.value,W.SIZE_IN_BYTES)}toString(){return"0x"+this.value.toString(16)}equals(e){return this.value===e.value}isZero(){return 0n===this.value}}W=K,K.MODULUS=0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47n,K.MAX_VALUE=W.MODULUS-1n,K.SIZE_IN_BYTES=32;var $=o(764).lW;class ee{constructor(e,t){this.x=e,this.y=t}static random(){return new ee(q.random(),q.random())}static fromBuffer(e){const t=I.asReader(e);return new this(q.fromBuffer(t),q.fromBuffer(t))}static fromString(e){return ee.fromBuffer($.from(e.replace(/^0x/i,""),"hex"))}toBuffer(){return $.concat([this.x.toBuffer(),this.y.toBuffer()])}toString(){return"0x"+this.toBuffer().toString("hex")}equals(e){return this.x.equals(e.x)&&this.y.equals(e.y)}}ee.SIZE_IN_BYTES=64,ee.EMPTY=new ee(q.ZERO,q.ZERO);class te{constructor(e){this.buffer=e}static fromBuffer(e){const t=I.asReader(e);return new te(t.readBytes(this.SIZE_IN_BYTES))}static random(){return new te(G(this.SIZE_IN_BYTES))}toBuffer(){return this.buffer}}te.SIZE_IN_BYTES=32;class ne{constructor(e){this.buffer=e}static fromBuffer(e){const t=I.asReader(e);return new ne(t.readBytes(this.SIZE_IN_BYTES))}static random(){return new ne(G(this.SIZE_IN_BYTES))}toBuffer(){return this.buffer}}ne.SIZE_IN_BYTES=64;class se{constructor(e){this.buffer=e}static fromBuffer(e){const t=I.asReader(e);return new se(t.readBytes(this.SIZE_IN_BYTES))}static random(){return new se(G(this.SIZE_IN_BYTES))}toBuffer(){return this.buffer}}se.SIZE_IN_BYTES=128;class ie{constructor(e){this.wasm=e}async pedersenCommit(e,t){const n=[e,t].map(P),s=[ee],i=(await this.wasm.callWasmExport("pedersen_commit",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async pedersenHash(e,t){const n=[e,t].map(P),s=[q],i=(await this.wasm.callWasmExport("pedersen_hash",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async pedersenHashes(e,t){const n=[e,t].map(P),s=[q],i=(await this.wasm.callWasmExport("pedersen_hashes",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async pedersenHashBuffer(e,t){const n=[e,t].map(P),s=[q],i=(await this.wasm.callWasmExport("pedersen_hash_buffer",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async poseidon2Hash(e){const t=[e].map(P),n=[q],s=(await this.wasm.callWasmExport("poseidon2_hash",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async poseidon2HashAccumulate(e){const t=[e].map(P),n=[q],s=(await this.wasm.callWasmExport("poseidon2_hash_accumulate",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async poseidon2Hashes(e){const t=[e].map(P),n=[q],s=(await this.wasm.callWasmExport("poseidon2_hashes",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async poseidon2Permutation(e){const t=[e].map(P),n=[j(q)],s=(await this.wasm.callWasmExport("poseidon2_permutation",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async blake2s(e){const t=[e].map(P),n=[te],s=(await this.wasm.callWasmExport("blake2s",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async blake2sToField(e){const t=[e].map(P),n=[q],s=(await this.wasm.callWasmExport("blake2s_to_field_",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async schnorrComputePublicKey(e){const t=[e].map(P),n=[ee],s=(await this.wasm.callWasmExport("schnorr_compute_public_key",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async schnorrNegatePublicKey(e){const t=[e].map(P),n=[ee],s=(await this.wasm.callWasmExport("schnorr_negate_public_key",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async schnorrConstructSignature(e,t){const n=[e,t].map(P),s=[te,te],i=(await this.wasm.callWasmExport("schnorr_construct_signature",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i}async schnorrVerifySignature(e,t,n,s){const i=[e,t,n,s].map(P),r=[Y()],a=(await this.wasm.callWasmExport("schnorr_verify_signature",i,r.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>r[t].fromBuffer(e)));return a[0]}async schnorrMultisigCreateMultisigPublicKey(e){const t=[e].map(P),n=[se],s=(await this.wasm.callWasmExport("schnorr_multisig_create_multisig_public_key",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async schnorrMultisigValidateAndCombineSignerPubkeys(e){const t=[e].map(P),n=[ee,Y()],s=(await this.wasm.callWasmExport("schnorr_multisig_validate_and_combine_signer_pubkeys",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s}async schnorrMultisigConstructSignatureRound1(){const e=[].map(P),t=[se,se],n=(await this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_1",e,t.map((e=>e.SIZE_IN_BYTES)))).map(((e,n)=>t[n].fromBuffer(e)));return n}async schnorrMultisigConstructSignatureRound2(e,t,n,s,i){const r=[e,t,n,s,i].map(P),a=[K,Y()],o=(await this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_2",r,a.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>a[t].fromBuffer(e)));return o}async schnorrMultisigCombineSignatures(e,t,n,s){const i=[e,t,n,s].map(P),r=[te,te,Y()],a=(await this.wasm.callWasmExport("schnorr_multisig_combine_signatures",i,r.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>r[t].fromBuffer(e)));return a}async aesEncryptBufferCbc(e,t,n,s){const i=[e,t,n,s].map(P),r=[H()],a=(await this.wasm.callWasmExport("aes_encrypt_buffer_cbc",i,r.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>r[t].fromBuffer(e)));return a[0]}async aesDecryptBufferCbc(e,t,n,s){const i=[e,t,n,s].map(P),r=[H()],a=(await this.wasm.callWasmExport("aes_decrypt_buffer_cbc",i,r.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>r[t].fromBuffer(e)));return a[0]}async srsInitSrs(e,t,n){const s=[e,t,n].map(P),i=[];(await this.wasm.callWasmExport("srs_init_srs",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)))}async srsInitGrumpkinSrs(e,t){const n=[e,t].map(P),s=[];(await this.wasm.callWasmExport("srs_init_grumpkin_srs",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)))}async examplesSimpleCreateAndVerifyProof(){const e=[].map(P),t=[Y()],n=(await this.wasm.callWasmExport("examples_simple_create_and_verify_proof",e,t.map((e=>e.SIZE_IN_BYTES)))).map(((e,n)=>t[n].fromBuffer(e)));return n[0]}async testThreads(e,t){const n=[e,t].map(P),s=[Q()],i=(await this.wasm.callWasmExport("test_threads",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async commonInitSlabAllocator(e){const t=[e].map(P),n=[];(await this.wasm.callWasmExport("common_init_slab_allocator",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)))}async acirGetCircuitSizes(e,t,n){const s=[e,t,n].map(P),i=[Q(),Q()],r=(await this.wasm.callWasmExport("acir_get_circuit_sizes",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)));return r}async acirNewAcirComposer(e){const t=[e].map(P),n=[R],s=(await this.wasm.callWasmExport("acir_new_acir_composer",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async acirDeleteAcirComposer(e){const t=[e].map(P),n=[];(await this.wasm.callWasmExport("acir_delete_acir_composer",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)))}async acirInitProvingKey(e,t,n){const s=[e,t,n].map(P),i=[];(await this.wasm.callWasmExport("acir_init_proving_key",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)))}async acirCreateProof(e,t,n,s){const i=[e,t,n,s].map(P),r=[H()],a=(await this.wasm.callWasmExport("acir_create_proof",i,r.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>r[t].fromBuffer(e)));return a[0]}async acirProveAndVerifyUltraHonk(e,t,n){const s=[e,t,n].map(P),i=[Y()],r=(await this.wasm.callWasmExport("acir_prove_and_verify_ultra_honk",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}async acirProveAndVerifyMegaHonk(e,t,n){const s=[e,t,n].map(P),i=[Y()],r=(await this.wasm.callWasmExport("acir_prove_and_verify_mega_honk",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}async acirFoldAndVerifyProgramStack(e,t,n){const s=[e,t,n].map(P),i=[Y()],r=(await this.wasm.callWasmExport("acir_fold_and_verify_program_stack",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}async acirLoadVerificationKey(e,t){const n=[e,t].map(P),s=[];(await this.wasm.callWasmExport("acir_load_verification_key",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)))}async acirInitVerificationKey(e){const t=[e].map(P),n=[];(await this.wasm.callWasmExport("acir_init_verification_key",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)))}async acirGetVerificationKey(e){const t=[e].map(P),n=[H()],s=(await this.wasm.callWasmExport("acir_get_verification_key",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async acirGetProvingKey(e,t,n){const s=[e,t,n].map(P),i=[H()],r=(await this.wasm.callWasmExport("acir_get_proving_key",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}async acirVerifyProof(e,t){const n=[e,t].map(P),s=[Y()],i=(await this.wasm.callWasmExport("acir_verify_proof",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async acirGetSolidityVerifier(e){const t=[e].map(P),n=[U()],s=(await this.wasm.callWasmExport("acir_get_solidity_verifier",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async acirSerializeProofIntoFields(e,t,n){const s=[e,t,n].map(P),i=[j(q)],r=(await this.wasm.callWasmExport("acir_serialize_proof_into_fields",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}async acirSerializeVerificationKeyIntoFields(e){const t=[e].map(P),n=[j(q),q],s=(await this.wasm.callWasmExport("acir_serialize_verification_key_into_fields",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s}async acirProveAndVerifyAztecClient(e,t){const n=[e,t].map(P),s=[Y()],i=(await this.wasm.callWasmExport("acir_prove_and_verify_aztec_client",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async acirProveAztecClient(e,t){const n=[e,t].map(P),s=[H(),H()],i=(await this.wasm.callWasmExport("acir_prove_aztec_client",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return[i[0],i[1]]}async acirVerifyAztecClient(e,t){const n=[e,t].map(P),s=[Y()],i=(await this.wasm.callWasmExport("acir_verify_aztec_client",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async acirProveUltraHonk(e,t,n){const s=[e,t,n].map(P),i=[H()],r=(await this.wasm.callWasmExport("acir_prove_ultra_honk",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}async acirProveUltraKeccakHonk(e,t,n){console.log("acirProveUltraKeccakHonk in");const s=[e,t,n].map(P),i=[H()],r=(await this.wasm.callWasmExport("acir_prove_ultra_keccak_honk",s,i.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}async acirVerifyUltraHonk(e,t){const n=[e,t].map(P),s=[Y()],i=(await this.wasm.callWasmExport("acir_verify_ultra_honk",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async acirVerifyUltraKeccakHonk(e,t){const n=[e,t].map(P),s=[Y()],i=(await this.wasm.callWasmExport("acir_verify_ultra_keccak_honk",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async acirWriteVkUltraHonk(e,t){const n=[e,t].map(P),s=[H()],i=(await this.wasm.callWasmExport("acir_write_vk_ultra_honk",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async acirWriteVkUltraKeccakHonk(e,t){const n=[e,t].map(P),s=[H()],i=(await this.wasm.callWasmExport("acir_write_vk_ultra_keccak_honk",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async acirHonkSolidityVerifier(e,t){const n=[e,t].map(P),s=[H()],i=(await this.wasm.callWasmExport("acir_honk_solidity_verifier",n,s.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}async acirProofAsFieldsUltraHonk(e){const t=[e].map(P),n=[j(q)],s=(await this.wasm.callWasmExport("acir_proof_as_fields_ultra_honk",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async acirVkAsFieldsUltraHonk(e){const t=[e].map(P),n=[j(q)],s=(await this.wasm.callWasmExport("acir_vk_as_fields_ultra_honk",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}async acirVkAsFieldsMegaHonk(e){const t=[e].map(P),n=[j(q)],s=(await this.wasm.callWasmExport("acir_vk_as_fields_mega_honk",t,n.map((e=>e.SIZE_IN_BYTES)))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}}class re{constructor(e){this.wasm=e}pedersenCommit(e,t){const n=[e,t].map(P),s=[ee],i=this.wasm.callWasmExport("pedersen_commit",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}pedersenHash(e,t){const n=[e,t].map(P),s=[q],i=this.wasm.callWasmExport("pedersen_hash",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}pedersenHashes(e,t){const n=[e,t].map(P),s=[q],i=this.wasm.callWasmExport("pedersen_hashes",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}pedersenHashBuffer(e,t){const n=[e,t].map(P),s=[q],i=this.wasm.callWasmExport("pedersen_hash_buffer",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}poseidon2Hash(e){const t=[e].map(P),n=[q],s=this.wasm.callWasmExport("poseidon2_hash",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}poseidon2HashAccumulate(e){const t=[e].map(P),n=[q],s=this.wasm.callWasmExport("poseidon2_hash_accumulate",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}poseidon2Hashes(e){const t=[e].map(P),n=[q],s=this.wasm.callWasmExport("poseidon2_hashes",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}poseidon2Permutation(e){const t=[e].map(P),n=[j(q)],s=this.wasm.callWasmExport("poseidon2_permutation",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}blake2s(e){const t=[e].map(P),n=[te],s=this.wasm.callWasmExport("blake2s",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}blake2sToField(e){const t=[e].map(P),n=[q],s=this.wasm.callWasmExport("blake2s_to_field_",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}schnorrComputePublicKey(e){const t=[e].map(P),n=[ee],s=this.wasm.callWasmExport("schnorr_compute_public_key",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}schnorrNegatePublicKey(e){const t=[e].map(P),n=[ee],s=this.wasm.callWasmExport("schnorr_negate_public_key",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}schnorrConstructSignature(e,t){const n=[e,t].map(P),s=[te,te],i=this.wasm.callWasmExport("schnorr_construct_signature",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i}schnorrVerifySignature(e,t,n,s){const i=[e,t,n,s].map(P),r=[Y()],a=this.wasm.callWasmExport("schnorr_verify_signature",i,r.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>r[t].fromBuffer(e)));return a[0]}schnorrMultisigCreateMultisigPublicKey(e){const t=[e].map(P),n=[se],s=this.wasm.callWasmExport("schnorr_multisig_create_multisig_public_key",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}schnorrMultisigValidateAndCombineSignerPubkeys(e){const t=[e].map(P),n=[ee,Y()],s=this.wasm.callWasmExport("schnorr_multisig_validate_and_combine_signer_pubkeys",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s}schnorrMultisigConstructSignatureRound1(){const e=[].map(P),t=[se,se],n=this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_1",e,t.map((e=>e.SIZE_IN_BYTES))).map(((e,n)=>t[n].fromBuffer(e)));return n}schnorrMultisigConstructSignatureRound2(e,t,n,s,i){const r=[e,t,n,s,i].map(P),a=[K,Y()],o=this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_2",r,a.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>a[t].fromBuffer(e)));return o}schnorrMultisigCombineSignatures(e,t,n,s){const i=[e,t,n,s].map(P),r=[te,te,Y()],a=this.wasm.callWasmExport("schnorr_multisig_combine_signatures",i,r.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>r[t].fromBuffer(e)));return a}aesEncryptBufferCbc(e,t,n,s){const i=[e,t,n,s].map(P),r=[H()],a=this.wasm.callWasmExport("aes_encrypt_buffer_cbc",i,r.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>r[t].fromBuffer(e)));return a[0]}aesDecryptBufferCbc(e,t,n,s){const i=[e,t,n,s].map(P),r=[H()],a=this.wasm.callWasmExport("aes_decrypt_buffer_cbc",i,r.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>r[t].fromBuffer(e)));return a[0]}srsInitSrs(e,t,n){const s=[e,t,n].map(P),i=[];this.wasm.callWasmExport("srs_init_srs",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)))}srsInitGrumpkinSrs(e,t){const n=[e,t].map(P),s=[];this.wasm.callWasmExport("srs_init_grumpkin_srs",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)))}examplesSimpleCreateAndVerifyProof(){const e=[].map(P),t=[Y()],n=this.wasm.callWasmExport("examples_simple_create_and_verify_proof",e,t.map((e=>e.SIZE_IN_BYTES))).map(((e,n)=>t[n].fromBuffer(e)));return n[0]}testThreads(e,t){const n=[e,t].map(P),s=[Q()],i=this.wasm.callWasmExport("test_threads",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}commonInitSlabAllocator(e){const t=[e].map(P),n=[];this.wasm.callWasmExport("common_init_slab_allocator",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)))}acirGetCircuitSizes(e,t,n){const s=[e,t,n].map(P),i=[Q(),Q()],r=this.wasm.callWasmExport("acir_get_circuit_sizes",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)));return r}acirNewAcirComposer(e){const t=[e].map(P),n=[R],s=this.wasm.callWasmExport("acir_new_acir_composer",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}acirDeleteAcirComposer(e){const t=[e].map(P),n=[];this.wasm.callWasmExport("acir_delete_acir_composer",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)))}acirInitProvingKey(e,t,n){const s=[e,t,n].map(P),i=[];this.wasm.callWasmExport("acir_init_proving_key",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)))}acirCreateProof(e,t,n,s){const i=[e,t,n,s].map(P),r=[H()],a=this.wasm.callWasmExport("acir_create_proof",i,r.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>r[t].fromBuffer(e)));return a[0]}acirProveAndVerifyUltraHonk(e,t,n){const s=[e,t,n].map(P),i=[Y()],r=this.wasm.callWasmExport("acir_prove_and_verify_ultra_honk",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}acirProveAndVerifyMegaHonk(e,t,n){const s=[e,t,n].map(P),i=[Y()],r=this.wasm.callWasmExport("acir_prove_and_verify_mega_honk",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}acirFoldAndVerifyProgramStack(e,t,n){const s=[e,t,n].map(P),i=[Y()],r=this.wasm.callWasmExport("acir_fold_and_verify_program_stack",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}acirLoadVerificationKey(e,t){const n=[e,t].map(P),s=[];this.wasm.callWasmExport("acir_load_verification_key",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)))}acirInitVerificationKey(e){const t=[e].map(P),n=[];this.wasm.callWasmExport("acir_init_verification_key",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)))}acirGetVerificationKey(e){const t=[e].map(P),n=[H()],s=this.wasm.callWasmExport("acir_get_verification_key",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}acirGetProvingKey(e,t,n){const s=[e,t,n].map(P),i=[H()],r=this.wasm.callWasmExport("acir_get_proving_key",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}acirVerifyProof(e,t){const n=[e,t].map(P),s=[Y()],i=this.wasm.callWasmExport("acir_verify_proof",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}acirGetSolidityVerifier(e){const t=[e].map(P),n=[U()],s=this.wasm.callWasmExport("acir_get_solidity_verifier",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}acirSerializeProofIntoFields(e,t,n){const s=[e,t,n].map(P),i=[j(q)],r=this.wasm.callWasmExport("acir_serialize_proof_into_fields",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}acirSerializeVerificationKeyIntoFields(e){const t=[e].map(P),n=[j(q),q],s=this.wasm.callWasmExport("acir_serialize_verification_key_into_fields",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s}acirProveUltraHonk(e,t,n){const s=[e,t,n].map(P),i=[H()],r=this.wasm.callWasmExport("acir_prove_ultra_honk",s,i.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>i[t].fromBuffer(e)));return r[0]}acirVerifyUltraHonk(e,t){const n=[e,t].map(P),s=[Y()],i=this.wasm.callWasmExport("acir_verify_ultra_honk",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}acirWriteVkUltraHonk(e,t){const n=[e,t].map(P),s=[H()],i=this.wasm.callWasmExport("acir_write_vk_ultra_honk",n,s.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>s[t].fromBuffer(e)));return i[0]}acirProofAsFieldsUltraHonk(e){const t=[e].map(P),n=[j(q)],s=this.wasm.callWasmExport("acir_proof_as_fields_ultra_honk",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}acirVkAsFieldsUltraHonk(e){const t=[e].map(P),n=[j(q)],s=this.wasm.callWasmExport("acir_vk_as_fields_ultra_honk",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}acirVkAsFieldsMegaHonk(e){const t=[e].map(P),n=[j(q)],s=this.wasm.callWasmExport("acir_vk_as_fields_mega_honk",t,n.map((e=>e.SIZE_IN_BYTES))).map(((e,t)=>n[t].fromBuffer(e)));return s[0]}}var ae=o(227),oe=o.n(ae),le=o(477),ce=o.n(le);function de(){return ce()("/******/ var __webpack_modules__ = ({\n\n/***/ 227:\n/***/ ((module, exports, __webpack_require__) => {\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(447)(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n/***/ }),\n\n/***/ 447:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(824);\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n/***/ }),\n\n/***/ 824:\n/***/ ((module) => {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n/***/ }),\n\n/***/ 477:\n/***/ ((module) => {\n\n\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};\n\n/***/ })\n\n/******/ });\n/************************************************************************/\n/******/ // The module cache\n/******/ var __webpack_module_cache__ = {};\n/******/ \n/******/ // The require function\n/******/ function __webpack_require__(moduleId) {\n/******/ \t// Check if module is in cache\n/******/ \tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \tif (cachedModule !== undefined) {\n/******/ \t\treturn cachedModule.exports;\n/******/ \t}\n/******/ \t// Create a new module (and put it into the cache)\n/******/ \tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t// no module.id needed\n/******/ \t\t// no module.loaded needed\n/******/ \t\texports: {}\n/******/ \t};\n/******/ \n/******/ \t// Execute the module function\n/******/ \t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \n/******/ \t// Return the exports of the module\n/******/ \treturn module.exports;\n/******/ }\n/******/ \n/************************************************************************/\n/******/ /* webpack/runtime/compat get default export */\n/******/ (() => {\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = (module) => {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t() => (module['default']) :\n/******/ \t\t\t() => (module);\n/******/ \t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\treturn getter;\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/define property getters */\n/******/ (() => {\n/******/ \t// define getter functions for harmony exports\n/******/ \t__webpack_require__.d = (exports, definition) => {\n/******/ \t\tfor(var key in definition) {\n/******/ \t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/hasOwnProperty shorthand */\n/******/ (() => {\n/******/ \t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ })();\n/******/ \n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\n\n// UNUSED EXPORTS: default\n\n;// CONCATENATED MODULE: ./node_modules/comlink/dist/esm/comlink.mjs\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\n\n// EXTERNAL MODULE: ./node_modules/debug/src/browser.js\nvar browser = __webpack_require__(227);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/helpers/browser/index.ts\n\nfunction getSharedMemoryAvailable() {\n    const globalScope = typeof window !== 'undefined' ? window : globalThis;\n    return typeof SharedArrayBuffer !== 'undefined' && globalScope.crossOriginIsolated;\n}\nfunction getRemoteBarretenbergWasm(worker) {\n    return wrap(worker);\n}\nfunction getNumCpu() {\n    return navigator.hardwareConcurrency;\n}\nfunction threadLogger() {\n    return undefined;\n}\nfunction killSelf() {\n    self.close();\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vaGVscGVycy9icm93c2VyL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFL0IsTUFBTSxVQUFVLHdCQUF3QjtJQUN0QyxNQUFNLFdBQVcsR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO0lBQ3hFLE9BQU8sT0FBTyxpQkFBaUIsS0FBSyxXQUFXLElBQUksV0FBVyxDQUFDLG1CQUFtQixDQUFDO0FBQ3JGLENBQUM7QUFFRCxNQUFNLFVBQVUseUJBQXlCLENBQUksTUFBYztJQUN6RCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQU0sQ0FBQztBQUMzQixDQUFDO0FBRUQsTUFBTSxVQUFVLFNBQVM7SUFDdkIsT0FBTyxTQUFTLENBQUMsbUJBQW1CLENBQUM7QUFDdkMsQ0FBQztBQUVELE1BQU0sVUFBVSxZQUFZO0lBQzFCLE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRCxNQUFNLFVBQVUsUUFBUTtJQUN0QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDZixDQUFDIn0=\n// EXTERNAL MODULE: ./node_modules/worker-loader/dist/runtime/inline.js\nvar inline = __webpack_require__(477);\nvar inline_default = /*#__PURE__*/__webpack_require__.n(inline);\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_thread/factory/browser/thread.worker.ts\n\n\n\nfunction Worker_fn() {\n  return inline_default()(\"/******/ var __webpack_modules__ = ({\\n\\n/***/ 227:\\n/***/ ((module, exports, __webpack_require__) => {\\n\\n/* eslint-env browser */\\n\\n/**\\n * This is the web browser implementation of `debug()`.\\n */\\n\\nexports.formatArgs = formatArgs;\\nexports.save = save;\\nexports.load = load;\\nexports.useColors = useColors;\\nexports.storage = localstorage();\\nexports.destroy = (() => {\\n\\tlet warned = false;\\n\\n\\treturn () => {\\n\\t\\tif (!warned) {\\n\\t\\t\\twarned = true;\\n\\t\\t\\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\\n\\t\\t}\\n\\t};\\n})();\\n\\n/**\\n * Colors.\\n */\\n\\nexports.colors = [\\n\\t'#0000CC',\\n\\t'#0000FF',\\n\\t'#0033CC',\\n\\t'#0033FF',\\n\\t'#0066CC',\\n\\t'#0066FF',\\n\\t'#0099CC',\\n\\t'#0099FF',\\n\\t'#00CC00',\\n\\t'#00CC33',\\n\\t'#00CC66',\\n\\t'#00CC99',\\n\\t'#00CCCC',\\n\\t'#00CCFF',\\n\\t'#3300CC',\\n\\t'#3300FF',\\n\\t'#3333CC',\\n\\t'#3333FF',\\n\\t'#3366CC',\\n\\t'#3366FF',\\n\\t'#3399CC',\\n\\t'#3399FF',\\n\\t'#33CC00',\\n\\t'#33CC33',\\n\\t'#33CC66',\\n\\t'#33CC99',\\n\\t'#33CCCC',\\n\\t'#33CCFF',\\n\\t'#6600CC',\\n\\t'#6600FF',\\n\\t'#6633CC',\\n\\t'#6633FF',\\n\\t'#66CC00',\\n\\t'#66CC33',\\n\\t'#9900CC',\\n\\t'#9900FF',\\n\\t'#9933CC',\\n\\t'#9933FF',\\n\\t'#99CC00',\\n\\t'#99CC33',\\n\\t'#CC0000',\\n\\t'#CC0033',\\n\\t'#CC0066',\\n\\t'#CC0099',\\n\\t'#CC00CC',\\n\\t'#CC00FF',\\n\\t'#CC3300',\\n\\t'#CC3333',\\n\\t'#CC3366',\\n\\t'#CC3399',\\n\\t'#CC33CC',\\n\\t'#CC33FF',\\n\\t'#CC6600',\\n\\t'#CC6633',\\n\\t'#CC9900',\\n\\t'#CC9933',\\n\\t'#CCCC00',\\n\\t'#CCCC33',\\n\\t'#FF0000',\\n\\t'#FF0033',\\n\\t'#FF0066',\\n\\t'#FF0099',\\n\\t'#FF00CC',\\n\\t'#FF00FF',\\n\\t'#FF3300',\\n\\t'#FF3333',\\n\\t'#FF3366',\\n\\t'#FF3399',\\n\\t'#FF33CC',\\n\\t'#FF33FF',\\n\\t'#FF6600',\\n\\t'#FF6633',\\n\\t'#FF9900',\\n\\t'#FF9933',\\n\\t'#FFCC00',\\n\\t'#FFCC33'\\n];\\n\\n/**\\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\\n * and the Firebug extension (any Firefox version) are known\\n * to support \\\"%c\\\" CSS customizations.\\n *\\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\\n */\\n\\n// eslint-disable-next-line complexity\\nfunction useColors() {\\n\\t// NB: In an Electron preload script, document will be defined but not fully\\n\\t// initialized. Since we know we're in Chrome, we'll just detect this case\\n\\t// explicitly\\n\\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// Internet Explorer and Edge do not support colors.\\n\\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\\\/(\\\\d+)/)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// Is webkit? http://stackoverflow.com/a/16459606/376773\\n\\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\\n\\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\\n\\t\\t// Is firebug? http://stackoverflow.com/a/398120/376773\\n\\t\\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\\n\\t\\t// Is firefox >= v31?\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\\n\\t\\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\\\/(\\\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\\n\\t\\t// Double check webkit in userAgent just in case we are in a worker\\n\\t\\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\\\/(\\\\d+)/));\\n}\\n\\n/**\\n * Colorize log arguments if enabled.\\n *\\n * @api public\\n */\\n\\nfunction formatArgs(args) {\\n\\targs[0] = (this.useColors ? '%c' : '') +\\n\\t\\tthis.namespace +\\n\\t\\t(this.useColors ? ' %c' : ' ') +\\n\\t\\targs[0] +\\n\\t\\t(this.useColors ? '%c ' : ' ') +\\n\\t\\t'+' + module.exports.humanize(this.diff);\\n\\n\\tif (!this.useColors) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tconst c = 'color: ' + this.color;\\n\\targs.splice(1, 0, c, 'color: inherit');\\n\\n\\t// The final \\\"%c\\\" is somewhat tricky, because there could be other\\n\\t// arguments passed either before or after the %c, so we need to\\n\\t// figure out the correct index to insert the CSS into\\n\\tlet index = 0;\\n\\tlet lastC = 0;\\n\\targs[0].replace(/%[a-zA-Z%]/g, match => {\\n\\t\\tif (match === '%%') {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tindex++;\\n\\t\\tif (match === '%c') {\\n\\t\\t\\t// We only are interested in the *last* %c\\n\\t\\t\\t// (the user may have provided their own)\\n\\t\\t\\tlastC = index;\\n\\t\\t}\\n\\t});\\n\\n\\targs.splice(lastC, 0, c);\\n}\\n\\n/**\\n * Invokes `console.debug()` when available.\\n * No-op when `console.debug` is not a \\\"function\\\".\\n * If `console.debug` is not available, falls back\\n * to `console.log`.\\n *\\n * @api public\\n */\\nexports.log = console.debug || console.log || (() => {});\\n\\n/**\\n * Save `namespaces`.\\n *\\n * @param {String} namespaces\\n * @api private\\n */\\nfunction save(namespaces) {\\n\\ttry {\\n\\t\\tif (namespaces) {\\n\\t\\t\\texports.storage.setItem('debug', namespaces);\\n\\t\\t} else {\\n\\t\\t\\texports.storage.removeItem('debug');\\n\\t\\t}\\n\\t} catch (error) {\\n\\t\\t// Swallow\\n\\t\\t// XXX (@Qix-) should we be logging these?\\n\\t}\\n}\\n\\n/**\\n * Load `namespaces`.\\n *\\n * @return {String} returns the previously persisted debug modes\\n * @api private\\n */\\nfunction load() {\\n\\tlet r;\\n\\ttry {\\n\\t\\tr = exports.storage.getItem('debug');\\n\\t} catch (error) {\\n\\t\\t// Swallow\\n\\t\\t// XXX (@Qix-) should we be logging these?\\n\\t}\\n\\n\\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\\n\\tif (!r && typeof process !== 'undefined' && 'env' in process) {\\n\\t\\tr = process.env.DEBUG;\\n\\t}\\n\\n\\treturn r;\\n}\\n\\n/**\\n * Localstorage attempts to return the localstorage.\\n *\\n * This is necessary because safari throws\\n * when a user disables cookies/localstorage\\n * and you attempt to access it.\\n *\\n * @return {LocalStorage}\\n * @api private\\n */\\n\\nfunction localstorage() {\\n\\ttry {\\n\\t\\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\\n\\t\\t// The Browser also has localStorage in the global context.\\n\\t\\treturn localStorage;\\n\\t} catch (error) {\\n\\t\\t// Swallow\\n\\t\\t// XXX (@Qix-) should we be logging these?\\n\\t}\\n}\\n\\nmodule.exports = __webpack_require__(447)(exports);\\n\\nconst {formatters} = module.exports;\\n\\n/**\\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\\n */\\n\\nformatters.j = function (v) {\\n\\ttry {\\n\\t\\treturn JSON.stringify(v);\\n\\t} catch (error) {\\n\\t\\treturn '[UnexpectedJSONParseError]: ' + error.message;\\n\\t}\\n};\\n\\n\\n/***/ }),\\n\\n/***/ 447:\\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\\n\\n\\n/**\\n * This is the common logic for both the Node.js and web browser\\n * implementations of `debug()`.\\n */\\n\\nfunction setup(env) {\\n\\tcreateDebug.debug = createDebug;\\n\\tcreateDebug.default = createDebug;\\n\\tcreateDebug.coerce = coerce;\\n\\tcreateDebug.disable = disable;\\n\\tcreateDebug.enable = enable;\\n\\tcreateDebug.enabled = enabled;\\n\\tcreateDebug.humanize = __webpack_require__(824);\\n\\tcreateDebug.destroy = destroy;\\n\\n\\tObject.keys(env).forEach(key => {\\n\\t\\tcreateDebug[key] = env[key];\\n\\t});\\n\\n\\t/**\\n\\t* The currently active debug mode names, and names to skip.\\n\\t*/\\n\\n\\tcreateDebug.names = [];\\n\\tcreateDebug.skips = [];\\n\\n\\t/**\\n\\t* Map of special \\\"%n\\\" handling functions, for the debug \\\"format\\\" argument.\\n\\t*\\n\\t* Valid key names are a single, lower or upper-case letter, i.e. \\\"n\\\" and \\\"N\\\".\\n\\t*/\\n\\tcreateDebug.formatters = {};\\n\\n\\t/**\\n\\t* Selects a color for a debug namespace\\n\\t* @param {String} namespace The namespace string for the debug instance to be colored\\n\\t* @return {Number|String} An ANSI color code for the given namespace\\n\\t* @api private\\n\\t*/\\n\\tfunction selectColor(namespace) {\\n\\t\\tlet hash = 0;\\n\\n\\t\\tfor (let i = 0; i < namespace.length; i++) {\\n\\t\\t\\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\\n\\t\\t\\thash |= 0; // Convert to 32bit integer\\n\\t\\t}\\n\\n\\t\\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\\n\\t}\\n\\tcreateDebug.selectColor = selectColor;\\n\\n\\t/**\\n\\t* Create a debugger with the given `namespace`.\\n\\t*\\n\\t* @param {String} namespace\\n\\t* @return {Function}\\n\\t* @api public\\n\\t*/\\n\\tfunction createDebug(namespace) {\\n\\t\\tlet prevTime;\\n\\t\\tlet enableOverride = null;\\n\\t\\tlet namespacesCache;\\n\\t\\tlet enabledCache;\\n\\n\\t\\tfunction debug(...args) {\\n\\t\\t\\t// Disabled?\\n\\t\\t\\tif (!debug.enabled) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst self = debug;\\n\\n\\t\\t\\t// Set `diff` timestamp\\n\\t\\t\\tconst curr = Number(new Date());\\n\\t\\t\\tconst ms = curr - (prevTime || curr);\\n\\t\\t\\tself.diff = ms;\\n\\t\\t\\tself.prev = prevTime;\\n\\t\\t\\tself.curr = curr;\\n\\t\\t\\tprevTime = curr;\\n\\n\\t\\t\\targs[0] = createDebug.coerce(args[0]);\\n\\n\\t\\t\\tif (typeof args[0] !== 'string') {\\n\\t\\t\\t\\t// Anything else let's inspect with %O\\n\\t\\t\\t\\targs.unshift('%O');\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Apply any `formatters` transformations\\n\\t\\t\\tlet index = 0;\\n\\t\\t\\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\\n\\t\\t\\t\\t// If we encounter an escaped % then don't increase the array index\\n\\t\\t\\t\\tif (match === '%%') {\\n\\t\\t\\t\\t\\treturn '%';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\tconst formatter = createDebug.formatters[format];\\n\\t\\t\\t\\tif (typeof formatter === 'function') {\\n\\t\\t\\t\\t\\tconst val = args[index];\\n\\t\\t\\t\\t\\tmatch = formatter.call(self, val);\\n\\n\\t\\t\\t\\t\\t// Now we need to remove `args[index]` since it's inlined in the `format`\\n\\t\\t\\t\\t\\targs.splice(index, 1);\\n\\t\\t\\t\\t\\tindex--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn match;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Apply env-specific formatting (colors, etc.)\\n\\t\\t\\tcreateDebug.formatArgs.call(self, args);\\n\\n\\t\\t\\tconst logFn = self.log || createDebug.log;\\n\\t\\t\\tlogFn.apply(self, args);\\n\\t\\t}\\n\\n\\t\\tdebug.namespace = namespace;\\n\\t\\tdebug.useColors = createDebug.useColors();\\n\\t\\tdebug.color = createDebug.selectColor(namespace);\\n\\t\\tdebug.extend = extend;\\n\\t\\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\\n\\n\\t\\tObject.defineProperty(debug, 'enabled', {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: false,\\n\\t\\t\\tget: () => {\\n\\t\\t\\t\\tif (enableOverride !== null) {\\n\\t\\t\\t\\t\\treturn enableOverride;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (namespacesCache !== createDebug.namespaces) {\\n\\t\\t\\t\\t\\tnamespacesCache = createDebug.namespaces;\\n\\t\\t\\t\\t\\tenabledCache = createDebug.enabled(namespace);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn enabledCache;\\n\\t\\t\\t},\\n\\t\\t\\tset: v => {\\n\\t\\t\\t\\tenableOverride = v;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// Env-specific initialization logic for debug instances\\n\\t\\tif (typeof createDebug.init === 'function') {\\n\\t\\t\\tcreateDebug.init(debug);\\n\\t\\t}\\n\\n\\t\\treturn debug;\\n\\t}\\n\\n\\tfunction extend(namespace, delimiter) {\\n\\t\\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\\n\\t\\tnewDebug.log = this.log;\\n\\t\\treturn newDebug;\\n\\t}\\n\\n\\t/**\\n\\t* Enables a debug mode by namespaces. This can include modes\\n\\t* separated by a colon and wildcards.\\n\\t*\\n\\t* @param {String} namespaces\\n\\t* @api public\\n\\t*/\\n\\tfunction enable(namespaces) {\\n\\t\\tcreateDebug.save(namespaces);\\n\\t\\tcreateDebug.namespaces = namespaces;\\n\\n\\t\\tcreateDebug.names = [];\\n\\t\\tcreateDebug.skips = [];\\n\\n\\t\\tlet i;\\n\\t\\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\\\s,]+/);\\n\\t\\tconst len = split.length;\\n\\n\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\tif (!split[i]) {\\n\\t\\t\\t\\t// ignore empty strings\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tnamespaces = split[i].replace(/\\\\*/g, '.*?');\\n\\n\\t\\t\\tif (namespaces[0] === '-') {\\n\\t\\t\\t\\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t* Disable debug output.\\n\\t*\\n\\t* @return {String} namespaces\\n\\t* @api public\\n\\t*/\\n\\tfunction disable() {\\n\\t\\tconst namespaces = [\\n\\t\\t\\t...createDebug.names.map(toNamespace),\\n\\t\\t\\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\\n\\t\\t].join(',');\\n\\t\\tcreateDebug.enable('');\\n\\t\\treturn namespaces;\\n\\t}\\n\\n\\t/**\\n\\t* Returns true if the given mode name is enabled, false otherwise.\\n\\t*\\n\\t* @param {String} name\\n\\t* @return {Boolean}\\n\\t* @api public\\n\\t*/\\n\\tfunction enabled(name) {\\n\\t\\tif (name[name.length - 1] === '*') {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tlet i;\\n\\t\\tlet len;\\n\\n\\t\\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\\n\\t\\t\\tif (createDebug.skips[i].test(name)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\\n\\t\\t\\tif (createDebug.names[i].test(name)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/**\\n\\t* Convert regexp to namespace\\n\\t*\\n\\t* @param {RegExp} regxep\\n\\t* @return {String} namespace\\n\\t* @api private\\n\\t*/\\n\\tfunction toNamespace(regexp) {\\n\\t\\treturn regexp.toString()\\n\\t\\t\\t.substring(2, regexp.toString().length - 2)\\n\\t\\t\\t.replace(/\\\\.\\\\*\\\\?$/, '*');\\n\\t}\\n\\n\\t/**\\n\\t* Coerce `val`.\\n\\t*\\n\\t* @param {Mixed} val\\n\\t* @return {Mixed}\\n\\t* @api private\\n\\t*/\\n\\tfunction coerce(val) {\\n\\t\\tif (val instanceof Error) {\\n\\t\\t\\treturn val.stack || val.message;\\n\\t\\t}\\n\\t\\treturn val;\\n\\t}\\n\\n\\t/**\\n\\t* XXX DO NOT USE. This is a temporary stub function.\\n\\t* XXX It WILL be removed in the next major release.\\n\\t*/\\n\\tfunction destroy() {\\n\\t\\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\\n\\t}\\n\\n\\tcreateDebug.enable(createDebug.load());\\n\\n\\treturn createDebug;\\n}\\n\\nmodule.exports = setup;\\n\\n\\n/***/ }),\\n\\n/***/ 824:\\n/***/ ((module) => {\\n\\n/**\\n * Helpers.\\n */\\n\\nvar s = 1000;\\nvar m = s * 60;\\nvar h = m * 60;\\nvar d = h * 24;\\nvar w = d * 7;\\nvar y = d * 365.25;\\n\\n/**\\n * Parse or format the given `val`.\\n *\\n * Options:\\n *\\n *  - `long` verbose formatting [false]\\n *\\n * @param {String|Number} val\\n * @param {Object} [options]\\n * @throws {Error} throw an error if val is not a non-empty string or a number\\n * @return {String|Number}\\n * @api public\\n */\\n\\nmodule.exports = function(val, options) {\\n  options = options || {};\\n  var type = typeof val;\\n  if (type === 'string' && val.length > 0) {\\n    return parse(val);\\n  } else if (type === 'number' && isFinite(val)) {\\n    return options.long ? fmtLong(val) : fmtShort(val);\\n  }\\n  throw new Error(\\n    'val is not a non-empty string or a valid number. val=' +\\n      JSON.stringify(val)\\n  );\\n};\\n\\n/**\\n * Parse the given `str` and return milliseconds.\\n *\\n * @param {String} str\\n * @return {Number}\\n * @api private\\n */\\n\\nfunction parse(str) {\\n  str = String(str);\\n  if (str.length > 100) {\\n    return;\\n  }\\n  var match = /^(-?(?:\\\\d+)?\\\\.?\\\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\\n    str\\n  );\\n  if (!match) {\\n    return;\\n  }\\n  var n = parseFloat(match[1]);\\n  var type = (match[2] || 'ms').toLowerCase();\\n  switch (type) {\\n    case 'years':\\n    case 'year':\\n    case 'yrs':\\n    case 'yr':\\n    case 'y':\\n      return n * y;\\n    case 'weeks':\\n    case 'week':\\n    case 'w':\\n      return n * w;\\n    case 'days':\\n    case 'day':\\n    case 'd':\\n      return n * d;\\n    case 'hours':\\n    case 'hour':\\n    case 'hrs':\\n    case 'hr':\\n    case 'h':\\n      return n * h;\\n    case 'minutes':\\n    case 'minute':\\n    case 'mins':\\n    case 'min':\\n    case 'm':\\n      return n * m;\\n    case 'seconds':\\n    case 'second':\\n    case 'secs':\\n    case 'sec':\\n    case 's':\\n      return n * s;\\n    case 'milliseconds':\\n    case 'millisecond':\\n    case 'msecs':\\n    case 'msec':\\n    case 'ms':\\n      return n;\\n    default:\\n      return undefined;\\n  }\\n}\\n\\n/**\\n * Short format for `ms`.\\n *\\n * @param {Number} ms\\n * @return {String}\\n * @api private\\n */\\n\\nfunction fmtShort(ms) {\\n  var msAbs = Math.abs(ms);\\n  if (msAbs >= d) {\\n    return Math.round(ms / d) + 'd';\\n  }\\n  if (msAbs >= h) {\\n    return Math.round(ms / h) + 'h';\\n  }\\n  if (msAbs >= m) {\\n    return Math.round(ms / m) + 'm';\\n  }\\n  if (msAbs >= s) {\\n    return Math.round(ms / s) + 's';\\n  }\\n  return ms + 'ms';\\n}\\n\\n/**\\n * Long format for `ms`.\\n *\\n * @param {Number} ms\\n * @return {String}\\n * @api private\\n */\\n\\nfunction fmtLong(ms) {\\n  var msAbs = Math.abs(ms);\\n  if (msAbs >= d) {\\n    return plural(ms, msAbs, d, 'day');\\n  }\\n  if (msAbs >= h) {\\n    return plural(ms, msAbs, h, 'hour');\\n  }\\n  if (msAbs >= m) {\\n    return plural(ms, msAbs, m, 'minute');\\n  }\\n  if (msAbs >= s) {\\n    return plural(ms, msAbs, s, 'second');\\n  }\\n  return ms + ' ms';\\n}\\n\\n/**\\n * Pluralization helper.\\n */\\n\\nfunction plural(ms, msAbs, n, name) {\\n  var isPlural = msAbs >= n * 1.5;\\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\\n}\\n\\n\\n/***/ })\\n\\n/******/ });\\n/************************************************************************/\\n/******/ // The module cache\\n/******/ var __webpack_module_cache__ = {};\\n/******/ \\n/******/ // The require function\\n/******/ function __webpack_require__(moduleId) {\\n/******/ \\t// Check if module is in cache\\n/******/ \\tvar cachedModule = __webpack_module_cache__[moduleId];\\n/******/ \\tif (cachedModule !== undefined) {\\n/******/ \\t\\treturn cachedModule.exports;\\n/******/ \\t}\\n/******/ \\t// Create a new module (and put it into the cache)\\n/******/ \\tvar module = __webpack_module_cache__[moduleId] = {\\n/******/ \\t\\t// no module.id needed\\n/******/ \\t\\t// no module.loaded needed\\n/******/ \\t\\texports: {}\\n/******/ \\t};\\n/******/ \\n/******/ \\t// Execute the module function\\n/******/ \\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n/******/ \\n/******/ \\t// Return the exports of the module\\n/******/ \\treturn module.exports;\\n/******/ }\\n/******/ \\n/************************************************************************/\\n/******/ /* webpack/runtime/compat get default export */\\n/******/ (() => {\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = (module) => {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\t() => (module['default']) :\\n/******/ \\t\\t\\t() => (module);\\n/******/ \\t\\t__webpack_require__.d(getter, { a: getter });\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/ })();\\n/******/ \\n/******/ /* webpack/runtime/define property getters */\\n/******/ (() => {\\n/******/ \\t// define getter functions for harmony exports\\n/******/ \\t__webpack_require__.d = (exports, definition) => {\\n/******/ \\t\\tfor(var key in definition) {\\n/******/ \\t\\t\\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\\n/******/ \\t\\t\\t\\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\\n/******/ \\t\\t\\t}\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/ })();\\n/******/ \\n/******/ /* webpack/runtime/hasOwnProperty shorthand */\\n/******/ (() => {\\n/******/ \\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\\n/******/ })();\\n/******/ \\n/************************************************************************/\\nvar __webpack_exports__ = {};\\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\\n(() => {\\n\\n// UNUSED EXPORTS: default\\n\\n;// CONCATENATED MODULE: ./node_modules/comlink/dist/esm/comlink.mjs\\n/**\\n * @license\\n * Copyright 2019 Google LLC\\n * SPDX-License-Identifier: Apache-2.0\\n */\\nconst proxyMarker = Symbol(\\\"Comlink.proxy\\\");\\nconst createEndpoint = Symbol(\\\"Comlink.endpoint\\\");\\nconst releaseProxy = Symbol(\\\"Comlink.releaseProxy\\\");\\nconst finalizer = Symbol(\\\"Comlink.finalizer\\\");\\nconst throwMarker = Symbol(\\\"Comlink.thrown\\\");\\nconst isObject = (val) => (typeof val === \\\"object\\\" && val !== null) || typeof val === \\\"function\\\";\\n/**\\n * Internal transfer handle to handle objects marked to proxy.\\n */\\nconst proxyTransferHandler = {\\n    canHandle: (val) => isObject(val) && val[proxyMarker],\\n    serialize(obj) {\\n        const { port1, port2 } = new MessageChannel();\\n        expose(obj, port1);\\n        return [port2, [port2]];\\n    },\\n    deserialize(port) {\\n        port.start();\\n        return comlink_wrap(port);\\n    },\\n};\\n/**\\n * Internal transfer handler to handle thrown exceptions.\\n */\\nconst throwTransferHandler = {\\n    canHandle: (value) => isObject(value) && throwMarker in value,\\n    serialize({ value }) {\\n        let serialized;\\n        if (value instanceof Error) {\\n            serialized = {\\n                isError: true,\\n                value: {\\n                    message: value.message,\\n                    name: value.name,\\n                    stack: value.stack,\\n                },\\n            };\\n        }\\n        else {\\n            serialized = { isError: false, value };\\n        }\\n        return [serialized, []];\\n    },\\n    deserialize(serialized) {\\n        if (serialized.isError) {\\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\\n        }\\n        throw serialized.value;\\n    },\\n};\\n/**\\n * Allows customizing the serialization of certain values.\\n */\\nconst transferHandlers = new Map([\\n    [\\\"proxy\\\", proxyTransferHandler],\\n    [\\\"throw\\\", throwTransferHandler],\\n]);\\nfunction isAllowedOrigin(allowedOrigins, origin) {\\n    for (const allowedOrigin of allowedOrigins) {\\n        if (origin === allowedOrigin || allowedOrigin === \\\"*\\\") {\\n            return true;\\n        }\\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\nfunction expose(obj, ep = globalThis, allowedOrigins = [\\\"*\\\"]) {\\n    ep.addEventListener(\\\"message\\\", function callback(ev) {\\n        if (!ev || !ev.data) {\\n            return;\\n        }\\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\\n            return;\\n        }\\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\\n        let returnValue;\\n        try {\\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\\n            switch (type) {\\n                case \\\"GET\\\" /* MessageType.GET */:\\n                    {\\n                        returnValue = rawValue;\\n                    }\\n                    break;\\n                case \\\"SET\\\" /* MessageType.SET */:\\n                    {\\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\\n                        returnValue = true;\\n                    }\\n                    break;\\n                case \\\"APPLY\\\" /* MessageType.APPLY */:\\n                    {\\n                        returnValue = rawValue.apply(parent, argumentList);\\n                    }\\n                    break;\\n                case \\\"CONSTRUCT\\\" /* MessageType.CONSTRUCT */:\\n                    {\\n                        const value = new rawValue(...argumentList);\\n                        returnValue = proxy(value);\\n                    }\\n                    break;\\n                case \\\"ENDPOINT\\\" /* MessageType.ENDPOINT */:\\n                    {\\n                        const { port1, port2 } = new MessageChannel();\\n                        expose(obj, port2);\\n                        returnValue = transfer(port1, [port1]);\\n                    }\\n                    break;\\n                case \\\"RELEASE\\\" /* MessageType.RELEASE */:\\n                    {\\n                        returnValue = undefined;\\n                    }\\n                    break;\\n                default:\\n                    return;\\n            }\\n        }\\n        catch (value) {\\n            returnValue = { value, [throwMarker]: 0 };\\n        }\\n        Promise.resolve(returnValue)\\n            .catch((value) => {\\n            return { value, [throwMarker]: 0 };\\n        })\\n            .then((returnValue) => {\\n            const [wireValue, transferables] = toWireValue(returnValue);\\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\\n            if (type === \\\"RELEASE\\\" /* MessageType.RELEASE */) {\\n                // detach and deactive after sending release response above.\\n                ep.removeEventListener(\\\"message\\\", callback);\\n                closeEndPoint(ep);\\n                if (finalizer in obj && typeof obj[finalizer] === \\\"function\\\") {\\n                    obj[finalizer]();\\n                }\\n            }\\n        })\\n            .catch((error) => {\\n            // Send Serialization Error To Caller\\n            const [wireValue, transferables] = toWireValue({\\n                value: new TypeError(\\\"Unserializable return value\\\"),\\n                [throwMarker]: 0,\\n            });\\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\\n        });\\n    });\\n    if (ep.start) {\\n        ep.start();\\n    }\\n}\\nfunction isMessagePort(endpoint) {\\n    return endpoint.constructor.name === \\\"MessagePort\\\";\\n}\\nfunction closeEndPoint(endpoint) {\\n    if (isMessagePort(endpoint))\\n        endpoint.close();\\n}\\nfunction comlink_wrap(ep, target) {\\n    return createProxy(ep, [], target);\\n}\\nfunction throwIfProxyReleased(isReleased) {\\n    if (isReleased) {\\n        throw new Error(\\\"Proxy has been released and is not useable\\\");\\n    }\\n}\\nfunction releaseEndpoint(ep) {\\n    return requestResponseMessage(ep, {\\n        type: \\\"RELEASE\\\" /* MessageType.RELEASE */,\\n    }).then(() => {\\n        closeEndPoint(ep);\\n    });\\n}\\nconst proxyCounter = new WeakMap();\\nconst proxyFinalizers = \\\"FinalizationRegistry\\\" in globalThis &&\\n    new FinalizationRegistry((ep) => {\\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\\n        proxyCounter.set(ep, newCount);\\n        if (newCount === 0) {\\n            releaseEndpoint(ep);\\n        }\\n    });\\nfunction registerProxy(proxy, ep) {\\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\\n    proxyCounter.set(ep, newCount);\\n    if (proxyFinalizers) {\\n        proxyFinalizers.register(proxy, ep, proxy);\\n    }\\n}\\nfunction unregisterProxy(proxy) {\\n    if (proxyFinalizers) {\\n        proxyFinalizers.unregister(proxy);\\n    }\\n}\\nfunction createProxy(ep, path = [], target = function () { }) {\\n    let isProxyReleased = false;\\n    const proxy = new Proxy(target, {\\n        get(_target, prop) {\\n            throwIfProxyReleased(isProxyReleased);\\n            if (prop === releaseProxy) {\\n                return () => {\\n                    unregisterProxy(proxy);\\n                    releaseEndpoint(ep);\\n                    isProxyReleased = true;\\n                };\\n            }\\n            if (prop === \\\"then\\\") {\\n                if (path.length === 0) {\\n                    return { then: () => proxy };\\n                }\\n                const r = requestResponseMessage(ep, {\\n                    type: \\\"GET\\\" /* MessageType.GET */,\\n                    path: path.map((p) => p.toString()),\\n                }).then(fromWireValue);\\n                return r.then.bind(r);\\n            }\\n            return createProxy(ep, [...path, prop]);\\n        },\\n        set(_target, prop, rawValue) {\\n            throwIfProxyReleased(isProxyReleased);\\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\\n            // boolean. To show good will, we return true asynchronously ¯\\\\_(ツ)_/¯\\n            const [value, transferables] = toWireValue(rawValue);\\n            return requestResponseMessage(ep, {\\n                type: \\\"SET\\\" /* MessageType.SET */,\\n                path: [...path, prop].map((p) => p.toString()),\\n                value,\\n            }, transferables).then(fromWireValue);\\n        },\\n        apply(_target, _thisArg, rawArgumentList) {\\n            throwIfProxyReleased(isProxyReleased);\\n            const last = path[path.length - 1];\\n            if (last === createEndpoint) {\\n                return requestResponseMessage(ep, {\\n                    type: \\\"ENDPOINT\\\" /* MessageType.ENDPOINT */,\\n                }).then(fromWireValue);\\n            }\\n            // We just pretend that `bind()` didn’t happen.\\n            if (last === \\\"bind\\\") {\\n                return createProxy(ep, path.slice(0, -1));\\n            }\\n            const [argumentList, transferables] = processArguments(rawArgumentList);\\n            return requestResponseMessage(ep, {\\n                type: \\\"APPLY\\\" /* MessageType.APPLY */,\\n                path: path.map((p) => p.toString()),\\n                argumentList,\\n            }, transferables).then(fromWireValue);\\n        },\\n        construct(_target, rawArgumentList) {\\n            throwIfProxyReleased(isProxyReleased);\\n            const [argumentList, transferables] = processArguments(rawArgumentList);\\n            return requestResponseMessage(ep, {\\n                type: \\\"CONSTRUCT\\\" /* MessageType.CONSTRUCT */,\\n                path: path.map((p) => p.toString()),\\n                argumentList,\\n            }, transferables).then(fromWireValue);\\n        },\\n    });\\n    registerProxy(proxy, ep);\\n    return proxy;\\n}\\nfunction myFlat(arr) {\\n    return Array.prototype.concat.apply([], arr);\\n}\\nfunction processArguments(argumentList) {\\n    const processed = argumentList.map(toWireValue);\\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\\n}\\nconst transferCache = new WeakMap();\\nfunction transfer(obj, transfers) {\\n    transferCache.set(obj, transfers);\\n    return obj;\\n}\\nfunction proxy(obj) {\\n    return Object.assign(obj, { [proxyMarker]: true });\\n}\\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \\\"*\\\") {\\n    return {\\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\\n        addEventListener: context.addEventListener.bind(context),\\n        removeEventListener: context.removeEventListener.bind(context),\\n    };\\n}\\nfunction toWireValue(value) {\\n    for (const [name, handler] of transferHandlers) {\\n        if (handler.canHandle(value)) {\\n            const [serializedValue, transferables] = handler.serialize(value);\\n            return [\\n                {\\n                    type: \\\"HANDLER\\\" /* WireValueType.HANDLER */,\\n                    name,\\n                    value: serializedValue,\\n                },\\n                transferables,\\n            ];\\n        }\\n    }\\n    return [\\n        {\\n            type: \\\"RAW\\\" /* WireValueType.RAW */,\\n            value,\\n        },\\n        transferCache.get(value) || [],\\n    ];\\n}\\nfunction fromWireValue(value) {\\n    switch (value.type) {\\n        case \\\"HANDLER\\\" /* WireValueType.HANDLER */:\\n            return transferHandlers.get(value.name).deserialize(value.value);\\n        case \\\"RAW\\\" /* WireValueType.RAW */:\\n            return value.value;\\n    }\\n}\\nfunction requestResponseMessage(ep, msg, transfers) {\\n    return new Promise((resolve) => {\\n        const id = generateUUID();\\n        ep.addEventListener(\\\"message\\\", function l(ev) {\\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\\n                return;\\n            }\\n            ep.removeEventListener(\\\"message\\\", l);\\n            resolve(ev.data);\\n        });\\n        if (ep.start) {\\n            ep.start();\\n        }\\n        ep.postMessage(Object.assign({ id }, msg), transfers);\\n    });\\n}\\nfunction generateUUID() {\\n    return new Array(4)\\n        .fill(0)\\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\\n        .join(\\\"-\\\");\\n}\\n\\n\\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/helpers/browser/index.ts\\n\\nfunction getSharedMemoryAvailable() {\\n    const globalScope = typeof window !== 'undefined' ? window : globalThis;\\n    return typeof SharedArrayBuffer !== 'undefined' && globalScope.crossOriginIsolated;\\n}\\nfunction getRemoteBarretenbergWasm(worker) {\\n    return wrap(worker);\\n}\\nfunction getNumCpu() {\\n    return navigator.hardwareConcurrency;\\n}\\nfunction threadLogger() {\\n    return undefined;\\n}\\nfunction killSelf() {\\n    self.close();\\n}\\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vaGVscGVycy9icm93c2VyL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFL0IsTUFBTSxVQUFVLHdCQUF3QjtJQUN0QyxNQUFNLFdBQVcsR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO0lBQ3hFLE9BQU8sT0FBTyxpQkFBaUIsS0FBSyxXQUFXLElBQUksV0FBVyxDQUFDLG1CQUFtQixDQUFDO0FBQ3JGLENBQUM7QUFFRCxNQUFNLFVBQVUseUJBQXlCLENBQUksTUFBYztJQUN6RCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQU0sQ0FBQztBQUMzQixDQUFDO0FBRUQsTUFBTSxVQUFVLFNBQVM7SUFDdkIsT0FBTyxTQUFTLENBQUMsbUJBQW1CLENBQUM7QUFDdkMsQ0FBQztBQUVELE1BQU0sVUFBVSxZQUFZO0lBQzFCLE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRCxNQUFNLFVBQVUsUUFBUTtJQUN0QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDZixDQUFDIn0=\\n// EXTERNAL MODULE: ./node_modules/debug/src/browser.js\\nvar browser = __webpack_require__(227);\\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\\n;// CONCATENATED MODULE: ./src/random/browser/index.ts\\nconst randomBytes = (len) => {\\n    const getWebCrypto = () => {\\n        if (typeof window !== 'undefined' && window.crypto)\\n            return window.crypto;\\n        if (typeof globalThis !== 'undefined' && globalThis.crypto)\\n            return globalThis.crypto;\\n        return undefined;\\n    };\\n    const crypto = getWebCrypto();\\n    if (!crypto) {\\n        throw new Error('randomBytes UnsupportedEnvironment');\\n    }\\n    const buf = new Uint8Array(len);\\n    // limit of Crypto.getRandomValues()\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\\n    const MAX_BYTES = 65536;\\n    if (len > MAX_BYTES) {\\n        // this is the max bytes crypto.getRandomValues\\n        // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\\n        for (let generated = 0; generated < len; generated += MAX_BYTES) {\\n            // buffer.slice automatically checks if the end is past the end of\\n            // the buffer so we don't have to here\\n            crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));\\n        }\\n    }\\n    else {\\n        crypto.getRandomValues(buf);\\n    }\\n    return buf;\\n};\\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvcmFuZG9tL2Jyb3dzZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBVyxFQUFFLEVBQUU7SUFDekMsTUFBTSxZQUFZLEdBQUcsR0FBRyxFQUFFO1FBQ3hCLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFJLE1BQU0sQ0FBQyxNQUFNO1lBQUUsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ3pFLElBQUksT0FBTyxVQUFVLEtBQUssV0FBVyxJQUFJLFVBQVUsQ0FBQyxNQUFNO1lBQUUsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDO1FBQ3JGLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUMsQ0FBQztJQUVGLE1BQU0sTUFBTSxHQUFHLFlBQVksRUFBRSxDQUFDO0lBQzlCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQUcsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFaEMsb0NBQW9DO0lBQ3BDLDBFQUEwRTtJQUMxRSxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFFeEIsSUFBSSxHQUFHLEdBQUcsU0FBUyxFQUFFLENBQUM7UUFDcEIsK0NBQStDO1FBQy9DLG9HQUFvRztRQUNwRyxLQUFLLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsR0FBRyxFQUFFLFNBQVMsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNoRSxrRUFBa0U7WUFDbEUsc0NBQXNDO1lBQ3RDLE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDekUsQ0FBQztJQUNILENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDLENBQUMifQ==\\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_base/index.ts\\n\\n\\nconst debug = browser_default()('bb.js:wasm');\\n/**\\n * Base implementation of BarretenbergWasm.\\n * Contains code that is common to the \\\"main thread\\\" implementation and the \\\"child thread\\\" implementation.\\n */\\nclass BarretenbergWasmBase {\\n    constructor() {\\n        this.memStore = {};\\n        this.logger = debug;\\n    }\\n    getImportObj(memory) {\\n        /* eslint-disable camelcase */\\n        const importObj = {\\n            // We need to implement a part of the wasi api:\\n            // https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md\\n            // We literally only need to support random_get, everything else is noop implementated in barretenberg.wasm.\\n            wasi_snapshot_preview1: {\\n                random_get: (out, length) => {\\n                    out = out >>> 0;\\n                    const randomData = randomBytes(length);\\n                    const mem = this.getMemory();\\n                    mem.set(randomData, out);\\n                },\\n                clock_time_get: (a1, a2, out) => {\\n                    out = out >>> 0;\\n                    const ts = BigInt(new Date().getTime()) * 1000000n;\\n                    const view = new DataView(this.getMemory().buffer);\\n                    view.setBigUint64(out, ts, true);\\n                },\\n                proc_exit: () => {\\n                    this.logger('PANIC: proc_exit was called.');\\n                    throw new Error();\\n                },\\n            },\\n            // These are functions implementations for imports we've defined are needed.\\n            // The native C++ build defines these in a module called \\\"env\\\". We must implement TypeScript versions here.\\n            env: {\\n                /**\\n                 * The 'info' call we use for logging in C++, calls this under the hood.\\n                 * The native code will just print to std:err (to avoid std::cout which is used for IPC).\\n                 * Here we just emit the log line for the client to decide what to do with.\\n                 */\\n                logstr: (addr) => {\\n                    const str = this.stringFromAddress(addr);\\n                    const m = this.getMemory();\\n                    const str2 = `${str} (mem: ${(m.length / (1024 * 1024)).toFixed(2)}MiB)`;\\n                    this.logger(str2);\\n                    if (str2.startsWith('WARNING:')) {\\n                        this.logger(new Error().stack);\\n                    }\\n                },\\n                get_data: (keyAddr, outBufAddr) => {\\n                    const key = this.stringFromAddress(keyAddr);\\n                    outBufAddr = outBufAddr >>> 0;\\n                    const data = this.memStore[key];\\n                    if (!data) {\\n                        this.logger(`get_data miss ${key}`);\\n                        return;\\n                    }\\n                    // this.logger(`get_data hit ${key} size: ${data.length} dest: ${outBufAddr}`);\\n                    // this.logger(Buffer.from(data.slice(0, 64)).toString('hex'));\\n                    this.writeMemory(outBufAddr, data);\\n                },\\n                set_data: (keyAddr, dataAddr, dataLength) => {\\n                    const key = this.stringFromAddress(keyAddr);\\n                    dataAddr = dataAddr >>> 0;\\n                    this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);\\n                    // this.logger(`set_data: ${key} length: ${dataLength}`);\\n                },\\n                memory,\\n            },\\n        };\\n        /* eslint-enable camelcase */\\n        return importObj;\\n    }\\n    exports() {\\n        return this.instance.exports;\\n    }\\n    /**\\n     * When returning values from the WASM, use >>> operator to convert signed representation to unsigned representation.\\n     */\\n    call(name, ...args) {\\n        if (!this.exports()[name]) {\\n            throw new Error(`WASM function ${name} not found.`);\\n        }\\n        try {\\n            return this.exports()[name](...args) >>> 0;\\n        }\\n        catch (err) {\\n            const message = `WASM function ${name} aborted, error: ${err}`;\\n            this.logger(message);\\n            this.logger(err.stack);\\n            throw err;\\n        }\\n    }\\n    memSize() {\\n        return this.getMemory().length;\\n    }\\n    /**\\n     * Returns a copy of the data, not a view.\\n     */\\n    getMemorySlice(start, end) {\\n        return this.getMemory().subarray(start, end).slice();\\n    }\\n    writeMemory(offset, arr) {\\n        const mem = this.getMemory();\\n        mem.set(arr, offset);\\n    }\\n    // PRIVATE METHODS\\n    getMemory() {\\n        return new Uint8Array(this.memory.buffer);\\n    }\\n    stringFromAddress(addr) {\\n        addr = addr >>> 0;\\n        const m = this.getMemory();\\n        let i = addr;\\n        for (; m[i] !== 0; ++i)\\n            ;\\n        const textDecoder = new TextDecoder('ascii');\\n        return textDecoder.decode(m.slice(addr, i));\\n    }\\n}\\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fYmFzZS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFdBQVcsTUFBTSxPQUFPLENBQUM7QUFDaEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXBELE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUV4Qzs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sb0JBQW9CO0lBQWpDO1FBQ1ksYUFBUSxHQUFrQyxFQUFFLENBQUM7UUFHN0MsV0FBTSxHQUEwQixLQUFLLENBQUM7SUE0SGxELENBQUM7SUExSFcsWUFBWSxDQUFDLE1BQTBCO1FBQy9DLDhCQUE4QjtRQUM5QixNQUFNLFNBQVMsR0FBRztZQUNoQiwrQ0FBK0M7WUFDL0Msd0VBQXdFO1lBQ3hFLDRHQUE0RztZQUM1RyxzQkFBc0IsRUFBRTtnQkFDdEIsVUFBVSxFQUFFLENBQUMsR0FBUSxFQUFFLE1BQWMsRUFBRSxFQUFFO29CQUN2QyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQztvQkFDaEIsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUN2QyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7b0JBQzdCLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUMzQixDQUFDO2dCQUNELGNBQWMsRUFBRSxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsR0FBVyxFQUFFLEVBQUU7b0JBQ3RELEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDO29CQUNoQixNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLFFBQVEs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\\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_thread/index.ts\\n\\n\\nclass BarretenbergWasmThread extends BarretenbergWasmBase {\\n    /**\\n     * Init as worker thread.\\n     */\\n    async initThread(module, memory) {\\n        this.logger = threadLogger() || this.logger;\\n        this.memory = memory;\\n        this.instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));\\n    }\\n    destroy() {\\n        killSelf();\\n    }\\n    getImportObj(memory) {\\n        const baseImports = super.getImportObj(memory);\\n        /* eslint-disable camelcase */\\n        return {\\n            ...baseImports,\\n            wasi: {\\n                'thread-spawn': () => {\\n                    this.logger('PANIC: threads cannot spawn threads!');\\n                    this.logger(new Error().stack);\\n                    killSelf();\\n                },\\n            },\\n            // These are functions implementations for imports we've defined are needed.\\n            // The native C++ build defines these in a module called \\\"env\\\". We must implement TypeScript versions here.\\n            env: {\\n                ...baseImports.env,\\n                env_hardware_concurrency: () => {\\n                    // We return 1, which should cause any algos using threading to just not create a thread.\\n                    return 1;\\n                },\\n            },\\n        };\\n        /* eslint-enable camelcase */\\n    }\\n}\\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fdGhyZWFkL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDN0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFFMUUsTUFBTSxPQUFPLHNCQUF1QixTQUFRLG9CQUFvQjtJQUM5RDs7T0FFRztJQUNJLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBMEIsRUFBRSxNQUEwQjtRQUM1RSxJQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDNUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLFdBQVcsQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDeEYsQ0FBQztJQUVNLE9BQU87UUFDWixRQUFRLEVBQUUsQ0FBQztJQUNiLENBQUM7SUFFUyxZQUFZLENBQUMsTUFBMEI7UUFDL0MsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUvQyw4QkFBOEI7UUFDOUIsT0FBTztZQUNMLEdBQUcsV0FBVztZQUNkLElBQUksRUFBRTtnQkFDSixjQUFjLEVBQUUsR0FBRyxFQUFFO29CQUNuQixJQUFJLENBQUMsTUFBTSxDQUFDLHNDQUFzQyxDQUFDLENBQUM7b0JBQ3BELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxLQUFNLENBQUMsQ0FBQztvQkFDaEMsUUFBUSxFQUFFLENBQUM7Z0JBQ2IsQ0FBQzthQUNGO1lBRUQsNEVBQTRFO1lBQzVFLDJHQUEyRztZQUMzRyxHQUFHLEVBQUU7Z0JBQ0gsR0FBRyxXQUFXLENBQUMsR0FBRztnQkFDbEIsd0JBQXdCLEVBQUUsR0FBRyxFQUFFO29CQUM3Qix5RkFBeUY7b0JBQ3pGLE9BQU8sQ0FBQyxDQUFDO2dCQUNYLENBQUM7YUFDRjtTQUNGLENBQUM7UUFDRiw2QkFBNkI7SUFDL0IsQ0FBQztDQUNGIn0=\\n;// CONCATENATED MODULE: ./node_modules/ts-loader/index.js??ruleSet[1].rules[2].use[0]!./src/barretenberg_wasm/barretenberg_wasm_thread/factory/browser/thread.worker.ts\\n\\n\\n\\nself.onmessage = function (e) {\\n    if (e.data.debug) {\\n        browser_default().enable(e.data.debug);\\n    }\\n};\\nexpose(new BarretenbergWasmThread());\\nself.postMessage({ ready: true });\\n/* harmony default export */ const thread_worker = (null);\\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhyZWFkLndvcmtlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9iYXJyZXRlbmJlcmdfd2FzbS9iYXJyZXRlbmJlcmdfd2FzbV90aHJlYWQvZmFjdG9yeS9icm93c2VyL3RocmVhZC53b3JrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNqQyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4RCxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFFMUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7SUFDMUIsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pCLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0FBQ0gsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLElBQUksc0JBQXNCLEVBQUUsQ0FBQyxDQUFDO0FBRXJDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUVsQyxlQUFlLElBQVcsQ0FBQyJ9\\n})();\\n\\n\", \"Worker\", undefined, undefined);\n}\n\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_thread/factory/browser/index.ts\n\n\nfunction createThreadWorker() {\n    const worker = new Worker_fn();\n    const debugStr = browser_default().disable();\n    browser_default().enable(debugStr);\n    worker.postMessage({ debug: debugStr });\n    return worker;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fdGhyZWFkL2ZhY3RvcnkvYnJvd3Nlci9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDMUIsT0FBTyxZQUFZLE1BQU0sb0JBQW9CLENBQUM7QUFFOUMsTUFBTSxVQUFVLGtCQUFrQjtJQUNoQyxNQUFNLE1BQU0sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBQ2xDLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNqQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUN4QyxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIn0=\n;// CONCATENATED MODULE: ./src/random/browser/index.ts\nconst randomBytes = (len) => {\n    const getWebCrypto = () => {\n        if (typeof window !== 'undefined' && window.crypto)\n            return window.crypto;\n        if (typeof globalThis !== 'undefined' && globalThis.crypto)\n            return globalThis.crypto;\n        return undefined;\n    };\n    const crypto = getWebCrypto();\n    if (!crypto) {\n        throw new Error('randomBytes UnsupportedEnvironment');\n    }\n    const buf = new Uint8Array(len);\n    // limit of Crypto.getRandomValues()\n    // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\n    const MAX_BYTES = 65536;\n    if (len > MAX_BYTES) {\n        // this is the max bytes crypto.getRandomValues\n        // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n        for (let generated = 0; generated < len; generated += MAX_BYTES) {\n            // buffer.slice automatically checks if the end is past the end of\n            // the buffer so we don't have to here\n            crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));\n        }\n    }\n    else {\n        crypto.getRandomValues(buf);\n    }\n    return buf;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvcmFuZG9tL2Jyb3dzZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBVyxFQUFFLEVBQUU7SUFDekMsTUFBTSxZQUFZLEdBQUcsR0FBRyxFQUFFO1FBQ3hCLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFJLE1BQU0sQ0FBQyxNQUFNO1lBQUUsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ3pFLElBQUksT0FBTyxVQUFVLEtBQUssV0FBVyxJQUFJLFVBQVUsQ0FBQyxNQUFNO1lBQUUsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDO1FBQ3JGLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUMsQ0FBQztJQUVGLE1BQU0sTUFBTSxHQUFHLFlBQVksRUFBRSxDQUFDO0lBQzlCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQUcsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFaEMsb0NBQW9DO0lBQ3BDLDBFQUEwRTtJQUMxRSxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFFeEIsSUFBSSxHQUFHLEdBQUcsU0FBUyxFQUFFLENBQUM7UUFDcEIsK0NBQStDO1FBQy9DLG9HQUFvRztRQUNwRyxLQUFLLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsR0FBRyxFQUFFLFNBQVMsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNoRSxrRUFBa0U7WUFDbEUsc0NBQXNDO1lBQ3RDLE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDekUsQ0FBQztJQUNILENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDLENBQUMifQ==\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_base/index.ts\n\n\nconst debug = browser_default()('bb.js:wasm');\n/**\n * Base implementation of BarretenbergWasm.\n * Contains code that is common to the \"main thread\" implementation and the \"child thread\" implementation.\n */\nclass BarretenbergWasmBase {\n    constructor() {\n        this.memStore = {};\n        this.logger = debug;\n    }\n    getImportObj(memory) {\n        /* eslint-disable camelcase */\n        const importObj = {\n            // We need to implement a part of the wasi api:\n            // https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md\n            // We literally only need to support random_get, everything else is noop implementated in barretenberg.wasm.\n            wasi_snapshot_preview1: {\n                random_get: (out, length) => {\n                    out = out >>> 0;\n                    const randomData = randomBytes(length);\n                    const mem = this.getMemory();\n                    mem.set(randomData, out);\n                },\n                clock_time_get: (a1, a2, out) => {\n                    out = out >>> 0;\n                    const ts = BigInt(new Date().getTime()) * 1000000n;\n                    const view = new DataView(this.getMemory().buffer);\n                    view.setBigUint64(out, ts, true);\n                },\n                proc_exit: () => {\n                    this.logger('PANIC: proc_exit was called.');\n                    throw new Error();\n                },\n            },\n            // These are functions implementations for imports we've defined are needed.\n            // The native C++ build defines these in a module called \"env\". We must implement TypeScript versions here.\n            env: {\n                /**\n                 * The 'info' call we use for logging in C++, calls this under the hood.\n                 * The native code will just print to std:err (to avoid std::cout which is used for IPC).\n                 * Here we just emit the log line for the client to decide what to do with.\n                 */\n                logstr: (addr) => {\n                    const str = this.stringFromAddress(addr);\n                    const m = this.getMemory();\n                    const str2 = `${str} (mem: ${(m.length / (1024 * 1024)).toFixed(2)}MiB)`;\n                    this.logger(str2);\n                    if (str2.startsWith('WARNING:')) {\n                        this.logger(new Error().stack);\n                    }\n                },\n                get_data: (keyAddr, outBufAddr) => {\n                    const key = this.stringFromAddress(keyAddr);\n                    outBufAddr = outBufAddr >>> 0;\n                    const data = this.memStore[key];\n                    if (!data) {\n                        this.logger(`get_data miss ${key}`);\n                        return;\n                    }\n                    // this.logger(`get_data hit ${key} size: ${data.length} dest: ${outBufAddr}`);\n                    // this.logger(Buffer.from(data.slice(0, 64)).toString('hex'));\n                    this.writeMemory(outBufAddr, data);\n                },\n                set_data: (keyAddr, dataAddr, dataLength) => {\n                    const key = this.stringFromAddress(keyAddr);\n                    dataAddr = dataAddr >>> 0;\n                    this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);\n                    // this.logger(`set_data: ${key} length: ${dataLength}`);\n                },\n                memory,\n            },\n        };\n        /* eslint-enable camelcase */\n        return importObj;\n    }\n    exports() {\n        return this.instance.exports;\n    }\n    /**\n     * When returning values from the WASM, use >>> operator to convert signed representation to unsigned representation.\n     */\n    call(name, ...args) {\n        if (!this.exports()[name]) {\n            throw new Error(`WASM function ${name} not found.`);\n        }\n        try {\n            return this.exports()[name](...args) >>> 0;\n        }\n        catch (err) {\n            const message = `WASM function ${name} aborted, error: ${err}`;\n            this.logger(message);\n            this.logger(err.stack);\n            throw err;\n        }\n    }\n    memSize() {\n        return this.getMemory().length;\n    }\n    /**\n     * Returns a copy of the data, not a view.\n     */\n    getMemorySlice(start, end) {\n        return this.getMemory().subarray(start, end).slice();\n    }\n    writeMemory(offset, arr) {\n        const mem = this.getMemory();\n        mem.set(arr, offset);\n    }\n    // PRIVATE METHODS\n    getMemory() {\n        return new Uint8Array(this.memory.buffer);\n    }\n    stringFromAddress(addr) {\n        addr = addr >>> 0;\n        const m = this.getMemory();\n        let i = addr;\n        for (; m[i] !== 0; ++i)\n            ;\n        const textDecoder = new TextDecoder('ascii');\n        return textDecoder.decode(m.slice(addr, i));\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fYmFzZS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFdBQVcsTUFBTSxPQUFPLENBQUM7QUFDaEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXBELE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUV4Qzs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sb0JBQW9CO0lBQWpDO1FBQ1ksYUFBUSxHQUFrQyxFQUFFLENBQUM7UUFHN0MsV0FBTSxHQUEwQixLQUFLLENBQUM7SUE0SGxELENBQUM7SUExSFcsWUFBWSxDQUFDLE1BQTBCO1FBQy9DLDhCQUE4QjtRQUM5QixNQUFNLFNBQVMsR0FBRztZQUNoQiwrQ0FBK0M7WUFDL0Msd0VBQXdFO1lBQ3hFLDRHQUE0RztZQUM1RyxzQkFBc0IsRUFBRTtnQkFDdEIsVUFBVSxFQUFFLENBQUMsR0FBUSxFQUFFLE1BQWMsRUFBRSxFQUFFO29CQUN2QyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQztvQkFDaEIsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUN2QyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7b0JBQzdCLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUMzQixDQUFDO2dCQUNELGNBQWMsRUFBRSxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsR0FBVyxFQUFFLEVBQUU7b0JBQ3RELEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDO29CQUNoQixNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLFFBQVEs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\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_main/heap_allocator.ts\n/**\n * Keeps track of heap allocations so they can be easily freed.\n * The WASM memory layout has 1024 bytes of unused \"scratch\" space at the start (addresses 0-1023).\n * We can leverage this for IO rather than making expensive bb_malloc bb_free calls.\n * Heap allocations will be created for input/output args that don't fit into the scratch space.\n * Input and output args can use the same scratch space as it's assume all input reads will be performed before any\n * output writes are performed.\n */\nclass HeapAllocator {\n    constructor(wasm) {\n        this.wasm = wasm;\n        this.allocs = [];\n        this.inScratchRemaining = 1024;\n        this.outScratchRemaining = 1024;\n    }\n    getInputs(buffers) {\n        return buffers.map(bufOrNum => {\n            if (typeof bufOrNum === 'object') {\n                if (bufOrNum.length <= this.inScratchRemaining) {\n                    const ptr = (this.inScratchRemaining -= bufOrNum.length);\n                    this.wasm.writeMemory(ptr, bufOrNum);\n                    return ptr;\n                }\n                else {\n                    const ptr = this.wasm.call('bbmalloc', bufOrNum.length);\n                    this.wasm.writeMemory(ptr, bufOrNum);\n                    this.allocs.push(ptr);\n                    return ptr;\n                }\n            }\n            else {\n                return bufOrNum;\n            }\n        });\n    }\n    getOutputPtrs(outLens) {\n        return outLens.map(len => {\n            // If the obj is variable length, we need a 4 byte ptr to write the serialized data address to.\n            // WARNING: 4 only works with WASM as it has 32 bit memory.\n            const size = len || 4;\n            if (size <= this.outScratchRemaining) {\n                return (this.outScratchRemaining -= size);\n            }\n            else {\n                const ptr = this.wasm.call('bbmalloc', size);\n                this.allocs.push(ptr);\n                return ptr;\n            }\n        });\n    }\n    addOutputPtr(ptr) {\n        if (ptr >= 1024) {\n            this.allocs.push(ptr);\n        }\n    }\n    freeAll() {\n        for (const ptr of this.allocs) {\n            this.wasm.call('bbfree', ptr);\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVhcF9hbGxvY2F0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fbWFpbi9oZWFwX2FsbG9jYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQTs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxPQUFPLGFBQWE7SUFLeEIsWUFBb0IsSUFBMEI7UUFBMUIsU0FBSSxHQUFKLElBQUksQ0FBc0I7UUFKdEMsV0FBTSxHQUFhLEVBQUUsQ0FBQztRQUN0Qix1QkFBa0IsR0FBRyxJQUFJLENBQUM7UUFDMUIsd0JBQW1CLEdBQUcsSUFBSSxDQUFDO0lBRWMsQ0FBQztJQUVsRCxTQUFTLENBQUMsT0FBZ0M7UUFDeEMsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzVCLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFLENBQUM7Z0JBQ2pDLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztvQkFDL0MsTUFBTSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUN6RCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7b0JBQ3JDLE9BQU8sR0FBRyxDQUFDO2dCQUNiLENBQUM7cUJBQU0sQ0FBQztvQkFDTixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUN4RCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7b0JBQ3JDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN0QixPQUFPLEdBQUcsQ0FBQztnQkFDYixDQUFDO1lBQ0gsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLE9BQU8sUUFBUSxDQUFDO1lBQ2xCLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxhQUFhLENBQUMsT0FBK0I7UUFDM0MsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3ZCLCtGQUErRjtZQUMvRiwyREFBMkQ7WUFDM0QsTUFBTSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQztZQUV0QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztnQkFDckMsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsSUFBSSxJQUFJLENBQUMsQ0FBQztZQUM1QyxDQUFDO2lCQUFNLENBQUM7Z0JBQ04sTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUM3QyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDdEIsT0FBTyxHQUFHLENBQUM7WUFDYixDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsWUFBWSxDQUFDLEdBQVc7UUFDdEIsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7WUFDaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEIsQ0FBQztJQUNILENBQUM7SUFFRCxPQUFPO1FBQ0wsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2hDLENBQUM7SUFDSCxDQUFDO0NBQ0YifQ==\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_main/index.ts\n\n\n\n\n\nconst barretenberg_wasm_main_debug = browser_default()('bb.js:wasm');\n/**\n * This is the \"main thread\" implementation of BarretenbergWasm.\n * It spawns a bunch of \"child thread\" implementations.\n * In a browser context, this still runs on a worker, as it will block waiting on child threads.\n */\nclass BarretenbergWasmMain extends BarretenbergWasmBase {\n    constructor() {\n        super(...arguments);\n        this.workers = [];\n        this.remoteWasms = [];\n        this.nextWorker = 0;\n        this.nextThreadId = 1;\n    }\n    getNumThreads() {\n        return this.workers.length + 1;\n    }\n    /**\n     * Init as main thread. Spawn child threads.\n     */\n    async init(module, threads = Math.min(getNumCpu(), BarretenbergWasmMain.MAX_THREADS), logger = barretenberg_wasm_main_debug, initial = 32, maximum = 2 ** 16) {\n        this.logger = logger;\n        const initialMb = (initial * 2 ** 16) / (1024 * 1024);\n        const maxMb = (maximum * 2 ** 16) / (1024 * 1024);\n        const shared = getSharedMemoryAvailable();\n        this.logger(`initial mem: ${initial} pages, ${initialMb}MiB. ` +\n            `max mem: ${maximum} pages, ${maxMb}MiB. ` +\n            `threads: ${threads}, shared: ${shared}`);\n        this.memory = new WebAssembly.Memory({ initial, maximum, shared });\n        const instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));\n        this.instance = instance;\n        // Init all global/static data.\n        this.call('_initialize');\n        // Create worker threads. Create 1 less than requested, as main thread counts as a thread.\n        if (threads > 1) {\n            this.logger(`creating ${threads} worker threads...`);\n            this.workers = await Promise.all(Array.from({ length: threads - 1 }).map(createThreadWorker));\n            this.remoteWasms = await Promise.all(this.workers.map((getRemoteBarretenbergWasm)));\n            await Promise.all(this.remoteWasms.map(w => w.initThread(module, this.memory)));\n        }\n    }\n    /**\n     * Called on main thread. Signals child threads to gracefully exit.\n     */\n    async destroy() {\n        await Promise.all(this.workers.map(w => w.terminate()));\n    }\n    getImportObj(memory) {\n        const baseImports = super.getImportObj(memory);\n        /* eslint-disable camelcase */\n        return {\n            ...baseImports,\n            wasi: {\n                'thread-spawn': (arg) => {\n                    arg = arg >>> 0;\n                    const id = this.nextThreadId++;\n                    const worker = this.nextWorker++ % this.remoteWasms.length;\n                    // this.logger(`spawning thread ${id} on worker ${worker} with arg ${arg >>> 0}`);\n                    this.remoteWasms[worker].call('wasi_thread_start', id, arg).catch(this.logger);\n                    // this.remoteWasms[worker].postMessage({ msg: 'thread', data: { id, arg } });\n                    return id;\n                },\n            },\n            env: {\n                ...baseImports.env,\n                env_hardware_concurrency: () => {\n                    // If there are no workers (we're already running as a worker, or the main thread requested no workers)\n                    // then we return 1, which should cause any algos using threading to just not create a thread.\n                    return this.remoteWasms.length + 1;\n                },\n            },\n        };\n        /* eslint-enable camelcase */\n    }\n    callWasmExport(funcName, inArgs, outLens) {\n        const alloc = new HeapAllocator(this);\n        const inPtrs = alloc.getInputs(inArgs);\n        const outPtrs = alloc.getOutputPtrs(outLens);\n        this.call(funcName, ...inPtrs, ...outPtrs);\n        const outArgs = this.getOutputArgs(outLens, outPtrs, alloc);\n        alloc.freeAll();\n        return outArgs;\n    }\n    getOutputArgs(outLens, outPtrs, alloc) {\n        return outLens.map((len, i) => {\n            if (len) {\n                return this.getMemorySlice(outPtrs[i], outPtrs[i] + len);\n            }\n            const slice = this.getMemorySlice(outPtrs[i], outPtrs[i] + 4);\n            const ptr = new DataView(slice.buffer, slice.byteOffset, slice.byteLength).getUint32(0, true);\n            // Add our heap buffer to the dealloc list.\n            alloc.addOutputPtr(ptr);\n            // The length will be found in the first 4 bytes of the buffer, big endian. See to_heap_buffer.\n            const lslice = this.getMemorySlice(ptr, ptr + 4);\n            const length = new DataView(lslice.buffer, lslice.byteOffset, lslice.byteLength).getUint32(0, false);\n            return this.getMemorySlice(ptr + 4, ptr + 4 + length);\n        });\n    }\n}\nBarretenbergWasmMain.MAX_THREADS = 32;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fbWFpbi9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLFdBQVcsTUFBTSxPQUFPLENBQUM7QUFFaEMsT0FBTyxFQUFFLFNBQVMsRUFBRSx5QkFBeUIsRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JHLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBRXZGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUVwRCxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUM7QUFFeEM7Ozs7R0FJRztBQUNILE1BQU0sT0FBTyxvQkFBcUIsU0FBUSxvQkFBb0I7SUFBOUQ7O1FBRVUsWUFBTyxHQUFhLEVBQUUsQ0FBQztRQUN2QixnQkFBVyxHQUFtQyxFQUFFLENBQUM7UUFDakQsZUFBVSxHQUFHLENBQUMsQ0FBQztRQUNmLGlCQUFZLEdBQUcsQ0FBQyxDQUFDO0lBOEczQixDQUFDO0lBNUdRLGFBQWE7UUFDbEIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLElBQUksQ0FDZixNQUEwQixFQUMxQixPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxXQUFXLENBQUMsRUFDakUsU0FBZ0MsS0FBSyxFQUNyQyxPQUFPLEdBQUcsRUFBRSxFQUNaLE9BQU8sR0FBRyxDQUFDLElBQUksRUFBRTtRQUVqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUVyQixNQUFN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\n;// CONCATENATED MODULE: ./node_modules/ts-loader/index.js??ruleSet[1].rules[2].use[0]!./src/barretenberg_wasm/barretenberg_wasm_main/factory/browser/main.worker.ts\n\n\n\nself.onmessage = function (e) {\n    if (e.data.debug) {\n        browser_default().enable(e.data.debug);\n    }\n};\nexpose(new BarretenbergWasmMain());\nself.postMessage({ ready: true });\n/* harmony default export */ const main_worker = (null);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi53b3JrZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fbWFpbi9mYWN0b3J5L2Jyb3dzZXIvbWFpbi53b3JrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNqQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0RCxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFFMUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7SUFDMUIsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pCLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0FBQ0gsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLElBQUksb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO0FBRW5DLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUVsQyxlQUFlLElBQVcsQ0FBQyJ9\n})();\n\n","Worker",void 0,void 0)}function ue(){const e="undefined"!=typeof window?window:globalThis;return"undefined"!=typeof SharedArrayBuffer&&e.crossOriginIsolated}function fe(e){return A(e)}function he(){return ce()("/******/ var __webpack_modules__ = ({\n\n/***/ 227:\n/***/ ((module, exports, __webpack_require__) => {\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(447)(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n/***/ }),\n\n/***/ 447:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(824);\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n/***/ }),\n\n/***/ 824:\n/***/ ((module) => {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n/***/ })\n\n/******/ });\n/************************************************************************/\n/******/ // The module cache\n/******/ var __webpack_module_cache__ = {};\n/******/ \n/******/ // The require function\n/******/ function __webpack_require__(moduleId) {\n/******/ \t// Check if module is in cache\n/******/ \tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \tif (cachedModule !== undefined) {\n/******/ \t\treturn cachedModule.exports;\n/******/ \t}\n/******/ \t// Create a new module (and put it into the cache)\n/******/ \tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t// no module.id needed\n/******/ \t\t// no module.loaded needed\n/******/ \t\texports: {}\n/******/ \t};\n/******/ \n/******/ \t// Execute the module function\n/******/ \t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \n/******/ \t// Return the exports of the module\n/******/ \treturn module.exports;\n/******/ }\n/******/ \n/************************************************************************/\n/******/ /* webpack/runtime/compat get default export */\n/******/ (() => {\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = (module) => {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t() => (module['default']) :\n/******/ \t\t\t() => (module);\n/******/ \t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\treturn getter;\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/define property getters */\n/******/ (() => {\n/******/ \t// define getter functions for harmony exports\n/******/ \t__webpack_require__.d = (exports, definition) => {\n/******/ \t\tfor(var key in definition) {\n/******/ \t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/hasOwnProperty shorthand */\n/******/ (() => {\n/******/ \t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ })();\n/******/ \n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\n\n// UNUSED EXPORTS: default\n\n;// CONCATENATED MODULE: ./node_modules/comlink/dist/esm/comlink.mjs\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return comlink_wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction comlink_wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\n\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/helpers/browser/index.ts\n\nfunction getSharedMemoryAvailable() {\n    const globalScope = typeof window !== 'undefined' ? window : globalThis;\n    return typeof SharedArrayBuffer !== 'undefined' && globalScope.crossOriginIsolated;\n}\nfunction getRemoteBarretenbergWasm(worker) {\n    return wrap(worker);\n}\nfunction getNumCpu() {\n    return navigator.hardwareConcurrency;\n}\nfunction threadLogger() {\n    return undefined;\n}\nfunction killSelf() {\n    self.close();\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vaGVscGVycy9icm93c2VyL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFL0IsTUFBTSxVQUFVLHdCQUF3QjtJQUN0QyxNQUFNLFdBQVcsR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO0lBQ3hFLE9BQU8sT0FBTyxpQkFBaUIsS0FBSyxXQUFXLElBQUksV0FBVyxDQUFDLG1CQUFtQixDQUFDO0FBQ3JGLENBQUM7QUFFRCxNQUFNLFVBQVUseUJBQXlCLENBQUksTUFBYztJQUN6RCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQU0sQ0FBQztBQUMzQixDQUFDO0FBRUQsTUFBTSxVQUFVLFNBQVM7SUFDdkIsT0FBTyxTQUFTLENBQUMsbUJBQW1CLENBQUM7QUFDdkMsQ0FBQztBQUVELE1BQU0sVUFBVSxZQUFZO0lBQzFCLE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRCxNQUFNLFVBQVUsUUFBUTtJQUN0QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDZixDQUFDIn0=\n// EXTERNAL MODULE: ./node_modules/debug/src/browser.js\nvar browser = __webpack_require__(227);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n;// CONCATENATED MODULE: ./src/random/browser/index.ts\nconst randomBytes = (len) => {\n    const getWebCrypto = () => {\n        if (typeof window !== 'undefined' && window.crypto)\n            return window.crypto;\n        if (typeof globalThis !== 'undefined' && globalThis.crypto)\n            return globalThis.crypto;\n        return undefined;\n    };\n    const crypto = getWebCrypto();\n    if (!crypto) {\n        throw new Error('randomBytes UnsupportedEnvironment');\n    }\n    const buf = new Uint8Array(len);\n    // limit of Crypto.getRandomValues()\n    // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\n    const MAX_BYTES = 65536;\n    if (len > MAX_BYTES) {\n        // this is the max bytes crypto.getRandomValues\n        // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n        for (let generated = 0; generated < len; generated += MAX_BYTES) {\n            // buffer.slice automatically checks if the end is past the end of\n            // the buffer so we don't have to here\n            crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));\n        }\n    }\n    else {\n        crypto.getRandomValues(buf);\n    }\n    return buf;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvcmFuZG9tL2Jyb3dzZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBVyxFQUFFLEVBQUU7SUFDekMsTUFBTSxZQUFZLEdBQUcsR0FBRyxFQUFFO1FBQ3hCLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFJLE1BQU0sQ0FBQyxNQUFNO1lBQUUsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ3pFLElBQUksT0FBTyxVQUFVLEtBQUssV0FBVyxJQUFJLFVBQVUsQ0FBQyxNQUFNO1lBQUUsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDO1FBQ3JGLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUMsQ0FBQztJQUVGLE1BQU0sTUFBTSxHQUFHLFlBQVksRUFBRSxDQUFDO0lBQzlCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQUcsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFaEMsb0NBQW9DO0lBQ3BDLDBFQUEwRTtJQUMxRSxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFFeEIsSUFBSSxHQUFHLEdBQUcsU0FBUyxFQUFFLENBQUM7UUFDcEIsK0NBQStDO1FBQy9DLG9HQUFvRztRQUNwRyxLQUFLLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsR0FBRyxFQUFFLFNBQVMsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNoRSxrRUFBa0U7WUFDbEUsc0NBQXNDO1lBQ3RDLE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDekUsQ0FBQztJQUNILENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDLENBQUMifQ==\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_base/index.ts\n\n\nconst debug = browser_default()('bb.js:wasm');\n/**\n * Base implementation of BarretenbergWasm.\n * Contains code that is common to the \"main thread\" implementation and the \"child thread\" implementation.\n */\nclass BarretenbergWasmBase {\n    constructor() {\n        this.memStore = {};\n        this.logger = debug;\n    }\n    getImportObj(memory) {\n        /* eslint-disable camelcase */\n        const importObj = {\n            // We need to implement a part of the wasi api:\n            // https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md\n            // We literally only need to support random_get, everything else is noop implementated in barretenberg.wasm.\n            wasi_snapshot_preview1: {\n                random_get: (out, length) => {\n                    out = out >>> 0;\n                    const randomData = randomBytes(length);\n                    const mem = this.getMemory();\n                    mem.set(randomData, out);\n                },\n                clock_time_get: (a1, a2, out) => {\n                    out = out >>> 0;\n                    const ts = BigInt(new Date().getTime()) * 1000000n;\n                    const view = new DataView(this.getMemory().buffer);\n                    view.setBigUint64(out, ts, true);\n                },\n                proc_exit: () => {\n                    this.logger('PANIC: proc_exit was called.');\n                    throw new Error();\n                },\n            },\n            // These are functions implementations for imports we've defined are needed.\n            // The native C++ build defines these in a module called \"env\". We must implement TypeScript versions here.\n            env: {\n                /**\n                 * The 'info' call we use for logging in C++, calls this under the hood.\n                 * The native code will just print to std:err (to avoid std::cout which is used for IPC).\n                 * Here we just emit the log line for the client to decide what to do with.\n                 */\n                logstr: (addr) => {\n                    const str = this.stringFromAddress(addr);\n                    const m = this.getMemory();\n                    const str2 = `${str} (mem: ${(m.length / (1024 * 1024)).toFixed(2)}MiB)`;\n                    this.logger(str2);\n                    if (str2.startsWith('WARNING:')) {\n                        this.logger(new Error().stack);\n                    }\n                },\n                get_data: (keyAddr, outBufAddr) => {\n                    const key = this.stringFromAddress(keyAddr);\n                    outBufAddr = outBufAddr >>> 0;\n                    const data = this.memStore[key];\n                    if (!data) {\n                        this.logger(`get_data miss ${key}`);\n                        return;\n                    }\n                    // this.logger(`get_data hit ${key} size: ${data.length} dest: ${outBufAddr}`);\n                    // this.logger(Buffer.from(data.slice(0, 64)).toString('hex'));\n                    this.writeMemory(outBufAddr, data);\n                },\n                set_data: (keyAddr, dataAddr, dataLength) => {\n                    const key = this.stringFromAddress(keyAddr);\n                    dataAddr = dataAddr >>> 0;\n                    this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);\n                    // this.logger(`set_data: ${key} length: ${dataLength}`);\n                },\n                memory,\n            },\n        };\n        /* eslint-enable camelcase */\n        return importObj;\n    }\n    exports() {\n        return this.instance.exports;\n    }\n    /**\n     * When returning values from the WASM, use >>> operator to convert signed representation to unsigned representation.\n     */\n    call(name, ...args) {\n        if (!this.exports()[name]) {\n            throw new Error(`WASM function ${name} not found.`);\n        }\n        try {\n            return this.exports()[name](...args) >>> 0;\n        }\n        catch (err) {\n            const message = `WASM function ${name} aborted, error: ${err}`;\n            this.logger(message);\n            this.logger(err.stack);\n            throw err;\n        }\n    }\n    memSize() {\n        return this.getMemory().length;\n    }\n    /**\n     * Returns a copy of the data, not a view.\n     */\n    getMemorySlice(start, end) {\n        return this.getMemory().subarray(start, end).slice();\n    }\n    writeMemory(offset, arr) {\n        const mem = this.getMemory();\n        mem.set(arr, offset);\n    }\n    // PRIVATE METHODS\n    getMemory() {\n        return new Uint8Array(this.memory.buffer);\n    }\n    stringFromAddress(addr) {\n        addr = addr >>> 0;\n        const m = this.getMemory();\n        let i = addr;\n        for (; m[i] !== 0; ++i)\n            ;\n        const textDecoder = new TextDecoder('ascii');\n        return textDecoder.decode(m.slice(addr, i));\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fYmFzZS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFdBQVcsTUFBTSxPQUFPLENBQUM7QUFDaEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXBELE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUV4Qzs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sb0JBQW9CO0lBQWpDO1FBQ1ksYUFBUSxHQUFrQyxFQUFFLENBQUM7UUFHN0MsV0FBTSxHQUEwQixLQUFLLENBQUM7SUE0SGxELENBQUM7SUExSFcsWUFBWSxDQUFDLE1BQTBCO1FBQy9DLDhCQUE4QjtRQUM5QixNQUFNLFNBQVMsR0FBRztZQUNoQiwrQ0FBK0M7WUFDL0Msd0VBQXdFO1lBQ3hFLDRHQUE0RztZQUM1RyxzQkFBc0IsRUFBRTtnQkFDdEIsVUFBVSxFQUFFLENBQUMsR0FBUSxFQUFFLE1BQWMsRUFBRSxFQUFFO29CQUN2QyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQztvQkFDaEIsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUN2QyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7b0JBQzdCLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUMzQixDQUFDO2dCQUNELGNBQWMsRUFBRSxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsR0FBVyxFQUFFLEVBQUU7b0JBQ3RELEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDO29CQUNoQixNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLFFBQVEs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\n;// CONCATENATED MODULE: ./src/barretenberg_wasm/barretenberg_wasm_thread/index.ts\n\n\nclass BarretenbergWasmThread extends BarretenbergWasmBase {\n    /**\n     * Init as worker thread.\n     */\n    async initThread(module, memory) {\n        this.logger = threadLogger() || this.logger;\n        this.memory = memory;\n        this.instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));\n    }\n    destroy() {\n        killSelf();\n    }\n    getImportObj(memory) {\n        const baseImports = super.getImportObj(memory);\n        /* eslint-disable camelcase */\n        return {\n            ...baseImports,\n            wasi: {\n                'thread-spawn': () => {\n                    this.logger('PANIC: threads cannot spawn threads!');\n                    this.logger(new Error().stack);\n                    killSelf();\n                },\n            },\n            // These are functions implementations for imports we've defined are needed.\n            // The native C++ build defines these in a module called \"env\". We must implement TypeScript versions here.\n            env: {\n                ...baseImports.env,\n                env_hardware_concurrency: () => {\n                    // We return 1, which should cause any algos using threading to just not create a thread.\n                    return 1;\n                },\n            },\n        };\n        /* eslint-enable camelcase */\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fdGhyZWFkL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDN0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFFMUUsTUFBTSxPQUFPLHNCQUF1QixTQUFRLG9CQUFvQjtJQUM5RDs7T0FFRztJQUNJLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBMEIsRUFBRSxNQUEwQjtRQUM1RSxJQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDNUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLFdBQVcsQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDeEYsQ0FBQztJQUVNLE9BQU87UUFDWixRQUFRLEVBQUUsQ0FBQztJQUNiLENBQUM7SUFFUyxZQUFZLENBQUMsTUFBMEI7UUFDL0MsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUvQyw4QkFBOEI7UUFDOUIsT0FBTztZQUNMLEdBQUcsV0FBVztZQUNkLElBQUksRUFBRTtnQkFDSixjQUFjLEVBQUUsR0FBRyxFQUFFO29CQUNuQixJQUFJLENBQUMsTUFBTSxDQUFDLHNDQUFzQyxDQUFDLENBQUM7b0JBQ3BELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxLQUFNLENBQUMsQ0FBQztvQkFDaEMsUUFBUSxFQUFFLENBQUM7Z0JBQ2IsQ0FBQzthQUNGO1lBRUQsNEVBQTRFO1lBQzVFLDJHQUEyRztZQUMzRyxHQUFHLEVBQUU7Z0JBQ0gsR0FBRyxXQUFXLENBQUMsR0FBRztnQkFDbEIsd0JBQXdCLEVBQUUsR0FBRyxFQUFFO29CQUM3Qix5RkFBeUY7b0JBQ3pGLE9BQU8sQ0FBQyxDQUFDO2dCQUNYLENBQUM7YUFDRjtTQUNGLENBQUM7UUFDRiw2QkFBNkI7SUFDL0IsQ0FBQztDQUNGIn0=\n;// CONCATENATED MODULE: ./node_modules/ts-loader/index.js??ruleSet[1].rules[2].use[0]!./src/barretenberg_wasm/barretenberg_wasm_thread/factory/browser/thread.worker.ts\n\n\n\nself.onmessage = function (e) {\n    if (e.data.debug) {\n        browser_default().enable(e.data.debug);\n    }\n};\nexpose(new BarretenbergWasmThread());\nself.postMessage({ ready: true });\n/* harmony default export */ const thread_worker = (null);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhyZWFkLndvcmtlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9iYXJyZXRlbmJlcmdfd2FzbS9iYXJyZXRlbmJlcmdfd2FzbV90aHJlYWQvZmFjdG9yeS9icm93c2VyL3RocmVhZC53b3JrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNqQyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4RCxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFFMUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7SUFDMUIsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pCLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0FBQ0gsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLElBQUksc0JBQXNCLEVBQUUsQ0FBQyxDQUFDO0FBRXJDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUVsQyxlQUFlLElBQVcsQ0FBQyJ9\n})();\n\n","Worker",void 0,void 0)}function pe(){const e=new he,t=oe().disable();return oe().enable(t),e.postMessage({debug:t}),e}const me=oe()("bb.js:wasm");class ge{constructor(){this.memStore={},this.logger=me}getImportObj(e){return{wasi_snapshot_preview1:{random_get:(e,t)=>{e>>>=0;const n=G(t);this.getMemory().set(n,e)},clock_time_get:(e,t,n)=>{n>>>=0;const s=1000000n*BigInt((new Date).getTime());new DataView(this.getMemory().buffer).setBigUint64(n,s,!0)},proc_exit:()=>{throw this.logger("PANIC: proc_exit was called."),new Error}},env:{logstr:e=>{const t=`${this.stringFromAddress(e)} (mem: ${(this.getMemory().length/1048576).toFixed(2)}MiB)`;this.logger(t),t.startsWith("WARNING:")&&this.logger((new Error).stack)},get_data:(e,t)=>{const n=this.stringFromAddress(e);t>>>=0;const s=this.memStore[n];s?this.writeMemory(t,s):this.logger(`get_data miss ${n}`)},set_data:(e,t,n)=>{const s=this.stringFromAddress(e);t>>>=0,this.memStore[s]=this.getMemorySlice(t,t+n)},memory:e}}}exports(){return this.instance.exports}call(e,...t){if(!this.exports()[e])throw new Error(`WASM function ${e} not found.`);try{return this.exports()[e](...t)>>>0}catch(t){const n=`WASM function ${e} aborted, error: ${t}`;throw this.logger(n),this.logger(t.stack),t}}memSize(){return this.getMemory().length}getMemorySlice(e,t){return this.getMemory().subarray(e,t).slice()}writeMemory(e,t){this.getMemory().set(t,e)}getMemory(){return new Uint8Array(this.memory.buffer)}stringFromAddress(e){e>>>=0;const t=this.getMemory();let n=e;for(;0!==t[n];++n);return new TextDecoder("ascii").decode(t.slice(e,n))}}class _e{constructor(e){this.wasm=e,this.allocs=[],this.inScratchRemaining=1024,this.outScratchRemaining=1024}getInputs(e){return e.map((e=>{if("object"==typeof e){if(e.length<=this.inScratchRemaining){const t=this.inScratchRemaining-=e.length;return this.wasm.writeMemory(t,e),t}{const t=this.wasm.call("bbmalloc",e.length);return this.wasm.writeMemory(t,e),this.allocs.push(t),t}}return e}))}getOutputPtrs(e){return e.map((e=>{const t=e||4;if(t<=this.outScratchRemaining)return this.outScratchRemaining-=t;{const e=this.wasm.call("bbmalloc",t);return this.allocs.push(e),e}}))}addOutputPtr(e){e>=1024&&this.allocs.push(e)}freeAll(){for(const e of this.allocs)this.wasm.call("bbfree",e)}}const be=oe()("bb.js:wasm");class ye extends ge{constructor(){super(...arguments),this.workers=[],this.remoteWasms=[],this.nextWorker=0,this.nextThreadId=1}getNumThreads(){return this.workers.length+1}async init(e,t=Math.min(function(){return navigator.hardwareConcurrency}(),ye.MAX_THREADS),n=be,s=32,i=65536){this.logger=n;const r=65536*s/1048576,a=65536*i/1048576,o=ue();this.logger(`initial mem: ${s} pages, ${r}MiB. max mem: ${i} pages, ${a}MiB. threads: ${t}, shared: ${o}`),this.memory=new WebAssembly.Memory({initial:s,maximum:i,shared:o});const l=await WebAssembly.instantiate(e,this.getImportObj(this.memory));this.instance=l,this.call("_initialize"),t>1&&(this.logger(`creating ${t} worker threads...`),this.workers=await Promise.all(Array.from({length:t-1}).map(pe)),this.remoteWasms=await Promise.all(this.workers.map(fe)),await Promise.all(this.remoteWasms.map((t=>t.initThread(e,this.memory)))))}async destroy(){await Promise.all(this.workers.map((e=>e.terminate())))}getImportObj(e){const t=super.getImportObj(e);return{...t,wasi:{"thread-spawn":e=>{e>>>=0;const t=this.nextThreadId++,n=this.nextWorker++%this.remoteWasms.length;return this.remoteWasms[n].call("wasi_thread_start",t,e).catch(this.logger),t}},env:{...t.env,env_hardware_concurrency:()=>this.remoteWasms.length+1}}}callWasmExport(e,t,n){const s=new _e(this),i=s.getInputs(t),r=s.getOutputPtrs(n);this.call(e,...i,...r);const a=this.getOutputArgs(n,r,s);return s.freeAll(),a}getOutputArgs(e,t,n){return e.map(((e,s)=>{if(e)return this.getMemorySlice(t[s],t[s]+e);const i=this.getMemorySlice(t[s],t[s]+4),r=new DataView(i.buffer,i.byteOffset,i.byteLength).getUint32(0,!0);n.addOutputPtr(r);const a=this.getMemorySlice(r,r+4),o=new DataView(a.buffer,a.byteOffset,a.byteLength).getUint32(0,!1);return this.getMemorySlice(r+4,r+4+o)}))}}ye.MAX_THREADS=32;function Ae(e){let t=e.length;for(;--t>=0;)e[t]=0}const we=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),xe=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),ve=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),Ee=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Me=new Array(576);Ae(Me);const ze=new Array(60);Ae(ze);const Be=new Array(512);Ae(Be);const Fe=new Array(256);Ae(Fe);const ke=new Array(29);Ae(ke);const Ce=new Array(30);function Oe(e,t,n,s,i){this.static_tree=e,this.extra_bits=t,this.extra_base=n,this.elems=s,this.max_length=i,this.has_stree=e&&e.length}let De,Le,Te;function Se(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}Ae(Ce);const Ne=e=>e<256?Be[e]:Be[256+(e>>>7)],Pe=(e,t)=>{e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255},Ie=(e,t,n)=>{e.bi_valid>16-n?(e.bi_buf|=t<<e.bi_valid&65535,Pe(e,e.bi_buf),e.bi_buf=t>>16-e.bi_valid,e.bi_valid+=n-16):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=n)},Ye=(e,t,n)=>{Ie(e,n[2*t],n[2*t+1])},Qe=(e,t)=>{let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1},je=(e,t,n)=>{const s=new Array(16);let i,r,a=0;for(i=1;i<=15;i++)a=a+n[i-1]<<1,s[i]=a;for(r=0;r<=t;r++){let t=e[2*r+1];0!==t&&(e[2*r]=Qe(s[t]++,t))}},He=e=>{let t;for(t=0;t<286;t++)e.dyn_ltree[2*t]=0;for(t=0;t<30;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.sym_next=e.matches=0},Ue=e=>{e.bi_valid>8?Pe(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0},Re=(e,t,n,s)=>{const i=2*t,r=2*n;return e[i]<e[r]||e[i]===e[r]&&s[t]<=s[n]},Ge=(e,t,n)=>{const s=e.heap[n];let i=n<<1;for(;i<=e.heap_len&&(i<e.heap_len&&Re(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!Re(t,s,e.heap[i],e.depth));)e.heap[n]=e.heap[i],n=i,i<<=1;e.heap[n]=s},Ze=(e,t,n)=>{let s,i,r,a,o=0;if(0!==e.sym_next)do{s=255&e.pending_buf[e.sym_buf+o++],s+=(255&e.pending_buf[e.sym_buf+o++])<<8,i=e.pending_buf[e.sym_buf+o++],0===s?Ye(e,i,t):(r=Fe[i],Ye(e,r+256+1,t),a=we[r],0!==a&&(i-=ke[r],Ie(e,i,a)),s--,r=Ne(s),Ye(e,r,n),a=xe[r],0!==a&&(s-=Ce[r],Ie(e,s,a)))}while(o<e.sym_next);Ye(e,256,t)},Je=(e,t)=>{const n=t.dyn_tree,s=t.stat_desc.static_tree,i=t.stat_desc.has_stree,r=t.stat_desc.elems;let a,o,l,c=-1;for(e.heap_len=0,e.heap_max=573,a=0;a<r;a++)0!==n[2*a]?(e.heap[++e.heap_len]=c=a,e.depth[a]=0):n[2*a+1]=0;for(;e.heap_len<2;)l=e.heap[++e.heap_len]=c<2?++c:0,n[2*l]=1,e.depth[l]=0,e.opt_len--,i&&(e.static_len-=s[2*l+1]);for(t.max_code=c,a=e.heap_len>>1;a>=1;a--)Ge(e,n,a);l=r;do{a=e.heap[1],e.heap[1]=e.heap[e.heap_len--],Ge(e,n,1),o=e.heap[1],e.heap[--e.heap_max]=a,e.heap[--e.heap_max]=o,n[2*l]=n[2*a]+n[2*o],e.depth[l]=(e.depth[a]>=e.depth[o]?e.depth[a]:e.depth[o])+1,n[2*a+1]=n[2*o+1]=l,e.heap[1]=l++,Ge(e,n,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],((e,t)=>{const n=t.dyn_tree,s=t.max_code,i=t.stat_desc.static_tree,r=t.stat_desc.has_stree,a=t.stat_desc.extra_bits,o=t.stat_desc.extra_base,l=t.stat_desc.max_length;let c,d,u,f,h,p,m=0;for(f=0;f<=15;f++)e.bl_count[f]=0;for(n[2*e.heap[e.heap_max]+1]=0,c=e.heap_max+1;c<573;c++)d=e.heap[c],f=n[2*n[2*d+1]+1]+1,f>l&&(f=l,m++),n[2*d+1]=f,d>s||(e.bl_count[f]++,h=0,d>=o&&(h=a[d-o]),p=n[2*d],e.opt_len+=p*(f+h),r&&(e.static_len+=p*(i[2*d+1]+h)));if(0!==m){do{for(f=l-1;0===e.bl_count[f];)f--;e.bl_count[f]--,e.bl_count[f+1]+=2,e.bl_count[l]--,m-=2}while(m>0);for(f=l;0!==f;f--)for(d=e.bl_count[f];0!==d;)u=e.heap[--c],u>s||(n[2*u+1]!==f&&(e.opt_len+=(f-n[2*u+1])*n[2*u],n[2*u+1]=f),d--)}})(e,t),je(n,c,e.bl_count)},Xe=(e,t,n)=>{let s,i,r=-1,a=t[1],o=0,l=7,c=4;for(0===a&&(l=138,c=3),t[2*(n+1)+1]=65535,s=0;s<=n;s++)i=a,a=t[2*(s+1)+1],++o<l&&i===a||(o<c?e.bl_tree[2*i]+=o:0!==i?(i!==r&&e.bl_tree[2*i]++,e.bl_tree[32]++):o<=10?e.bl_tree[34]++:e.bl_tree[36]++,o=0,r=i,0===a?(l=138,c=3):i===a?(l=6,c=3):(l=7,c=4))},We=(e,t,n)=>{let s,i,r=-1,a=t[1],o=0,l=7,c=4;for(0===a&&(l=138,c=3),s=0;s<=n;s++)if(i=a,a=t[2*(s+1)+1],!(++o<l&&i===a)){if(o<c)do{Ye(e,i,e.bl_tree)}while(0!=--o);else 0!==i?(i!==r&&(Ye(e,i,e.bl_tree),o--),Ye(e,16,e.bl_tree),Ie(e,o-3,2)):o<=10?(Ye(e,17,e.bl_tree),Ie(e,o-3,3)):(Ye(e,18,e.bl_tree),Ie(e,o-11,7));o=0,r=i,0===a?(l=138,c=3):i===a?(l=6,c=3):(l=7,c=4)}};let Ve=!1;const qe=(e,t,n,s)=>{Ie(e,0+(s?1:0),3),Ue(e),Pe(e,n),Pe(e,~n),n&&e.pending_buf.set(e.window.subarray(t,t+n),e.pending),e.pending+=n};var Ke={_tr_init:e=>{Ve||((()=>{let e,t,n,s,i;const r=new Array(16);for(n=0,s=0;s<28;s++)for(ke[s]=n,e=0;e<1<<we[s];e++)Fe[n++]=s;for(Fe[n-1]=s,i=0,s=0;s<16;s++)for(Ce[s]=i,e=0;e<1<<xe[s];e++)Be[i++]=s;for(i>>=7;s<30;s++)for(Ce[s]=i<<7,e=0;e<1<<xe[s]-7;e++)Be[256+i++]=s;for(t=0;t<=15;t++)r[t]=0;for(e=0;e<=143;)Me[2*e+1]=8,e++,r[8]++;for(;e<=255;)Me[2*e+1]=9,e++,r[9]++;for(;e<=279;)Me[2*e+1]=7,e++,r[7]++;for(;e<=287;)Me[2*e+1]=8,e++,r[8]++;for(je(Me,287,r),e=0;e<30;e++)ze[2*e+1]=5,ze[2*e]=Qe(e,5);De=new Oe(Me,we,257,286,15),Le=new Oe(ze,xe,0,30,15),Te=new Oe(new Array(0),ve,0,19,7)})(),Ve=!0),e.l_desc=new Se(e.dyn_ltree,De),e.d_desc=new Se(e.dyn_dtree,Le),e.bl_desc=new Se(e.bl_tree,Te),e.bi_buf=0,e.bi_valid=0,He(e)},_tr_stored_block:qe,_tr_flush_block:(e,t,n,s)=>{let i,r,a=0;e.level>0?(2===e.strm.data_type&&(e.strm.data_type=(e=>{let t,n=4093624447;for(t=0;t<=31;t++,n>>>=1)if(1&n&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<256;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0})(e)),Je(e,e.l_desc),Je(e,e.d_desc),a=(e=>{let t;for(Xe(e,e.dyn_ltree,e.l_desc.max_code),Xe(e,e.dyn_dtree,e.d_desc.max_code),Je(e,e.bl_desc),t=18;t>=3&&0===e.bl_tree[2*Ee[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t})(e),i=e.opt_len+3+7>>>3,r=e.static_len+3+7>>>3,r<=i&&(i=r)):i=r=n+5,n+4<=i&&-1!==t?qe(e,t,n,s):4===e.strategy||r===i?(Ie(e,2+(s?1:0),3),Ze(e,Me,ze)):(Ie(e,4+(s?1:0),3),((e,t,n,s)=>{let i;for(Ie(e,t-257,5),Ie(e,n-1,5),Ie(e,s-4,4),i=0;i<s;i++)Ie(e,e.bl_tree[2*Ee[i]+1],3);We(e,e.dyn_ltree,t-1),We(e,e.dyn_dtree,n-1)})(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),Ze(e,e.dyn_ltree,e.dyn_dtree)),He(e),s&&Ue(e)},_tr_tally:(e,t,n)=>(e.pending_buf[e.sym_buf+e.sym_next++]=t,e.pending_buf[e.sym_buf+e.sym_next++]=t>>8,e.pending_buf[e.sym_buf+e.sym_next++]=n,0===t?e.dyn_ltree[2*n]++:(e.matches++,t--,e.dyn_ltree[2*(Fe[n]+256+1)]++,e.dyn_dtree[2*Ne(t)]++),e.sym_next===e.sym_end),_tr_align:e=>{Ie(e,2,3),Ye(e,256,Me),(e=>{16===e.bi_valid?(Pe(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)})(e)}},$e=(e,t,n,s)=>{let i=65535&e,r=e>>>16&65535,a=0;for(;0!==n;){a=n>2e3?2e3:n,n-=a;do{i=i+t[s++]|0,r=r+i|0}while(--a);i%=65521,r%=65521}return i|r<<16};const et=new Uint32Array((()=>{let e,t=[];for(var n=0;n<256;n++){e=n;for(var s=0;s<8;s++)e=1&e?3988292384^e>>>1:e>>>1;t[n]=e}return t})());var tt=(e,t,n,s)=>{const i=et,r=s+n;e^=-1;for(let n=s;n<r;n++)e=e>>>8^i[255&(e^t[n])];return~e},nt={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},st={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:it,_tr_stored_block:rt,_tr_flush_block:at,_tr_tally:ot,_tr_align:lt}=Ke,{Z_NO_FLUSH:ct,Z_PARTIAL_FLUSH:dt,Z_FULL_FLUSH:ut,Z_FINISH:ft,Z_BLOCK:ht,Z_OK:pt,Z_STREAM_END:mt,Z_STREAM_ERROR:gt,Z_DATA_ERROR:_t,Z_BUF_ERROR:bt,Z_DEFAULT_COMPRESSION:yt,Z_FILTERED:At,Z_HUFFMAN_ONLY:wt,Z_RLE:xt,Z_FIXED:vt,Z_DEFAULT_STRATEGY:Et,Z_UNKNOWN:Mt,Z_DEFLATED:zt}=st,Bt=258,Ft=262,kt=42,Ct=113,Ot=666,Dt=(e,t)=>(e.msg=nt[t],t),Lt=e=>2*e-(e>4?9:0),Tt=e=>{let t=e.length;for(;--t>=0;)e[t]=0},St=e=>{let t,n,s,i=e.w_size;t=e.hash_size,s=t;do{n=e.head[--s],e.head[s]=n>=i?n-i:0}while(--t);t=i,s=t;do{n=e.prev[--s],e.prev[s]=n>=i?n-i:0}while(--t)};let Nt=(e,t,n)=>(t<<e.hash_shift^n)&e.hash_mask;const Pt=e=>{const t=e.state;let n=t.pending;n>e.avail_out&&(n=e.avail_out),0!==n&&(e.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+n),e.next_out),e.next_out+=n,t.pending_out+=n,e.total_out+=n,e.avail_out-=n,t.pending-=n,0===t.pending&&(t.pending_out=0))},It=(e,t)=>{at(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,Pt(e.strm)},Yt=(e,t)=>{e.pending_buf[e.pending++]=t},Qt=(e,t)=>{e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t},jt=(e,t,n,s)=>{let i=e.avail_in;return i>s&&(i=s),0===i?0:(e.avail_in-=i,t.set(e.input.subarray(e.next_in,e.next_in+i),n),1===e.state.wrap?e.adler=$e(e.adler,t,i,n):2===e.state.wrap&&(e.adler=tt(e.adler,t,i,n)),e.next_in+=i,e.total_in+=i,i)},Ht=(e,t)=>{let n,s,i=e.max_chain_length,r=e.strstart,a=e.prev_length,o=e.nice_match;const l=e.strstart>e.w_size-Ft?e.strstart-(e.w_size-Ft):0,c=e.window,d=e.w_mask,u=e.prev,f=e.strstart+Bt;let h=c[r+a-1],p=c[r+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(n=t,c[n+a]===p&&c[n+a-1]===h&&c[n]===c[r]&&c[++n]===c[r+1]){r+=2,n++;do{}while(c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&r<f);if(s=Bt-(f-r),r=f-Bt,s>a){if(e.match_start=t,a=s,s>=o)break;h=c[r+a-1],p=c[r+a]}}}while((t=u[t&d])>l&&0!=--i);return a<=e.lookahead?a:e.lookahead},Ut=e=>{const t=e.w_size;let n,s,i;do{if(s=e.window_size-e.lookahead-e.strstart,e.strstart>=t+(t-Ft)&&(e.window.set(e.window.subarray(t,t+t-s),0),e.match_start-=t,e.strstart-=t,e.block_start-=t,e.insert>e.strstart&&(e.insert=e.strstart),St(e),s+=t),0===e.strm.avail_in)break;if(n=jt(e.strm,e.window,e.strstart+e.lookahead,s),e.lookahead+=n,e.lookahead+e.insert>=3)for(i=e.strstart-e.insert,e.ins_h=e.window[i],e.ins_h=Nt(e,e.ins_h,e.window[i+1]);e.insert&&(e.ins_h=Nt(e,e.ins_h,e.window[i+3-1]),e.prev[i&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=i,i++,e.insert--,!(e.lookahead+e.insert<3)););}while(e.lookahead<Ft&&0!==e.strm.avail_in)},Rt=(e,t)=>{let n,s,i,r=e.pending_buf_size-5>e.w_size?e.w_size:e.pending_buf_size-5,a=0,o=e.strm.avail_in;do{if(n=65535,i=e.bi_valid+42>>3,e.strm.avail_out<i)break;if(i=e.strm.avail_out-i,s=e.strstart-e.block_start,n>s+e.strm.avail_in&&(n=s+e.strm.avail_in),n>i&&(n=i),n<r&&(0===n&&t!==ft||t===ct||n!==s+e.strm.avail_in))break;a=t===ft&&n===s+e.strm.avail_in?1:0,rt(e,0,0,a),e.pending_buf[e.pending-4]=n,e.pending_buf[e.pending-3]=n>>8,e.pending_buf[e.pending-2]=~n,e.pending_buf[e.pending-1]=~n>>8,Pt(e.strm),s&&(s>n&&(s=n),e.strm.output.set(e.window.subarray(e.block_start,e.block_start+s),e.strm.next_out),e.strm.next_out+=s,e.strm.avail_out-=s,e.strm.total_out+=s,e.block_start+=s,n-=s),n&&(jt(e.strm,e.strm.output,e.strm.next_out,n),e.strm.next_out+=n,e.strm.avail_out-=n,e.strm.total_out+=n)}while(0===a);return o-=e.strm.avail_in,o&&(o>=e.w_size?(e.matches=2,e.window.set(e.strm.input.subarray(e.strm.next_in-e.w_size,e.strm.next_in),0),e.strstart=e.w_size,e.insert=e.strstart):(e.window_size-e.strstart<=o&&(e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,e.insert>e.strstart&&(e.insert=e.strstart)),e.window.set(e.strm.input.subarray(e.strm.next_in-o,e.strm.next_in),e.strstart),e.strstart+=o,e.insert+=o>e.w_size-e.insert?e.w_size-e.insert:o),e.block_start=e.strstart),e.high_water<e.strstart&&(e.high_water=e.strstart),a?4:t!==ct&&t!==ft&&0===e.strm.avail_in&&e.strstart===e.block_start?2:(i=e.window_size-e.strstart,e.strm.avail_in>i&&e.block_start>=e.w_size&&(e.block_start-=e.w_size,e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,i+=e.w_size,e.insert>e.strstart&&(e.insert=e.strstart)),i>e.strm.avail_in&&(i=e.strm.avail_in),i&&(jt(e.strm,e.window,e.strstart,i),e.strstart+=i,e.insert+=i>e.w_size-e.insert?e.w_size-e.insert:i),e.high_water<e.strstart&&(e.high_water=e.strstart),i=e.bi_valid+42>>3,i=e.pending_buf_size-i>65535?65535:e.pending_buf_size-i,r=i>e.w_size?e.w_size:i,s=e.strstart-e.block_start,(s>=r||(s||t===ft)&&t!==ct&&0===e.strm.avail_in&&s<=i)&&(n=s>i?i:s,a=t===ft&&0===e.strm.avail_in&&n===s?1:0,rt(e,e.block_start,n,a),e.block_start+=n,Pt(e.strm)),a?3:1)},Gt=(e,t)=>{let n,s;for(;;){if(e.lookahead<Ft){if(Ut(e),e.lookahead<Ft&&t===ct)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=Nt(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==n&&e.strstart-n<=e.w_size-Ft&&(e.match_length=Ht(e,n)),e.match_length>=3)if(s=ot(e,e.strstart-e.match_start,e.match_length-3),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=3){e.match_length--;do{e.strstart++,e.ins_h=Nt(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=Nt(e,e.ins_h,e.window[e.strstart+1]);else s=ot(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(s&&(It(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<2?e.strstart:2,t===ft?(It(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(It(e,!1),0===e.strm.avail_out)?1:2},Zt=(e,t)=>{let n,s,i;for(;;){if(e.lookahead<Ft){if(Ut(e),e.lookahead<Ft&&t===ct)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=Nt(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=2,0!==n&&e.prev_length<e.max_lazy_match&&e.strstart-n<=e.w_size-Ft&&(e.match_length=Ht(e,n),e.match_length<=5&&(e.strategy===At||3===e.match_length&&e.strstart-e.match_start>4096)&&(e.match_length=2)),e.prev_length>=3&&e.match_length<=e.prev_length){i=e.strstart+e.lookahead-3,s=ot(e,e.strstart-1-e.prev_match,e.prev_length-3),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=i&&(e.ins_h=Nt(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=2,e.strstart++,s&&(It(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if(s=ot(e,0,e.window[e.strstart-1]),s&&It(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(s=ot(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<2?e.strstart:2,t===ft?(It(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(It(e,!1),0===e.strm.avail_out)?1:2};function Jt(e,t,n,s,i){this.good_length=e,this.max_lazy=t,this.nice_length=n,this.max_chain=s,this.func=i}const Xt=[new Jt(0,0,0,0,Rt),new Jt(4,4,8,4,Gt),new Jt(4,5,16,8,Gt),new Jt(4,6,32,32,Gt),new Jt(4,4,16,16,Zt),new Jt(8,16,32,32,Zt),new Jt(8,16,128,128,Zt),new Jt(8,32,128,256,Zt),new Jt(32,128,258,1024,Zt),new Jt(32,258,258,4096,Zt)];function Wt(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=zt,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),Tt(this.dyn_ltree),Tt(this.dyn_dtree),Tt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),Tt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),Tt(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const Vt=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.status!==kt&&57!==t.status&&69!==t.status&&73!==t.status&&91!==t.status&&103!==t.status&&t.status!==Ct&&t.status!==Ot?1:0},qt=e=>{if(Vt(e))return Dt(e,gt);e.total_in=e.total_out=0,e.data_type=Mt;const t=e.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=2===t.wrap?57:t.wrap?kt:Ct,e.adler=2===t.wrap?0:1,t.last_flush=-2,it(t),pt},Kt=e=>{const t=qt(e);var n;return t===pt&&((n=e.state).window_size=2*n.w_size,Tt(n.head),n.max_lazy_match=Xt[n.level].max_lazy,n.good_match=Xt[n.level].good_length,n.nice_match=Xt[n.level].nice_length,n.max_chain_length=Xt[n.level].max_chain,n.strstart=0,n.block_start=0,n.lookahead=0,n.insert=0,n.match_length=n.prev_length=2,n.match_available=0,n.ins_h=0),t},$t=(e,t,n,s,i,r)=>{if(!e)return gt;let a=1;if(t===yt&&(t=6),s<0?(a=0,s=-s):s>15&&(a=2,s-=16),i<1||i>9||n!==zt||s<8||s>15||t<0||t>9||r<0||r>vt||8===s&&1!==a)return Dt(e,gt);8===s&&(s=9);const o=new Wt;return e.state=o,o.strm=e,o.status=kt,o.wrap=a,o.gzhead=null,o.w_bits=s,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+3-1)/3),o.window=new Uint8Array(2*o.w_size),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=3*(o.lit_bufsize-1),o.level=t,o.strategy=r,o.method=n,Kt(e)};var en={deflateInit:(e,t)=>$t(e,t,zt,15,8,Et),deflateInit2:$t,deflateReset:Kt,deflateResetKeep:qt,deflateSetHeader:(e,t)=>Vt(e)||2!==e.state.wrap?gt:(e.state.gzhead=t,pt),deflate:(e,t)=>{if(Vt(e)||t>ht||t<0)return e?Dt(e,gt):gt;const n=e.state;if(!e.output||0!==e.avail_in&&!e.input||n.status===Ot&&t!==ft)return Dt(e,0===e.avail_out?bt:gt);const s=n.last_flush;if(n.last_flush=t,0!==n.pending){if(Pt(e),0===e.avail_out)return n.last_flush=-1,pt}else if(0===e.avail_in&&Lt(t)<=Lt(s)&&t!==ft)return Dt(e,bt);if(n.status===Ot&&0!==e.avail_in)return Dt(e,bt);if(n.status===kt&&0===n.wrap&&(n.status=Ct),n.status===kt){let t=zt+(n.w_bits-8<<4)<<8,s=-1;if(s=n.strategy>=wt||n.level<2?0:n.level<6?1:6===n.level?2:3,t|=s<<6,0!==n.strstart&&(t|=32),t+=31-t%31,Qt(n,t),0!==n.strstart&&(Qt(n,e.adler>>>16),Qt(n,65535&e.adler)),e.adler=1,n.status=Ct,Pt(e),0!==n.pending)return n.last_flush=-1,pt}if(57===n.status)if(e.adler=0,Yt(n,31),Yt(n,139),Yt(n,8),n.gzhead)Yt(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),Yt(n,255&n.gzhead.time),Yt(n,n.gzhead.time>>8&255),Yt(n,n.gzhead.time>>16&255),Yt(n,n.gzhead.time>>24&255),Yt(n,9===n.level?2:n.strategy>=wt||n.level<2?4:0),Yt(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(Yt(n,255&n.gzhead.extra.length),Yt(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=tt(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69;else if(Yt(n,0),Yt(n,0),Yt(n,0),Yt(n,0),Yt(n,0),Yt(n,9===n.level?2:n.strategy>=wt||n.level<2?4:0),Yt(n,3),n.status=Ct,Pt(e),0!==n.pending)return n.last_flush=-1,pt;if(69===n.status){if(n.gzhead.extra){let t=n.pending,s=(65535&n.gzhead.extra.length)-n.gzindex;for(;n.pending+s>n.pending_buf_size;){let i=n.pending_buf_size-n.pending;if(n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex,n.gzindex+i),n.pending),n.pending=n.pending_buf_size,n.gzhead.hcrc&&n.pending>t&&(e.adler=tt(e.adler,n.pending_buf,n.pending-t,t)),n.gzindex+=i,Pt(e),0!==n.pending)return n.last_flush=-1,pt;t=0,s-=i}let i=new Uint8Array(n.gzhead.extra);n.pending_buf.set(i.subarray(n.gzindex,n.gzindex+s),n.pending),n.pending+=s,n.gzhead.hcrc&&n.pending>t&&(e.adler=tt(e.adler,n.pending_buf,n.pending-t,t)),n.gzindex=0}n.status=73}if(73===n.status){if(n.gzhead.name){let t,s=n.pending;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>s&&(e.adler=tt(e.adler,n.pending_buf,n.pending-s,s)),Pt(e),0!==n.pending)return n.last_flush=-1,pt;s=0}t=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,Yt(n,t)}while(0!==t);n.gzhead.hcrc&&n.pending>s&&(e.adler=tt(e.adler,n.pending_buf,n.pending-s,s)),n.gzindex=0}n.status=91}if(91===n.status){if(n.gzhead.comment){let t,s=n.pending;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>s&&(e.adler=tt(e.adler,n.pending_buf,n.pending-s,s)),Pt(e),0!==n.pending)return n.last_flush=-1,pt;s=0}t=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,Yt(n,t)}while(0!==t);n.gzhead.hcrc&&n.pending>s&&(e.adler=tt(e.adler,n.pending_buf,n.pending-s,s))}n.status=103}if(103===n.status){if(n.gzhead.hcrc){if(n.pending+2>n.pending_buf_size&&(Pt(e),0!==n.pending))return n.last_flush=-1,pt;Yt(n,255&e.adler),Yt(n,e.adler>>8&255),e.adler=0}if(n.status=Ct,Pt(e),0!==n.pending)return n.last_flush=-1,pt}if(0!==e.avail_in||0!==n.lookahead||t!==ct&&n.status!==Ot){let s=0===n.level?Rt(n,t):n.strategy===wt?((e,t)=>{let n;for(;;){if(0===e.lookahead&&(Ut(e),0===e.lookahead)){if(t===ct)return 1;break}if(e.match_length=0,n=ot(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,n&&(It(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===ft?(It(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(It(e,!1),0===e.strm.avail_out)?1:2})(n,t):n.strategy===xt?((e,t)=>{let n,s,i,r;const a=e.window;for(;;){if(e.lookahead<=Bt){if(Ut(e),e.lookahead<=Bt&&t===ct)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=3&&e.strstart>0&&(i=e.strstart-1,s=a[i],s===a[++i]&&s===a[++i]&&s===a[++i])){r=e.strstart+Bt;do{}while(s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&i<r);e.match_length=Bt-(r-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=3?(n=ot(e,1,e.match_length-3),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(n=ot(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),n&&(It(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===ft?(It(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(It(e,!1),0===e.strm.avail_out)?1:2})(n,t):Xt[n.level].func(n,t);if(3!==s&&4!==s||(n.status=Ot),1===s||3===s)return 0===e.avail_out&&(n.last_flush=-1),pt;if(2===s&&(t===dt?lt(n):t!==ht&&(rt(n,0,0,!1),t===ut&&(Tt(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),Pt(e),0===e.avail_out))return n.last_flush=-1,pt}return t!==ft?pt:n.wrap<=0?mt:(2===n.wrap?(Yt(n,255&e.adler),Yt(n,e.adler>>8&255),Yt(n,e.adler>>16&255),Yt(n,e.adler>>24&255),Yt(n,255&e.total_in),Yt(n,e.total_in>>8&255),Yt(n,e.total_in>>16&255),Yt(n,e.total_in>>24&255)):(Qt(n,e.adler>>>16),Qt(n,65535&e.adler)),Pt(e),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?pt:mt)},deflateEnd:e=>{if(Vt(e))return gt;const t=e.state.status;return e.state=null,t===Ct?Dt(e,_t):pt},deflateSetDictionary:(e,t)=>{let n=t.length;if(Vt(e))return gt;const s=e.state,i=s.wrap;if(2===i||1===i&&s.status!==kt||s.lookahead)return gt;if(1===i&&(e.adler=$e(e.adler,t,n,0)),s.wrap=0,n>=s.w_size){0===i&&(Tt(s.head),s.strstart=0,s.block_start=0,s.insert=0);let e=new Uint8Array(s.w_size);e.set(t.subarray(n-s.w_size,n),0),t=e,n=s.w_size}const r=e.avail_in,a=e.next_in,o=e.input;for(e.avail_in=n,e.next_in=0,e.input=t,Ut(s);s.lookahead>=3;){let e=s.strstart,t=s.lookahead-2;do{s.ins_h=Nt(s,s.ins_h,s.window[e+3-1]),s.prev[e&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=e,e++}while(--t);s.strstart=e,s.lookahead=2,Ut(s)}return s.strstart+=s.lookahead,s.block_start=s.strstart,s.insert=s.lookahead,s.lookahead=0,s.match_length=s.prev_length=2,s.match_available=0,e.next_in=a,e.input=o,e.avail_in=r,s.wrap=i,pt},deflateInfo:"pako deflate (from Nodeca project)"};const tn=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var nn={assign:function(e){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const n=t.shift();if(n){if("object"!=typeof n)throw new TypeError(n+"must be non-object");for(const t in n)tn(n,t)&&(e[t]=n[t])}}return e},flattenChunks:e=>{let t=0;for(let n=0,s=e.length;n<s;n++)t+=e[n].length;const n=new Uint8Array(t);for(let t=0,s=0,i=e.length;t<i;t++){let i=e[t];n.set(i,s),s+=i.length}return n}};let sn=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){sn=!1}const rn=new Uint8Array(256);for(let e=0;e<256;e++)rn[e]=e>=252?6:e>=248?5:e>=240?4:e>=224?3:e>=192?2:1;rn[254]=rn[254]=1;var an={string2buf:e=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);let t,n,s,i,r,a=e.length,o=0;for(i=0;i<a;i++)n=e.charCodeAt(i),55296==(64512&n)&&i+1<a&&(s=e.charCodeAt(i+1),56320==(64512&s)&&(n=65536+(n-55296<<10)+(s-56320),i++)),o+=n<128?1:n<2048?2:n<65536?3:4;for(t=new Uint8Array(o),r=0,i=0;r<o;i++)n=e.charCodeAt(i),55296==(64512&n)&&i+1<a&&(s=e.charCodeAt(i+1),56320==(64512&s)&&(n=65536+(n-55296<<10)+(s-56320),i++)),n<128?t[r++]=n:n<2048?(t[r++]=192|n>>>6,t[r++]=128|63&n):n<65536?(t[r++]=224|n>>>12,t[r++]=128|n>>>6&63,t[r++]=128|63&n):(t[r++]=240|n>>>18,t[r++]=128|n>>>12&63,t[r++]=128|n>>>6&63,t[r++]=128|63&n);return t},buf2string:(e,t)=>{const n=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));let s,i;const r=new Array(2*n);for(i=0,s=0;s<n;){let t=e[s++];if(t<128){r[i++]=t;continue}let a=rn[t];if(a>4)r[i++]=65533,s+=a-1;else{for(t&=2===a?31:3===a?15:7;a>1&&s<n;)t=t<<6|63&e[s++],a--;a>1?r[i++]=65533:t<65536?r[i++]=t:(t-=65536,r[i++]=55296|t>>10&1023,r[i++]=56320|1023&t)}}return((e,t)=>{if(t<65534&&e.subarray&&sn)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));let n="";for(let s=0;s<t;s++)n+=String.fromCharCode(e[s]);return n})(r,i)},utf8border:(e,t)=>{(t=t||e.length)>e.length&&(t=e.length);let n=t-1;for(;n>=0&&128==(192&e[n]);)n--;return n<0||0===n?t:n+rn[e[n]]>t?n:t}},on=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const ln=Object.prototype.toString,{Z_NO_FLUSH:cn,Z_SYNC_FLUSH:dn,Z_FULL_FLUSH:un,Z_FINISH:fn,Z_OK:hn,Z_STREAM_END:pn,Z_DEFAULT_COMPRESSION:mn,Z_DEFAULT_STRATEGY:gn,Z_DEFLATED:_n}=st;function bn(e){this.options=nn.assign({level:mn,method:_n,chunkSize:16384,windowBits:15,memLevel:8,strategy:gn},e||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new on,this.strm.avail_out=0;let n=en.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(n!==hn)throw new Error(nt[n]);if(t.header&&en.deflateSetHeader(this.strm,t.header),t.dictionary){let e;if(e="string"==typeof t.dictionary?an.string2buf(t.dictionary):"[object ArrayBuffer]"===ln.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,n=en.deflateSetDictionary(this.strm,e),n!==hn)throw new Error(nt[n]);this._dict_set=!0}}function yn(e,t){const n=new bn(t);if(n.push(e,!0),n.err)throw n.msg||nt[n.err];return n.result}bn.prototype.push=function(e,t){const n=this.strm,s=this.options.chunkSize;let i,r;if(this.ended)return!1;for(r=t===~~t?t:!0===t?fn:cn,"string"==typeof e?n.input=an.string2buf(e):"[object ArrayBuffer]"===ln.call(e)?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;)if(0===n.avail_out&&(n.output=new Uint8Array(s),n.next_out=0,n.avail_out=s),(r===dn||r===un)&&n.avail_out<=6)this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;else{if(i=en.deflate(n,r),i===pn)return n.next_out>0&&this.onData(n.output.subarray(0,n.next_out)),i=en.deflateEnd(this.strm),this.onEnd(i),this.ended=!0,i===hn;if(0!==n.avail_out){if(r>0&&n.next_out>0)this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;else if(0===n.avail_in)break}else this.onData(n.output)}return!0},bn.prototype.onData=function(e){this.chunks.push(e)},bn.prototype.onEnd=function(e){e===hn&&(this.result=nn.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var An={Deflate:bn,deflate:yn,deflateRaw:function(e,t){return(t=t||{}).raw=!0,yn(e,t)},gzip:function(e,t){return(t=t||{}).gzip=!0,yn(e,t)},constants:st};const wn=16209;var xn=function(e,t){let n,s,i,r,a,o,l,c,d,u,f,h,p,m,g,_,b,y,A,w,x,v,E,M;const z=e.state;n=e.next_in,E=e.input,s=n+(e.avail_in-5),i=e.next_out,M=e.output,r=i-(t-e.avail_out),a=i+(e.avail_out-257),o=z.dmax,l=z.wsize,c=z.whave,d=z.wnext,u=z.window,f=z.hold,h=z.bits,p=z.lencode,m=z.distcode,g=(1<<z.lenbits)-1,_=(1<<z.distbits)-1;e:do{h<15&&(f+=E[n++]<<h,h+=8,f+=E[n++]<<h,h+=8),b=p[f&g];t:for(;;){if(y=b>>>24,f>>>=y,h-=y,y=b>>>16&255,0===y)M[i++]=65535&b;else{if(!(16&y)){if(64&y){if(32&y){z.mode=16191;break e}e.msg="invalid literal/length code",z.mode=wn;break e}b=p[(65535&b)+(f&(1<<y)-1)];continue t}for(A=65535&b,y&=15,y&&(h<y&&(f+=E[n++]<<h,h+=8),A+=f&(1<<y)-1,f>>>=y,h-=y),h<15&&(f+=E[n++]<<h,h+=8,f+=E[n++]<<h,h+=8),b=m[f&_];;){if(y=b>>>24,f>>>=y,h-=y,y=b>>>16&255,16&y){if(w=65535&b,y&=15,h<y&&(f+=E[n++]<<h,h+=8,h<y&&(f+=E[n++]<<h,h+=8)),w+=f&(1<<y)-1,w>o){e.msg="invalid distance too far back",z.mode=wn;break e}if(f>>>=y,h-=y,y=i-r,w>y){if(y=w-y,y>c&&z.sane){e.msg="invalid distance too far back",z.mode=wn;break e}if(x=0,v=u,0===d){if(x+=l-y,y<A){A-=y;do{M[i++]=u[x++]}while(--y);x=i-w,v=M}}else if(d<y){if(x+=l+d-y,y-=d,y<A){A-=y;do{M[i++]=u[x++]}while(--y);if(x=0,d<A){y=d,A-=y;do{M[i++]=u[x++]}while(--y);x=i-w,v=M}}}else if(x+=d-y,y<A){A-=y;do{M[i++]=u[x++]}while(--y);x=i-w,v=M}for(;A>2;)M[i++]=v[x++],M[i++]=v[x++],M[i++]=v[x++],A-=3;A&&(M[i++]=v[x++],A>1&&(M[i++]=v[x++]))}else{x=i-w;do{M[i++]=M[x++],M[i++]=M[x++],M[i++]=M[x++],A-=3}while(A>2);A&&(M[i++]=M[x++],A>1&&(M[i++]=M[x++]))}break}if(64&y){e.msg="invalid distance code",z.mode=wn;break e}b=m[(65535&b)+(f&(1<<y)-1)]}}break}}while(n<s&&i<a);A=h>>3,n-=A,h-=A<<3,f&=(1<<h)-1,e.next_in=n,e.next_out=i,e.avail_in=n<s?s-n+5:5-(n-s),e.avail_out=i<a?a-i+257:257-(i-a),z.hold=f,z.bits=h};const vn=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),En=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),Mn=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),zn=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var Bn=(e,t,n,s,i,r,a,o)=>{const l=o.bits;let c,d,u,f,h,p,m=0,g=0,_=0,b=0,y=0,A=0,w=0,x=0,v=0,E=0,M=null;const z=new Uint16Array(16),B=new Uint16Array(16);let F,k,C,O=null;for(m=0;m<=15;m++)z[m]=0;for(g=0;g<s;g++)z[t[n+g]]++;for(y=l,b=15;b>=1&&0===z[b];b--);if(y>b&&(y=b),0===b)return i[r++]=20971520,i[r++]=20971520,o.bits=1,0;for(_=1;_<b&&0===z[_];_++);for(y<_&&(y=_),x=1,m=1;m<=15;m++)if(x<<=1,x-=z[m],x<0)return-1;if(x>0&&(0===e||1!==b))return-1;for(B[1]=0,m=1;m<15;m++)B[m+1]=B[m]+z[m];for(g=0;g<s;g++)0!==t[n+g]&&(a[B[t[n+g]]++]=g);if(0===e?(M=O=a,p=20):1===e?(M=vn,O=En,p=257):(M=Mn,O=zn,p=0),E=0,g=0,m=_,h=r,A=y,w=0,u=-1,v=1<<y,f=v-1,1===e&&v>852||2===e&&v>592)return 1;for(;;){F=m-w,a[g]+1<p?(k=0,C=a[g]):a[g]>=p?(k=O[a[g]-p],C=M[a[g]-p]):(k=96,C=0),c=1<<m-w,d=1<<A,_=d;do{d-=c,i[h+(E>>w)+d]=F<<24|k<<16|C}while(0!==d);for(c=1<<m-1;E&c;)c>>=1;if(0!==c?(E&=c-1,E+=c):E=0,g++,0==--z[m]){if(m===b)break;m=t[n+a[g]]}if(m>y&&(E&f)!==u){for(0===w&&(w=y),h+=_,A=m-w,x=1<<A;A+w<b&&(x-=z[A+w],!(x<=0));)A++,x<<=1;if(v+=1<<A,1===e&&v>852||2===e&&v>592)return 1;u=E&f,i[u]=y<<24|A<<16|h-r}}return 0!==E&&(i[h+E]=m-w<<24|64<<16),o.bits=y,0};const{Z_FINISH:Fn,Z_BLOCK:kn,Z_TREES:Cn,Z_OK:On,Z_STREAM_END:Dn,Z_NEED_DICT:Ln,Z_STREAM_ERROR:Tn,Z_DATA_ERROR:Sn,Z_MEM_ERROR:Nn,Z_BUF_ERROR:Pn,Z_DEFLATED:In}=st,Yn=16180,Qn=16190,jn=16191,Hn=16192,Un=16194,Rn=16199,Gn=16200,Zn=16206,Jn=16209,Xn=e=>(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24);function Wn(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Vn=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.mode<Yn||t.mode>16211?1:0},qn=e=>{if(Vn(e))return Tn;const t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=Yn,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,On},Kn=e=>{if(Vn(e))return Tn;const t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,qn(e)},$n=(e,t)=>{let n;if(Vn(e))return Tn;const s=e.state;return t<0?(n=0,t=-t):(n=5+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?Tn:(null!==s.window&&s.wbits!==t&&(s.window=null),s.wrap=n,s.wbits=t,Kn(e))},es=(e,t)=>{if(!e)return Tn;const n=new Wn;e.state=n,n.strm=e,n.window=null,n.mode=Yn;const s=$n(e,t);return s!==On&&(e.state=null),s};let ts,ns,ss=!0;const is=e=>{if(ss){ts=new Int32Array(512),ns=new Int32Array(32);let t=0;for(;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(Bn(1,e.lens,0,288,ts,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;Bn(2,e.lens,0,32,ns,0,e.work,{bits:5}),ss=!1}e.lencode=ts,e.lenbits=9,e.distcode=ns,e.distbits=5},rs=(e,t,n,s)=>{let i;const r=e.state;return null===r.window&&(r.wsize=1<<r.wbits,r.wnext=0,r.whave=0,r.window=new Uint8Array(r.wsize)),s>=r.wsize?(r.window.set(t.subarray(n-r.wsize,n),0),r.wnext=0,r.whave=r.wsize):(i=r.wsize-r.wnext,i>s&&(i=s),r.window.set(t.subarray(n-s,n-s+i),r.wnext),(s-=i)?(r.window.set(t.subarray(n-s,n),0),r.wnext=s,r.whave=r.wsize):(r.wnext+=i,r.wnext===r.wsize&&(r.wnext=0),r.whave<r.wsize&&(r.whave+=i))),0};var as={inflateReset:Kn,inflateReset2:$n,inflateResetKeep:qn,inflateInit:e=>es(e,15),inflateInit2:es,inflate:(e,t)=>{let n,s,i,r,a,o,l,c,d,u,f,h,p,m,g,_,b,y,A,w,x,v,E=0;const M=new Uint8Array(4);let z,B;const F=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Vn(e)||!e.output||!e.input&&0!==e.avail_in)return Tn;n=e.state,n.mode===jn&&(n.mode=Hn),a=e.next_out,i=e.output,l=e.avail_out,r=e.next_in,s=e.input,o=e.avail_in,c=n.hold,d=n.bits,u=o,f=l,v=On;e:for(;;)switch(n.mode){case Yn:if(0===n.wrap){n.mode=Hn;break}for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(2&n.wrap&&35615===c){0===n.wbits&&(n.wbits=15),n.check=0,M[0]=255&c,M[1]=c>>>8&255,n.check=tt(n.check,M,2,0),c=0,d=0,n.mode=16181;break}if(n.head&&(n.head.done=!1),!(1&n.wrap)||(((255&c)<<8)+(c>>8))%31){e.msg="incorrect header check",n.mode=Jn;break}if((15&c)!==In){e.msg="unknown compression method",n.mode=Jn;break}if(c>>>=4,d-=4,x=8+(15&c),0===n.wbits&&(n.wbits=x),x>15||x>n.wbits){e.msg="invalid window size",n.mode=Jn;break}n.dmax=1<<n.wbits,n.flags=0,e.adler=n.check=1,n.mode=512&c?16189:jn,c=0,d=0;break;case 16181:for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(n.flags=c,(255&n.flags)!==In){e.msg="unknown compression method",n.mode=Jn;break}if(57344&n.flags){e.msg="unknown header flags set",n.mode=Jn;break}n.head&&(n.head.text=c>>8&1),512&n.flags&&4&n.wrap&&(M[0]=255&c,M[1]=c>>>8&255,n.check=tt(n.check,M,2,0)),c=0,d=0,n.mode=16182;case 16182:for(;d<32;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.head&&(n.head.time=c),512&n.flags&&4&n.wrap&&(M[0]=255&c,M[1]=c>>>8&255,M[2]=c>>>16&255,M[3]=c>>>24&255,n.check=tt(n.check,M,4,0)),c=0,d=0,n.mode=16183;case 16183:for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.head&&(n.head.xflags=255&c,n.head.os=c>>8),512&n.flags&&4&n.wrap&&(M[0]=255&c,M[1]=c>>>8&255,n.check=tt(n.check,M,2,0)),c=0,d=0,n.mode=16184;case 16184:if(1024&n.flags){for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.length=c,n.head&&(n.head.extra_len=c),512&n.flags&&4&n.wrap&&(M[0]=255&c,M[1]=c>>>8&255,n.check=tt(n.check,M,2,0)),c=0,d=0}else n.head&&(n.head.extra=null);n.mode=16185;case 16185:if(1024&n.flags&&(h=n.length,h>o&&(h=o),h&&(n.head&&(x=n.head.extra_len-n.length,n.head.extra||(n.head.extra=new Uint8Array(n.head.extra_len)),n.head.extra.set(s.subarray(r,r+h),x)),512&n.flags&&4&n.wrap&&(n.check=tt(n.check,s,h,r)),o-=h,r+=h,n.length-=h),n.length))break e;n.length=0,n.mode=16186;case 16186:if(2048&n.flags){if(0===o)break e;h=0;do{x=s[r+h++],n.head&&x&&n.length<65536&&(n.head.name+=String.fromCharCode(x))}while(x&&h<o);if(512&n.flags&&4&n.wrap&&(n.check=tt(n.check,s,h,r)),o-=h,r+=h,x)break e}else n.head&&(n.head.name=null);n.length=0,n.mode=16187;case 16187:if(4096&n.flags){if(0===o)break e;h=0;do{x=s[r+h++],n.head&&x&&n.length<65536&&(n.head.comment+=String.fromCharCode(x))}while(x&&h<o);if(512&n.flags&&4&n.wrap&&(n.check=tt(n.check,s,h,r)),o-=h,r+=h,x)break e}else n.head&&(n.head.comment=null);n.mode=16188;case 16188:if(512&n.flags){for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(4&n.wrap&&c!==(65535&n.check)){e.msg="header crc mismatch",n.mode=Jn;break}c=0,d=0}n.head&&(n.head.hcrc=n.flags>>9&1,n.head.done=!0),e.adler=n.check=0,n.mode=jn;break;case 16189:for(;d<32;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}e.adler=n.check=Xn(c),c=0,d=0,n.mode=Qn;case Qn:if(0===n.havedict)return e.next_out=a,e.avail_out=l,e.next_in=r,e.avail_in=o,n.hold=c,n.bits=d,Ln;e.adler=n.check=1,n.mode=jn;case jn:if(t===kn||t===Cn)break e;case Hn:if(n.last){c>>>=7&d,d-=7&d,n.mode=Zn;break}for(;d<3;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}switch(n.last=1&c,c>>>=1,d-=1,3&c){case 0:n.mode=16193;break;case 1:if(is(n),n.mode=Rn,t===Cn){c>>>=2,d-=2;break e}break;case 2:n.mode=16196;break;case 3:e.msg="invalid block type",n.mode=Jn}c>>>=2,d-=2;break;case 16193:for(c>>>=7&d,d-=7&d;d<32;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if((65535&c)!=(c>>>16^65535)){e.msg="invalid stored block lengths",n.mode=Jn;break}if(n.length=65535&c,c=0,d=0,n.mode=Un,t===Cn)break e;case Un:n.mode=16195;case 16195:if(h=n.length,h){if(h>o&&(h=o),h>l&&(h=l),0===h)break e;i.set(s.subarray(r,r+h),a),o-=h,r+=h,l-=h,a+=h,n.length-=h;break}n.mode=jn;break;case 16196:for(;d<14;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(n.nlen=257+(31&c),c>>>=5,d-=5,n.ndist=1+(31&c),c>>>=5,d-=5,n.ncode=4+(15&c),c>>>=4,d-=4,n.nlen>286||n.ndist>30){e.msg="too many length or distance symbols",n.mode=Jn;break}n.have=0,n.mode=16197;case 16197:for(;n.have<n.ncode;){for(;d<3;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.lens[F[n.have++]]=7&c,c>>>=3,d-=3}for(;n.have<19;)n.lens[F[n.have++]]=0;if(n.lencode=n.lendyn,n.lenbits=7,z={bits:n.lenbits},v=Bn(0,n.lens,0,19,n.lencode,0,n.work,z),n.lenbits=z.bits,v){e.msg="invalid code lengths set",n.mode=Jn;break}n.have=0,n.mode=16198;case 16198:for(;n.have<n.nlen+n.ndist;){for(;E=n.lencode[c&(1<<n.lenbits)-1],g=E>>>24,_=E>>>16&255,b=65535&E,!(g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(b<16)c>>>=g,d-=g,n.lens[n.have++]=b;else{if(16===b){for(B=g+2;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(c>>>=g,d-=g,0===n.have){e.msg="invalid bit length repeat",n.mode=Jn;break}x=n.lens[n.have-1],h=3+(3&c),c>>>=2,d-=2}else if(17===b){for(B=g+3;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}c>>>=g,d-=g,x=0,h=3+(7&c),c>>>=3,d-=3}else{for(B=g+7;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}c>>>=g,d-=g,x=0,h=11+(127&c),c>>>=7,d-=7}if(n.have+h>n.nlen+n.ndist){e.msg="invalid bit length repeat",n.mode=Jn;break}for(;h--;)n.lens[n.have++]=x}}if(n.mode===Jn)break;if(0===n.lens[256]){e.msg="invalid code -- missing end-of-block",n.mode=Jn;break}if(n.lenbits=9,z={bits:n.lenbits},v=Bn(1,n.lens,0,n.nlen,n.lencode,0,n.work,z),n.lenbits=z.bits,v){e.msg="invalid literal/lengths set",n.mode=Jn;break}if(n.distbits=6,n.distcode=n.distdyn,z={bits:n.distbits},v=Bn(2,n.lens,n.nlen,n.ndist,n.distcode,0,n.work,z),n.distbits=z.bits,v){e.msg="invalid distances set",n.mode=Jn;break}if(n.mode=Rn,t===Cn)break e;case Rn:n.mode=Gn;case Gn:if(o>=6&&l>=258){e.next_out=a,e.avail_out=l,e.next_in=r,e.avail_in=o,n.hold=c,n.bits=d,xn(e,f),a=e.next_out,i=e.output,l=e.avail_out,r=e.next_in,s=e.input,o=e.avail_in,c=n.hold,d=n.bits,n.mode===jn&&(n.back=-1);break}for(n.back=0;E=n.lencode[c&(1<<n.lenbits)-1],g=E>>>24,_=E>>>16&255,b=65535&E,!(g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(_&&!(240&_)){for(y=g,A=_,w=b;E=n.lencode[w+((c&(1<<y+A)-1)>>y)],g=E>>>24,_=E>>>16&255,b=65535&E,!(y+g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}c>>>=y,d-=y,n.back+=y}if(c>>>=g,d-=g,n.back+=g,n.length=b,0===_){n.mode=16205;break}if(32&_){n.back=-1,n.mode=jn;break}if(64&_){e.msg="invalid literal/length code",n.mode=Jn;break}n.extra=15&_,n.mode=16201;case 16201:if(n.extra){for(B=n.extra;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.length+=c&(1<<n.extra)-1,c>>>=n.extra,d-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=16202;case 16202:for(;E=n.distcode[c&(1<<n.distbits)-1],g=E>>>24,_=E>>>16&255,b=65535&E,!(g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(!(240&_)){for(y=g,A=_,w=b;E=n.distcode[w+((c&(1<<y+A)-1)>>y)],g=E>>>24,_=E>>>16&255,b=65535&E,!(y+g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}c>>>=y,d-=y,n.back+=y}if(c>>>=g,d-=g,n.back+=g,64&_){e.msg="invalid distance code",n.mode=Jn;break}n.offset=b,n.extra=15&_,n.mode=16203;case 16203:if(n.extra){for(B=n.extra;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.offset+=c&(1<<n.extra)-1,c>>>=n.extra,d-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){e.msg="invalid distance too far back",n.mode=Jn;break}n.mode=16204;case 16204:if(0===l)break e;if(h=f-l,n.offset>h){if(h=n.offset-h,h>n.whave&&n.sane){e.msg="invalid distance too far back",n.mode=Jn;break}h>n.wnext?(h-=n.wnext,p=n.wsize-h):p=n.wnext-h,h>n.length&&(h=n.length),m=n.window}else m=i,p=a-n.offset,h=n.length;h>l&&(h=l),l-=h,n.length-=h;do{i[a++]=m[p++]}while(--h);0===n.length&&(n.mode=Gn);break;case 16205:if(0===l)break e;i[a++]=n.length,l--,n.mode=Gn;break;case Zn:if(n.wrap){for(;d<32;){if(0===o)break e;o--,c|=s[r++]<<d,d+=8}if(f-=l,e.total_out+=f,n.total+=f,4&n.wrap&&f&&(e.adler=n.check=n.flags?tt(n.check,i,f,a-f):$e(n.check,i,f,a-f)),f=l,4&n.wrap&&(n.flags?c:Xn(c))!==n.check){e.msg="incorrect data check",n.mode=Jn;break}c=0,d=0}n.mode=16207;case 16207:if(n.wrap&&n.flags){for(;d<32;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(4&n.wrap&&c!==(4294967295&n.total)){e.msg="incorrect length check",n.mode=Jn;break}c=0,d=0}n.mode=16208;case 16208:v=Dn;break e;case Jn:v=Sn;break e;case 16210:return Nn;default:return Tn}return e.next_out=a,e.avail_out=l,e.next_in=r,e.avail_in=o,n.hold=c,n.bits=d,(n.wsize||f!==e.avail_out&&n.mode<Jn&&(n.mode<Zn||t!==Fn))&&rs(e,e.output,e.next_out,f-e.avail_out),u-=e.avail_in,f-=e.avail_out,e.total_in+=u,e.total_out+=f,n.total+=f,4&n.wrap&&f&&(e.adler=n.check=n.flags?tt(n.check,i,f,e.next_out-f):$e(n.check,i,f,e.next_out-f)),e.data_type=n.bits+(n.last?64:0)+(n.mode===jn?128:0)+(n.mode===Rn||n.mode===Un?256:0),(0===u&&0===f||t===Fn)&&v===On&&(v=Pn),v},inflateEnd:e=>{if(Vn(e))return Tn;let t=e.state;return t.window&&(t.window=null),e.state=null,On},inflateGetHeader:(e,t)=>{if(Vn(e))return Tn;const n=e.state;return 2&n.wrap?(n.head=t,t.done=!1,On):Tn},inflateSetDictionary:(e,t)=>{const n=t.length;let s,i,r;return Vn(e)?Tn:(s=e.state,0!==s.wrap&&s.mode!==Qn?Tn:s.mode===Qn&&(i=1,i=$e(i,t,n,0),i!==s.check)?Sn:(r=rs(e,t,n,n),r?(s.mode=16210,Nn):(s.havedict=1,On)))},inflateInfo:"pako inflate (from Nodeca project)"},os=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const ls=Object.prototype.toString,{Z_NO_FLUSH:cs,Z_FINISH:ds,Z_OK:us,Z_STREAM_END:fs,Z_NEED_DICT:hs,Z_STREAM_ERROR:ps,Z_DATA_ERROR:ms,Z_MEM_ERROR:gs}=st;function _s(e){this.options=nn.assign({chunkSize:65536,windowBits:15,to:""},e||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&(15&t.windowBits||(t.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new on,this.strm.avail_out=0;let n=as.inflateInit2(this.strm,t.windowBits);if(n!==us)throw new Error(nt[n]);if(this.header=new os,as.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=an.string2buf(t.dictionary):"[object ArrayBuffer]"===ls.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(n=as.inflateSetDictionary(this.strm,t.dictionary),n!==us)))throw new Error(nt[n])}function bs(e,t){const n=new _s(t);if(n.push(e),n.err)throw n.msg||nt[n.err];return n.result}_s.prototype.push=function(e,t){const n=this.strm,s=this.options.chunkSize,i=this.options.dictionary;let r,a,o;if(this.ended)return!1;for(a=t===~~t?t:!0===t?ds:cs,"[object ArrayBuffer]"===ls.call(e)?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;){for(0===n.avail_out&&(n.output=new Uint8Array(s),n.next_out=0,n.avail_out=s),r=as.inflate(n,a),r===hs&&i&&(r=as.inflateSetDictionary(n,i),r===us?r=as.inflate(n,a):r===ms&&(r=hs));n.avail_in>0&&r===fs&&n.state.wrap>0&&0!==e[n.next_in];)as.inflateReset(n),r=as.inflate(n,a);switch(r){case ps:case ms:case hs:case gs:return this.onEnd(r),this.ended=!0,!1}if(o=n.avail_out,n.next_out&&(0===n.avail_out||r===fs))if("string"===this.options.to){let e=an.utf8border(n.output,n.next_out),t=n.next_out-e,i=an.buf2string(n.output,e);n.next_out=t,n.avail_out=s-t,t&&n.output.set(n.output.subarray(e,e+t),0),this.onData(i)}else this.onData(n.output.length===n.next_out?n.output:n.output.subarray(0,n.next_out));if(r!==us||0!==o){if(r===fs)return r=as.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(0===n.avail_in)break}}return!0},_s.prototype.onData=function(e){this.chunks.push(e)},_s.prototype.onEnd=function(e){e===us&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=nn.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var ys={Inflate:_s,inflate:bs,inflateRaw:function(e,t){return(t=t||{}).raw=!0,bs(e,t)},ungzip:bs,constants:st};const{Deflate:As,deflate:ws,deflateRaw:xs,gzip:vs}=An,{Inflate:Es,inflate:Ms,inflateRaw:zs,ungzip:Bs}=ys;var Fs={Deflate:As,deflate:ws,deflateRaw:xs,gzip:vs,Inflate:Es,inflate:Ms,inflateRaw:zs,ungzip:Bs,constants:st};const ks=oe()("bb.js:wasm");async function Cs(e=32,t){const n=ue(),s=n?await async function(){if("undefined"!=typeof navigator&&navigator.hardwareConcurrency)return navigator.hardwareConcurrency;try{return(await o.e(522).then(o.t.bind(o,522,23))).cpus().length}catch(e){return ks("Could not detect environment. Falling back to one thread.: {e}"),1}}():1,i=Math.min(e,s,32),r=await async function(e,t){let n=e?"/barretenberg-threads.wasm.gz":"/barretenberg.wasm.gz";n=t?`${t}/${/[^/]+(?=\/$|$)/.exec(n)?.[0]}`:n;const s=await fetch(n),i=await s.arrayBuffer(),r=new Uint8Array(i);return 31===r[0]&&139===r[1]&&8===r[2]?Fs.ungzip(r).buffer:r}(n,t);return{module:await WebAssembly.compile(r),threads:i}}const Os=4,Ds=32,Ls=3*Ds;function Ts(e){const t=Ps(e.slice(4)),n=Number(t[1]),s=Ls+Os,i=e.slice(0,s),r=n*Ds,a=e.slice(s+r);return{proof:new Uint8Array([...i,...a]),publicInputs:e.slice(s,s+r)}}function Ss(e,t){const n=t.slice(0,Ls+Os),s=t.slice(Ls+Os);return Uint8Array.from([...n,...e,...s])}function Ns(e){const t=Is(e.publicInputs);return Uint8Array.from([...t,...e.proof])}function Ps(e){const t=[];for(let n=0;n<e.length;n+=32){const s=e.slice(n,n+32);t.push(s)}return t.map(Ys)}function Is(e){return function(e){const t=e.reduce(((e,t)=>e+t.length),0),n=new Uint8Array(t);let s=0;for(const t of e)n.set(t,s),s+=t.length;return n}(e.map(Qs))}function Ys(e){const t=[];return e.forEach((function(e){let n=e.toString(16);n.length%2&&(n="0"+n),t.push(n)})),"0x"+t.join("")}function Qs(e){const t=BigInt(e).toString(16).padStart(64,"0"),n=t.length/2,s=new Uint8Array(n);let i=0,r=0;for(;i<n;)s[i]=parseInt(t.slice(r,r+2),16),i+=1,r+=2;return s}class js{constructor(e={threads:1}){this.options=e}async instantiate(){if(!this.api){const e=await zi.new(this.options);await e.initSRSForCircuitSize(0),this.acirComposer=await e.acirNewAcirComposer(0),this.api=e}}async verifyUltraPlonkProof(e,t){await this.instantiate(),await this.api.acirLoadVerificationKey(this.acirComposer,new D(t));const n=Ns(e);return await this.api.acirVerifyProof(this.acirComposer,n)}async verifyUltraHonkProof(e,t){await this.instantiate();const n=Ss(Is(e.publicInputs),e.proof);return await this.api.acirVerifyUltraHonk(n,new D(t))}async destroy(){this.api&&await this.api.destroy()}}var Hs=Uint8Array,Us=Uint16Array,Rs=Int32Array,Gs=new Hs([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Zs=new Hs([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Js=new Hs([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Xs=function(e,t){for(var n=new Us(31),s=0;s<31;++s)n[s]=t+=1<<e[s-1];var i=new Rs(n[30]);for(s=1;s<30;++s)for(var r=n[s];r<n[s+1];++r)i[r]=r-n[s]<<5|s;return{b:n,r:i}},Ws=Xs(Gs,2),Vs=Ws.b,qs=Ws.r;Vs[28]=258,qs[258]=28;for(var Ks=Xs(Zs,0),$s=Ks.b,ei=(Ks.r,new Us(32768)),ti=0;ti<32768;++ti){var ni=(43690&ti)>>1|(21845&ti)<<1;ni=(61680&(ni=(52428&ni)>>2|(13107&ni)<<2))>>4|(3855&ni)<<4,ei[ti]=((65280&ni)>>8|(255&ni)<<8)>>1}var si=function(e,t,n){for(var s=e.length,i=0,r=new Us(t);i<s;++i)e[i]&&++r[e[i]-1];var a,o=new Us(t);for(i=1;i<t;++i)o[i]=o[i-1]+r[i-1]<<1;if(n){a=new Us(1<<t);var l=15-t;for(i=0;i<s;++i)if(e[i])for(var c=i<<4|e[i],d=t-e[i],u=o[e[i]-1]++<<d,f=u|(1<<d)-1;u<=f;++u)a[ei[u]>>l]=c}else for(a=new Us(s),i=0;i<s;++i)e[i]&&(a[i]=ei[o[e[i]-1]++]>>15-e[i]);return a},ii=new Hs(288);for(ti=0;ti<144;++ti)ii[ti]=8;for(ti=144;ti<256;++ti)ii[ti]=9;for(ti=256;ti<280;++ti)ii[ti]=7;for(ti=280;ti<288;++ti)ii[ti]=8;var ri=new Hs(32);for(ti=0;ti<32;++ti)ri[ti]=5;var ai=si(ii,9,1),oi=si(ri,5,1),li=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},ci=function(e,t,n){var s=t/8|0;return(e[s]|e[s+1]<<8)>>(7&t)&n},di=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},ui=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],fi=function(e,t,n){var s=new Error(t||ui[e]);if(s.code=e,Error.captureStackTrace&&Error.captureStackTrace(s,fi),!n)throw s;return s},hi=function(e,t,n,s){var i=e.length,r=s?s.length:0;if(!i||t.f&&!t.l)return n||new Hs(0);var a=!n,o=a||2!=t.i,l=t.i;a&&(n=new Hs(3*i));var c,d=function(e){var t=n.length;if(e>t){var s=new Hs(Math.max(2*t,e));s.set(n),n=s}},u=t.f||0,f=t.p||0,h=t.b||0,p=t.l,m=t.d,g=t.m,_=t.n,b=8*i;do{if(!p){u=ci(e,f,1);var y=ci(e,f+1,3);if(f+=3,!y){var A=e[(c=f,(O=4+((c+7)/8|0))-4)]|e[O-3]<<8,w=O+A;if(w>i){l&&fi(0);break}o&&d(h+A),n.set(e.subarray(O,w),h),t.b=h+=A,t.p=f=8*w,t.f=u;continue}if(1==y)p=ai,m=oi,g=9,_=5;else if(2==y){var x=ci(e,f,31)+257,v=ci(e,f+10,15)+4,E=x+ci(e,f+5,31)+1;f+=14;for(var M=new Hs(E),z=new Hs(19),B=0;B<v;++B)z[Js[B]]=ci(e,f+3*B,7);f+=3*v;var F=li(z),k=(1<<F)-1,C=si(z,F,1);for(B=0;B<E;){var O,D=C[ci(e,f,k)];if(f+=15&D,(O=D>>4)<16)M[B++]=O;else{var L=0,T=0;for(16==O?(T=3+ci(e,f,3),f+=2,L=M[B-1]):17==O?(T=3+ci(e,f,7),f+=3):18==O&&(T=11+ci(e,f,127),f+=7);T--;)M[B++]=L}}var S=M.subarray(0,x),N=M.subarray(x);g=li(S),_=li(N),p=si(S,g,1),m=si(N,_,1)}else fi(1);if(f>b){l&&fi(0);break}}o&&d(h+131072);for(var P=(1<<g)-1,I=(1<<_)-1,Y=f;;Y=f){var Q=(L=p[di(e,f)&P])>>4;if((f+=15&L)>b){l&&fi(0);break}if(L||fi(2),Q<256)n[h++]=Q;else{if(256==Q){Y=f,p=null;break}var j=Q-254;if(Q>264){var H=Gs[B=Q-257];j=ci(e,f,(1<<H)-1)+Vs[B],f+=H}var U=m[di(e,f)&I],R=U>>4;if(U||fi(3),f+=15&U,N=$s[R],R>3&&(H=Zs[R],N+=di(e,f)&(1<<H)-1,f+=H),f>b){l&&fi(0);break}o&&d(h+131072);var G=h+j;if(h<N){var Z=r-N,J=Math.min(N,G);for(Z+h<0&&fi(3);h<J;++h)n[h]=s[Z+h]}for(;h<G;++h)n[h]=n[h-N]}}t.l=p,t.p=Y,t.b=h,t.f=u,p&&(u=1,t.m=g,t.d=m,t.n=_)}while(!u);return h!=n.length&&a?function(e,t,n){return(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length),new Hs(e.subarray(t,n))}(n,0,h):n.subarray(0,h)},pi=new Hs(0),mi=function(e){31==e[0]&&139==e[1]&&8==e[2]||fi(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=2+(e[10]|e[11]<<8));for(var s=(t>>3&1)+(t>>4&1);s>0;s-=!e[n++]);return n+(2&t)},gi=function(e){var t=e.length;return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0},_i=function(e,t){return(8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31)&&fi(6,"invalid zlib data"),(e[1]>>5&1)==+!t&&fi(6,"invalid zlib data: "+(32&e[1]?"need":"unexpected")+" dictionary"),2+(e[1]>>3&4)};function bi(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?function(e,t){var n=mi(e);return n+8>e.length&&fi(6,"invalid gzip data"),hi(e.subarray(n,-8),{i:2},t&&t.out||new Hs(gi(e)),t&&t.dictionary)}(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?function(e,t){return hi(e,{i:2},t&&t.out,t&&t.dictionary)}(e,t):function(e,t){return hi(e.subarray(_i(e,t&&t.dictionary),-4),{i:2},t&&t.out,t&&t.dictionary)}(e,t)}var yi="undefined"!=typeof TextDecoder&&new TextDecoder;try{yi.decode(pi,{stream:!0})}catch(e){}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Ai=o(764).lW;class wi{constructor(e,t={threads:1},n={recursive:!1}){this.backendOptions=t,this.circuitOptions=n,this.acirUncompressedBytecode=Ei(e)}async instantiate(){if(!this.api){const e=await zi.new(this.backendOptions),t=!1,[n,s]=await e.acirGetCircuitSizes(this.acirUncompressedBytecode,this.circuitOptions.recursive,t);await e.initSRSForCircuitSize(s),this.acirComposer=await e.acirNewAcirComposer(s),await e.acirInitProvingKey(this.acirComposer,this.acirUncompressedBytecode,this.circuitOptions.recursive),this.api=e}}async generateProof(e){await this.instantiate();const t=await this.api.acirCreateProof(this.acirComposer,this.acirUncompressedBytecode,this.circuitOptions.recursive,bi(e)),n=t.length-2144,s=t.slice(0,n);return{proof:t.slice(n),publicInputs:Ps(s)}}async generateRecursiveProofArtifacts(e,t=0){await this.instantiate();const n=Ns(e),s=(await this.api.acirSerializeProofIntoFields(this.acirComposer,n,t)).slice(t);await this.api.acirInitVerificationKey(this.acirComposer);const i=await this.api.acirSerializeVerificationKeyIntoFields(this.acirComposer);return{proofAsFields:s.map((e=>e.toString())),vkAsFields:i[0].map((e=>e.toString())),vkHash:i[1].toString()}}async verifyProof(e){await this.instantiate(),await this.api.acirInitVerificationKey(this.acirComposer);const t=Ns(e);return await this.api.acirVerifyProof(this.acirComposer,t)}async getVerificationKey(){return await this.instantiate(),await this.api.acirInitVerificationKey(this.acirComposer),await this.api.acirGetVerificationKey(this.acirComposer)}async getSolidityVerifier(){return await this.instantiate(),await this.api.acirInitVerificationKey(this.acirComposer),await this.api.acirGetSolidityVerifier(this.acirComposer)}async destroy(){this.api&&await this.api.destroy()}}class xi{constructor(e,t={threads:1},n={recursive:!1}){this.backendOptions=t,this.circuitOptions=n,this.acirUncompressedBytecode=Ei(e)}async instantiate(){if(!this.api){const e=await zi.new(this.backendOptions),t=!0;await e.acirInitSRS(this.acirUncompressedBytecode,this.circuitOptions.recursive,t),this.api=e}}async generateProof(e,t){await this.instantiate();const n=t?.keccak?this.api.acirProveUltraKeccakHonk.bind(this.api):this.api.acirProveUltraHonk.bind(this.api),s=await n(this.acirUncompressedBytecode,this.circuitOptions.recursive,bi(e)),i=Ps(s.slice(4)),r=Number(i[1]),a=100,o=s.slice(0,a),l=32*r,c=s.slice(a+l);return{proof:new Uint8Array([...o,...c]),publicInputs:Ps(s.slice(a,a+l))}}async generateProofForRecursiveAggregation(e,t){await this.instantiate();const n=t?.keccak?this.api.acirProveUltraKeccakHonk.bind(this.api):this.api.acirProveUltraHonk.bind(this.api),s=await n(this.acirUncompressedBytecode,this.circuitOptions.recursive,bi(e)),i=Ps(s.slice(4)),r=Number(i[1])-16,a=32*r,o=32*r,l=new Uint8Array(s.length-o);return l.set(s.subarray(0,100),0),l.set(s.subarray(100+o),100),{proof:Ps(l.slice(4)),publicInputs:Ps(s.slice(100,100+a))}}async verifyProof(e,t){await this.instantiate();const n=Ss(Is(e.publicInputs),e.proof),s=t?.keccak?this.api.acirWriteVkUltraKeccakHonk.bind(this.api):this.api.acirWriteVkUltraHonk.bind(this.api),i=t?.keccak?this.api.acirVerifyUltraKeccakHonk.bind(this.api):this.api.acirVerifyUltraHonk.bind(this.api),r=await s(this.acirUncompressedBytecode,this.circuitOptions.recursive);return await i(n,new D(r))}async getVerificationKey(){return await this.instantiate(),await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode,this.circuitOptions.recursive)}async getSolidityVerifier(e){await this.instantiate();const t=e??await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode,this.circuitOptions.recursive);return await this.api.acirHonkSolidityVerifier(this.acirUncompressedBytecode,new D(t))}async generateRecursiveProofArtifacts(e,t){await this.instantiate();const n=await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode,this.circuitOptions.recursive);return{proofAsFields:[],vkAsFields:(await this.api.acirVkAsFieldsUltraHonk(n)).map((e=>e.toString())),vkHash:""}}async destroy(){this.api&&await this.api.destroy()}}class vi{constructor(e,t={threads:1}){this.acirMsgpack=e,this.options=t}async instantiate(){if(!this.api){const e=await zi.new(this.options);await e.initSRSClientIVC(),this.api=e}}async prove(e){return await this.instantiate(),this.api.acirProveAztecClient(this.acirMsgpack,e)}async verify(e,t){return await this.instantiate(),this.api.acirVerifyAztecClient(e,t)}async proveAndVerify(e){return await this.instantiate(),this.api.acirProveAndVerifyAztecClient(this.acirMsgpack,e)}async destroy(){this.api&&await this.api.destroy()}}function Ei(e){return bi(function(e){if(void 0!==Ai){const t=Ai.from(e,"base64");return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}if("function"==typeof atob)return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)));throw new Error("No implementation found for base64 decoding.")}(e))}const Mi=oe()("bb.js:wasm");class zi extends ie{constructor(e,t,n){super(t),this.worker=e,this.options=n}static async new(e={}){const t=function(){const e=new de,t=oe().disable();return oe().enable(t),e.postMessage({debug:t}),e}(),n=fe(t),{module:s,threads:i}=await Cs(e.threads,e.wasmPath);return await n.init(s,i,F(Mi),e.memory?.initial,e.memory?.maximum),new zi(t,n,e)}async getNumThreads(){return await this.wasm.getNumThreads()}async initSRSForCircuitSize(e){const t=await c.new(e+1,this.options.crsPath);await this.srsInitSrs(new D(t.getG1Data()),t.numPoints,new D(t.getG2Data()))}async initSRSClientIVC(){const e=await c.new(1048577,this.options.crsPath),t=await d.new(65537,this.options.crsPath);await this.srsInitSrs(new D(e.getG1Data()),e.numPoints,new D(e.getG2Data())),await this.srsInitGrumpkinSrs(new D(t.getG1Data()),t.numPoints)}async acirInitSRS(e,t,n){const[s,i]=await this.acirGetCircuitSizes(e,t,n);return this.initSRSForCircuitSize(i)}async destroy(){await this.wasm.destroy(),await this.worker.terminate()}}let Bi,Fi;class ki extends re{constructor(e){super(e)}static async new(e){const t=new ye,{module:n,threads:s}=await Cs(1,e);return await t.init(n,s),new ki(t)}static async initSingleton(e){return Bi||(Bi=ki.new(e)),Fi=await Bi,Fi}static getSingleton(){if(!Fi)throw new Error("First call BarretenbergSync.initSingleton() on @aztec/bb.js module.");return Fi}getWasm(){return this.wasm}}})();var c=l.AL,d=l.Fr,u=l.ld,f=i(7877),h=i(8891).Buffer;function p(e){const t=e.toString("hex");return 0===t.length?BigInt(0):BigInt(`0x${t}`)}function m(e,t){if(e<BigInt(0))throw new Error(`Cannot convert negative bigint ${e.toString()} to buffer with toBufferBE.`);const n=e.toString(16),s=h.from(n.padStart(2*t,"0").slice(0,2*t),"hex");if(s.length>t)throw new Error(`Number ${e.toString(16)} does not fit in ${t}`);return s}function g(e){if(!/^(0x)?[0-9a-fA-F]*$/.test(e)||e.length%2!=0)throw new Error(`Invalid hex string: ${e}`);return h.from(e.replace(/^0x/i,""),"hex")}var _=i(3023),b=i(6041),y=i(9777),A=i.t(y,2);const{env:w={},argv:x=[],platform:v=""}="undefined"==typeof process?{}:process,E="NO_COLOR"in w||x.includes("--no-color"),M="FORCE_COLOR"in w||x.includes("--color"),z="win32"===v,B="dumb"===w.TERM,F=A&&y.isatty&&y.isatty(1)&&w.TERM&&!B,k=!E&&(M||z&&!B||F||"CI"in w&&("GITHUB_ACTIONS"in w||"GITLAB_CI"in w||"CIRCLECI"in w)),C=(e,t,n,s,i=t.substring(0,e)+s,r=t.substring(e+n.length),a=r.indexOf(n))=>i+(a<0?r:C(a,r,n,s)),O=(e,t,n)=>((e,t,n=e,s=e.length+1)=>i=>i||""!==i&&void 0!==i?((e,t,n,s,i)=>e<0?n+t+s:n+C(e,t,s,i)+s)((""+i).indexOf(t,s),i,e,t,n):"")(`[${e}m`,`[${t}m`,n),D={reset:O(0,0),bold:O(1,22,"[22m[1m"),dim:O(2,22,"[22m[2m"),italic:O(3,23),underline:O(4,24),inverse:O(7,27),hidden:O(8,28),strikethrough:O(9,29),black:O(30,39),red:O(31,39),green:O(32,39),yellow:O(33,39),blue:O(34,39),magenta:O(35,39),cyan:O(36,39),white:O(37,39),gray:O(90,39),bgBlack:O(40,49),bgRed:O(41,49),bgGreen:O(42,49),bgYellow:O(43,49),bgBlue:O(44,49),bgMagenta:O(45,49),bgCyan:O(46,49),bgWhite:O(47,49),blackBright:O(90,39),redBright:O(91,39),greenBright:O(92,39),yellowBright:O(93,39),blueBright:O(94,39),magentaBright:O(95,39),cyanBright:O(96,39),whiteBright:O(97,39),bgBlackBright:O(100,49),bgRedBright:O(101,49),bgGreenBright:O(102,49),bgYellowBright:O(103,49),bgBlueBright:O(104,49),bgMagentaBright:O(105,49),bgCyanBright:O(106,49),bgWhiteBright:O(107,49)},L=({useColor:e=k}={})=>e?D:Object.keys(D).reduce(((e,t)=>({...e,[t]:String})),{}),{reset:T,bold:S,dim:N,italic:P,underline:I,inverse:Y,hidden:Q,strikethrough:j,black:H,red:U,green:R,yellow:G,blue:Z,magenta:J,cyan:X,white:W,gray:V,bgBlack:q,bgRed:K,bgGreen:$,bgYellow:ee,bgBlue:te,bgMagenta:ne,bgCyan:se,bgWhite:ie,blackBright:re,redBright:ae,greenBright:oe,yellowBright:le,blueBright:ce,magentaBright:de,cyanBright:ue,whiteBright:fe,bgBlackBright:he,bgRedBright:pe,bgGreenBright:me,bgYellowBright:ge,bgBlueBright:_e,bgMagentaBright:be,bgCyanBright:ye,bgWhiteBright:Ae}=L();var we=i(8968);function xe(e,t,n,s="Array size exceeds target length"){if(e.length>n)throw new Error(s);return[...e,...Array(n-e.length).fill(t)]}function ve(e,t){return[...Array(e).keys()].map((e=>t(e)))}async function Ee(e,t){return await Promise.all(Array(e).fill(0).map(((e,n)=>t(n))))}function Me(e){return e.filter((e=>e&&("isZero"in e?!e.isZero():!e.isEmpty()))).map((e=>e.toBuffer().length)).reduce(((e,t)=>e+t),0)}function ze(e){return{parseEnv:t=>function(e,t){const n=parseInt(e,10);return Number.isSafeInteger(n)?n:t}(t,e),defaultValue:e}}function Be(e){return{parseEnv:e=>BigInt(e),defaultValue:e}}function Fe(e){return void 0!==e&&["1","true","TRUE"].includes(e)}const ke="logging.googleapis.com/trace",Ce="logging.googleapis.com/spanId",Oe="logging.googleapis.com/trace_sampled",De={messageKey:"message",timestamp:()=>`,"timestamp":"${new Date(Date.now()).toISOString()}"`,formatters:{log(e){const{trace_id:t,span_id:n,trace_flags:s,...i}=e;return t&&n?{[ke]:t,[Ce]:n,[Oe]:s?"01"===s:void 0,trace_flags:s,...i}:e},level(e,t){let n;switch(e){case"trace":case"debug":n="DEBUG";break;case"verbose":case"info":n="INFO";break;case"warn":n="WARNING";break;case"error":n="ERROR";break;case"fatal":n="CRITICAL";break;default:n="DEFAULT"}return{severity:n,level:t}}}},Le=["silent","fatal","error","warn","info","verbose","debug","trace"];function Te(e,t){for(const[n,s]of e)if(t.startsWith(n))return s}function Se(e){if(!Le.includes(e))throw new Error(`Invalid log level: ${e}`)}function Ne(e){if(!e)return[];const t=e.split(";"),n=[];for(const e of t){const[t]=e.split(":",1),s=e.slice(t.length+1);if(!s||!t)throw new Error(`Invalid log filter statement: ${e}`);const i=t.trim().toLowerCase();Se(i);for(const e of s.split(","))n.push([e.trim().toLowerCase().replace(/^aztec:/,""),i])}return n.reverse()}function Pe(e){e=Ye.reduce(((e,t)=>t(e)),e.replace(/^aztec:/,""));const t=tt.child({module:e},{level:Te(He,e)}),n=(e,n,s)=>Qe(t,e)&&t[e](function(e){return Ie.reduce(((e,t)=>t(e)),e)}(s??{}),n);return{silent:()=>{},fatal:(e,t,s)=>n("fatal",nt(e,t),s),error:(e,t,s)=>n("error",nt(e,t),s),warn:(e,t)=>n("warn",e,t),info:(e,t)=>n("info",e,t),verbose:(e,t)=>n("verbose",e,t),debug:(e,t)=>n("debug",e,t),trace:(e,t)=>n("trace",e,t),level:t.level,isLevelEnabled:e=>Qe(t,e),module:e}}const Ie=[],Ye=[];function Qe(e,t){return"function"==typeof e.isLevelEnabled?e.isLevelEnabled(t):e.levels.values[t]>=e.levels.values[e.level]}const[je,He]=function(e,t){if(!e)return["info",[]];const[n]=e.split(";",1);return Se(n),[n,Ne(e.slice(n.length+1))]}({NODE_ENV:"production"}.LOG_LEVEL),Ue={verbose:25},Re=Fe({NODE_ENV:"production"}.USE_GCLOUD_OBSERVABILITY),Ge={customLevels:Ue,messageKey:"msg",useOnlyCustomLevels:!1,level:je,...Re?De:{}},Ze={labels:{...we.pino.levels.labels,...Object.fromEntries(Object.entries(Ue).map((e=>e.reverse())))},values:{...we.pino.levels.values,...Ue}},Je=!0,{bold:Xe,reset:We}=L({useColor:Je}),Ve={target:"pino-pretty",options:{destination:2,sync:!0,colorize:Je,ignore:"module,pid,hostname,trace_id,span_id,trace_flags,severity",messageFormat:`${Xe("{module}")} ${We("{msg}")}`,customLevels:"fatal:60,error:50,warn:40,info:30,verbose:25,debug:20,trace:10",customColors:"fatal:bgRed,error:red,warn:yellow,info:green,verbose:magenta,debug:blue,trace:gray",minimumLevel:"trace",singleLine:!Fe({NODE_ENV:"production"}.LOG_MULTILINE)},level:"trace"},qe={target:"pino/file",options:{destination:2},level:"trace"},Ke={NODE_ENV:"production"}.OTEL_EXPORTER_OTLP_LOGS_ENDPOINT,$e=!!Ke&&!Re,et={target:"@aztec/telemetry-client/otel-pino-stream",options:{levels:Ze},level:"trace"},tt=function(){if(b){if({NODE_ENV:"production"}.JEST_WORKER_ID)return(0,we.pino)(Ge,we.pino.destination(2));{const e=[Fe({NODE_ENV:"production"}.LOG_JSON)?qe:Ve,$e?et:void 0].filter((e=>void 0!==e));return(0,we.pino)(Ge,we.pino.transport({targets:e,levels:Ze.values}))}}return(0,we.pino)({...Ge,browser:{asObject:!1}})}();function nt(e,t){return t?`${e}: ${(0,f.inspect)(t)}`:e}tt.verbose({module:"logger",...He.reduce(((e,[t,n])=>({...e,[`log.${t}`]:n})),{})},b?`Logger initialized with level ${je}`+($e?` with OTLP exporter to ${Ke}`:""):`Browser console logger initialized with level ${je}`);var st=i(8891).Buffer;class it{constructor(e,t=Pe("foundation:randomness_singleton")){this.seed=e,this.log=t,this.counter=0,void 0!==e?(this.log.debug(`Using pseudo-randomness with seed: ${e}`),this.counter=e):this.log.debug("Using true randomness")}static getInstance(){if(!it.instance){const e={NODE_ENV:"production"}.SEED?Number({NODE_ENV:"production"}.SEED):void 0;it.instance=new it(e)}return it.instance}isDeterministic(){return void 0!==this.seed}getBytes(e){if(void 0===this.seed)throw new Error("RandomnessSingleton is not implemented for non-deterministic mode");const t=st.alloc(e);for(let n=0;n<e;n++)t[n]=this.counter>>8*n&255;return this.counter++,t}}var rt=i(8891).Buffer;const at=65536,ot=e=>{const t=it.getInstance();if(t.isDeterministic())return t.getBytes(e);if(b)return _.randomBytes(e);const n="undefined"!=typeof window&&window.crypto?window.crypto:"undefined"!=typeof self&&self.crypto?self.crypto:void 0;if(!n)throw new Error("randomBytes UnsupportedEnvironment");const s=rt.allocUnsafe(e);if(e>at)for(let t=0;t<e;t+=at)n.getRandomValues(s.slice(t,t+at));else n.getRandomValues(s);return s},lt=e=>{const t=ot(6);return parseInt(t.toString("hex"),16)%e};var ct,dt;!function(e){e.assertEqual=e=>e,e.assertIs=function(e){},e.assertNever=function(e){throw new Error},e.arrayToEnum=e=>{const t={};for(const n of e)t[n]=n;return t},e.getValidEnumValues=t=>{const n=e.objectKeys(t).filter((e=>"number"!=typeof t[t[e]])),s={};for(const e of n)s[e]=t[e];return e.objectValues(s)},e.objectValues=t=>e.objectKeys(t).map((function(e){return t[e]})),e.objectKeys="function"==typeof Object.keys?e=>Object.keys(e):e=>{const t=[];for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.push(n);return t},e.find=(e,t)=>{for(const n of e)if(t(n))return n},e.isInteger="function"==typeof Number.isInteger?e=>Number.isInteger(e):e=>"number"==typeof e&&isFinite(e)&&Math.floor(e)===e,e.joinValues=function(e,t=" | "){return e.map((e=>"string"==typeof e?`'${e}'`:e)).join(t)},e.jsonStringifyReplacer=(e,t)=>"bigint"==typeof t?t.toString():t}(ct||(ct={})),function(e){e.mergeShapes=(e,t)=>({...e,...t})}(dt||(dt={}));const ut=ct.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),ft=e=>{switch(typeof e){case"undefined":return ut.undefined;case"string":return ut.string;case"number":return isNaN(e)?ut.nan:ut.number;case"boolean":return ut.boolean;case"function":return ut.function;case"bigint":return ut.bigint;case"symbol":return ut.symbol;case"object":return Array.isArray(e)?ut.array:null===e?ut.null:e.then&&"function"==typeof e.then&&e.catch&&"function"==typeof e.catch?ut.promise:"undefined"!=typeof Map&&e instanceof Map?ut.map:"undefined"!=typeof Set&&e instanceof Set?ut.set:"undefined"!=typeof Date&&e instanceof Date?ut.date:ut.object;default:return ut.unknown}},ht=ct.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]);class pt extends Error{constructor(e){super(),this.issues=[],this.addIssue=e=>{this.issues=[...this.issues,e]},this.addIssues=(e=[])=>{this.issues=[...this.issues,...e]};const t=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,t):this.__proto__=t,this.name="ZodError",this.issues=e}get errors(){return this.issues}format(e){const t=e||function(e){return e.message},n={_errors:[]},s=e=>{for(const i of e.issues)if("invalid_union"===i.code)i.unionErrors.map(s);else if("invalid_return_type"===i.code)s(i.returnTypeError);else if("invalid_arguments"===i.code)s(i.argumentsError);else if(0===i.path.length)n._errors.push(t(i));else{let e=n,s=0;for(;s<i.path.length;){const n=i.path[s];s===i.path.length-1?(e[n]=e[n]||{_errors:[]},e[n]._errors.push(t(i))):e[n]=e[n]||{_errors:[]},e=e[n],s++}}};return s(this),n}static assert(e){if(!(e instanceof pt))throw new Error(`Not a ZodError: ${e}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,ct.jsonStringifyReplacer,2)}get isEmpty(){return 0===this.issues.length}flatten(e=(e=>e.message)){const t={},n=[];for(const s of this.issues)s.path.length>0?(t[s.path[0]]=t[s.path[0]]||[],t[s.path[0]].push(e(s))):n.push(e(s));return{formErrors:n,fieldErrors:t}}get formErrors(){return this.flatten()}}pt.create=e=>new pt(e);const mt=(e,t)=>{let n;switch(e.code){case ht.invalid_type:n=e.received===ut.undefined?"Required":`Expected ${e.expected}, received ${e.received}`;break;case ht.invalid_literal:n=`Invalid literal value, expected ${JSON.stringify(e.expected,ct.jsonStringifyReplacer)}`;break;case ht.unrecognized_keys:n=`Unrecognized key(s) in object: ${ct.joinValues(e.keys,", ")}`;break;case ht.invalid_union:n="Invalid input";break;case ht.invalid_union_discriminator:n=`Invalid discriminator value. Expected ${ct.joinValues(e.options)}`;break;case ht.invalid_enum_value:n=`Invalid enum value. Expected ${ct.joinValues(e.options)}, received '${e.received}'`;break;case ht.invalid_arguments:n="Invalid function arguments";break;case ht.invalid_return_type:n="Invalid function return type";break;case ht.invalid_date:n="Invalid date";break;case ht.invalid_string:"object"==typeof e.validation?"includes"in e.validation?(n=`Invalid input: must include "${e.validation.includes}"`,"number"==typeof e.validation.position&&(n=`${n} at one or more positions greater than or equal to ${e.validation.position}`)):"startsWith"in e.validation?n=`Invalid input: must start with "${e.validation.startsWith}"`:"endsWith"in e.validation?n=`Invalid input: must end with "${e.validation.endsWith}"`:ct.assertNever(e.validation):n="regex"!==e.validation?`Invalid ${e.validation}`:"Invalid";break;case ht.too_small:n="array"===e.type?`Array must contain ${e.exact?"exactly":e.inclusive?"at least":"more than"} ${e.minimum} element(s)`:"string"===e.type?`String must contain ${e.exact?"exactly":e.inclusive?"at least":"over"} ${e.minimum} character(s)`:"number"===e.type?`Number must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${e.minimum}`:"date"===e.type?`Date must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(e.minimum))}`:"Invalid input";break;case ht.too_big:n="array"===e.type?`Array must contain ${e.exact?"exactly":e.inclusive?"at most":"less than"} ${e.maximum} element(s)`:"string"===e.type?`String must contain ${e.exact?"exactly":e.inclusive?"at most":"under"} ${e.maximum} character(s)`:"number"===e.type?`Number must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}`:"bigint"===e.type?`BigInt must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}`:"date"===e.type?`Date must be ${e.exact?"exactly":e.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(e.maximum))}`:"Invalid input";break;case ht.custom:n="Invalid input";break;case ht.invalid_intersection_types:n="Intersection results could not be merged";break;case ht.not_multiple_of:n=`Number must be a multiple of ${e.multipleOf}`;break;case ht.not_finite:n="Number must be finite";break;default:n=t.defaultError,ct.assertNever(e)}return{message:n}};let gt=mt;function _t(){return gt}const bt=e=>{const{data:t,path:n,errorMaps:s,issueData:i}=e,r=[...n,...i.path||[]],a={...i,path:r};if(void 0!==i.message)return{...i,path:r,message:i.message};let o="";const l=s.filter((e=>!!e)).slice().reverse();for(const e of l)o=e(a,{data:t,defaultError:o}).message;return{...i,path:r,message:o}};function yt(e,t){const n=_t(),s=bt({issueData:t,data:e.data,path:e.path,errorMaps:[e.common.contextualErrorMap,e.schemaErrorMap,n,n===mt?void 0:mt].filter((e=>!!e))});e.common.issues.push(s)}class At{constructor(){this.value="valid"}dirty(){"valid"===this.value&&(this.value="dirty")}abort(){"aborted"!==this.value&&(this.value="aborted")}static mergeArray(e,t){const n=[];for(const s of t){if("aborted"===s.status)return wt;"dirty"===s.status&&e.dirty(),n.push(s.value)}return{status:e.value,value:n}}static async mergeObjectAsync(e,t){const n=[];for(const e of t){const t=await e.key,s=await e.value;n.push({key:t,value:s})}return At.mergeObjectSync(e,n)}static mergeObjectSync(e,t){const n={};for(const s of t){const{key:t,value:i}=s;if("aborted"===t.status)return wt;if("aborted"===i.status)return wt;"dirty"===t.status&&e.dirty(),"dirty"===i.status&&e.dirty(),"__proto__"===t.value||void 0===i.value&&!s.alwaysSet||(n[t.value]=i.value)}return{status:e.value,value:n}}}const wt=Object.freeze({status:"aborted"}),xt=e=>({status:"dirty",value:e}),vt=e=>({status:"valid",value:e}),Et=e=>"aborted"===e.status,Mt=e=>"dirty"===e.status,zt=e=>"valid"===e.status,Bt=e=>"undefined"!=typeof Promise&&e instanceof Promise;function Ft(e,t,n,s){if("a"===n&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!s:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?s:"a"===n?s.call(e):s?s.value:t.get(e)}function kt(e,t,n,s,i){if("m"===s)throw new TypeError("Private method is not writable");if("a"===s&&!i)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===s?i.call(e,n):i?i.value=n:t.set(e,n),n}var Ct,Ot,Dt;"function"==typeof SuppressedError&&SuppressedError,function(e){e.errToObj=e=>"string"==typeof e?{message:e}:e||{},e.toString=e=>"string"==typeof e?e:null==e?void 0:e.message}(Ct||(Ct={}));class Lt{constructor(e,t,n,s){this._cachedPath=[],this.parent=e,this.data=t,this._path=n,this._key=s}get path(){return this._cachedPath.length||(this._key instanceof Array?this._cachedPath.push(...this._path,...this._key):this._cachedPath.push(...this._path,this._key)),this._cachedPath}}const Tt=(e,t)=>{if(zt(t))return{success:!0,data:t.value};if(!e.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;const t=new pt(e.common.issues);return this._error=t,this._error}}};function St(e){if(!e)return{};const{errorMap:t,invalid_type_error:n,required_error:s,description:i}=e;if(t&&(n||s))throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');return t?{errorMap:t,description:i}:{errorMap:(t,i)=>{var r,a;const{message:o}=e;return"invalid_enum_value"===t.code?{message:null!=o?o:i.defaultError}:void 0===i.data?{message:null!==(r=null!=o?o:s)&&void 0!==r?r:i.defaultError}:"invalid_type"!==t.code?{message:i.defaultError}:{message:null!==(a=null!=o?o:n)&&void 0!==a?a:i.defaultError}},description:i}}class Nt{constructor(e){this.spa=this.safeParseAsync,this._def=e,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this)}get description(){return this._def.description}_getType(e){return ft(e.data)}_getOrReturnCtx(e,t){return t||{common:e.parent.common,data:e.data,parsedType:ft(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}_processInputParams(e){return{status:new At,ctx:{common:e.parent.common,data:e.data,parsedType:ft(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}}_parseSync(e){const t=this._parse(e);if(Bt(t))throw new Error("Synchronous parse encountered promise.");return t}_parseAsync(e){const t=this._parse(e);return Promise.resolve(t)}parse(e,t){const n=this.safeParse(e,t);if(n.success)return n.data;throw n.error}safeParse(e,t){var n;const s={common:{issues:[],async:null!==(n=null==t?void 0:t.async)&&void 0!==n&&n,contextualErrorMap:null==t?void 0:t.errorMap},path:(null==t?void 0:t.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:ft(e)},i=this._parseSync({data:e,path:s.path,parent:s});return Tt(s,i)}async parseAsync(e,t){const n=await this.safeParseAsync(e,t);if(n.success)return n.data;throw n.error}async safeParseAsync(e,t){const n={common:{issues:[],contextualErrorMap:null==t?void 0:t.errorMap,async:!0},path:(null==t?void 0:t.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:ft(e)},s=this._parse({data:e,path:n.path,parent:n}),i=await(Bt(s)?s:Promise.resolve(s));return Tt(n,i)}refine(e,t){const n=e=>"string"==typeof t||void 0===t?{message:t}:"function"==typeof t?t(e):t;return this._refinement(((t,s)=>{const i=e(t),r=()=>s.addIssue({code:ht.custom,...n(t)});return"undefined"!=typeof Promise&&i instanceof Promise?i.then((e=>!!e||(r(),!1))):!!i||(r(),!1)}))}refinement(e,t){return this._refinement(((n,s)=>!!e(n)||(s.addIssue("function"==typeof t?t(n,s):t),!1)))}_refinement(e){return new On({schema:this,typeName:Un.ZodEffects,effect:{type:"refinement",refinement:e}})}superRefine(e){return this._refinement(e)}optional(){return Dn.create(this,this._def)}nullable(){return Ln.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return fn.create(this,this._def)}promise(){return Cn.create(this,this._def)}or(e){return mn.create([this,e],this._def)}and(e){return yn.create(this,e,this._def)}transform(e){return new On({...St(this._def),schema:this,typeName:Un.ZodEffects,effect:{type:"transform",transform:e}})}default(e){const t="function"==typeof e?e:()=>e;return new Tn({...St(this._def),innerType:this,defaultValue:t,typeName:Un.ZodDefault})}brand(){return new In({typeName:Un.ZodBranded,type:this,...St(this._def)})}catch(e){const t="function"==typeof e?e:()=>e;return new Sn({...St(this._def),innerType:this,catchValue:t,typeName:Un.ZodCatch})}describe(e){return new(0,this.constructor)({...this._def,description:e})}pipe(e){return Yn.create(this,e)}readonly(){return Qn.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}const Pt=/^c[^\s-]{8,}$/i,It=/^[0-9a-z]+$/,Yt=/^[0-9A-HJKMNP-TV-Z]{26}$/,Qt=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,jt=/^[a-z0-9_-]{21}$/i,Ht=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,Ut=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;let Rt;const Gt=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,Zt=/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,Jt=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,Xt="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",Wt=new RegExp(`^${Xt}$`);function Vt(e){let t="([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";return e.precision?t=`${t}\\.\\d{${e.precision}}`:null==e.precision&&(t=`${t}(\\.\\d+)?`),t}function qt(e){let t=`${Xt}T${Vt(e)}`;const n=[];return n.push(e.local?"Z?":"Z"),e.offset&&n.push("([+-]\\d{2}:?\\d{2})"),t=`${t}(${n.join("|")})`,new RegExp(`^${t}$`)}class Kt extends Nt{_parse(e){if(this._def.coerce&&(e.data=String(e.data)),this._getType(e)!==ut.string){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.string,received:t.parsedType}),wt}const t=new At;let n;for(const r of this._def.checks)if("min"===r.kind)e.data.length<r.value&&(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.too_small,minimum:r.value,type:"string",inclusive:!0,exact:!1,message:r.message}),t.dirty());else if("max"===r.kind)e.data.length>r.value&&(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.too_big,maximum:r.value,type:"string",inclusive:!0,exact:!1,message:r.message}),t.dirty());else if("length"===r.kind){const s=e.data.length>r.value,i=e.data.length<r.value;(s||i)&&(n=this._getOrReturnCtx(e,n),s?yt(n,{code:ht.too_big,maximum:r.value,type:"string",inclusive:!0,exact:!0,message:r.message}):i&&yt(n,{code:ht.too_small,minimum:r.value,type:"string",inclusive:!0,exact:!0,message:r.message}),t.dirty())}else if("email"===r.kind)Ut.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"email",code:ht.invalid_string,message:r.message}),t.dirty());else if("emoji"===r.kind)Rt||(Rt=new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$","u")),Rt.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"emoji",code:ht.invalid_string,message:r.message}),t.dirty());else if("uuid"===r.kind)Qt.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"uuid",code:ht.invalid_string,message:r.message}),t.dirty());else if("nanoid"===r.kind)jt.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"nanoid",code:ht.invalid_string,message:r.message}),t.dirty());else if("cuid"===r.kind)Pt.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"cuid",code:ht.invalid_string,message:r.message}),t.dirty());else if("cuid2"===r.kind)It.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"cuid2",code:ht.invalid_string,message:r.message}),t.dirty());else if("ulid"===r.kind)Yt.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"ulid",code:ht.invalid_string,message:r.message}),t.dirty());else if("url"===r.kind)try{new URL(e.data)}catch(s){n=this._getOrReturnCtx(e,n),yt(n,{validation:"url",code:ht.invalid_string,message:r.message}),t.dirty()}else"regex"===r.kind?(r.regex.lastIndex=0,r.regex.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"regex",code:ht.invalid_string,message:r.message}),t.dirty())):"trim"===r.kind?e.data=e.data.trim():"includes"===r.kind?e.data.includes(r.value,r.position)||(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.invalid_string,validation:{includes:r.value,position:r.position},message:r.message}),t.dirty()):"toLowerCase"===r.kind?e.data=e.data.toLowerCase():"toUpperCase"===r.kind?e.data=e.data.toUpperCase():"startsWith"===r.kind?e.data.startsWith(r.value)||(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.invalid_string,validation:{startsWith:r.value},message:r.message}),t.dirty()):"endsWith"===r.kind?e.data.endsWith(r.value)||(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.invalid_string,validation:{endsWith:r.value},message:r.message}),t.dirty()):"datetime"===r.kind?qt(r).test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.invalid_string,validation:"datetime",message:r.message}),t.dirty()):"date"===r.kind?Wt.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.invalid_string,validation:"date",message:r.message}),t.dirty()):"time"===r.kind?new RegExp(`^${Vt(r)}$`).test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.invalid_string,validation:"time",message:r.message}),t.dirty()):"duration"===r.kind?Ht.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"duration",code:ht.invalid_string,message:r.message}),t.dirty()):"ip"===r.kind?(s=e.data,("v4"!==(i=r.version)&&i||!Gt.test(s))&&("v6"!==i&&i||!Zt.test(s))&&(n=this._getOrReturnCtx(e,n),yt(n,{validation:"ip",code:ht.invalid_string,message:r.message}),t.dirty())):"base64"===r.kind?Jt.test(e.data)||(n=this._getOrReturnCtx(e,n),yt(n,{validation:"base64",code:ht.invalid_string,message:r.message}),t.dirty()):ct.assertNever(r);var s,i;return{status:t.value,value:e.data}}_regex(e,t,n){return this.refinement((t=>e.test(t)),{validation:t,code:ht.invalid_string,...Ct.errToObj(n)})}_addCheck(e){return new Kt({...this._def,checks:[...this._def.checks,e]})}email(e){return this._addCheck({kind:"email",...Ct.errToObj(e)})}url(e){return this._addCheck({kind:"url",...Ct.errToObj(e)})}emoji(e){return this._addCheck({kind:"emoji",...Ct.errToObj(e)})}uuid(e){return this._addCheck({kind:"uuid",...Ct.errToObj(e)})}nanoid(e){return this._addCheck({kind:"nanoid",...Ct.errToObj(e)})}cuid(e){return this._addCheck({kind:"cuid",...Ct.errToObj(e)})}cuid2(e){return this._addCheck({kind:"cuid2",...Ct.errToObj(e)})}ulid(e){return this._addCheck({kind:"ulid",...Ct.errToObj(e)})}base64(e){return this._addCheck({kind:"base64",...Ct.errToObj(e)})}ip(e){return this._addCheck({kind:"ip",...Ct.errToObj(e)})}datetime(e){var t,n;return"string"==typeof e?this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:e}):this._addCheck({kind:"datetime",precision:void 0===(null==e?void 0:e.precision)?null:null==e?void 0:e.precision,offset:null!==(t=null==e?void 0:e.offset)&&void 0!==t&&t,local:null!==(n=null==e?void 0:e.local)&&void 0!==n&&n,...Ct.errToObj(null==e?void 0:e.message)})}date(e){return this._addCheck({kind:"date",message:e})}time(e){return"string"==typeof e?this._addCheck({kind:"time",precision:null,message:e}):this._addCheck({kind:"time",precision:void 0===(null==e?void 0:e.precision)?null:null==e?void 0:e.precision,...Ct.errToObj(null==e?void 0:e.message)})}duration(e){return this._addCheck({kind:"duration",...Ct.errToObj(e)})}regex(e,t){return this._addCheck({kind:"regex",regex:e,...Ct.errToObj(t)})}includes(e,t){return this._addCheck({kind:"includes",value:e,position:null==t?void 0:t.position,...Ct.errToObj(null==t?void 0:t.message)})}startsWith(e,t){return this._addCheck({kind:"startsWith",value:e,...Ct.errToObj(t)})}endsWith(e,t){return this._addCheck({kind:"endsWith",value:e,...Ct.errToObj(t)})}min(e,t){return this._addCheck({kind:"min",value:e,...Ct.errToObj(t)})}max(e,t){return this._addCheck({kind:"max",value:e,...Ct.errToObj(t)})}length(e,t){return this._addCheck({kind:"length",value:e,...Ct.errToObj(t)})}nonempty(e){return this.min(1,Ct.errToObj(e))}trim(){return new Kt({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new Kt({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new Kt({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find((e=>"datetime"===e.kind))}get isDate(){return!!this._def.checks.find((e=>"date"===e.kind))}get isTime(){return!!this._def.checks.find((e=>"time"===e.kind))}get isDuration(){return!!this._def.checks.find((e=>"duration"===e.kind))}get isEmail(){return!!this._def.checks.find((e=>"email"===e.kind))}get isURL(){return!!this._def.checks.find((e=>"url"===e.kind))}get isEmoji(){return!!this._def.checks.find((e=>"emoji"===e.kind))}get isUUID(){return!!this._def.checks.find((e=>"uuid"===e.kind))}get isNANOID(){return!!this._def.checks.find((e=>"nanoid"===e.kind))}get isCUID(){return!!this._def.checks.find((e=>"cuid"===e.kind))}get isCUID2(){return!!this._def.checks.find((e=>"cuid2"===e.kind))}get isULID(){return!!this._def.checks.find((e=>"ulid"===e.kind))}get isIP(){return!!this._def.checks.find((e=>"ip"===e.kind))}get isBase64(){return!!this._def.checks.find((e=>"base64"===e.kind))}get minLength(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxLength(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}}function $t(e,t){const n=(e.toString().split(".")[1]||"").length,s=(t.toString().split(".")[1]||"").length,i=n>s?n:s;return parseInt(e.toFixed(i).replace(".",""))%parseInt(t.toFixed(i).replace(".",""))/Math.pow(10,i)}Kt.create=e=>{var t;return new Kt({checks:[],typeName:Un.ZodString,coerce:null!==(t=null==e?void 0:e.coerce)&&void 0!==t&&t,...St(e)})};class en extends Nt{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(e){if(this._def.coerce&&(e.data=Number(e.data)),this._getType(e)!==ut.number){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.number,received:t.parsedType}),wt}let t;const n=new At;for(const s of this._def.checks)"int"===s.kind?ct.isInteger(e.data)||(t=this._getOrReturnCtx(e,t),yt(t,{code:ht.invalid_type,expected:"integer",received:"float",message:s.message}),n.dirty()):"min"===s.kind?(s.inclusive?e.data<s.value:e.data<=s.value)&&(t=this._getOrReturnCtx(e,t),yt(t,{code:ht.too_small,minimum:s.value,type:"number",inclusive:s.inclusive,exact:!1,message:s.message}),n.dirty()):"max"===s.kind?(s.inclusive?e.data>s.value:e.data>=s.value)&&(t=this._getOrReturnCtx(e,t),yt(t,{code:ht.too_big,maximum:s.value,type:"number",inclusive:s.inclusive,exact:!1,message:s.message}),n.dirty()):"multipleOf"===s.kind?0!==$t(e.data,s.value)&&(t=this._getOrReturnCtx(e,t),yt(t,{code:ht.not_multiple_of,multipleOf:s.value,message:s.message}),n.dirty()):"finite"===s.kind?Number.isFinite(e.data)||(t=this._getOrReturnCtx(e,t),yt(t,{code:ht.not_finite,message:s.message}),n.dirty()):ct.assertNever(s);return{status:n.value,value:e.data}}gte(e,t){return this.setLimit("min",e,!0,Ct.toString(t))}gt(e,t){return this.setLimit("min",e,!1,Ct.toString(t))}lte(e,t){return this.setLimit("max",e,!0,Ct.toString(t))}lt(e,t){return this.setLimit("max",e,!1,Ct.toString(t))}setLimit(e,t,n,s){return new en({...this._def,checks:[...this._def.checks,{kind:e,value:t,inclusive:n,message:Ct.toString(s)}]})}_addCheck(e){return new en({...this._def,checks:[...this._def.checks,e]})}int(e){return this._addCheck({kind:"int",message:Ct.toString(e)})}positive(e){return this._addCheck({kind:"min",value:0,inclusive:!1,message:Ct.toString(e)})}negative(e){return this._addCheck({kind:"max",value:0,inclusive:!1,message:Ct.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:0,inclusive:!0,message:Ct.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:0,inclusive:!0,message:Ct.toString(e)})}multipleOf(e,t){return this._addCheck({kind:"multipleOf",value:e,message:Ct.toString(t)})}finite(e){return this._addCheck({kind:"finite",message:Ct.toString(e)})}safe(e){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:Ct.toString(e)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:Ct.toString(e)})}get minValue(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxValue(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}get isInt(){return!!this._def.checks.find((e=>"int"===e.kind||"multipleOf"===e.kind&&ct.isInteger(e.value)))}get isFinite(){let e=null,t=null;for(const n of this._def.checks){if("finite"===n.kind||"int"===n.kind||"multipleOf"===n.kind)return!0;"min"===n.kind?(null===t||n.value>t)&&(t=n.value):"max"===n.kind&&(null===e||n.value<e)&&(e=n.value)}return Number.isFinite(t)&&Number.isFinite(e)}}en.create=e=>new en({checks:[],typeName:Un.ZodNumber,coerce:(null==e?void 0:e.coerce)||!1,...St(e)});class tn extends Nt{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte}_parse(e){if(this._def.coerce&&(e.data=BigInt(e.data)),this._getType(e)!==ut.bigint){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.bigint,received:t.parsedType}),wt}let t;const n=new At;for(const s of this._def.checks)"min"===s.kind?(s.inclusive?e.data<s.value:e.data<=s.value)&&(t=this._getOrReturnCtx(e,t),yt(t,{code:ht.too_small,type:"bigint",minimum:s.value,inclusive:s.inclusive,message:s.message}),n.dirty()):"max"===s.kind?(s.inclusive?e.data>s.value:e.data>=s.value)&&(t=this._getOrReturnCtx(e,t),yt(t,{code:ht.too_big,type:"bigint",maximum:s.value,inclusive:s.inclusive,message:s.message}),n.dirty()):"multipleOf"===s.kind?e.data%s.value!==BigInt(0)&&(t=this._getOrReturnCtx(e,t),yt(t,{code:ht.not_multiple_of,multipleOf:s.value,message:s.message}),n.dirty()):ct.assertNever(s);return{status:n.value,value:e.data}}gte(e,t){return this.setLimit("min",e,!0,Ct.toString(t))}gt(e,t){return this.setLimit("min",e,!1,Ct.toString(t))}lte(e,t){return this.setLimit("max",e,!0,Ct.toString(t))}lt(e,t){return this.setLimit("max",e,!1,Ct.toString(t))}setLimit(e,t,n,s){return new tn({...this._def,checks:[...this._def.checks,{kind:e,value:t,inclusive:n,message:Ct.toString(s)}]})}_addCheck(e){return new tn({...this._def,checks:[...this._def.checks,e]})}positive(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:Ct.toString(e)})}negative(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:Ct.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:Ct.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:Ct.toString(e)})}multipleOf(e,t){return this._addCheck({kind:"multipleOf",value:e,message:Ct.toString(t)})}get minValue(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxValue(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}}tn.create=e=>{var t;return new tn({checks:[],typeName:Un.ZodBigInt,coerce:null!==(t=null==e?void 0:e.coerce)&&void 0!==t&&t,...St(e)})};class nn extends Nt{_parse(e){if(this._def.coerce&&(e.data=Boolean(e.data)),this._getType(e)!==ut.boolean){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.boolean,received:t.parsedType}),wt}return vt(e.data)}}nn.create=e=>new nn({typeName:Un.ZodBoolean,coerce:(null==e?void 0:e.coerce)||!1,...St(e)});class sn extends Nt{_parse(e){if(this._def.coerce&&(e.data=new Date(e.data)),this._getType(e)!==ut.date){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.date,received:t.parsedType}),wt}if(isNaN(e.data.getTime()))return yt(this._getOrReturnCtx(e),{code:ht.invalid_date}),wt;const t=new At;let n;for(const s of this._def.checks)"min"===s.kind?e.data.getTime()<s.value&&(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.too_small,message:s.message,inclusive:!0,exact:!1,minimum:s.value,type:"date"}),t.dirty()):"max"===s.kind?e.data.getTime()>s.value&&(n=this._getOrReturnCtx(e,n),yt(n,{code:ht.too_big,message:s.message,inclusive:!0,exact:!1,maximum:s.value,type:"date"}),t.dirty()):ct.assertNever(s);return{status:t.value,value:new Date(e.data.getTime())}}_addCheck(e){return new sn({...this._def,checks:[...this._def.checks,e]})}min(e,t){return this._addCheck({kind:"min",value:e.getTime(),message:Ct.toString(t)})}max(e,t){return this._addCheck({kind:"max",value:e.getTime(),message:Ct.toString(t)})}get minDate(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return null!=e?new Date(e):null}get maxDate(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return null!=e?new Date(e):null}}sn.create=e=>new sn({checks:[],coerce:(null==e?void 0:e.coerce)||!1,typeName:Un.ZodDate,...St(e)});class rn extends Nt{_parse(e){if(this._getType(e)!==ut.symbol){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.symbol,received:t.parsedType}),wt}return vt(e.data)}}rn.create=e=>new rn({typeName:Un.ZodSymbol,...St(e)});class an extends Nt{_parse(e){if(this._getType(e)!==ut.undefined){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.undefined,received:t.parsedType}),wt}return vt(e.data)}}an.create=e=>new an({typeName:Un.ZodUndefined,...St(e)});class on extends Nt{_parse(e){if(this._getType(e)!==ut.null){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.null,received:t.parsedType}),wt}return vt(e.data)}}on.create=e=>new on({typeName:Un.ZodNull,...St(e)});class ln extends Nt{constructor(){super(...arguments),this._any=!0}_parse(e){return vt(e.data)}}ln.create=e=>new ln({typeName:Un.ZodAny,...St(e)});class cn extends Nt{constructor(){super(...arguments),this._unknown=!0}_parse(e){return vt(e.data)}}cn.create=e=>new cn({typeName:Un.ZodUnknown,...St(e)});class dn extends Nt{_parse(e){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.never,received:t.parsedType}),wt}}dn.create=e=>new dn({typeName:Un.ZodNever,...St(e)});class un extends Nt{_parse(e){if(this._getType(e)!==ut.undefined){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.void,received:t.parsedType}),wt}return vt(e.data)}}un.create=e=>new un({typeName:Un.ZodVoid,...St(e)});class fn extends Nt{_parse(e){const{ctx:t,status:n}=this._processInputParams(e),s=this._def;if(t.parsedType!==ut.array)return yt(t,{code:ht.invalid_type,expected:ut.array,received:t.parsedType}),wt;if(null!==s.exactLength){const e=t.data.length>s.exactLength.value,i=t.data.length<s.exactLength.value;(e||i)&&(yt(t,{code:e?ht.too_big:ht.too_small,minimum:i?s.exactLength.value:void 0,maximum:e?s.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:s.exactLength.message}),n.dirty())}if(null!==s.minLength&&t.data.length<s.minLength.value&&(yt(t,{code:ht.too_small,minimum:s.minLength.value,type:"array",inclusive:!0,exact:!1,message:s.minLength.message}),n.dirty()),null!==s.maxLength&&t.data.length>s.maxLength.value&&(yt(t,{code:ht.too_big,maximum:s.maxLength.value,type:"array",inclusive:!0,exact:!1,message:s.maxLength.message}),n.dirty()),t.common.async)return Promise.all([...t.data].map(((e,n)=>s.type._parseAsync(new Lt(t,e,t.path,n))))).then((e=>At.mergeArray(n,e)));const i=[...t.data].map(((e,n)=>s.type._parseSync(new Lt(t,e,t.path,n))));return At.mergeArray(n,i)}get element(){return this._def.type}min(e,t){return new fn({...this._def,minLength:{value:e,message:Ct.toString(t)}})}max(e,t){return new fn({...this._def,maxLength:{value:e,message:Ct.toString(t)}})}length(e,t){return new fn({...this._def,exactLength:{value:e,message:Ct.toString(t)}})}nonempty(e){return this.min(1,e)}}function hn(e){if(e instanceof pn){const t={};for(const n in e.shape){const s=e.shape[n];t[n]=Dn.create(hn(s))}return new pn({...e._def,shape:()=>t})}return e instanceof fn?new fn({...e._def,type:hn(e.element)}):e instanceof Dn?Dn.create(hn(e.unwrap())):e instanceof Ln?Ln.create(hn(e.unwrap())):e instanceof An?An.create(e.items.map((e=>hn(e)))):e}fn.create=(e,t)=>new fn({type:e,minLength:null,maxLength:null,exactLength:null,typeName:Un.ZodArray,...St(t)});class pn extends Nt{constructor(){super(...arguments),this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(null!==this._cached)return this._cached;const e=this._def.shape(),t=ct.objectKeys(e);return this._cached={shape:e,keys:t}}_parse(e){if(this._getType(e)!==ut.object){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.object,received:t.parsedType}),wt}const{status:t,ctx:n}=this._processInputParams(e),{shape:s,keys:i}=this._getCached(),r=[];if(!(this._def.catchall instanceof dn&&"strip"===this._def.unknownKeys))for(const e in n.data)i.includes(e)||r.push(e);const a=[];for(const e of i){const t=s[e],i=n.data[e];a.push({key:{status:"valid",value:e},value:t._parse(new Lt(n,i,n.path,e)),alwaysSet:e in n.data})}if(this._def.catchall instanceof dn){const e=this._def.unknownKeys;if("passthrough"===e)for(const e of r)a.push({key:{status:"valid",value:e},value:{status:"valid",value:n.data[e]}});else if("strict"===e)r.length>0&&(yt(n,{code:ht.unrecognized_keys,keys:r}),t.dirty());else if("strip"!==e)throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{const e=this._def.catchall;for(const t of r){const s=n.data[t];a.push({key:{status:"valid",value:t},value:e._parse(new Lt(n,s,n.path,t)),alwaysSet:t in n.data})}}return n.common.async?Promise.resolve().then((async()=>{const e=[];for(const t of a){const n=await t.key,s=await t.value;e.push({key:n,value:s,alwaysSet:t.alwaysSet})}return e})).then((e=>At.mergeObjectSync(t,e))):At.mergeObjectSync(t,a)}get shape(){return this._def.shape()}strict(e){return Ct.errToObj,new pn({...this._def,unknownKeys:"strict",...void 0!==e?{errorMap:(t,n)=>{var s,i,r,a;const o=null!==(r=null===(i=(s=this._def).errorMap)||void 0===i?void 0:i.call(s,t,n).message)&&void 0!==r?r:n.defaultError;return"unrecognized_keys"===t.code?{message:null!==(a=Ct.errToObj(e).message)&&void 0!==a?a:o}:{message:o}}}:{}})}strip(){return new pn({...this._def,unknownKeys:"strip"})}passthrough(){return new pn({...this._def,unknownKeys:"passthrough"})}extend(e){return new pn({...this._def,shape:()=>({...this._def.shape(),...e})})}merge(e){return new pn({unknownKeys:e._def.unknownKeys,catchall:e._def.catchall,shape:()=>({...this._def.shape(),...e._def.shape()}),typeName:Un.ZodObject})}setKey(e,t){return this.augment({[e]:t})}catchall(e){return new pn({...this._def,catchall:e})}pick(e){const t={};return ct.objectKeys(e).forEach((n=>{e[n]&&this.shape[n]&&(t[n]=this.shape[n])})),new pn({...this._def,shape:()=>t})}omit(e){const t={};return ct.objectKeys(this.shape).forEach((n=>{e[n]||(t[n]=this.shape[n])})),new pn({...this._def,shape:()=>t})}deepPartial(){return hn(this)}partial(e){const t={};return ct.objectKeys(this.shape).forEach((n=>{const s=this.shape[n];e&&!e[n]?t[n]=s:t[n]=s.optional()})),new pn({...this._def,shape:()=>t})}required(e){const t={};return ct.objectKeys(this.shape).forEach((n=>{if(e&&!e[n])t[n]=this.shape[n];else{let e=this.shape[n];for(;e instanceof Dn;)e=e._def.innerType;t[n]=e}})),new pn({...this._def,shape:()=>t})}keyof(){return Bn(ct.objectKeys(this.shape))}}pn.create=(e,t)=>new pn({shape:()=>e,unknownKeys:"strip",catchall:dn.create(),typeName:Un.ZodObject,...St(t)}),pn.strictCreate=(e,t)=>new pn({shape:()=>e,unknownKeys:"strict",catchall:dn.create(),typeName:Un.ZodObject,...St(t)}),pn.lazycreate=(e,t)=>new pn({shape:e,unknownKeys:"strip",catchall:dn.create(),typeName:Un.ZodObject,...St(t)});class mn extends Nt{_parse(e){const{ctx:t}=this._processInputParams(e),n=this._def.options;if(t.common.async)return Promise.all(n.map((async e=>{const n={...t,common:{...t.common,issues:[]},parent:null};return{result:await e._parseAsync({data:t.data,path:t.path,parent:n}),ctx:n}}))).then((function(e){for(const t of e)if("valid"===t.result.status)return t.result;for(const n of e)if("dirty"===n.result.status)return t.common.issues.push(...n.ctx.common.issues),n.result;const n=e.map((e=>new pt(e.ctx.common.issues)));return yt(t,{code:ht.invalid_union,unionErrors:n}),wt}));{let e;const s=[];for(const i of n){const n={...t,common:{...t.common,issues:[]},parent:null},r=i._parseSync({data:t.data,path:t.path,parent:n});if("valid"===r.status)return r;"dirty"!==r.status||e||(e={result:r,ctx:n}),n.common.issues.length&&s.push(n.common.issues)}if(e)return t.common.issues.push(...e.ctx.common.issues),e.result;const i=s.map((e=>new pt(e)));return yt(t,{code:ht.invalid_union,unionErrors:i}),wt}}get options(){return this._def.options}}mn.create=(e,t)=>new mn({options:e,typeName:Un.ZodUnion,...St(t)});const gn=e=>e instanceof Mn?gn(e.schema):e instanceof On?gn(e.innerType()):e instanceof zn?[e.value]:e instanceof Fn?e.options:e instanceof kn?ct.objectValues(e.enum):e instanceof Tn?gn(e._def.innerType):e instanceof an?[void 0]:e instanceof on?[null]:e instanceof Dn?[void 0,...gn(e.unwrap())]:e instanceof Ln?[null,...gn(e.unwrap())]:e instanceof In||e instanceof Qn?gn(e.unwrap()):e instanceof Sn?gn(e._def.innerType):[];class _n extends Nt{_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==ut.object)return yt(t,{code:ht.invalid_type,expected:ut.object,received:t.parsedType}),wt;const n=this.discriminator,s=t.data[n],i=this.optionsMap.get(s);return i?t.common.async?i._parseAsync({data:t.data,path:t.path,parent:t}):i._parseSync({data:t.data,path:t.path,parent:t}):(yt(t,{code:ht.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[n]}),wt)}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(e,t,n){const s=new Map;for(const n of t){const t=gn(n.shape[e]);if(!t.length)throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);for(const i of t){if(s.has(i))throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(i)}`);s.set(i,n)}}return new _n({typeName:Un.ZodDiscriminatedUnion,discriminator:e,options:t,optionsMap:s,...St(n)})}}function bn(e,t){const n=ft(e),s=ft(t);if(e===t)return{valid:!0,data:e};if(n===ut.object&&s===ut.object){const n=ct.objectKeys(t),s=ct.objectKeys(e).filter((e=>-1!==n.indexOf(e))),i={...e,...t};for(const n of s){const s=bn(e[n],t[n]);if(!s.valid)return{valid:!1};i[n]=s.data}return{valid:!0,data:i}}if(n===ut.array&&s===ut.array){if(e.length!==t.length)return{valid:!1};const n=[];for(let s=0;s<e.length;s++){const i=bn(e[s],t[s]);if(!i.valid)return{valid:!1};n.push(i.data)}return{valid:!0,data:n}}return n===ut.date&&s===ut.date&&+e==+t?{valid:!0,data:e}:{valid:!1}}class yn extends Nt{_parse(e){const{status:t,ctx:n}=this._processInputParams(e),s=(e,s)=>{if(Et(e)||Et(s))return wt;const i=bn(e.value,s.value);return i.valid?((Mt(e)||Mt(s))&&t.dirty(),{status:t.value,value:i.data}):(yt(n,{code:ht.invalid_intersection_types}),wt)};return n.common.async?Promise.all([this._def.left._parseAsync({data:n.data,path:n.path,parent:n}),this._def.right._parseAsync({data:n.data,path:n.path,parent:n})]).then((([e,t])=>s(e,t))):s(this._def.left._parseSync({data:n.data,path:n.path,parent:n}),this._def.right._parseSync({data:n.data,path:n.path,parent:n}))}}yn.create=(e,t,n)=>new yn({left:e,right:t,typeName:Un.ZodIntersection,...St(n)});class An extends Nt{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==ut.array)return yt(n,{code:ht.invalid_type,expected:ut.array,received:n.parsedType}),wt;if(n.data.length<this._def.items.length)return yt(n,{code:ht.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),wt;!this._def.rest&&n.data.length>this._def.items.length&&(yt(n,{code:ht.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),t.dirty());const s=[...n.data].map(((e,t)=>{const s=this._def.items[t]||this._def.rest;return s?s._parse(new Lt(n,e,n.path,t)):null})).filter((e=>!!e));return n.common.async?Promise.all(s).then((e=>At.mergeArray(t,e))):At.mergeArray(t,s)}get items(){return this._def.items}rest(e){return new An({...this._def,rest:e})}}An.create=(e,t)=>{if(!Array.isArray(e))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new An({items:e,typeName:Un.ZodTuple,rest:null,...St(t)})};class wn extends Nt{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==ut.object)return yt(n,{code:ht.invalid_type,expected:ut.object,received:n.parsedType}),wt;const s=[],i=this._def.keyType,r=this._def.valueType;for(const e in n.data)s.push({key:i._parse(new Lt(n,e,n.path,e)),value:r._parse(new Lt(n,n.data[e],n.path,e)),alwaysSet:e in n.data});return n.common.async?At.mergeObjectAsync(t,s):At.mergeObjectSync(t,s)}get element(){return this._def.valueType}static create(e,t,n){return new wn(t instanceof Nt?{keyType:e,valueType:t,typeName:Un.ZodRecord,...St(n)}:{keyType:Kt.create(),valueType:e,typeName:Un.ZodRecord,...St(t)})}}class xn extends Nt{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==ut.map)return yt(n,{code:ht.invalid_type,expected:ut.map,received:n.parsedType}),wt;const s=this._def.keyType,i=this._def.valueType,r=[...n.data.entries()].map((([e,t],r)=>({key:s._parse(new Lt(n,e,n.path,[r,"key"])),value:i._parse(new Lt(n,t,n.path,[r,"value"]))})));if(n.common.async){const e=new Map;return Promise.resolve().then((async()=>{for(const n of r){const s=await n.key,i=await n.value;if("aborted"===s.status||"aborted"===i.status)return wt;"dirty"!==s.status&&"dirty"!==i.status||t.dirty(),e.set(s.value,i.value)}return{status:t.value,value:e}}))}{const e=new Map;for(const n of r){const s=n.key,i=n.value;if("aborted"===s.status||"aborted"===i.status)return wt;"dirty"!==s.status&&"dirty"!==i.status||t.dirty(),e.set(s.value,i.value)}return{status:t.value,value:e}}}}xn.create=(e,t,n)=>new xn({valueType:t,keyType:e,typeName:Un.ZodMap,...St(n)});class vn extends Nt{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==ut.set)return yt(n,{code:ht.invalid_type,expected:ut.set,received:n.parsedType}),wt;const s=this._def;null!==s.minSize&&n.data.size<s.minSize.value&&(yt(n,{code:ht.too_small,minimum:s.minSize.value,type:"set",inclusive:!0,exact:!1,message:s.minSize.message}),t.dirty()),null!==s.maxSize&&n.data.size>s.maxSize.value&&(yt(n,{code:ht.too_big,maximum:s.maxSize.value,type:"set",inclusive:!0,exact:!1,message:s.maxSize.message}),t.dirty());const i=this._def.valueType;function r(e){const n=new Set;for(const s of e){if("aborted"===s.status)return wt;"dirty"===s.status&&t.dirty(),n.add(s.value)}return{status:t.value,value:n}}const a=[...n.data.values()].map(((e,t)=>i._parse(new Lt(n,e,n.path,t))));return n.common.async?Promise.all(a).then((e=>r(e))):r(a)}min(e,t){return new vn({...this._def,minSize:{value:e,message:Ct.toString(t)}})}max(e,t){return new vn({...this._def,maxSize:{value:e,message:Ct.toString(t)}})}size(e,t){return this.min(e,t).max(e,t)}nonempty(e){return this.min(1,e)}}vn.create=(e,t)=>new vn({valueType:e,minSize:null,maxSize:null,typeName:Un.ZodSet,...St(t)});class En extends Nt{constructor(){super(...arguments),this.validate=this.implement}_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==ut.function)return yt(t,{code:ht.invalid_type,expected:ut.function,received:t.parsedType}),wt;function n(e,n){return bt({data:e,path:t.path,errorMaps:[t.common.contextualErrorMap,t.schemaErrorMap,_t(),mt].filter((e=>!!e)),issueData:{code:ht.invalid_arguments,argumentsError:n}})}function s(e,n){return bt({data:e,path:t.path,errorMaps:[t.common.contextualErrorMap,t.schemaErrorMap,_t(),mt].filter((e=>!!e)),issueData:{code:ht.invalid_return_type,returnTypeError:n}})}const i={errorMap:t.common.contextualErrorMap},r=t.data;if(this._def.returns instanceof Cn){const e=this;return vt((async function(...t){const a=new pt([]),o=await e._def.args.parseAsync(t,i).catch((e=>{throw a.addIssue(n(t,e)),a})),l=await Reflect.apply(r,this,o);return await e._def.returns._def.type.parseAsync(l,i).catch((e=>{throw a.addIssue(s(l,e)),a}))}))}{const e=this;return vt((function(...t){const a=e._def.args.safeParse(t,i);if(!a.success)throw new pt([n(t,a.error)]);const o=Reflect.apply(r,this,a.data),l=e._def.returns.safeParse(o,i);if(!l.success)throw new pt([s(o,l.error)]);return l.data}))}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...e){return new En({...this._def,args:An.create(e).rest(cn.create())})}returns(e){return new En({...this._def,returns:e})}implement(e){return this.parse(e)}strictImplement(e){return this.parse(e)}static create(e,t,n){return new En({args:e||An.create([]).rest(cn.create()),returns:t||cn.create(),typeName:Un.ZodFunction,...St(n)})}}class Mn extends Nt{get schema(){return this._def.getter()}_parse(e){const{ctx:t}=this._processInputParams(e);return this._def.getter()._parse({data:t.data,path:t.path,parent:t})}}Mn.create=(e,t)=>new Mn({getter:e,typeName:Un.ZodLazy,...St(t)});class zn extends Nt{_parse(e){if(e.data!==this._def.value){const t=this._getOrReturnCtx(e);return yt(t,{received:t.data,code:ht.invalid_literal,expected:this._def.value}),wt}return{status:"valid",value:e.data}}get value(){return this._def.value}}function Bn(e,t){return new Fn({values:e,typeName:Un.ZodEnum,...St(t)})}zn.create=(e,t)=>new zn({value:e,typeName:Un.ZodLiteral,...St(t)});class Fn extends Nt{constructor(){super(...arguments),Ot.set(this,void 0)}_parse(e){if("string"!=typeof e.data){const t=this._getOrReturnCtx(e),n=this._def.values;return yt(t,{expected:ct.joinValues(n),received:t.parsedType,code:ht.invalid_type}),wt}if(Ft(this,Ot,"f")||kt(this,Ot,new Set(this._def.values),"f"),!Ft(this,Ot,"f").has(e.data)){const t=this._getOrReturnCtx(e),n=this._def.values;return yt(t,{received:t.data,code:ht.invalid_enum_value,options:n}),wt}return vt(e.data)}get options(){return this._def.values}get enum(){const e={};for(const t of this._def.values)e[t]=t;return e}get Values(){const e={};for(const t of this._def.values)e[t]=t;return e}get Enum(){const e={};for(const t of this._def.values)e[t]=t;return e}extract(e,t=this._def){return Fn.create(e,{...this._def,...t})}exclude(e,t=this._def){return Fn.create(this.options.filter((t=>!e.includes(t))),{...this._def,...t})}}Ot=new WeakMap,Fn.create=Bn;class kn extends Nt{constructor(){super(...arguments),Dt.set(this,void 0)}_parse(e){const t=ct.getValidEnumValues(this._def.values),n=this._getOrReturnCtx(e);if(n.parsedType!==ut.string&&n.parsedType!==ut.number){const e=ct.objectValues(t);return yt(n,{expected:ct.joinValues(e),received:n.parsedType,code:ht.invalid_type}),wt}if(Ft(this,Dt,"f")||kt(this,Dt,new Set(ct.getValidEnumValues(this._def.values)),"f"),!Ft(this,Dt,"f").has(e.data)){const e=ct.objectValues(t);return yt(n,{received:n.data,code:ht.invalid_enum_value,options:e}),wt}return vt(e.data)}get enum(){return this._def.values}}Dt=new WeakMap,kn.create=(e,t)=>new kn({values:e,typeName:Un.ZodNativeEnum,...St(t)});class Cn extends Nt{unwrap(){return this._def.type}_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==ut.promise&&!1===t.common.async)return yt(t,{code:ht.invalid_type,expected:ut.promise,received:t.parsedType}),wt;const n=t.parsedType===ut.promise?t.data:Promise.resolve(t.data);return vt(n.then((e=>this._def.type.parseAsync(e,{path:t.path,errorMap:t.common.contextualErrorMap}))))}}Cn.create=(e,t)=>new Cn({type:e,typeName:Un.ZodPromise,...St(t)});class On extends Nt{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===Un.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(e){const{status:t,ctx:n}=this._processInputParams(e),s=this._def.effect||null,i={addIssue:e=>{yt(n,e),e.fatal?t.abort():t.dirty()},get path(){return n.path}};if(i.addIssue=i.addIssue.bind(i),"preprocess"===s.type){const e=s.transform(n.data,i);if(n.common.async)return Promise.resolve(e).then((async e=>{if("aborted"===t.value)return wt;const s=await this._def.schema._parseAsync({data:e,path:n.path,parent:n});return"aborted"===s.status?wt:"dirty"===s.status||"dirty"===t.value?xt(s.value):s}));{if("aborted"===t.value)return wt;const s=this._def.schema._parseSync({data:e,path:n.path,parent:n});return"aborted"===s.status?wt:"dirty"===s.status||"dirty"===t.value?xt(s.value):s}}if("refinement"===s.type){const e=e=>{const t=s.refinement(e,i);if(n.common.async)return Promise.resolve(t);if(t instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return e};if(!1===n.common.async){const s=this._def.schema._parseSync({data:n.data,path:n.path,parent:n});return"aborted"===s.status?wt:("dirty"===s.status&&t.dirty(),e(s.value),{status:t.value,value:s.value})}return this._def.schema._parseAsync({data:n.data,path:n.path,parent:n}).then((n=>"aborted"===n.status?wt:("dirty"===n.status&&t.dirty(),e(n.value).then((()=>({status:t.value,value:n.value}))))))}if("transform"===s.type){if(!1===n.common.async){const e=this._def.schema._parseSync({data:n.data,path:n.path,parent:n});if(!zt(e))return e;const r=s.transform(e.value,i);if(r instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:t.value,value:r}}return this._def.schema._parseAsync({data:n.data,path:n.path,parent:n}).then((e=>zt(e)?Promise.resolve(s.transform(e.value,i)).then((e=>({status:t.value,value:e}))):e))}ct.assertNever(s)}}On.create=(e,t,n)=>new On({schema:e,typeName:Un.ZodEffects,effect:t,...St(n)}),On.createWithPreprocess=(e,t,n)=>new On({schema:t,effect:{type:"preprocess",transform:e},typeName:Un.ZodEffects,...St(n)});class Dn extends Nt{_parse(e){return this._getType(e)===ut.undefined?vt(void 0):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}Dn.create=(e,t)=>new Dn({innerType:e,typeName:Un.ZodOptional,...St(t)});class Ln extends Nt{_parse(e){return this._getType(e)===ut.null?vt(null):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}Ln.create=(e,t)=>new Ln({innerType:e,typeName:Un.ZodNullable,...St(t)});class Tn extends Nt{_parse(e){const{ctx:t}=this._processInputParams(e);let n=t.data;return t.parsedType===ut.undefined&&(n=this._def.defaultValue()),this._def.innerType._parse({data:n,path:t.path,parent:t})}removeDefault(){return this._def.innerType}}Tn.create=(e,t)=>new Tn({innerType:e,typeName:Un.ZodDefault,defaultValue:"function"==typeof t.default?t.default:()=>t.default,...St(t)});class Sn extends Nt{_parse(e){const{ctx:t}=this._processInputParams(e),n={...t,common:{...t.common,issues:[]}},s=this._def.innerType._parse({data:n.data,path:n.path,parent:{...n}});return Bt(s)?s.then((e=>({status:"valid",value:"valid"===e.status?e.value:this._def.catchValue({get error(){return new pt(n.common.issues)},input:n.data})}))):{status:"valid",value:"valid"===s.status?s.value:this._def.catchValue({get error(){return new pt(n.common.issues)},input:n.data})}}removeCatch(){return this._def.innerType}}Sn.create=(e,t)=>new Sn({innerType:e,typeName:Un.ZodCatch,catchValue:"function"==typeof t.catch?t.catch:()=>t.catch,...St(t)});class Nn extends Nt{_parse(e){if(this._getType(e)!==ut.nan){const t=this._getOrReturnCtx(e);return yt(t,{code:ht.invalid_type,expected:ut.nan,received:t.parsedType}),wt}return{status:"valid",value:e.data}}}Nn.create=e=>new Nn({typeName:Un.ZodNaN,...St(e)});const Pn=Symbol("zod_brand");class In extends Nt{_parse(e){const{ctx:t}=this._processInputParams(e),n=t.data;return this._def.type._parse({data:n,path:t.path,parent:t})}unwrap(){return this._def.type}}class Yn extends Nt{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.common.async)return(async()=>{const e=await this._def.in._parseAsync({data:n.data,path:n.path,parent:n});return"aborted"===e.status?wt:"dirty"===e.status?(t.dirty(),xt(e.value)):this._def.out._parseAsync({data:e.value,path:n.path,parent:n})})();{const e=this._def.in._parseSync({data:n.data,path:n.path,parent:n});return"aborted"===e.status?wt:"dirty"===e.status?(t.dirty(),{status:"dirty",value:e.value}):this._def.out._parseSync({data:e.value,path:n.path,parent:n})}}static create(e,t){return new Yn({in:e,out:t,typeName:Un.ZodPipeline})}}class Qn extends Nt{_parse(e){const t=this._def.innerType._parse(e),n=e=>(zt(e)&&(e.value=Object.freeze(e.value)),e);return Bt(t)?t.then((e=>n(e))):n(t)}unwrap(){return this._def.innerType}}function jn(e,t={},n){return e?ln.create().superRefine(((s,i)=>{var r,a;if(!e(s)){const e="function"==typeof t?t(s):"string"==typeof t?{message:t}:t,o=null===(a=null!==(r=e.fatal)&&void 0!==r?r:n)||void 0===a||a,l="string"==typeof e?{message:e}:e;i.addIssue({code:"custom",...l,fatal:o})}})):ln.create()}Qn.create=(e,t)=>new Qn({innerType:e,typeName:Un.ZodReadonly,...St(t)});const Hn={object:pn.lazycreate};var Un;!function(e){e.ZodString="ZodString",e.ZodNumber="ZodNumber",e.ZodNaN="ZodNaN",e.ZodBigInt="ZodBigInt",e.ZodBoolean="ZodBoolean",e.ZodDate="ZodDate",e.ZodSymbol="ZodSymbol",e.ZodUndefined="ZodUndefined",e.ZodNull="ZodNull",e.ZodAny="ZodAny",e.ZodUnknown="ZodUnknown",e.ZodNever="ZodNever",e.ZodVoid="ZodVoid",e.ZodArray="ZodArray",e.ZodObject="ZodObject",e.ZodUnion="ZodUnion",e.ZodDiscriminatedUnion="ZodDiscriminatedUnion",e.ZodIntersection="ZodIntersection",e.ZodTuple="ZodTuple",e.ZodRecord="ZodRecord",e.ZodMap="ZodMap",e.ZodSet="ZodSet",e.ZodFunction="ZodFunction",e.ZodLazy="ZodLazy",e.ZodLiteral="ZodLiteral",e.ZodEnum="ZodEnum",e.ZodEffects="ZodEffects",e.ZodNativeEnum="ZodNativeEnum",e.ZodOptional="ZodOptional",e.ZodNullable="ZodNullable",e.ZodDefault="ZodDefault",e.ZodCatch="ZodCatch",e.ZodPromise="ZodPromise",e.ZodBranded="ZodBranded",e.ZodPipeline="ZodPipeline",e.ZodReadonly="ZodReadonly"}(Un||(Un={}));const Rn=Kt.create,Gn=en.create,Zn=Nn.create,Jn=tn.create,Xn=nn.create,Wn=sn.create,Vn=rn.create,qn=an.create,Kn=on.create,$n=ln.create,es=cn.create,ts=dn.create,ns=un.create,ss=fn.create,is=pn.create,rs=pn.strictCreate,as=mn.create,os=_n.create,ls=yn.create,cs=An.create,ds=wn.create,us=xn.create,fs=vn.create,hs=En.create,ps=Mn.create,ms=zn.create,gs=Fn.create,_s=kn.create,bs=Cn.create,ys=On.create,As=Dn.create,ws=Ln.create,xs=On.createWithPreprocess,vs=Yn.create,Es={string:e=>Kt.create({...e,coerce:!0}),number:e=>en.create({...e,coerce:!0}),boolean:e=>nn.create({...e,coerce:!0}),bigint:e=>tn.create({...e,coerce:!0}),date:e=>sn.create({...e,coerce:!0})},Ms=wt;var zs=Object.freeze({__proto__:null,defaultErrorMap:mt,setErrorMap:function(e){gt=e},getErrorMap:_t,makeIssue:bt,EMPTY_PATH:[],addIssueToContext:yt,ParseStatus:At,INVALID:wt,DIRTY:xt,OK:vt,isAborted:Et,isDirty:Mt,isValid:zt,isAsync:Bt,get util(){return ct},get objectUtil(){return dt},ZodParsedType:ut,getParsedType:ft,ZodType:Nt,datetimeRegex:qt,ZodString:Kt,ZodNumber:en,ZodBigInt:tn,ZodBoolean:nn,ZodDate:sn,ZodSymbol:rn,ZodUndefined:an,ZodNull:on,ZodAny:ln,ZodUnknown:cn,ZodNever:dn,ZodVoid:un,ZodArray:fn,ZodObject:pn,ZodUnion:mn,ZodDiscriminatedUnion:_n,ZodIntersection:yn,ZodTuple:An,ZodRecord:wn,ZodMap:xn,ZodSet:vn,ZodFunction:En,ZodLazy:Mn,ZodLiteral:zn,ZodEnum:Fn,ZodNativeEnum:kn,ZodPromise:Cn,ZodEffects:On,ZodTransformer:On,ZodOptional:Dn,ZodNullable:Ln,ZodDefault:Tn,ZodCatch:Sn,ZodNaN:Nn,BRAND:Pn,ZodBranded:In,ZodPipeline:Yn,ZodReadonly:Qn,custom:jn,Schema:Nt,ZodSchema:Nt,late:Hn,get ZodFirstPartyTypeKind(){return Un},coerce:Es,any:$n,array:ss,bigint:Jn,boolean:Xn,date:Wn,discriminatedUnion:os,effect:ys,enum:gs,function:hs,instanceof:(e,t={message:`Input not instance of ${e.name}`})=>jn((t=>t instanceof e),t),intersection:ls,lazy:ps,literal:ms,map:us,nan:Zn,nativeEnum:_s,never:ts,null:Kn,nullable:ws,number:Gn,object:is,oboolean:()=>Xn().optional(),onumber:()=>Gn().optional(),optional:As,ostring:()=>Rn().optional(),pipeline:vs,preprocess:xs,promise:bs,record:ds,set:fs,strictObject:rs,string:Rn,symbol:Vn,transformer:ys,tuple:cs,undefined:qn,union:as,unknown:es,void:ns,NEVER:Ms,ZodIssueCode:ht,quotelessJson:e=>JSON.stringify(e,null,2).replace(/"([^"]+)":/g,"$1:"),ZodError:pt}),Bs=i(8891).Buffer;function Fs(e){return e.startsWith("0x")}function ks(e){return Fs(e)?e.slice(2):e}function Cs(e){return/^(0x)?[0-9a-fA-F]*$/.test(e)}function Os(e){return Bs.from(ks(e),"hex")}function Ds(e){return`0x${e.toString("hex")}`}var Ls=i(8891).Buffer;const Ts=zs.string().refine(Cs,"Not a valid hex string").transform(ks),Ss=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,Ns=zs.string().refine((e=>e.length>1024||Ss.test(e)),"Not a valid base64 string").transform((e=>Ls.from(e,"base64")));class Ps extends Dn{constructor(){super(...arguments),this._isNullableOptional=!0}_parse(e){const t=this._getType(e);return t===ut.undefined||t===ut.null?vt(void 0):this._def.innerType._parse(e)}static create(e){return new Ps({innerType:e,typeName:Un.ZodOptional})}}function Is(e){return Ps.create(e)}function Ys(e,t){const n=(t?zs.string().refine(t,"Not a valid instance"):zs.string()).refine(Cs,"Not a valid hex string");return"fromString"in e?n.transform(e.fromString.bind(e)):n.transform((e=>Ls.from(ks(e),"hex"))).transform(e.fromBuffer.bind(e))}function Qs(e){return Ns.transform(e.fromBuffer.bind(e))}function js(e,t){return zs.array(zs.tuple([e,t])).transform((e=>new Map(e)))}function Hs(e,t,n,s){if("a"===n&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!s:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?s:"a"===n?s.call(e):s?s.value:t.get(e)}function Us(e,t,n,s,i){if("m"===s)throw new TypeError("Private method is not writable");if("a"===s&&!i)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===s?i.call(e,n):i?i.value=n:t.set(e,n),n}Object.create,Object.create,"function"==typeof SuppressedError&&SuppressedError;var Rs,Gs,Zs=i(8891).Buffer;class Js{constructor(e,t=0){Rs.add(this),this.buffer=e,this.index=t}static asReader(e){if(e instanceof Js)return e;const t=Zs.isBuffer(e)?e:Zs.from(e.buffer,e.byteOffset,e.byteLength);return new Js(t)}isEmpty(){return this.index===this.buffer.length}readNumber(){return Hs(this,Rs,"m",Gs).call(this,4),this.index+=4,this.buffer.readUint32BE(this.index-4)}readNumbers(e){return Array.from({length:e},(()=>this.readNumber()))}readUInt256(){Hs(this,Rs,"m",Gs).call(this,32);let e=BigInt(0);for(let t=0;t<32;t++)e=e<<BigInt(8)|BigInt(this.buffer[this.index+t]);return this.index+=32,e}readUInt16(){return Hs(this,Rs,"m",Gs).call(this,2),this.index+=2,this.buffer.readUInt16BE(this.index-2)}readUInt8(){return Hs(this,Rs,"m",Gs).call(this,1),this.index+=1,this.buffer.readUInt8(this.index-1)}readBoolean(){return Hs(this,Rs,"m",Gs).call(this,1),this.index+=1,Boolean(this.buffer.at(this.index-1))}readBytes(e){return Hs(this,Rs,"m",Gs).call(this,e),this.index+=e,Zs.from(this.buffer.subarray(this.index-e,this.index))}readToEnd(){const e=this.buffer.subarray(this.index);return this.index=this.buffer.length,e}readNumberVector(){return this.readVector({fromBuffer:e=>e.readNumber()})}readVector(e){const t=this.readNumber(),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.fromBuffer(this);return n}readVectorUint8Prefix(e){const t=this.readUInt8(),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.fromBuffer(this);return n}readArray(e,t){return Array.from({length:e},(()=>t.fromBuffer(this)))}readBufferArray(e=-1){const t=[],n=e>=0?this.index+e:this.buffer.length;for(Hs(this,Rs,"m",Gs).call(this,n-this.index);this.index<n;){const e=this.readBuffer();t.push(e)}if(this.index!==n)throw new Error(`Reader buffer was not fully consumed. Consumed up to ${this.index} bytes. End of data: ${n} bytes.`);return t}readObject(e){return e.fromBuffer(this)}peekBytes(e){return Hs(this,Rs,"m",Gs).call(this,e||0),this.buffer.subarray(this.index,e?this.index+e:void 0)}readString(){return this.readBuffer().toString()}readBuffer(){const e=this.readNumber();return Hs(this,Rs,"m",Gs).call(this,e),this.readBytes(e)}readUint8Array(){const e=this.readNumber();return Hs(this,Rs,"m",Gs).call(this,e),this.readBytes(e)}readMap(e){const t=this.readNumber(),n={};for(let s=0;s<t;s++){const t=this.readString(),s=this.readObject(e);n[t]=s}return n}getLength(){return this.buffer.length}remainingBytes(){return this.buffer.length-this.index}}Rs=new WeakSet,Gs=function(e){if(this.index+e>this.buffer.length)throw new Error(`Attempted to read beyond buffer length. Start index: ${this.index}, Num bytes to read: ${e}, Buffer length: ${this.buffer.length}`)},i(8891).Buffer;class Xs{static register(e,t){this.registry.set(e,t)}static getConstructor(e){return this.registry.get(e)}}Xs.registry=new Map;var Ws,Vs=i(8891).Buffer;const qs=Vs.alloc(32);class Ks{get value(){return this.toBigInt()}get size(){return Ks.SIZE_IN_BYTES}constructor(e){if(Vs.isBuffer(e)){if(e.length>Ks.SIZE_IN_BYTES)throw new Error(`Value length ${e.length} exceeds ${Ks.SIZE_IN_BYTES}`);this.asBuffer=e.length===Ks.SIZE_IN_BYTES?e:Vs.concat([Vs.alloc(Ks.SIZE_IN_BYTES-e.length),e])}else if("bigint"==typeof e||"number"==typeof e||"boolean"==typeof e){if(this.asBigInt=BigInt(e),this.asBigInt>=this.modulus())throw new Error(`Value 0x${this.asBigInt.toString(16)} is greater or equal to field modulus.`)}else{if(!(e instanceof Ks))throw new Error(`Type '${typeof e}' with value '${e}' passed to BaseField ctor.`);this.asBuffer=e.asBuffer,this.asBigInt=e.asBigInt}}toBuffer(){return this.asBuffer||(this.asBuffer=m(this.asBigInt,32)),Vs.from(this.asBuffer)}toString(){return`0x${this.toBuffer().toString("hex")}`}toBigInt(){if(void 0===this.asBigInt&&(this.asBigInt=p(this.asBuffer),this.asBigInt>=this.modulus()))throw new Error(`Value 0x${this.asBigInt.toString(16)} is greater or equal to field modulus.`);return this.asBigInt}toBool(){return Boolean(this.toBigInt())}toNumber(){const e=this.toBigInt();if(e>Number.MAX_SAFE_INTEGER)throw new Error(`Value ${e.toString(16)} greater than than max safe integer`);return Number(e)}toNumberUnsafe(){const e=this.toBigInt();return Number(e)}toShortString(){const e=this.toString();return`${e.slice(0,10)}...${e.slice(-4)}`}equals(e){return this.toBuffer().equals(e.toBuffer())}lt(e){return this.toBigInt()<e.toBigInt()}cmp(e){const t=this.toBigInt(),n=e.toBigInt();return t===n?0:t<n?-1:1}isZero(){return this.toBuffer().equals(qs)}isEmpty(){return this.isZero()}toFriendlyJSON(){return this.toString()}toField(){return this}}function $s(e,t){return new t(Js.asReader(e).readBytes(Ks.SIZE_IN_BYTES))}function ei(e,t){return new t(p(e)%t.MODULUS)}function ti(e){return ei(ot(64),e)}function ni(e,t){const n=e.replace(/^0x/i,""),s=n.match(/^[0-9A-F]+$/i)?.[0];if(void 0===s)throw new Error(`Invalid hex-encoded string: "${e}"`);return new t(Vs.from(s.length%2==1?"0"+s:s,"hex"))}Ks.SIZE_IN_BYTES=32;class si extends Ks{constructor(e){super(e)}[f.inspect.custom](){return`Fr<${this.toString()}>`}modulus(){return Ws.MODULUS}static random(){return ti(Ws)}static zero(){return Ws.ZERO}static isZero(e){return e.isZero()}static fromBuffer(e){return $s(e,Ws)}static fromBufferReduce(e){return ei(e,Ws)}static fromString(e){if(null!==e.match(/^\d+$/))return new Ws(m(BigInt(e),32));if(null!==e.match(/^0x/i))return ni(e,Ws);throw new Error("Tried to create a Fr from an invalid string")}static fromHexString(e){return ni(e,Ws)}add(e){return new Ws((this.toBigInt()+e.toBigInt())%Ws.MODULUS)}square(){return new Ws(this.toBigInt()*this.toBigInt()%Ws.MODULUS)}negate(){return new Ws(Ws.MODULUS-this.toBigInt())}sub(e){const t=this.toBigInt()-e.toBigInt();return new Ws(t<0?t+Ws.MODULUS:t)}mul(e){return new Ws(this.toBigInt()*e.toBigInt()%Ws.MODULUS)}div(e){if(e.isZero())throw new Error("Division by zero");const t=function(e){const[t,n,s]=ri(e,si.MODULUS);if(1n!=t)throw Error("Inverse does not exist");return new si(n>0?n:n+si.MODULUS)}(e.toBigInt());return this.mul(t)}ediv(e){if(e.isZero())throw new Error("Division by zero");return new Ws(this.toBigInt()/e.toBigInt())}async sqrt(){const e=(await c.initSingleton()).getWasm(),[t]=e.callWasmExport("bn254_fr_sqrt",[this.toBuffer()],[Ws.SIZE_IN_BYTES+1]);return 1===t[0]?new Ws(Vs.from(t.slice(1))):null}toJSON(){return this.toString()}static get schema(){return Ys(Ws)}}Ws=si,si.ZERO=new Ws(0n),si.ONE=new Ws(1n),si.MODULUS=0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001n,si.MAX_FIELD_VALUE=new Ws(Ws.MODULUS-1n),Xs.register("Fr",si);class ii extends Ks{[f.inspect.custom](){return`Fq<${this.toString()}>`}get lo(){return new si(this.toBigInt()&ii.LOW_MASK)}get hi(){return new si(this.toBigInt()>>ii.HIGH_SHIFT)}constructor(e){super(e)}modulus(){return ii.MODULUS}static random(){return ti(ii)}static zero(){return ii.ZERO}static fromBuffer(e){return $s(e,ii)}static fromBufferReduce(e){return ei(e,ii)}static fromString(e){if(null!==e.match(/^\d+$/))return new ii(m(BigInt(e),32));if(null!==e.match(/^0x/i))return ni(e,ii);throw new Error("Tried to create a Fq from an invalid string")}static fromHexString(e){return ni(e,ii)}static fromHighLow(e,t){return new ii((e.toBigInt()<<ii.HIGH_SHIFT)+t.toBigInt())}add(e){return new ii((this.toBigInt()+e.toBigInt())%ii.MODULUS)}toJSON(){return this.toString()}static get schema(){return Ys(ii)}}function ri(e,t){if(0n==e)return[t,0n,1n];{const[n,s,i]=ri(t%e,e);return[n,i-t/e*s,s]}}ii.ZERO=new ii(0n),ii.MODULUS=0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47n,ii.HIGH_SHIFT=BigInt(Ks.SIZE_IN_BYTES/2*8),ii.LOW_MASK=(1n<<ii.HIGH_SHIFT)-1n,Xs.register("Fq",ii);const ai=ii;var oi=i(8891).Buffer;function li(e,t=4){const n=oi.alloc(t);return n.writeUInt32BE(e,t-4),n}function ci(e,t=4){const n=oi.alloc(t);return n.writeInt32BE(e,t-4),n}function di(e){const t=oi.alloc(1);return t.writeUInt8(e,0),t}function ui(e){const t=oi.alloc(4);return t.writeUInt32BE(e.length,0),oi.concat([t,e])}var fi=i(8891).Buffer;function hi(e,t=4){const n=mi(e);let s;if(1===t)s=fi.alloc(1),s.writeUInt8(n.length,0);else{if(4!==t)throw new Error(`Unsupported prefix length. Got ${t}, expected 1 or 4`);s=fi.alloc(4),s.writeUInt32BE(n.length,0)}return fi.concat([s,...n])}function pi(e,t=1){const n=fi.alloc(t);return n.writeUInt8(e?1:0,t-1),n}function mi(...e){const t=[];for(const n of e)if(Array.isArray(n))t.push(...mi(...n));else if(fi.isBuffer(n))t.push(n);else if("boolean"==typeof n)t.push(pi(n));else if("bigint"==typeof n){if(n>BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"))throw new Error(`BigInt ${n} does not fit into 32 bytes`);t.push(bi(n))}else if("number"==typeof n)t.push(li(n));else if("string"==typeof n)t.push(li(n.length)),t.push(fi.from(n));else{if(!("toBuffer"in n))throw new Error(`Cannot serialize input to buffer: ${typeof n} ${n.constructor?.name}`);t.push(n.toBuffer())}return t}function gi(...e){const t=[];for(const n of e)if(Array.isArray(n))t.push(...gi(...n));else if(n instanceof si)t.push(n);else if("boolean"==typeof n||"number"==typeof n||"bigint"==typeof n)t.push(new si(n));else if("toFields"in n)t.push(...n.toFields());else if("toFr"in n)t.push(n.toFr());else if("toField"in n)t.push(n.toField());else{if(!fi.isBuffer(n))throw new Error(`Cannot serialize input to field: ${typeof n} ${n.constructor?.name}`);t.push(si.fromBuffer(n))}return t}function _i(...e){return fi.concat(mi(...e))}function bi(e,t=32){return m(e,t)}var yi=i(8891).Buffer;async function Ai(e){const t=gi(e),n=(await c.initSingleton()).poseidon2Hash(t.map((e=>new d(e.toBuffer()))));return si.fromBuffer(yi.from(n.toBuffer()))}async function wi(e,t){const n=gi(e);n.unshift(new si(t));const s=(await c.initSingleton()).poseidon2Hash(n.map((e=>new d(e.toBuffer()))));return si.fromBuffer(yi.from(s.toBuffer()))}async function xi(e){const t=[];for(let n=0;n<e.length;n+=31){const s=yi.alloc(32,0);e.slice(n,n+31).copy(s),s.reverse(),t.push(si.fromBuffer(s))}const n=(await c.initSingleton()).poseidon2Hash(t.map((e=>new d(e.toBuffer()))));return si.fromBuffer(yi.from(n.toBuffer()))}class vi{constructor(e,t=0){if(this.fields=e,this.index=t,this.length=e.length,t>=this.length)throw new Error("Offset out of bounds.")}static asReader(e){return e instanceof vi?e:new vi(e)}get cursor(){return this.index}skip(e){if(this.index+e>this.length)throw new Error("Not enough fields to be consumed.");this.index+=e}readField(){if(this.index===this.length)throw new Error("Not enough fields to be consumed.");return this.fields[this.index++]}peekField(){if(this.index===this.length)throw new Error("Not enough fields to be consumed.");return this.fields[this.index]}readFq(){return ii.fromHighLow(this.readField(),this.readField())}readBoolean(){const e=this.readField().toBigInt();if(e>1n)throw new Error("Field is not a boolean.");return 1n==e}readU32(){const e=this.readField().toBigInt();if(e>=1n<<32n)throw new Error("Field is not a u32.");return Number(e)}readFieldArray(e){const t=[];for(let n=0;n<e;++n)t.push(this.readField());return t}readArray(e,t){return Array.from({length:e},(()=>t.fromFields(this)))}readObject(e){return e.fromFields(this)}isFinished(){return this.index>=this.length}}class Ei{constructor(e,t,n){this.x=e,this.y=t,this.isInfinite=n,this.kind="point"}toJSON(){return this.toString()}static get schema(){return Ys(Ei)}static async random(){for(;;)try{return await Ei.fromXAndSign(si.random(),ot(1)[0]%2==0)}catch(e){if(!(e instanceof Mi))throw e;continue}}static fromBuffer(e){const t=Js.asReader(e);return new this(si.fromBuffer(t),si.fromBuffer(t),!1)}static fromCompressedBuffer(e){const t=p(Js.asReader(e).readBytes(Ei.COMPRESSED_SIZE_IN_BYTES)),n=new si(t&(1n<<255n)-1n),s=0n!==(t&1n<<255n);return this.fromXAndSign(n,s)}static fromString(e){return this.fromBuffer(Os(e))}toFields(){return[this.x,this.y,new si(this.isInfinite)]}static fromFields(e){const t=vi.asReader(e);return new this(t.readField(),t.readField(),t.readBoolean())}static async fromXAndSign(e,t){const n=await Ei.YFromX(e);if(null==n)throw new Mi(e);const s=n.toBigInt()<=(si.MODULUS-1n)/2n?n.toBigInt():si.MODULUS-n.toBigInt(),i=si.MODULUS-s;return new this(e,new si(t?s:i),!1)}static YFromX(e){return e.square().mul(e).sub(new si(17)).sqrt()}toXAndSign(){return[this.x,this.y.toBigInt()<=(si.MODULUS-1n)/2n]}toBigInts(){return{x:this.x.toBigInt(),y:this.y.toBigInt(),isInfinite:this.isInfinite?1n:0n}}toBuffer(){if(this.isInfinite)throw new Error("Cannot serialize infinite point without isInfinite flag");const e=_i([this.x,this.y]);if(e.length!==Ei.SIZE_IN_BYTES)throw new Error(`Invalid buffer length for Point: ${e.length}`);return e}toCompressedBuffer(){const[e,t]=this.toXAndSign(),n=_i(e.toBigInt()+(t?2n**255n:0n));if(n.length!==Ei.COMPRESSED_SIZE_IN_BYTES)throw new Error(`Invalid buffer length for compressed Point: ${n.length}`);return n}toString(){return Ds(this.toBuffer())}toShortString(){const e=this.toString();return`${e.slice(0,10)}...${e.slice(-4)}`}toNoirStruct(){return{x:this.x,y:this.y,is_infinite:this.isInfinite}}toWrappedNoirStruct(){return{inner:this.toNoirStruct()}}equals(e){return this.x.equals(e.x)&&this.y.equals(e.y)}isZero(){return this.x.isZero()&&this.y.isZero()}hash(){return Ai(this.toFields())}get inf(){return this.isInfinite}isOnGrumpkin(){if(this.inf)return!0;const e=this.y.square(),t=this.x.mul(this.x).mul(this.x).sub(new si(17));return e.equals(t)}}Ei.ZERO=new Ei(si.ZERO,si.ZERO,!1),Ei.SIZE_IN_BYTES=2*si.SIZE_IN_BYTES,Ei.COMPRESSED_SIZE_IN_BYTES=si.SIZE_IN_BYTES;class Mi extends Error{constructor(e){super("The given x-coordinate is not on the Grumpkin curve: "+e.toString()),this.name="NotOnCurveError"}}var zi=i(8891).Buffer;class Bi{constructor(e){this.fields=e}toFields(){return this.fields}static random(){return this.fromField(si.random())}toFieldsBuffer(){return zi.concat([this.fields[0].toBuffer(),this.fields[1].toBuffer()])}toBuffer(){const e=this.fields[0].toBuffer(),t=this.fields[1].toBuffer();return e[0]=t[31],e}equals(e){return this.toBigInt()===e.toBigInt()}toBigInt(){return p(this.toBuffer())}static fromBuffer(e){if(32!=e.length)throw new Error("Invalid size of coordinate buffer");const t=zi.alloc(32);e.copy(t,0,0,32);const n=zi.alloc(32);return n[31]=t[0],t[0]=0,new Bi([si.fromBuffer(t),si.fromBuffer(n)])}static fromField(e){const t=e.toBuffer(),n=zi.alloc(32);return n[31]=t[0],t[0]=0,new Bi([si.fromBuffer(t),si.fromBuffer(n)])}}Bi.ZERO=new Bi([si.ZERO,si.ZERO]);const Fi=29,ki=5,Ci=40,Oi=40,Di=64,Li=64,Ti=32,Si=64,Ni=32,Pi=18,Ii=48,Yi=3578010381,Qi=3e3,ji=538,Hi=1e9,Ui=6e6;var Ri,Gi;function Zi(e){let t=e.length;for(;--t>=0;)e[t]=0}(Gi=Ri||(Ri={}))[Gi.NOTE_HASH=1]="NOTE_HASH",Gi[Gi.NOTE_HASH_NONCE=2]="NOTE_HASH_NONCE",Gi[Gi.UNIQUE_NOTE_HASH=3]="UNIQUE_NOTE_HASH",Gi[Gi.SILOED_NOTE_HASH=4]="SILOED_NOTE_HASH",Gi[Gi.MESSAGE_NULLIFIER=5]="MESSAGE_NULLIFIER",Gi[Gi.INITIALIZATION_NULLIFIER=6]="INITIALIZATION_NULLIFIER",Gi[Gi.OUTER_NULLIFIER=7]="OUTER_NULLIFIER",Gi[Gi.PUBLIC_DATA_READ=8]="PUBLIC_DATA_READ",Gi[Gi.PUBLIC_DATA_UPDATE_REQUEST=9]="PUBLIC_DATA_UPDATE_REQUEST",Gi[Gi.FUNCTION_DATA=10]="FUNCTION_DATA",Gi[Gi.FUNCTION_LEAF=11]="FUNCTION_LEAF",Gi[Gi.CONTRACT_DEPLOYMENT_DATA=12]="CONTRACT_DEPLOYMENT_DATA",Gi[Gi.CONSTRUCTOR=13]="CONSTRUCTOR",Gi[Gi.CONSTRUCTOR_ARGS=14]="CONSTRUCTOR_ARGS",Gi[Gi.CONTRACT_ADDRESS_V1=15]="CONTRACT_ADDRESS_V1",Gi[Gi.CONTRACT_LEAF=16]="CONTRACT_LEAF",Gi[Gi.CALL_CONTEXT=17]="CALL_CONTEXT",Gi[Gi.CALL_STACK_ITEM=18]="CALL_STACK_ITEM",Gi[Gi.CALL_STACK_ITEM_2=19]="CALL_STACK_ITEM_2",Gi[Gi.SECRET_HASH=20]="SECRET_HASH",Gi[Gi.L2_TO_L1_MSG=21]="L2_TO_L1_MSG",Gi[Gi.TX_CONTEXT=22]="TX_CONTEXT",Gi[Gi.PUBLIC_LEAF_INDEX=23]="PUBLIC_LEAF_INDEX",Gi[Gi.PUBLIC_DATA_LEAF=24]="PUBLIC_DATA_LEAF",Gi[Gi.SIGNED_TX_REQUEST=25]="SIGNED_TX_REQUEST",Gi[Gi.GLOBAL_VARIABLES=26]="GLOBAL_VARIABLES",Gi[Gi.PARTIAL_ADDRESS=27]="PARTIAL_ADDRESS",Gi[Gi.BLOCK_HASH=28]="BLOCK_HASH",Gi[Gi.SIDE_EFFECT=29]="SIDE_EFFECT",Gi[Gi.FEE_PAYLOAD=30]="FEE_PAYLOAD",Gi[Gi.COMBINED_PAYLOAD=31]="COMBINED_PAYLOAD",Gi[Gi.TX_NULLIFIER=32]="TX_NULLIFIER",Gi[Gi.TX_REQUEST=33]="TX_REQUEST",Gi[Gi.SIGNATURE_PAYLOAD=34]="SIGNATURE_PAYLOAD",Gi[Gi.VK=41]="VK",Gi[Gi.PRIVATE_CIRCUIT_PUBLIC_INPUTS=42]="PRIVATE_CIRCUIT_PUBLIC_INPUTS",Gi[Gi.PUBLIC_CIRCUIT_PUBLIC_INPUTS=43]="PUBLIC_CIRCUIT_PUBLIC_INPUTS",Gi[Gi.FUNCTION_ARGS=44]="FUNCTION_ARGS",Gi[Gi.AUTHWIT_INNER=45]="AUTHWIT_INNER",Gi[Gi.AUTHWIT_OUTER=46]="AUTHWIT_OUTER",Gi[Gi.AUTHWIT_NULLIFIER=47]="AUTHWIT_NULLIFIER",Gi[Gi.NSK_M=48]="NSK_M",Gi[Gi.IVSK_M=49]="IVSK_M",Gi[Gi.OVSK_M=50]="OVSK_M",Gi[Gi.TSK_M=51]="TSK_M",Gi[Gi.PUBLIC_KEYS_HASH=52]="PUBLIC_KEYS_HASH",Gi[Gi.NOTE_NULLIFIER=53]="NOTE_NULLIFIER",Gi[Gi.NOTE_HIDING_POINT=54]="NOTE_HIDING_POINT",Gi[Gi.SYMMETRIC_KEY=55]="SYMMETRIC_KEY",Gi[Gi.SYMMETRIC_KEY_2=56]="SYMMETRIC_KEY_2",Gi[Gi.PUBLIC_TX_HASH=57]="PUBLIC_TX_HASH",Gi[Gi.PRIVATE_TX_HASH=58]="PRIVATE_TX_HASH",BigInt(1e21);const Ji=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),Xi=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Wi=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),Vi=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),qi=new Array(576);Zi(qi);const Ki=new Array(60);Zi(Ki);const $i=new Array(512);Zi($i);const er=new Array(256);Zi(er);const tr=new Array(29);Zi(tr);const nr=new Array(30);function sr(e,t,n,s,i){this.static_tree=e,this.extra_bits=t,this.extra_base=n,this.elems=s,this.max_length=i,this.has_stree=e&&e.length}let ir,rr,ar;function or(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}Zi(nr);const lr=e=>e<256?$i[e]:$i[256+(e>>>7)],cr=(e,t)=>{e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255},dr=(e,t,n)=>{e.bi_valid>16-n?(e.bi_buf|=t<<e.bi_valid&65535,cr(e,e.bi_buf),e.bi_buf=t>>16-e.bi_valid,e.bi_valid+=n-16):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=n)},ur=(e,t,n)=>{dr(e,n[2*t],n[2*t+1])},fr=(e,t)=>{let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1},hr=(e,t,n)=>{const s=new Array(16);let i,r,a=0;for(i=1;i<=15;i++)a=a+n[i-1]<<1,s[i]=a;for(r=0;r<=t;r++){let t=e[2*r+1];0!==t&&(e[2*r]=fr(s[t]++,t))}},pr=e=>{let t;for(t=0;t<286;t++)e.dyn_ltree[2*t]=0;for(t=0;t<30;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.sym_next=e.matches=0},mr=e=>{e.bi_valid>8?cr(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0},gr=(e,t,n,s)=>{const i=2*t,r=2*n;return e[i]<e[r]||e[i]===e[r]&&s[t]<=s[n]},_r=(e,t,n)=>{const s=e.heap[n];let i=n<<1;for(;i<=e.heap_len&&(i<e.heap_len&&gr(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!gr(t,s,e.heap[i],e.depth));)e.heap[n]=e.heap[i],n=i,i<<=1;e.heap[n]=s},br=(e,t,n)=>{let s,i,r,a,o=0;if(0!==e.sym_next)do{s=255&e.pending_buf[e.sym_buf+o++],s+=(255&e.pending_buf[e.sym_buf+o++])<<8,i=e.pending_buf[e.sym_buf+o++],0===s?ur(e,i,t):(r=er[i],ur(e,r+256+1,t),a=Ji[r],0!==a&&(i-=tr[r],dr(e,i,a)),s--,r=lr(s),ur(e,r,n),a=Xi[r],0!==a&&(s-=nr[r],dr(e,s,a)))}while(o<e.sym_next);ur(e,256,t)},yr=(e,t)=>{const n=t.dyn_tree,s=t.stat_desc.static_tree,i=t.stat_desc.has_stree,r=t.stat_desc.elems;let a,o,l,c=-1;for(e.heap_len=0,e.heap_max=573,a=0;a<r;a++)0!==n[2*a]?(e.heap[++e.heap_len]=c=a,e.depth[a]=0):n[2*a+1]=0;for(;e.heap_len<2;)l=e.heap[++e.heap_len]=c<2?++c:0,n[2*l]=1,e.depth[l]=0,e.opt_len--,i&&(e.static_len-=s[2*l+1]);for(t.max_code=c,a=e.heap_len>>1;a>=1;a--)_r(e,n,a);l=r;do{a=e.heap[1],e.heap[1]=e.heap[e.heap_len--],_r(e,n,1),o=e.heap[1],e.heap[--e.heap_max]=a,e.heap[--e.heap_max]=o,n[2*l]=n[2*a]+n[2*o],e.depth[l]=(e.depth[a]>=e.depth[o]?e.depth[a]:e.depth[o])+1,n[2*a+1]=n[2*o+1]=l,e.heap[1]=l++,_r(e,n,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],((e,t)=>{const n=t.dyn_tree,s=t.max_code,i=t.stat_desc.static_tree,r=t.stat_desc.has_stree,a=t.stat_desc.extra_bits,o=t.stat_desc.extra_base,l=t.stat_desc.max_length;let c,d,u,f,h,p,m=0;for(f=0;f<=15;f++)e.bl_count[f]=0;for(n[2*e.heap[e.heap_max]+1]=0,c=e.heap_max+1;c<573;c++)d=e.heap[c],f=n[2*n[2*d+1]+1]+1,f>l&&(f=l,m++),n[2*d+1]=f,d>s||(e.bl_count[f]++,h=0,d>=o&&(h=a[d-o]),p=n[2*d],e.opt_len+=p*(f+h),r&&(e.static_len+=p*(i[2*d+1]+h)));if(0!==m){do{for(f=l-1;0===e.bl_count[f];)f--;e.bl_count[f]--,e.bl_count[f+1]+=2,e.bl_count[l]--,m-=2}while(m>0);for(f=l;0!==f;f--)for(d=e.bl_count[f];0!==d;)u=e.heap[--c],u>s||(n[2*u+1]!==f&&(e.opt_len+=(f-n[2*u+1])*n[2*u],n[2*u+1]=f),d--)}})(e,t),hr(n,c,e.bl_count)},Ar=(e,t,n)=>{let s,i,r=-1,a=t[1],o=0,l=7,c=4;for(0===a&&(l=138,c=3),t[2*(n+1)+1]=65535,s=0;s<=n;s++)i=a,a=t[2*(s+1)+1],++o<l&&i===a||(o<c?e.bl_tree[2*i]+=o:0!==i?(i!==r&&e.bl_tree[2*i]++,e.bl_tree[32]++):o<=10?e.bl_tree[34]++:e.bl_tree[36]++,o=0,r=i,0===a?(l=138,c=3):i===a?(l=6,c=3):(l=7,c=4))},wr=(e,t,n)=>{let s,i,r=-1,a=t[1],o=0,l=7,c=4;for(0===a&&(l=138,c=3),s=0;s<=n;s++)if(i=a,a=t[2*(s+1)+1],!(++o<l&&i===a)){if(o<c)do{ur(e,i,e.bl_tree)}while(0!=--o);else 0!==i?(i!==r&&(ur(e,i,e.bl_tree),o--),ur(e,16,e.bl_tree),dr(e,o-3,2)):o<=10?(ur(e,17,e.bl_tree),dr(e,o-3,3)):(ur(e,18,e.bl_tree),dr(e,o-11,7));o=0,r=i,0===a?(l=138,c=3):i===a?(l=6,c=3):(l=7,c=4)}};let xr=!1;const vr=(e,t,n,s)=>{dr(e,0+(s?1:0),3),mr(e),cr(e,n),cr(e,~n),n&&e.pending_buf.set(e.window.subarray(t,t+n),e.pending),e.pending+=n};var Er={_tr_init:e=>{xr||((()=>{let e,t,n,s,i;const r=new Array(16);for(n=0,s=0;s<28;s++)for(tr[s]=n,e=0;e<1<<Ji[s];e++)er[n++]=s;for(er[n-1]=s,i=0,s=0;s<16;s++)for(nr[s]=i,e=0;e<1<<Xi[s];e++)$i[i++]=s;for(i>>=7;s<30;s++)for(nr[s]=i<<7,e=0;e<1<<Xi[s]-7;e++)$i[256+i++]=s;for(t=0;t<=15;t++)r[t]=0;for(e=0;e<=143;)qi[2*e+1]=8,e++,r[8]++;for(;e<=255;)qi[2*e+1]=9,e++,r[9]++;for(;e<=279;)qi[2*e+1]=7,e++,r[7]++;for(;e<=287;)qi[2*e+1]=8,e++,r[8]++;for(hr(qi,287,r),e=0;e<30;e++)Ki[2*e+1]=5,Ki[2*e]=fr(e,5);ir=new sr(qi,Ji,257,286,15),rr=new sr(Ki,Xi,0,30,15),ar=new sr(new Array(0),Wi,0,19,7)})(),xr=!0),e.l_desc=new or(e.dyn_ltree,ir),e.d_desc=new or(e.dyn_dtree,rr),e.bl_desc=new or(e.bl_tree,ar),e.bi_buf=0,e.bi_valid=0,pr(e)},_tr_stored_block:vr,_tr_flush_block:(e,t,n,s)=>{let i,r,a=0;e.level>0?(2===e.strm.data_type&&(e.strm.data_type=(e=>{let t,n=4093624447;for(t=0;t<=31;t++,n>>>=1)if(1&n&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<256;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0})(e)),yr(e,e.l_desc),yr(e,e.d_desc),a=(e=>{let t;for(Ar(e,e.dyn_ltree,e.l_desc.max_code),Ar(e,e.dyn_dtree,e.d_desc.max_code),yr(e,e.bl_desc),t=18;t>=3&&0===e.bl_tree[2*Vi[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t})(e),i=e.opt_len+3+7>>>3,r=e.static_len+3+7>>>3,r<=i&&(i=r)):i=r=n+5,n+4<=i&&-1!==t?vr(e,t,n,s):4===e.strategy||r===i?(dr(e,2+(s?1:0),3),br(e,qi,Ki)):(dr(e,4+(s?1:0),3),((e,t,n,s)=>{let i;for(dr(e,t-257,5),dr(e,n-1,5),dr(e,s-4,4),i=0;i<s;i++)dr(e,e.bl_tree[2*Vi[i]+1],3);wr(e,e.dyn_ltree,t-1),wr(e,e.dyn_dtree,n-1)})(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),br(e,e.dyn_ltree,e.dyn_dtree)),pr(e),s&&mr(e)},_tr_tally:(e,t,n)=>(e.pending_buf[e.sym_buf+e.sym_next++]=t,e.pending_buf[e.sym_buf+e.sym_next++]=t>>8,e.pending_buf[e.sym_buf+e.sym_next++]=n,0===t?e.dyn_ltree[2*n]++:(e.matches++,t--,e.dyn_ltree[2*(er[n]+256+1)]++,e.dyn_dtree[2*lr(t)]++),e.sym_next===e.sym_end),_tr_align:e=>{dr(e,2,3),ur(e,256,qi),(e=>{16===e.bi_valid?(cr(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)})(e)}},Mr=(e,t,n,s)=>{let i=65535&e,r=e>>>16&65535,a=0;for(;0!==n;){a=n>2e3?2e3:n,n-=a;do{i=i+t[s++]|0,r=r+i|0}while(--a);i%=65521,r%=65521}return i|r<<16};const zr=new Uint32Array((()=>{let e,t=[];for(var n=0;n<256;n++){e=n;for(var s=0;s<8;s++)e=1&e?3988292384^e>>>1:e>>>1;t[n]=e}return t})());var Br=(e,t,n,s)=>{const i=zr,r=s+n;e^=-1;for(let n=s;n<r;n++)e=e>>>8^i[255&(e^t[n])];return~e},Fr={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},kr={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:Cr,_tr_stored_block:Or,_tr_flush_block:Dr,_tr_tally:Lr,_tr_align:Tr}=Er,{Z_NO_FLUSH:Sr,Z_PARTIAL_FLUSH:Nr,Z_FULL_FLUSH:Pr,Z_FINISH:Ir,Z_BLOCK:Yr,Z_OK:Qr,Z_STREAM_END:jr,Z_STREAM_ERROR:Hr,Z_DATA_ERROR:Ur,Z_BUF_ERROR:Rr,Z_DEFAULT_COMPRESSION:Gr,Z_FILTERED:Zr,Z_HUFFMAN_ONLY:Jr,Z_RLE:Xr,Z_FIXED:Wr,Z_DEFAULT_STRATEGY:Vr,Z_UNKNOWN:qr,Z_DEFLATED:Kr}=kr,$r=258,ea=262,ta=42,na=113,sa=666,ia=(e,t)=>(e.msg=Fr[t],t),ra=e=>2*e-(e>4?9:0),aa=e=>{let t=e.length;for(;--t>=0;)e[t]=0},oa=e=>{let t,n,s,i=e.w_size;t=e.hash_size,s=t;do{n=e.head[--s],e.head[s]=n>=i?n-i:0}while(--t);t=i,s=t;do{n=e.prev[--s],e.prev[s]=n>=i?n-i:0}while(--t)};let la=(e,t,n)=>(t<<e.hash_shift^n)&e.hash_mask;const ca=e=>{const t=e.state;let n=t.pending;n>e.avail_out&&(n=e.avail_out),0!==n&&(e.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+n),e.next_out),e.next_out+=n,t.pending_out+=n,e.total_out+=n,e.avail_out-=n,t.pending-=n,0===t.pending&&(t.pending_out=0))},da=(e,t)=>{Dr(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,ca(e.strm)},ua=(e,t)=>{e.pending_buf[e.pending++]=t},fa=(e,t)=>{e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t},ha=(e,t,n,s)=>{let i=e.avail_in;return i>s&&(i=s),0===i?0:(e.avail_in-=i,t.set(e.input.subarray(e.next_in,e.next_in+i),n),1===e.state.wrap?e.adler=Mr(e.adler,t,i,n):2===e.state.wrap&&(e.adler=Br(e.adler,t,i,n)),e.next_in+=i,e.total_in+=i,i)},pa=(e,t)=>{let n,s,i=e.max_chain_length,r=e.strstart,a=e.prev_length,o=e.nice_match;const l=e.strstart>e.w_size-ea?e.strstart-(e.w_size-ea):0,c=e.window,d=e.w_mask,u=e.prev,f=e.strstart+$r;let h=c[r+a-1],p=c[r+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(n=t,c[n+a]===p&&c[n+a-1]===h&&c[n]===c[r]&&c[++n]===c[r+1]){r+=2,n++;do{}while(c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&c[++r]===c[++n]&&r<f);if(s=$r-(f-r),r=f-$r,s>a){if(e.match_start=t,a=s,s>=o)break;h=c[r+a-1],p=c[r+a]}}}while((t=u[t&d])>l&&0!=--i);return a<=e.lookahead?a:e.lookahead},ma=e=>{const t=e.w_size;let n,s,i;do{if(s=e.window_size-e.lookahead-e.strstart,e.strstart>=t+(t-ea)&&(e.window.set(e.window.subarray(t,t+t-s),0),e.match_start-=t,e.strstart-=t,e.block_start-=t,e.insert>e.strstart&&(e.insert=e.strstart),oa(e),s+=t),0===e.strm.avail_in)break;if(n=ha(e.strm,e.window,e.strstart+e.lookahead,s),e.lookahead+=n,e.lookahead+e.insert>=3)for(i=e.strstart-e.insert,e.ins_h=e.window[i],e.ins_h=la(e,e.ins_h,e.window[i+1]);e.insert&&(e.ins_h=la(e,e.ins_h,e.window[i+3-1]),e.prev[i&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=i,i++,e.insert--,!(e.lookahead+e.insert<3)););}while(e.lookahead<ea&&0!==e.strm.avail_in)},ga=(e,t)=>{let n,s,i,r=e.pending_buf_size-5>e.w_size?e.w_size:e.pending_buf_size-5,a=0,o=e.strm.avail_in;do{if(n=65535,i=e.bi_valid+42>>3,e.strm.avail_out<i)break;if(i=e.strm.avail_out-i,s=e.strstart-e.block_start,n>s+e.strm.avail_in&&(n=s+e.strm.avail_in),n>i&&(n=i),n<r&&(0===n&&t!==Ir||t===Sr||n!==s+e.strm.avail_in))break;a=t===Ir&&n===s+e.strm.avail_in?1:0,Or(e,0,0,a),e.pending_buf[e.pending-4]=n,e.pending_buf[e.pending-3]=n>>8,e.pending_buf[e.pending-2]=~n,e.pending_buf[e.pending-1]=~n>>8,ca(e.strm),s&&(s>n&&(s=n),e.strm.output.set(e.window.subarray(e.block_start,e.block_start+s),e.strm.next_out),e.strm.next_out+=s,e.strm.avail_out-=s,e.strm.total_out+=s,e.block_start+=s,n-=s),n&&(ha(e.strm,e.strm.output,e.strm.next_out,n),e.strm.next_out+=n,e.strm.avail_out-=n,e.strm.total_out+=n)}while(0===a);return o-=e.strm.avail_in,o&&(o>=e.w_size?(e.matches=2,e.window.set(e.strm.input.subarray(e.strm.next_in-e.w_size,e.strm.next_in),0),e.strstart=e.w_size,e.insert=e.strstart):(e.window_size-e.strstart<=o&&(e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,e.insert>e.strstart&&(e.insert=e.strstart)),e.window.set(e.strm.input.subarray(e.strm.next_in-o,e.strm.next_in),e.strstart),e.strstart+=o,e.insert+=o>e.w_size-e.insert?e.w_size-e.insert:o),e.block_start=e.strstart),e.high_water<e.strstart&&(e.high_water=e.strstart),a?4:t!==Sr&&t!==Ir&&0===e.strm.avail_in&&e.strstart===e.block_start?2:(i=e.window_size-e.strstart,e.strm.avail_in>i&&e.block_start>=e.w_size&&(e.block_start-=e.w_size,e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,i+=e.w_size,e.insert>e.strstart&&(e.insert=e.strstart)),i>e.strm.avail_in&&(i=e.strm.avail_in),i&&(ha(e.strm,e.window,e.strstart,i),e.strstart+=i,e.insert+=i>e.w_size-e.insert?e.w_size-e.insert:i),e.high_water<e.strstart&&(e.high_water=e.strstart),i=e.bi_valid+42>>3,i=e.pending_buf_size-i>65535?65535:e.pending_buf_size-i,r=i>e.w_size?e.w_size:i,s=e.strstart-e.block_start,(s>=r||(s||t===Ir)&&t!==Sr&&0===e.strm.avail_in&&s<=i)&&(n=s>i?i:s,a=t===Ir&&0===e.strm.avail_in&&n===s?1:0,Or(e,e.block_start,n,a),e.block_start+=n,ca(e.strm)),a?3:1)},_a=(e,t)=>{let n,s;for(;;){if(e.lookahead<ea){if(ma(e),e.lookahead<ea&&t===Sr)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=la(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==n&&e.strstart-n<=e.w_size-ea&&(e.match_length=pa(e,n)),e.match_length>=3)if(s=Lr(e,e.strstart-e.match_start,e.match_length-3),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=3){e.match_length--;do{e.strstart++,e.ins_h=la(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=la(e,e.ins_h,e.window[e.strstart+1]);else s=Lr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(s&&(da(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<2?e.strstart:2,t===Ir?(da(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(da(e,!1),0===e.strm.avail_out)?1:2},ba=(e,t)=>{let n,s,i;for(;;){if(e.lookahead<ea){if(ma(e),e.lookahead<ea&&t===Sr)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=la(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=2,0!==n&&e.prev_length<e.max_lazy_match&&e.strstart-n<=e.w_size-ea&&(e.match_length=pa(e,n),e.match_length<=5&&(e.strategy===Zr||3===e.match_length&&e.strstart-e.match_start>4096)&&(e.match_length=2)),e.prev_length>=3&&e.match_length<=e.prev_length){i=e.strstart+e.lookahead-3,s=Lr(e,e.strstart-1-e.prev_match,e.prev_length-3),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=i&&(e.ins_h=la(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=2,e.strstart++,s&&(da(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if(s=Lr(e,0,e.window[e.strstart-1]),s&&da(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(s=Lr(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<2?e.strstart:2,t===Ir?(da(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(da(e,!1),0===e.strm.avail_out)?1:2};function ya(e,t,n,s,i){this.good_length=e,this.max_lazy=t,this.nice_length=n,this.max_chain=s,this.func=i}const Aa=[new ya(0,0,0,0,ga),new ya(4,4,8,4,_a),new ya(4,5,16,8,_a),new ya(4,6,32,32,_a),new ya(4,4,16,16,ba),new ya(8,16,32,32,ba),new ya(8,16,128,128,ba),new ya(8,32,128,256,ba),new ya(32,128,258,1024,ba),new ya(32,258,258,4096,ba)];function wa(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Kr,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),aa(this.dyn_ltree),aa(this.dyn_dtree),aa(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),aa(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),aa(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const xa=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.status!==ta&&57!==t.status&&69!==t.status&&73!==t.status&&91!==t.status&&103!==t.status&&t.status!==na&&t.status!==sa?1:0},va=e=>{if(xa(e))return ia(e,Hr);e.total_in=e.total_out=0,e.data_type=qr;const t=e.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=2===t.wrap?57:t.wrap?ta:na,e.adler=2===t.wrap?0:1,t.last_flush=-2,Cr(t),Qr},Ea=e=>{const t=va(e);var n;return t===Qr&&((n=e.state).window_size=2*n.w_size,aa(n.head),n.max_lazy_match=Aa[n.level].max_lazy,n.good_match=Aa[n.level].good_length,n.nice_match=Aa[n.level].nice_length,n.max_chain_length=Aa[n.level].max_chain,n.strstart=0,n.block_start=0,n.lookahead=0,n.insert=0,n.match_length=n.prev_length=2,n.match_available=0,n.ins_h=0),t},Ma=(e,t,n,s,i,r)=>{if(!e)return Hr;let a=1;if(t===Gr&&(t=6),s<0?(a=0,s=-s):s>15&&(a=2,s-=16),i<1||i>9||n!==Kr||s<8||s>15||t<0||t>9||r<0||r>Wr||8===s&&1!==a)return ia(e,Hr);8===s&&(s=9);const o=new wa;return e.state=o,o.strm=e,o.status=ta,o.wrap=a,o.gzhead=null,o.w_bits=s,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+3-1)/3),o.window=new Uint8Array(2*o.w_size),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=3*(o.lit_bufsize-1),o.level=t,o.strategy=r,o.method=n,Ea(e)};var za={deflateInit:(e,t)=>Ma(e,t,Kr,15,8,Vr),deflateInit2:Ma,deflateReset:Ea,deflateResetKeep:va,deflateSetHeader:(e,t)=>xa(e)||2!==e.state.wrap?Hr:(e.state.gzhead=t,Qr),deflate:(e,t)=>{if(xa(e)||t>Yr||t<0)return e?ia(e,Hr):Hr;const n=e.state;if(!e.output||0!==e.avail_in&&!e.input||n.status===sa&&t!==Ir)return ia(e,0===e.avail_out?Rr:Hr);const s=n.last_flush;if(n.last_flush=t,0!==n.pending){if(ca(e),0===e.avail_out)return n.last_flush=-1,Qr}else if(0===e.avail_in&&ra(t)<=ra(s)&&t!==Ir)return ia(e,Rr);if(n.status===sa&&0!==e.avail_in)return ia(e,Rr);if(n.status===ta&&0===n.wrap&&(n.status=na),n.status===ta){let t=Kr+(n.w_bits-8<<4)<<8,s=-1;if(s=n.strategy>=Jr||n.level<2?0:n.level<6?1:6===n.level?2:3,t|=s<<6,0!==n.strstart&&(t|=32),t+=31-t%31,fa(n,t),0!==n.strstart&&(fa(n,e.adler>>>16),fa(n,65535&e.adler)),e.adler=1,n.status=na,ca(e),0!==n.pending)return n.last_flush=-1,Qr}if(57===n.status)if(e.adler=0,ua(n,31),ua(n,139),ua(n,8),n.gzhead)ua(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),ua(n,255&n.gzhead.time),ua(n,n.gzhead.time>>8&255),ua(n,n.gzhead.time>>16&255),ua(n,n.gzhead.time>>24&255),ua(n,9===n.level?2:n.strategy>=Jr||n.level<2?4:0),ua(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(ua(n,255&n.gzhead.extra.length),ua(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=Br(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69;else if(ua(n,0),ua(n,0),ua(n,0),ua(n,0),ua(n,0),ua(n,9===n.level?2:n.strategy>=Jr||n.level<2?4:0),ua(n,3),n.status=na,ca(e),0!==n.pending)return n.last_flush=-1,Qr;if(69===n.status){if(n.gzhead.extra){let t=n.pending,s=(65535&n.gzhead.extra.length)-n.gzindex;for(;n.pending+s>n.pending_buf_size;){let i=n.pending_buf_size-n.pending;if(n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex,n.gzindex+i),n.pending),n.pending=n.pending_buf_size,n.gzhead.hcrc&&n.pending>t&&(e.adler=Br(e.adler,n.pending_buf,n.pending-t,t)),n.gzindex+=i,ca(e),0!==n.pending)return n.last_flush=-1,Qr;t=0,s-=i}let i=new Uint8Array(n.gzhead.extra);n.pending_buf.set(i.subarray(n.gzindex,n.gzindex+s),n.pending),n.pending+=s,n.gzhead.hcrc&&n.pending>t&&(e.adler=Br(e.adler,n.pending_buf,n.pending-t,t)),n.gzindex=0}n.status=73}if(73===n.status){if(n.gzhead.name){let t,s=n.pending;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>s&&(e.adler=Br(e.adler,n.pending_buf,n.pending-s,s)),ca(e),0!==n.pending)return n.last_flush=-1,Qr;s=0}t=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,ua(n,t)}while(0!==t);n.gzhead.hcrc&&n.pending>s&&(e.adler=Br(e.adler,n.pending_buf,n.pending-s,s)),n.gzindex=0}n.status=91}if(91===n.status){if(n.gzhead.comment){let t,s=n.pending;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>s&&(e.adler=Br(e.adler,n.pending_buf,n.pending-s,s)),ca(e),0!==n.pending)return n.last_flush=-1,Qr;s=0}t=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,ua(n,t)}while(0!==t);n.gzhead.hcrc&&n.pending>s&&(e.adler=Br(e.adler,n.pending_buf,n.pending-s,s))}n.status=103}if(103===n.status){if(n.gzhead.hcrc){if(n.pending+2>n.pending_buf_size&&(ca(e),0!==n.pending))return n.last_flush=-1,Qr;ua(n,255&e.adler),ua(n,e.adler>>8&255),e.adler=0}if(n.status=na,ca(e),0!==n.pending)return n.last_flush=-1,Qr}if(0!==e.avail_in||0!==n.lookahead||t!==Sr&&n.status!==sa){let s=0===n.level?ga(n,t):n.strategy===Jr?((e,t)=>{let n;for(;;){if(0===e.lookahead&&(ma(e),0===e.lookahead)){if(t===Sr)return 1;break}if(e.match_length=0,n=Lr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,n&&(da(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===Ir?(da(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(da(e,!1),0===e.strm.avail_out)?1:2})(n,t):n.strategy===Xr?((e,t)=>{let n,s,i,r;const a=e.window;for(;;){if(e.lookahead<=$r){if(ma(e),e.lookahead<=$r&&t===Sr)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=3&&e.strstart>0&&(i=e.strstart-1,s=a[i],s===a[++i]&&s===a[++i]&&s===a[++i])){r=e.strstart+$r;do{}while(s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&s===a[++i]&&i<r);e.match_length=$r-(r-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=3?(n=Lr(e,1,e.match_length-3),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(n=Lr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),n&&(da(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===Ir?(da(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(da(e,!1),0===e.strm.avail_out)?1:2})(n,t):Aa[n.level].func(n,t);if(3!==s&&4!==s||(n.status=sa),1===s||3===s)return 0===e.avail_out&&(n.last_flush=-1),Qr;if(2===s&&(t===Nr?Tr(n):t!==Yr&&(Or(n,0,0,!1),t===Pr&&(aa(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),ca(e),0===e.avail_out))return n.last_flush=-1,Qr}return t!==Ir?Qr:n.wrap<=0?jr:(2===n.wrap?(ua(n,255&e.adler),ua(n,e.adler>>8&255),ua(n,e.adler>>16&255),ua(n,e.adler>>24&255),ua(n,255&e.total_in),ua(n,e.total_in>>8&255),ua(n,e.total_in>>16&255),ua(n,e.total_in>>24&255)):(fa(n,e.adler>>>16),fa(n,65535&e.adler)),ca(e),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?Qr:jr)},deflateEnd:e=>{if(xa(e))return Hr;const t=e.state.status;return e.state=null,t===na?ia(e,Ur):Qr},deflateSetDictionary:(e,t)=>{let n=t.length;if(xa(e))return Hr;const s=e.state,i=s.wrap;if(2===i||1===i&&s.status!==ta||s.lookahead)return Hr;if(1===i&&(e.adler=Mr(e.adler,t,n,0)),s.wrap=0,n>=s.w_size){0===i&&(aa(s.head),s.strstart=0,s.block_start=0,s.insert=0);let e=new Uint8Array(s.w_size);e.set(t.subarray(n-s.w_size,n),0),t=e,n=s.w_size}const r=e.avail_in,a=e.next_in,o=e.input;for(e.avail_in=n,e.next_in=0,e.input=t,ma(s);s.lookahead>=3;){let e=s.strstart,t=s.lookahead-2;do{s.ins_h=la(s,s.ins_h,s.window[e+3-1]),s.prev[e&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=e,e++}while(--t);s.strstart=e,s.lookahead=2,ma(s)}return s.strstart+=s.lookahead,s.block_start=s.strstart,s.insert=s.lookahead,s.lookahead=0,s.match_length=s.prev_length=2,s.match_available=0,e.next_in=a,e.input=o,e.avail_in=r,s.wrap=i,Qr},deflateInfo:"pako deflate (from Nodeca project)"};const Ba=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var Fa={assign:function(e){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const n=t.shift();if(n){if("object"!=typeof n)throw new TypeError(n+"must be non-object");for(const t in n)Ba(n,t)&&(e[t]=n[t])}}return e},flattenChunks:e=>{let t=0;for(let n=0,s=e.length;n<s;n++)t+=e[n].length;const n=new Uint8Array(t);for(let t=0,s=0,i=e.length;t<i;t++){let i=e[t];n.set(i,s),s+=i.length}return n}};let ka=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){ka=!1}const Ca=new Uint8Array(256);for(let e=0;e<256;e++)Ca[e]=e>=252?6:e>=248?5:e>=240?4:e>=224?3:e>=192?2:1;Ca[254]=Ca[254]=1;var Oa={string2buf:e=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);let t,n,s,i,r,a=e.length,o=0;for(i=0;i<a;i++)n=e.charCodeAt(i),55296==(64512&n)&&i+1<a&&(s=e.charCodeAt(i+1),56320==(64512&s)&&(n=65536+(n-55296<<10)+(s-56320),i++)),o+=n<128?1:n<2048?2:n<65536?3:4;for(t=new Uint8Array(o),r=0,i=0;r<o;i++)n=e.charCodeAt(i),55296==(64512&n)&&i+1<a&&(s=e.charCodeAt(i+1),56320==(64512&s)&&(n=65536+(n-55296<<10)+(s-56320),i++)),n<128?t[r++]=n:n<2048?(t[r++]=192|n>>>6,t[r++]=128|63&n):n<65536?(t[r++]=224|n>>>12,t[r++]=128|n>>>6&63,t[r++]=128|63&n):(t[r++]=240|n>>>18,t[r++]=128|n>>>12&63,t[r++]=128|n>>>6&63,t[r++]=128|63&n);return t},buf2string:(e,t)=>{const n=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));let s,i;const r=new Array(2*n);for(i=0,s=0;s<n;){let t=e[s++];if(t<128){r[i++]=t;continue}let a=Ca[t];if(a>4)r[i++]=65533,s+=a-1;else{for(t&=2===a?31:3===a?15:7;a>1&&s<n;)t=t<<6|63&e[s++],a--;a>1?r[i++]=65533:t<65536?r[i++]=t:(t-=65536,r[i++]=55296|t>>10&1023,r[i++]=56320|1023&t)}}return((e,t)=>{if(t<65534&&e.subarray&&ka)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));let n="";for(let s=0;s<t;s++)n+=String.fromCharCode(e[s]);return n})(r,i)},utf8border:(e,t)=>{(t=t||e.length)>e.length&&(t=e.length);let n=t-1;for(;n>=0&&128==(192&e[n]);)n--;return n<0||0===n?t:n+Ca[e[n]]>t?n:t}},Da=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const La=Object.prototype.toString,{Z_NO_FLUSH:Ta,Z_SYNC_FLUSH:Sa,Z_FULL_FLUSH:Na,Z_FINISH:Pa,Z_OK:Ia,Z_STREAM_END:Ya,Z_DEFAULT_COMPRESSION:Qa,Z_DEFAULT_STRATEGY:ja,Z_DEFLATED:Ha}=kr;function Ua(e){this.options=Fa.assign({level:Qa,method:Ha,chunkSize:16384,windowBits:15,memLevel:8,strategy:ja},e||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Da,this.strm.avail_out=0;let n=za.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(n!==Ia)throw new Error(Fr[n]);if(t.header&&za.deflateSetHeader(this.strm,t.header),t.dictionary){let e;if(e="string"==typeof t.dictionary?Oa.string2buf(t.dictionary):"[object ArrayBuffer]"===La.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,n=za.deflateSetDictionary(this.strm,e),n!==Ia)throw new Error(Fr[n]);this._dict_set=!0}}function Ra(e,t){const n=new Ua(t);if(n.push(e,!0),n.err)throw n.msg||Fr[n.err];return n.result}Ua.prototype.push=function(e,t){const n=this.strm,s=this.options.chunkSize;let i,r;if(this.ended)return!1;for(r=t===~~t?t:!0===t?Pa:Ta,"string"==typeof e?n.input=Oa.string2buf(e):"[object ArrayBuffer]"===La.call(e)?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;)if(0===n.avail_out&&(n.output=new Uint8Array(s),n.next_out=0,n.avail_out=s),(r===Sa||r===Na)&&n.avail_out<=6)this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;else{if(i=za.deflate(n,r),i===Ya)return n.next_out>0&&this.onData(n.output.subarray(0,n.next_out)),i=za.deflateEnd(this.strm),this.onEnd(i),this.ended=!0,i===Ia;if(0!==n.avail_out){if(r>0&&n.next_out>0)this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;else if(0===n.avail_in)break}else this.onData(n.output)}return!0},Ua.prototype.onData=function(e){this.chunks.push(e)},Ua.prototype.onEnd=function(e){e===Ia&&(this.result=Fa.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Ga={Deflate:Ua,deflate:Ra,deflateRaw:function(e,t){return(t=t||{}).raw=!0,Ra(e,t)},gzip:function(e,t){return(t=t||{}).gzip=!0,Ra(e,t)},constants:kr};const Za=16209;var Ja=function(e,t){let n,s,i,r,a,o,l,c,d,u,f,h,p,m,g,_,b,y,A,w,x,v,E,M;const z=e.state;n=e.next_in,E=e.input,s=n+(e.avail_in-5),i=e.next_out,M=e.output,r=i-(t-e.avail_out),a=i+(e.avail_out-257),o=z.dmax,l=z.wsize,c=z.whave,d=z.wnext,u=z.window,f=z.hold,h=z.bits,p=z.lencode,m=z.distcode,g=(1<<z.lenbits)-1,_=(1<<z.distbits)-1;e:do{h<15&&(f+=E[n++]<<h,h+=8,f+=E[n++]<<h,h+=8),b=p[f&g];t:for(;;){if(y=b>>>24,f>>>=y,h-=y,y=b>>>16&255,0===y)M[i++]=65535&b;else{if(!(16&y)){if(64&y){if(32&y){z.mode=16191;break e}e.msg="invalid literal/length code",z.mode=Za;break e}b=p[(65535&b)+(f&(1<<y)-1)];continue t}for(A=65535&b,y&=15,y&&(h<y&&(f+=E[n++]<<h,h+=8),A+=f&(1<<y)-1,f>>>=y,h-=y),h<15&&(f+=E[n++]<<h,h+=8,f+=E[n++]<<h,h+=8),b=m[f&_];;){if(y=b>>>24,f>>>=y,h-=y,y=b>>>16&255,16&y){if(w=65535&b,y&=15,h<y&&(f+=E[n++]<<h,h+=8,h<y&&(f+=E[n++]<<h,h+=8)),w+=f&(1<<y)-1,w>o){e.msg="invalid distance too far back",z.mode=Za;break e}if(f>>>=y,h-=y,y=i-r,w>y){if(y=w-y,y>c&&z.sane){e.msg="invalid distance too far back",z.mode=Za;break e}if(x=0,v=u,0===d){if(x+=l-y,y<A){A-=y;do{M[i++]=u[x++]}while(--y);x=i-w,v=M}}else if(d<y){if(x+=l+d-y,y-=d,y<A){A-=y;do{M[i++]=u[x++]}while(--y);if(x=0,d<A){y=d,A-=y;do{M[i++]=u[x++]}while(--y);x=i-w,v=M}}}else if(x+=d-y,y<A){A-=y;do{M[i++]=u[x++]}while(--y);x=i-w,v=M}for(;A>2;)M[i++]=v[x++],M[i++]=v[x++],M[i++]=v[x++],A-=3;A&&(M[i++]=v[x++],A>1&&(M[i++]=v[x++]))}else{x=i-w;do{M[i++]=M[x++],M[i++]=M[x++],M[i++]=M[x++],A-=3}while(A>2);A&&(M[i++]=M[x++],A>1&&(M[i++]=M[x++]))}break}if(64&y){e.msg="invalid distance code",z.mode=Za;break e}b=m[(65535&b)+(f&(1<<y)-1)]}}break}}while(n<s&&i<a);A=h>>3,n-=A,h-=A<<3,f&=(1<<h)-1,e.next_in=n,e.next_out=i,e.avail_in=n<s?s-n+5:5-(n-s),e.avail_out=i<a?a-i+257:257-(i-a),z.hold=f,z.bits=h};const Xa=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Wa=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),Va=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),qa=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var Ka=(e,t,n,s,i,r,a,o)=>{const l=o.bits;let c,d,u,f,h,p,m=0,g=0,_=0,b=0,y=0,A=0,w=0,x=0,v=0,E=0,M=null;const z=new Uint16Array(16),B=new Uint16Array(16);let F,k,C,O=null;for(m=0;m<=15;m++)z[m]=0;for(g=0;g<s;g++)z[t[n+g]]++;for(y=l,b=15;b>=1&&0===z[b];b--);if(y>b&&(y=b),0===b)return i[r++]=20971520,i[r++]=20971520,o.bits=1,0;for(_=1;_<b&&0===z[_];_++);for(y<_&&(y=_),x=1,m=1;m<=15;m++)if(x<<=1,x-=z[m],x<0)return-1;if(x>0&&(0===e||1!==b))return-1;for(B[1]=0,m=1;m<15;m++)B[m+1]=B[m]+z[m];for(g=0;g<s;g++)0!==t[n+g]&&(a[B[t[n+g]]++]=g);if(0===e?(M=O=a,p=20):1===e?(M=Xa,O=Wa,p=257):(M=Va,O=qa,p=0),E=0,g=0,m=_,h=r,A=y,w=0,u=-1,v=1<<y,f=v-1,1===e&&v>852||2===e&&v>592)return 1;for(;;){F=m-w,a[g]+1<p?(k=0,C=a[g]):a[g]>=p?(k=O[a[g]-p],C=M[a[g]-p]):(k=96,C=0),c=1<<m-w,d=1<<A,_=d;do{d-=c,i[h+(E>>w)+d]=F<<24|k<<16|C}while(0!==d);for(c=1<<m-1;E&c;)c>>=1;if(0!==c?(E&=c-1,E+=c):E=0,g++,0==--z[m]){if(m===b)break;m=t[n+a[g]]}if(m>y&&(E&f)!==u){for(0===w&&(w=y),h+=_,A=m-w,x=1<<A;A+w<b&&(x-=z[A+w],!(x<=0));)A++,x<<=1;if(v+=1<<A,1===e&&v>852||2===e&&v>592)return 1;u=E&f,i[u]=y<<24|A<<16|h-r}}return 0!==E&&(i[h+E]=m-w<<24|64<<16),o.bits=y,0};const{Z_FINISH:$a,Z_BLOCK:eo,Z_TREES:to,Z_OK:no,Z_STREAM_END:so,Z_NEED_DICT:io,Z_STREAM_ERROR:ro,Z_DATA_ERROR:ao,Z_MEM_ERROR:oo,Z_BUF_ERROR:lo,Z_DEFLATED:co}=kr,uo=16180,fo=16190,ho=16191,po=16192,mo=16194,go=16199,_o=16200,bo=16206,yo=16209,Ao=e=>(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24);function wo(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const xo=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.mode<uo||t.mode>16211?1:0},vo=e=>{if(xo(e))return ro;const t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=uo,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,no},Eo=e=>{if(xo(e))return ro;const t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,vo(e)},Mo=(e,t)=>{let n;if(xo(e))return ro;const s=e.state;return t<0?(n=0,t=-t):(n=5+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?ro:(null!==s.window&&s.wbits!==t&&(s.window=null),s.wrap=n,s.wbits=t,Eo(e))},zo=(e,t)=>{if(!e)return ro;const n=new wo;e.state=n,n.strm=e,n.window=null,n.mode=uo;const s=Mo(e,t);return s!==no&&(e.state=null),s};let Bo,Fo,ko=!0;const Co=e=>{if(ko){Bo=new Int32Array(512),Fo=new Int32Array(32);let t=0;for(;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(Ka(1,e.lens,0,288,Bo,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;Ka(2,e.lens,0,32,Fo,0,e.work,{bits:5}),ko=!1}e.lencode=Bo,e.lenbits=9,e.distcode=Fo,e.distbits=5},Oo=(e,t,n,s)=>{let i;const r=e.state;return null===r.window&&(r.wsize=1<<r.wbits,r.wnext=0,r.whave=0,r.window=new Uint8Array(r.wsize)),s>=r.wsize?(r.window.set(t.subarray(n-r.wsize,n),0),r.wnext=0,r.whave=r.wsize):(i=r.wsize-r.wnext,i>s&&(i=s),r.window.set(t.subarray(n-s,n-s+i),r.wnext),(s-=i)?(r.window.set(t.subarray(n-s,n),0),r.wnext=s,r.whave=r.wsize):(r.wnext+=i,r.wnext===r.wsize&&(r.wnext=0),r.whave<r.wsize&&(r.whave+=i))),0};var Do={inflateReset:Eo,inflateReset2:Mo,inflateResetKeep:vo,inflateInit:e=>zo(e,15),inflateInit2:zo,inflate:(e,t)=>{let n,s,i,r,a,o,l,c,d,u,f,h,p,m,g,_,b,y,A,w,x,v,E=0;const M=new Uint8Array(4);let z,B;const F=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(xo(e)||!e.output||!e.input&&0!==e.avail_in)return ro;n=e.state,n.mode===ho&&(n.mode=po),a=e.next_out,i=e.output,l=e.avail_out,r=e.next_in,s=e.input,o=e.avail_in,c=n.hold,d=n.bits,u=o,f=l,v=no;e:for(;;)switch(n.mode){case uo:if(0===n.wrap){n.mode=po;break}for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(2&n.wrap&&35615===c){0===n.wbits&&(n.wbits=15),n.check=0,M[0]=255&c,M[1]=c>>>8&255,n.check=Br(n.check,M,2,0),c=0,d=0,n.mode=16181;break}if(n.head&&(n.head.done=!1),!(1&n.wrap)||(((255&c)<<8)+(c>>8))%31){e.msg="incorrect header check",n.mode=yo;break}if((15&c)!==co){e.msg="unknown compression method",n.mode=yo;break}if(c>>>=4,d-=4,x=8+(15&c),0===n.wbits&&(n.wbits=x),x>15||x>n.wbits){e.msg="invalid window size",n.mode=yo;break}n.dmax=1<<n.wbits,n.flags=0,e.adler=n.check=1,n.mode=512&c?16189:ho,c=0,d=0;break;case 16181:for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(n.flags=c,(255&n.flags)!==co){e.msg="unknown compression method",n.mode=yo;break}if(57344&n.flags){e.msg="unknown header flags set",n.mode=yo;break}n.head&&(n.head.text=c>>8&1),512&n.flags&&4&n.wrap&&(M[0]=255&c,M[1]=c>>>8&255,n.check=Br(n.check,M,2,0)),c=0,d=0,n.mode=16182;case 16182:for(;d<32;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.head&&(n.head.time=c),512&n.flags&&4&n.wrap&&(M[0]=255&c,M[1]=c>>>8&255,M[2]=c>>>16&255,M[3]=c>>>24&255,n.check=Br(n.check,M,4,0)),c=0,d=0,n.mode=16183;case 16183:for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.head&&(n.head.xflags=255&c,n.head.os=c>>8),512&n.flags&&4&n.wrap&&(M[0]=255&c,M[1]=c>>>8&255,n.check=Br(n.check,M,2,0)),c=0,d=0,n.mode=16184;case 16184:if(1024&n.flags){for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.length=c,n.head&&(n.head.extra_len=c),512&n.flags&&4&n.wrap&&(M[0]=255&c,M[1]=c>>>8&255,n.check=Br(n.check,M,2,0)),c=0,d=0}else n.head&&(n.head.extra=null);n.mode=16185;case 16185:if(1024&n.flags&&(h=n.length,h>o&&(h=o),h&&(n.head&&(x=n.head.extra_len-n.length,n.head.extra||(n.head.extra=new Uint8Array(n.head.extra_len)),n.head.extra.set(s.subarray(r,r+h),x)),512&n.flags&&4&n.wrap&&(n.check=Br(n.check,s,h,r)),o-=h,r+=h,n.length-=h),n.length))break e;n.length=0,n.mode=16186;case 16186:if(2048&n.flags){if(0===o)break e;h=0;do{x=s[r+h++],n.head&&x&&n.length<65536&&(n.head.name+=String.fromCharCode(x))}while(x&&h<o);if(512&n.flags&&4&n.wrap&&(n.check=Br(n.check,s,h,r)),o-=h,r+=h,x)break e}else n.head&&(n.head.name=null);n.length=0,n.mode=16187;case 16187:if(4096&n.flags){if(0===o)break e;h=0;do{x=s[r+h++],n.head&&x&&n.length<65536&&(n.head.comment+=String.fromCharCode(x))}while(x&&h<o);if(512&n.flags&&4&n.wrap&&(n.check=Br(n.check,s,h,r)),o-=h,r+=h,x)break e}else n.head&&(n.head.comment=null);n.mode=16188;case 16188:if(512&n.flags){for(;d<16;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(4&n.wrap&&c!==(65535&n.check)){e.msg="header crc mismatch",n.mode=yo;break}c=0,d=0}n.head&&(n.head.hcrc=n.flags>>9&1,n.head.done=!0),e.adler=n.check=0,n.mode=ho;break;case 16189:for(;d<32;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}e.adler=n.check=Ao(c),c=0,d=0,n.mode=fo;case fo:if(0===n.havedict)return e.next_out=a,e.avail_out=l,e.next_in=r,e.avail_in=o,n.hold=c,n.bits=d,io;e.adler=n.check=1,n.mode=ho;case ho:if(t===eo||t===to)break e;case po:if(n.last){c>>>=7&d,d-=7&d,n.mode=bo;break}for(;d<3;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}switch(n.last=1&c,c>>>=1,d-=1,3&c){case 0:n.mode=16193;break;case 1:if(Co(n),n.mode=go,t===to){c>>>=2,d-=2;break e}break;case 2:n.mode=16196;break;case 3:e.msg="invalid block type",n.mode=yo}c>>>=2,d-=2;break;case 16193:for(c>>>=7&d,d-=7&d;d<32;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if((65535&c)!=(c>>>16^65535)){e.msg="invalid stored block lengths",n.mode=yo;break}if(n.length=65535&c,c=0,d=0,n.mode=mo,t===to)break e;case mo:n.mode=16195;case 16195:if(h=n.length,h){if(h>o&&(h=o),h>l&&(h=l),0===h)break e;i.set(s.subarray(r,r+h),a),o-=h,r+=h,l-=h,a+=h,n.length-=h;break}n.mode=ho;break;case 16196:for(;d<14;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(n.nlen=257+(31&c),c>>>=5,d-=5,n.ndist=1+(31&c),c>>>=5,d-=5,n.ncode=4+(15&c),c>>>=4,d-=4,n.nlen>286||n.ndist>30){e.msg="too many length or distance symbols",n.mode=yo;break}n.have=0,n.mode=16197;case 16197:for(;n.have<n.ncode;){for(;d<3;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.lens[F[n.have++]]=7&c,c>>>=3,d-=3}for(;n.have<19;)n.lens[F[n.have++]]=0;if(n.lencode=n.lendyn,n.lenbits=7,z={bits:n.lenbits},v=Ka(0,n.lens,0,19,n.lencode,0,n.work,z),n.lenbits=z.bits,v){e.msg="invalid code lengths set",n.mode=yo;break}n.have=0,n.mode=16198;case 16198:for(;n.have<n.nlen+n.ndist;){for(;E=n.lencode[c&(1<<n.lenbits)-1],g=E>>>24,_=E>>>16&255,b=65535&E,!(g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(b<16)c>>>=g,d-=g,n.lens[n.have++]=b;else{if(16===b){for(B=g+2;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(c>>>=g,d-=g,0===n.have){e.msg="invalid bit length repeat",n.mode=yo;break}x=n.lens[n.have-1],h=3+(3&c),c>>>=2,d-=2}else if(17===b){for(B=g+3;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}c>>>=g,d-=g,x=0,h=3+(7&c),c>>>=3,d-=3}else{for(B=g+7;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}c>>>=g,d-=g,x=0,h=11+(127&c),c>>>=7,d-=7}if(n.have+h>n.nlen+n.ndist){e.msg="invalid bit length repeat",n.mode=yo;break}for(;h--;)n.lens[n.have++]=x}}if(n.mode===yo)break;if(0===n.lens[256]){e.msg="invalid code -- missing end-of-block",n.mode=yo;break}if(n.lenbits=9,z={bits:n.lenbits},v=Ka(1,n.lens,0,n.nlen,n.lencode,0,n.work,z),n.lenbits=z.bits,v){e.msg="invalid literal/lengths set",n.mode=yo;break}if(n.distbits=6,n.distcode=n.distdyn,z={bits:n.distbits},v=Ka(2,n.lens,n.nlen,n.ndist,n.distcode,0,n.work,z),n.distbits=z.bits,v){e.msg="invalid distances set",n.mode=yo;break}if(n.mode=go,t===to)break e;case go:n.mode=_o;case _o:if(o>=6&&l>=258){e.next_out=a,e.avail_out=l,e.next_in=r,e.avail_in=o,n.hold=c,n.bits=d,Ja(e,f),a=e.next_out,i=e.output,l=e.avail_out,r=e.next_in,s=e.input,o=e.avail_in,c=n.hold,d=n.bits,n.mode===ho&&(n.back=-1);break}for(n.back=0;E=n.lencode[c&(1<<n.lenbits)-1],g=E>>>24,_=E>>>16&255,b=65535&E,!(g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(_&&!(240&_)){for(y=g,A=_,w=b;E=n.lencode[w+((c&(1<<y+A)-1)>>y)],g=E>>>24,_=E>>>16&255,b=65535&E,!(y+g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}c>>>=y,d-=y,n.back+=y}if(c>>>=g,d-=g,n.back+=g,n.length=b,0===_){n.mode=16205;break}if(32&_){n.back=-1,n.mode=ho;break}if(64&_){e.msg="invalid literal/length code",n.mode=yo;break}n.extra=15&_,n.mode=16201;case 16201:if(n.extra){for(B=n.extra;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.length+=c&(1<<n.extra)-1,c>>>=n.extra,d-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=16202;case 16202:for(;E=n.distcode[c&(1<<n.distbits)-1],g=E>>>24,_=E>>>16&255,b=65535&E,!(g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(!(240&_)){for(y=g,A=_,w=b;E=n.distcode[w+((c&(1<<y+A)-1)>>y)],g=E>>>24,_=E>>>16&255,b=65535&E,!(y+g<=d);){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}c>>>=y,d-=y,n.back+=y}if(c>>>=g,d-=g,n.back+=g,64&_){e.msg="invalid distance code",n.mode=yo;break}n.offset=b,n.extra=15&_,n.mode=16203;case 16203:if(n.extra){for(B=n.extra;d<B;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}n.offset+=c&(1<<n.extra)-1,c>>>=n.extra,d-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){e.msg="invalid distance too far back",n.mode=yo;break}n.mode=16204;case 16204:if(0===l)break e;if(h=f-l,n.offset>h){if(h=n.offset-h,h>n.whave&&n.sane){e.msg="invalid distance too far back",n.mode=yo;break}h>n.wnext?(h-=n.wnext,p=n.wsize-h):p=n.wnext-h,h>n.length&&(h=n.length),m=n.window}else m=i,p=a-n.offset,h=n.length;h>l&&(h=l),l-=h,n.length-=h;do{i[a++]=m[p++]}while(--h);0===n.length&&(n.mode=_o);break;case 16205:if(0===l)break e;i[a++]=n.length,l--,n.mode=_o;break;case bo:if(n.wrap){for(;d<32;){if(0===o)break e;o--,c|=s[r++]<<d,d+=8}if(f-=l,e.total_out+=f,n.total+=f,4&n.wrap&&f&&(e.adler=n.check=n.flags?Br(n.check,i,f,a-f):Mr(n.check,i,f,a-f)),f=l,4&n.wrap&&(n.flags?c:Ao(c))!==n.check){e.msg="incorrect data check",n.mode=yo;break}c=0,d=0}n.mode=16207;case 16207:if(n.wrap&&n.flags){for(;d<32;){if(0===o)break e;o--,c+=s[r++]<<d,d+=8}if(4&n.wrap&&c!==(4294967295&n.total)){e.msg="incorrect length check",n.mode=yo;break}c=0,d=0}n.mode=16208;case 16208:v=so;break e;case yo:v=ao;break e;case 16210:return oo;default:return ro}return e.next_out=a,e.avail_out=l,e.next_in=r,e.avail_in=o,n.hold=c,n.bits=d,(n.wsize||f!==e.avail_out&&n.mode<yo&&(n.mode<bo||t!==$a))&&Oo(e,e.output,e.next_out,f-e.avail_out),u-=e.avail_in,f-=e.avail_out,e.total_in+=u,e.total_out+=f,n.total+=f,4&n.wrap&&f&&(e.adler=n.check=n.flags?Br(n.check,i,f,e.next_out-f):Mr(n.check,i,f,e.next_out-f)),e.data_type=n.bits+(n.last?64:0)+(n.mode===ho?128:0)+(n.mode===go||n.mode===mo?256:0),(0===u&&0===f||t===$a)&&v===no&&(v=lo),v},inflateEnd:e=>{if(xo(e))return ro;let t=e.state;return t.window&&(t.window=null),e.state=null,no},inflateGetHeader:(e,t)=>{if(xo(e))return ro;const n=e.state;return 2&n.wrap?(n.head=t,t.done=!1,no):ro},inflateSetDictionary:(e,t)=>{const n=t.length;let s,i,r;return xo(e)?ro:(s=e.state,0!==s.wrap&&s.mode!==fo?ro:s.mode===fo&&(i=1,i=Mr(i,t,n,0),i!==s.check)?ao:(r=Oo(e,t,n,n),r?(s.mode=16210,oo):(s.havedict=1,no)))},inflateInfo:"pako inflate (from Nodeca project)"},Lo=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const To=Object.prototype.toString,{Z_NO_FLUSH:So,Z_FINISH:No,Z_OK:Po,Z_STREAM_END:Io,Z_NEED_DICT:Yo,Z_STREAM_ERROR:Qo,Z_DATA_ERROR:jo,Z_MEM_ERROR:Ho}=kr;function Uo(e){this.options=Fa.assign({chunkSize:65536,windowBits:15,to:""},e||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&(15&t.windowBits||(t.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Da,this.strm.avail_out=0;let n=Do.inflateInit2(this.strm,t.windowBits);if(n!==Po)throw new Error(Fr[n]);if(this.header=new Lo,Do.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=Oa.string2buf(t.dictionary):"[object ArrayBuffer]"===To.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(n=Do.inflateSetDictionary(this.strm,t.dictionary),n!==Po)))throw new Error(Fr[n])}function Ro(e,t){const n=new Uo(t);if(n.push(e),n.err)throw n.msg||Fr[n.err];return n.result}Uo.prototype.push=function(e,t){const n=this.strm,s=this.options.chunkSize,i=this.options.dictionary;let r,a,o;if(this.ended)return!1;for(a=t===~~t?t:!0===t?No:So,"[object ArrayBuffer]"===To.call(e)?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;){for(0===n.avail_out&&(n.output=new Uint8Array(s),n.next_out=0,n.avail_out=s),r=Do.inflate(n,a),r===Yo&&i&&(r=Do.inflateSetDictionary(n,i),r===Po?r=Do.inflate(n,a):r===jo&&(r=Yo));n.avail_in>0&&r===Io&&n.state.wrap>0&&0!==e[n.next_in];)Do.inflateReset(n),r=Do.inflate(n,a);switch(r){case Qo:case jo:case Yo:case Ho:return this.onEnd(r),this.ended=!0,!1}if(o=n.avail_out,n.next_out&&(0===n.avail_out||r===Io))if("string"===this.options.to){let e=Oa.utf8border(n.output,n.next_out),t=n.next_out-e,i=Oa.buf2string(n.output,e);n.next_out=t,n.avail_out=s-t,t&&n.output.set(n.output.subarray(e,e+t),0),this.onData(i)}else this.onData(n.output.length===n.next_out?n.output:n.output.subarray(0,n.next_out));if(r!==Po||0!==o){if(r===Io)return r=Do.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(0===n.avail_in)break}}return!0},Uo.prototype.onData=function(e){this.chunks.push(e)},Uo.prototype.onEnd=function(e){e===Po&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=Fa.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Go={Inflate:Uo,inflate:Ro,inflateRaw:function(e,t){return(t=t||{}).raw=!0,Ro(e,t)},ungzip:Ro,constants:kr};const{Deflate:Zo,deflate:Jo,deflateRaw:Xo,gzip:Wo}=Ga,{Inflate:Vo,inflate:qo,inflateRaw:Ko,ungzip:$o}=Go;var el=qo;let tl;i(7989),new class{constructor(){this.logs=[]}enable(){tl=(...e)=>{this.logs.push([(new Date).toISOString(),...e])}}getLogs(e=0){return e?this.logs.slice(-e):this.logs}clear(e=this.logs.length){this.logs=this.logs.slice(e)}};var nl=i(3322),sl=i(8891).Buffer;class il{constructor(e){if(this.buffer=e,e.length!==il.SIZE)throw new Error(`Expected buffer to have length ${il.SIZE} but was ${e.length}`)}toBuffer(){return this.buffer}static fromBuffer(e){const t=Js.asReader(e);return new il(t.readBytes(il.SIZE))}equals(e){return this.buffer.equals(e.buffer)}isZero(){return this.buffer.equals(sl.alloc(32,0))}toString(){return Ds(this.buffer)}toJSON(){return this.toString()}toBigInt(){return function(e,t=0,n=32){return{elem:p(e.subarray(t,t+n)),adv:n}}(this.buffer,0,il.SIZE).elem}static fromBigInt(e){return new il(bi(e,il.SIZE))}static fromField(e){return new il(bi(e.toBigInt()))}static fromBuffer28(e){if(28!=e.length)throw new Error("Expected Buffer32 input buffer to be 28 bytes");const t=sl.concat([sl.alloc(this.SIZE-28),e]);return new il(t)}static fromString(e){if(e.startsWith("0x")&&(e=e.slice(2)),64!==e.length)throw new Error(`Expected string to be 64 characters long, but was ${e.length}`);return new il(sl.from(e,"hex"))}static fromNumber(e){return new il(bi(BigInt(e),il.SIZE))}static random(){return new il(sl.from(ot(il.SIZE)))}}function rl(e){return e instanceof il&&(e=e.buffer),new nl.vm(256).update(e).digest()}function al(e){const t=new nl.vm(256);return t.reset(),t.update(e),t.digest("hex")}il.SIZE=32,il.ZERO=new il(sl.alloc(il.SIZE));var ol=i(6460),ll=i(8891).Buffer;function cl(e){return ll.from(ol.sha256().update(e).digest())}function dl(e){return function(e){if(32!==e.length)throw new Error("Buffer to truncate must be 32 bytes");return oi.concat([oi.alloc(1),e.subarray(0,31)])}(cl(e))}var ul=i(8891).Buffer;const fl=e=>{const t=_i(e);return ai.fromBufferReduce((e=>ul.from(ol.sha512().update(e).digest()))(t))};var hl=i(8891).Buffer;async function pl(e,t=0){const n=gi(e),s=(await c.initSingleton()).pedersenHash(n.map((e=>new d(e.toBuffer()))),t);return si.fromBuffer(hl.from(s.toBuffer()))}function ml(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function gl(e,...t){if(!((n=e)instanceof Uint8Array||null!=n&&"object"==typeof n&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function _l(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}const bl="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,yl=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),Al=(e,t)=>e<<32-t|e>>>t;function wl(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),gl(e),e}new Uint8Array(new Uint32Array([287454020]).buffer)[0];class xl{clone(){return this._cloneInto()}}function vl(e){const t=t=>e().update(wl(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function El(e=32){if(bl&&"function"==typeof bl.getRandomValues)return bl.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}const Ml=(e,t,n)=>e&t^e&n^t&n;class zl extends xl{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=yl(this.buffer)}update(e){_l(this);const{view:t,buffer:n,blockLen:s}=this,i=(e=wl(e)).length;for(let r=0;r<i;){const a=Math.min(s-this.pos,i-r);if(a!==s)n.set(e.subarray(r,r+a),this.pos),this.pos+=a,r+=a,this.pos===s&&(this.process(t,0),this.pos=0);else{const t=yl(e);for(;s<=i-r;r+=s)this.process(t,r)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){_l(this),function(e,t){gl(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:i}=this;let{pos:r}=this;t[r++]=128,this.buffer.subarray(r).fill(0),this.padOffset>s-r&&(this.process(n,0),r=0);for(let e=r;e<s;e++)t[e]=0;!function(e,t,n,s){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,s);const i=BigInt(32),r=BigInt(4294967295),a=Number(n>>i&r),o=Number(n&r),l=s?4:0,c=s?0:4;e.setUint32(t+l,a,s),e.setUint32(t+c,o,s)}(n,s-8,BigInt(8*this.length),i),this.process(n,0);const a=yl(e),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=o/4,c=this.get();if(l>c.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<l;e++)a.setUint32(4*e,c[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:i,destroyed:r,pos:a}=this;return e.length=s,e.pos=a,e.finished=i,e.destroyed=r,s%t&&e.buffer.set(n),e}}const Bl=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Fl=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),kl=new Uint32Array(64);class Cl extends zl{constructor(){super(64,32,8,!1),this.A=0|Fl[0],this.B=0|Fl[1],this.C=0|Fl[2],this.D=0|Fl[3],this.E=0|Fl[4],this.F=0|Fl[5],this.G=0|Fl[6],this.H=0|Fl[7]}get(){const{A:e,B:t,C:n,D:s,E:i,F:r,G:a,H:o}=this;return[e,t,n,s,i,r,a,o]}set(e,t,n,s,i,r,a,o){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|s,this.E=0|i,this.F=0|r,this.G=0|a,this.H=0|o}process(e,t){for(let n=0;n<16;n++,t+=4)kl[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=kl[e-15],n=kl[e-2],s=Al(t,7)^Al(t,18)^t>>>3,i=Al(n,17)^Al(n,19)^n>>>10;kl[e]=i+kl[e-7]+s+kl[e-16]|0}let{A:n,B:s,C:i,D:r,E:a,F:o,G:l,H:c}=this;for(let e=0;e<64;e++){const t=c+(Al(a,6)^Al(a,11)^Al(a,25))+((d=a)&o^~d&l)+Bl[e]+kl[e]|0,u=(Al(n,2)^Al(n,13)^Al(n,22))+Ml(n,s,i)|0;c=l,l=o,o=a,a=r+t|0,r=i,i=s,s=n,n=t+u|0}var d;n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,r=r+this.D|0,a=a+this.E|0,o=o+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(n,s,i,r,a,o,l,c)}roundClean(){kl.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Ol=vl((()=>new Cl)),Dl=(BigInt(0),BigInt(1)),Ll=BigInt(2);function Tl(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function Sl(e){if(!Tl(e))throw new Error("Uint8Array expected")}const Nl=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function Pl(e){Sl(e);let t="";for(let n=0;n<e.length;n++)t+=Nl[e[n]];return t}function Il(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}const Yl={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Ql(e){return e>=Yl._0&&e<=Yl._9?e-Yl._0:e>=Yl._A&&e<=Yl._F?e-(Yl._A-10):e>=Yl._a&&e<=Yl._f?e-(Yl._a-10):void 0}function jl(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,n=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(n);for(let t=0,i=0;t<n;t++,i+=2){const n=Ql(e.charCodeAt(i)),r=Ql(e.charCodeAt(i+1));if(void 0===n||void 0===r){const t=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+i)}s[t]=16*n+r}return s}function Hl(e){return Il(Pl(e))}function Ul(e){return Sl(e),Il(Pl(Uint8Array.from(e).reverse()))}function Rl(e,t){return jl(e.toString(16).padStart(2*t,"0"))}function Gl(e,t){return Rl(e,t).reverse()}function Zl(e,t,n){let s;if("string"==typeof t)try{s=jl(t)}catch(n){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`)}else{if(!Tl(t))throw new Error(`${e} must be hex string or Uint8Array`);s=Uint8Array.from(t)}const i=s.length;if("number"==typeof n&&i!==n)throw new Error(`${e} expected ${n} bytes, got ${i}`);return s}function Jl(...e){let t=0;for(let n=0;n<e.length;n++){const s=e[n];Sl(s),t+=s.length}const n=new Uint8Array(t);for(let t=0,s=0;t<e.length;t++){const i=e[t];n.set(i,s),s+=i.length}return n}const Xl=e=>(Ll<<BigInt(e-1))-Dl,Wl=e=>new Uint8Array(e),Vl=e=>Uint8Array.from(e);function ql(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let s=Wl(e),i=Wl(e),r=0;const a=()=>{s.fill(1),i.fill(0),r=0},o=(...e)=>n(i,s,...e),l=(e=Wl())=>{i=o(Vl([0]),e),s=o(),0!==e.length&&(i=o(Vl([1]),e),s=o())},c=()=>{if(r++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){s=o();const t=s.slice();n.push(t),e+=s.length}return Jl(...n)};return(e,t)=>{let n;for(a(),l(e);!(n=t(c()));)l();return a(),n}}const Kl={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||Tl(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function $l(e,t,n={}){const s=(t,n,s)=>{const i=Kl[n];if("function"!=typeof i)throw new Error(`Invalid validator "${n}", expected function`);const r=e[t];if(!(s&&void 0===r||i(r,e)))throw new Error(`Invalid param ${String(t)}=${r} (${typeof r}), expected ${n}`)};for(const[e,n]of Object.entries(t))s(e,n,!1);for(const[e,t]of Object.entries(n))s(e,t,!0);return e}const ec=BigInt(0),tc=BigInt(1),nc=BigInt(2),sc=BigInt(3),ic=BigInt(4),rc=BigInt(5),ac=BigInt(8);function oc(e,t){const n=e%t;return n>=ec?n:t+n}function lc(e,t,n){if(n<=ec||t<ec)throw new Error("Expected power/modulo > 0");if(n===tc)return ec;let s=tc;for(;t>ec;)t&tc&&(s=s*e%n),e=e*e%n,t>>=tc;return s}function cc(e,t,n){let s=e;for(;t-- >ec;)s*=s,s%=n;return s}function dc(e,t){if(e===ec||t<=ec)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=oc(e,t),s=t,i=ec,r=tc,a=tc,o=ec;for(;n!==ec;){const e=s/n,t=s%n,l=i-a*e,c=r-o*e;s=n,n=t,i=a,r=o,a=l,o=c}if(s!==tc)throw new Error("invert: does not exist");return oc(i,t)}BigInt(9),BigInt(16);const uc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function fc(e,t){const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function hc(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function pc(e){const t=hc(e);return t+Math.ceil(t/2)}class mc extends xl{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,function(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");ml(e.outputLen),ml(e.blockLen)}(e);const n=wl(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?e.create().update(n).digest():n);for(let e=0;e<i.length;e++)i[e]^=54;this.iHash.update(i),this.oHash=e.create();for(let e=0;e<i.length;e++)i[e]^=106;this.oHash.update(i),i.fill(0)}update(e){return _l(this),this.iHash.update(e),this}digestInto(e){_l(this),gl(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:r,outputLen:a}=this;return e.finished=s,e.destroyed=i,e.blockLen=r,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const gc=(e,t,n)=>new mc(e,t).update(n).digest();gc.create=(e,t)=>new mc(e,t);const _c=BigInt(0),bc=BigInt(1);function yc(e){return $l(e.Fp,uc.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),$l(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...fc(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const{bytesToNumberBE:Ac,hexToBytes:wc}=e,xc={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=xc;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const n=e[1],s=e.subarray(2,n+2);if(!n||s.length!==n)throw new t("Invalid signature integer: wrong length");if(128&s[0])throw new t("Invalid signature integer: negative");if(0===s[0]&&!(128&s[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Ac(s),l:e.subarray(n+2)}},toSig(e){const{Err:t}=xc,n="string"==typeof e?wc(e):e;Sl(n);let s=n.length;if(s<2||48!=n[0])throw new t("Invalid signature tag");if(n[1]!==s-2)throw new t("Invalid signature: incorrect length");const{d:i,l:r}=xc._parseInt(n.subarray(2)),{d:a,l:o}=xc._parseInt(r);if(o.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s:a}},hexFromSig(e){const t=e=>8&Number.parseInt(e[0],16)?"00"+e:e,n=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},s=t(n(e.s)),i=t(n(e.r)),r=s.length/2,a=i.length/2,o=n(r),l=n(a);return`30${n(a+r+4)}02${l}${i}02${o}${s}`}},vc=BigInt(0),Ec=BigInt(1),Mc=(BigInt(2),BigInt(3));function zc(e){const t=function(e){const t=yc(e);return $l(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:n,n:s}=t,i=n.BYTES+1,r=2*n.BYTES+1;function a(e){return oc(e,s)}function o(e){return dc(e,s)}const{ProjectivePoint:l,normPrivateKeyToScalar:c,weierstrassEquation:d,isWithinCurveOrder:u}=function(e){const t=function(e){const t=yc(e);$l(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:s,a:i}=t;if(n){if(!s.eql(i,s.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:n}=t,s=t.toBytes||((e,t,s)=>{const i=t.toAffine();return Jl(Uint8Array.from([4]),n.toBytes(i.x),n.toBytes(i.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:n.fromBytes(t.subarray(0,n.BYTES)),y:n.fromBytes(t.subarray(n.BYTES,2*n.BYTES))}});function r(e){const{a:s,b:i}=t,r=n.sqr(e),a=n.mul(r,e);return n.add(n.add(a,n.mul(e,s)),i)}if(!n.eql(n.sqr(t.Gy),r(t.Gx)))throw new Error("bad generator point: equation left != right");function a(e){return"bigint"==typeof e&&vc<e&&e<t.n}function o(e){if(!a(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function l(e){const{allowedPrivateKeyLengths:n,nByteLength:s,wrapPrivateKey:i,n:r}=t;if(n&&"bigint"!=typeof e){if(Tl(e)&&(e=Pl(e)),"string"!=typeof e||!n.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*s,"0")}let a;try{a="bigint"==typeof e?e:Hl(Zl("private key",e,s))}catch(t){throw new Error(`private key must be ${s} bytes, hex or bigint, not ${typeof e}`)}return i&&(a=oc(a,r)),o(a),a}const c=new Map;function d(e){if(!(e instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(e,t,s){if(this.px=e,this.py=t,this.pz=s,null==e||!n.isValid(e))throw new Error("x required");if(null==t||!n.isValid(t))throw new Error("y required");if(null==s||!n.isValid(s))throw new Error("z required")}static fromAffine(e){const{x:t,y:s}=e||{};if(!e||!n.isValid(t)||!n.isValid(s))throw new Error("invalid affine point");if(e instanceof u)throw new Error("projective point not allowed");const i=e=>n.eql(e,n.ZERO);return i(t)&&i(s)?u.ZERO:new u(t,s,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(t[n]))).map(u.fromAffine)}static fromHex(e){const t=u.fromAffine(i(Zl("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return u.BASE.multiply(l(e))}_setWindowSize(e){this._WINDOW_SIZE=e,c.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:s}=this.toAffine();if(!n.isValid(e)||!n.isValid(s))throw new Error("bad point: x or y not FE");const i=n.sqr(s),a=r(e);if(!n.eql(i,a))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(n.isOdd)return!n.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){d(e);const{px:t,py:s,pz:i}=this,{px:r,py:a,pz:o}=e,l=n.eql(n.mul(t,o),n.mul(r,i)),c=n.eql(n.mul(s,o),n.mul(a,i));return l&&c}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:e,b:s}=t,i=n.mul(s,Mc),{px:r,py:a,pz:o}=this;let l=n.ZERO,c=n.ZERO,d=n.ZERO,f=n.mul(r,r),h=n.mul(a,a),p=n.mul(o,o),m=n.mul(r,a);return m=n.add(m,m),d=n.mul(r,o),d=n.add(d,d),l=n.mul(e,d),c=n.mul(i,p),c=n.add(l,c),l=n.sub(h,c),c=n.add(h,c),c=n.mul(l,c),l=n.mul(m,l),d=n.mul(i,d),p=n.mul(e,p),m=n.sub(f,p),m=n.mul(e,m),m=n.add(m,d),d=n.add(f,f),f=n.add(d,f),f=n.add(f,p),f=n.mul(f,m),c=n.add(c,f),p=n.mul(a,o),p=n.add(p,p),f=n.mul(p,m),l=n.sub(l,f),d=n.mul(p,h),d=n.add(d,d),d=n.add(d,d),new u(l,c,d)}add(e){d(e);const{px:s,py:i,pz:r}=this,{px:a,py:o,pz:l}=e;let c=n.ZERO,f=n.ZERO,h=n.ZERO;const p=t.a,m=n.mul(t.b,Mc);let g=n.mul(s,a),_=n.mul(i,o),b=n.mul(r,l),y=n.add(s,i),A=n.add(a,o);y=n.mul(y,A),A=n.add(g,_),y=n.sub(y,A),A=n.add(s,r);let w=n.add(a,l);return A=n.mul(A,w),w=n.add(g,b),A=n.sub(A,w),w=n.add(i,r),c=n.add(o,l),w=n.mul(w,c),c=n.add(_,b),w=n.sub(w,c),h=n.mul(p,A),c=n.mul(m,b),h=n.add(c,h),c=n.sub(_,h),h=n.add(_,h),f=n.mul(c,h),_=n.add(g,g),_=n.add(_,g),b=n.mul(p,b),A=n.mul(m,A),_=n.add(_,b),b=n.sub(g,b),b=n.mul(p,b),A=n.add(A,b),g=n.mul(_,A),f=n.add(f,g),g=n.mul(w,A),c=n.mul(y,c),c=n.sub(c,g),g=n.mul(y,_),h=n.mul(w,h),h=n.add(h,g),new u(c,f,h)}subtract(e){return this.add(e.negate())}is0(){return this.equals(u.ZERO)}wNAF(e){return h.wNAFCached(this,c,e,(e=>{const t=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(t[n]))).map(u.fromAffine)}))}multiplyUnsafe(e){const s=u.ZERO;if(e===vc)return s;if(o(e),e===Ec)return this;const{endo:i}=t;if(!i)return h.unsafeLadder(this,e);let{k1neg:r,k1:a,k2neg:l,k2:c}=i.splitScalar(e),d=s,f=s,p=this;for(;a>vc||c>vc;)a&Ec&&(d=d.add(p)),c&Ec&&(f=f.add(p)),p=p.double(),a>>=Ec,c>>=Ec;return r&&(d=d.negate()),l&&(f=f.negate()),f=new u(n.mul(f.px,i.beta),f.py,f.pz),d.add(f)}multiply(e){o(e);let s,i,r=e;const{endo:a}=t;if(a){const{k1neg:e,k1:t,k2neg:o,k2:l}=a.splitScalar(r);let{p:c,f:d}=this.wNAF(t),{p:f,f:p}=this.wNAF(l);c=h.constTimeNegate(e,c),f=h.constTimeNegate(o,f),f=new u(n.mul(f.px,a.beta),f.py,f.pz),s=c.add(f),i=d.add(p)}else{const{p:e,f:t}=this.wNAF(r);s=e,i=t}return u.normalizeZ([s,i])[0]}multiplyAndAddUnsafe(e,t,n){const s=u.BASE,i=(e,t)=>t!==vc&&t!==Ec&&e.equals(s)?e.multiply(t):e.multiplyUnsafe(t),r=i(this,t).add(i(e,n));return r.is0()?void 0:r}toAffine(e){const{px:t,py:s,pz:i}=this,r=this.is0();null==e&&(e=r?n.ONE:n.inv(i));const a=n.mul(t,e),o=n.mul(s,e),l=n.mul(i,e);if(r)return{x:n.ZERO,y:n.ZERO};if(!n.eql(l,n.ONE))throw new Error("invZ was invalid");return{x:a,y:o}}isTorsionFree(){const{h:e,isTorsionFree:n}=t;if(e===Ec)return!0;if(n)return n(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:n}=t;return e===Ec?this:n?n(u,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),s(u,this,e)}toHex(e=!0){return Pl(this.toRawBytes(e))}}u.BASE=new u(t.Gx,t.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const f=t.nBitLength,h=function(e,t){const n=(e,t)=>{const n=t.negate();return e?n:t},s=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:n,unsafeLadder(t,n){let s=e.ZERO,i=t;for(;n>_c;)n&bc&&(s=s.add(i)),i=i.double(),n>>=bc;return s},precomputeWindow(e,t){const{windows:n,windowSize:i}=s(t),r=[];let a=e,o=a;for(let e=0;e<n;e++){o=a,r.push(o);for(let e=1;e<i;e++)o=o.add(a),r.push(o);a=o.double()}return r},wNAF(t,i,r){const{windows:a,windowSize:o}=s(t);let l=e.ZERO,c=e.BASE;const d=BigInt(2**t-1),u=2**t,f=BigInt(t);for(let e=0;e<a;e++){const t=e*o;let s=Number(r&d);r>>=f,s>o&&(s-=u,r+=bc);const a=t,h=t+Math.abs(s)-1,p=e%2!=0,m=s<0;0===s?c=c.add(n(p,i[a])):l=l.add(n(m,i[h]))}return{p:l,f:c}},wNAFCached(e,t,n,s){const i=e._WINDOW_SIZE||1;let r=t.get(e);return r||(r=this.precomputeWindow(e,i),1!==i&&t.set(e,s(r))),this.wNAF(i,r,n)}}}(u,t.endo?Math.ceil(f/2):f);return{CURVE:t,ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:r,isWithinCurveOrder:a}}({...t,toBytes(e,t,s){const i=t.toAffine(),r=n.toBytes(i.x),a=Jl;return s?a(Uint8Array.from([t.hasEvenY()?2:3]),r):a(Uint8Array.from([4]),r,n.toBytes(i.y))},fromBytes(e){const t=e.length,s=e[0],a=e.subarray(1);if(t!==i||2!==s&&3!==s){if(t===r&&4===s)return{x:n.fromBytes(a.subarray(0,n.BYTES)),y:n.fromBytes(a.subarray(n.BYTES,2*n.BYTES))};throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${r} uncompressed bytes`)}{const e=Hl(a);if(!(vc<(o=e)&&o<n.ORDER))throw new Error("Point is not on curve");const t=d(e);let i;try{i=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~s)!=((i&Ec)===Ec)&&(i=n.neg(i)),{x:e,y:i}}var o}}),f=e=>Pl(Rl(e,t.nByteLength));function h(e){return e>s>>Ec}const p=(e,t,n)=>Hl(e.slice(t,n));class m{constructor(e,t,n){this.r=e,this.s=t,this.recovery=n,this.assertValidity()}static fromCompact(e){const n=t.nByteLength;return e=Zl("compactSignature",e,2*n),new m(p(e,0,n),p(e,n,2*n))}static fromDER(e){const{r:t,s:n}=xc.toSig(Zl("DER",e));return new m(t,n)}assertValidity(){if(!u(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!u(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new m(this.r,this.s,e)}recoverPublicKey(e){const{r:s,s:i,recovery:r}=this,c=y(Zl("msgHash",e));if(null==r||![0,1,2,3].includes(r))throw new Error("recovery id invalid");const d=2===r||3===r?s+t.n:s;if(d>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const u=1&r?"03":"02",h=l.fromHex(u+f(d)),p=o(d),m=a(-c*p),g=a(i*p),_=l.BASE.multiplyAndAddUnsafe(h,m,g);if(!_)throw new Error("point at infinify");return _.assertValidity(),_}hasHighS(){return h(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return jl(this.toDERHex())}toDERHex(){return xc.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return jl(this.toCompactHex())}toCompactHex(){return f(this.r)+f(this.s)}}const g={isValidPrivateKey(e){try{return c(e),!0}catch(e){return!1}},normPrivateKeyToScalar:c,randomPrivateKey:()=>{const e=pc(t.n);return function(e,t,n=!1){const s=e.length,i=hc(t),r=pc(t);if(s<16||s<r||s>1024)throw new Error(`expected ${r}-1024 bytes of input, got ${s}`);const a=oc(n?Hl(e):Ul(e),t-tc)+tc;return n?Gl(a,i):Rl(a,i)}(t.randomBytes(e),t.n)},precompute:(e=8,t=l.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function _(e){const t=Tl(e),n="string"==typeof e,s=(t||n)&&e.length;return t?s===i||s===r:n?s===2*i||s===2*r:e instanceof l}const b=t.bits2int||function(e){const n=Hl(e),s=8*e.length-t.nBitLength;return s>0?n>>BigInt(s):n},y=t.bits2int_modN||function(e){return a(b(e))},A=Xl(t.nBitLength);function w(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(vc<=e&&e<A))throw new Error(`bigint expected < 2^${t.nBitLength}`);return Rl(e,t.nByteLength)}const x={lowS:t.lowS,prehash:!1},v={lowS:t.lowS,prehash:!1};return l.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return l.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,n=!0){if(_(e))throw new Error("first arg must be private key");if(!_(t))throw new Error("second arg must be public key");return l.fromHex(t).multiply(c(e)).toRawBytes(n)},sign:function(e,s,i=x){const{seed:r,k2sig:d}=function(e,s,i=x){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{hash:r,randomBytes:d}=t;let{lowS:f,prehash:p,extraEntropy:g}=i;null==f&&(f=!0),e=Zl("msgHash",e),p&&(e=Zl("prehashed msgHash",r(e)));const _=y(e),A=c(s),v=[w(A),w(_)];if(null!=g&&!1!==g){const e=!0===g?d(n.BYTES):g;v.push(Zl("extraEntropy",e))}const E=Jl(...v),M=_;return{seed:E,k2sig:function(e){const t=b(e);if(!u(t))return;const n=o(t),s=l.BASE.multiply(t).toAffine(),i=a(s.x);if(i===vc)return;const r=a(n*a(M+i*A));if(r===vc)return;let c=(s.x===i?0:2)|Number(s.y&Ec),d=r;return f&&h(r)&&(d=function(e){return h(e)?a(-e):e}(r),c^=1),new m(i,d,c)}}}(e,s,i),f=t;return ql(f.hash.outputLen,f.nByteLength,f.hmac)(r,d)},verify:function(e,n,s,i=v){const r=e;if(n=Zl("msgHash",n),s=Zl("publicKey",s),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:c,prehash:d}=i;let u,f;try{if("string"==typeof r||Tl(r))try{u=m.fromDER(r)}catch(e){if(!(e instanceof xc.Err))throw e;u=m.fromCompact(r)}else{if("object"!=typeof r||"bigint"!=typeof r.r||"bigint"!=typeof r.s)throw new Error("PARSE");{const{r:e,s:t}=r;u=new m(e,t)}}f=l.fromHex(s)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&u.hasHighS())return!1;d&&(n=t.hash(n));const{r:h,s:p}=u,g=y(n),_=o(p),b=a(g*_),A=a(h*_),w=l.BASE.multiplyAndAddUnsafe(f,b,A)?.toAffine();return!!w&&a(w.x)===h},ProjectivePoint:l,Signature:m,utils:g}}function Bc(e){return{hash:e,hmac:(t,...n)=>gc(e,t,function(...e){let t=0;for(let n=0;n<e.length;n++){const s=e[n];gl(s),t+=s.length}const n=new Uint8Array(t);for(let t=0,s=0;t<e.length;t++){const i=e[t];n.set(i,s),s+=i.length}return n}(...n)),randomBytes:El}}BigInt(4);const Fc=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),kc=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Cc=BigInt(1),Oc=BigInt(2),Dc=(e,t)=>(e+t/Oc)/t;const Lc=function(e,t,n=!1,s={}){if(e<=ec)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:i,nByteLength:r}=fc(e,t);if(r>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=function(e){if(e%ic===sc){const t=(e+tc)/ic;return function(e,n){const s=e.pow(n,t);if(!e.eql(e.sqr(s),n))throw new Error("Cannot find square root");return s}}if(e%ac===rc){const t=(e-rc)/ac;return function(e,n){const s=e.mul(n,nc),i=e.pow(s,t),r=e.mul(n,i),a=e.mul(e.mul(r,nc),i),o=e.mul(r,e.sub(a,e.ONE));if(!e.eql(e.sqr(o),n))throw new Error("Cannot find square root");return o}}return function(e){const t=(e-tc)/nc;let n,s,i;for(n=e-tc,s=0;n%nc===ec;n/=nc,s++);for(i=nc;i<e&&lc(i,t,e)!==e-tc;i++);if(1===s){const t=(e+tc)/ic;return function(e,n){const s=e.pow(n,t);if(!e.eql(e.sqr(s),n))throw new Error("Cannot find square root");return s}}const r=(n+tc)/nc;return function(e,a){if(e.pow(a,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let o=s,l=e.pow(e.mul(e.ONE,i),n),c=e.pow(a,r),d=e.pow(a,n);for(;!e.eql(d,e.ONE);){if(e.eql(d,e.ZERO))return e.ZERO;let t=1;for(let n=e.sqr(d);t<o&&!e.eql(n,e.ONE);t++)n=e.sqr(n);const n=e.pow(l,tc<<BigInt(o-t-1));l=e.sqr(n),c=e.mul(c,n),d=e.mul(d,l),o=t}return c}}(e)}(e),o=Object.freeze({ORDER:e,BITS:i,BYTES:r,MASK:Xl(i),ZERO:ec,ONE:tc,create:t=>oc(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return ec<=t&&t<e},is0:e=>e===ec,isOdd:e=>(e&tc)===tc,neg:t=>oc(-t,e),eql:(e,t)=>e===t,sqr:t=>oc(t*t,e),add:(t,n)=>oc(t+n,e),sub:(t,n)=>oc(t-n,e),mul:(t,n)=>oc(t*n,e),pow:(e,t)=>function(e,t,n){if(n<ec)throw new Error("Expected power > 0");if(n===ec)return e.ONE;if(n===tc)return t;let s=e.ONE,i=t;for(;n>ec;)n&tc&&(s=e.mul(s,i)),i=e.sqr(i),n>>=tc;return s}(o,e,t),div:(t,n)=>oc(t*dc(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>dc(t,e),sqrt:s.sqrt||(e=>a(o,e)),invertBatch:e=>function(e,t){const n=new Array(t.length),s=t.reduce(((t,s,i)=>e.is0(s)?t:(n[i]=t,e.mul(t,s))),e.ONE),i=e.inv(s);return t.reduceRight(((t,s,i)=>e.is0(s)?t:(n[i]=e.mul(t,n[i]),e.mul(t,s))),i),n}(o,e),cmov:(e,t,n)=>n?t:e,toBytes:e=>n?Gl(e,r):Rl(e,r),fromBytes:e=>{if(e.length!==r)throw new Error(`Fp.fromBytes: expected ${r}, got ${e.length}`);return n?Ul(e):Hl(e)}});return Object.freeze(o)}(Fc,void 0,void 0,{sqrt:function(e){const t=Fc,n=BigInt(3),s=BigInt(6),i=BigInt(11),r=BigInt(22),a=BigInt(23),o=BigInt(44),l=BigInt(88),c=e*e*e%t,d=c*c*e%t,u=cc(d,n,t)*d%t,f=cc(u,n,t)*d%t,h=cc(f,Oc,t)*c%t,p=cc(h,i,t)*h%t,m=cc(p,r,t)*p%t,g=cc(m,o,t)*m%t,_=cc(g,l,t)*g%t,b=cc(_,o,t)*m%t,y=cc(b,n,t)*d%t,A=cc(y,a,t)*p%t,w=cc(A,s,t)*c%t,x=cc(w,Oc,t);if(!Lc.eql(Lc.sqr(x),e))throw new Error("Cannot find square root");return x}}),Tc=function(e,t){const n=t=>zc({...e,...Bc(t)});return Object.freeze({...n(t),create:n})}({a:BigInt(0),b:BigInt(7),Fp:Lc,n:kc,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=kc,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),s=-Cc*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),r=n,a=BigInt("0x100000000000000000000000000000000"),o=Dc(r*e,t),l=Dc(-s*e,t);let c=oc(e-o*n-l*i,t),d=oc(-o*s-l*r,t);const u=c>a,f=d>a;if(u&&(c=t-c),f&&(d=t-d),c>a||d>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:u,k1:c,k2neg:f,k2:d}}}},Ol);BigInt(0),Tc.ProjectivePoint;var Sc=i(8891).Buffer;class Nc{constructor(e){if(this.buffer=e,e.length!==Nc.SIZE_IN_BYTES)throw new Error(`Expect buffer size to be ${Nc.SIZE_IN_BYTES}. Got ${e.length}.`)}static fromString(e){if(!Nc.isAddress(e))throw new Error(`Invalid address string: ${e}`);return new Nc(Sc.from(e.replace(/^0x/i,""),"hex"))}static random(){return new Nc(ot(20))}static isAddress(e){return!!/^(0x)?[0-9a-f]{40}$/i.test(e)&&(!(!/^(0x|0X)?[0-9a-f]{40}$/.test(e)&&!/^(0x|0X)?[0-9A-F]{40}$/.test(e))||Nc.checkAddressChecksum(e))}isZero(){return this.equals(Nc.ZERO)}static checkAddressChecksum(e){const t=al((e=e.replace(/^0x/i,"")).toLowerCase());for(let n=0;n<40;n++)if(parseInt(t[n],16)>7&&e[n].toUpperCase()!==e[n]||parseInt(t[n],16)<=7&&e[n].toLowerCase()!==e[n])return!1;return!0}static toChecksumAddress(e){if(!Nc.isAddress(e))throw new Error("Invalid address string.");const t=al(e=e.toLowerCase().replace(/^0x/i,""));let n="0x";for(let s=0;s<e.length;s++)parseInt(t[s],16)>7?n+=e[s].toUpperCase():n+=e[s];return n}equals(e){return this.buffer.equals(e.buffer)}toString(){return Ds(this.buffer)}[f.inspect.custom](){return`EthAddress<${this.toString()}>`}toChecksumString(){return Nc.toChecksumAddress(this.buffer.toString("hex"))}toBuffer(){return this.buffer}toBuffer32(){const e=Sc.alloc(32);return this.buffer.copy(e,12),e}toField(){return si.fromBuffer(this.toBuffer32())}static fromField(e){return new Nc(e.toBuffer().slice(-Nc.SIZE_IN_BYTES))}static fromFields(e){const t=vi.asReader(e);return Nc.fromField(t.readField())}static fromBuffer(e){const t=Js.asReader(e);return new Nc(t.readBytes(Nc.SIZE_IN_BYTES))}toJSON(){return this.toString()}static get schema(){return Ys(Nc,Nc.isAddress)}}Nc.SIZE_IN_BYTES=20,Nc.ZERO=new Nc(Sc.alloc(Nc.SIZE_IN_BYTES)),Xs.register("EthAddress",Nc);class Pc{constructor(e,t,n,s=!1){this.r=e,this.s=t,this.v=n,this.isEmpty=s}static fromBuffer(e){const t=Js.asReader(e),n=t.readObject(il),s=t.readObject(il),i=t.readNumber(),r=n.isZero()&&s.isZero();return new Pc(n,s,i,r)}static isValidString(e){return/^0x[0-9a-f]{129,}$/i.test(e)}static fromString(e){const t=Os(e),n=Js.asReader(t),s=n.readObject(il),i=n.readObject(il),r=parseInt(e.slice(130),16),a=s.isZero()&&i.isZero();return new Pc(s,i,r,a)}static random(){return new Pc(il.random(),il.random(),Math.floor(2*Math.random()),!1)}static empty(){return new Pc(il.ZERO,il.ZERO,0,!0)}equals(e){return this.r.equals(e.r)&&this.s.equals(e.s)&&this.v===e.v&&this.isEmpty===e.isEmpty}toBuffer(){const e=_i([this.r,this.s,this.v]);return this.size=e.length,e}getSize(){return this.size||(this.size=this.toBuffer().length),this.size}toString(){return`0x${this.r.buffer.toString("hex")}${this.s.buffer.toString("hex")}${this.v.toString(16)}`}toViemSignature(){return{r:this.r.toString(),s:this.s.toString(),v:this.v,isEmpty:this.isEmpty}}toJSON(){return this.toString()}static get schema(){return zs.string().refine(Fs,"No hex prefix").refine(Pc.isValidString,"Not a valid Ethereum signature").transform(Pc.fromString)}}var Ic=i(8891).Buffer;function Yc(e,t){const n=function(e,t){const{r:n,s,v:i}=t,r=function(e){if(0===e||1===e)return e;if(27===e)return 0;if(28===e)return 1;throw new Error("Invalid yParityOrV value")}(i),a=new Tc.Signature(n.toBigInt(),s.toBigInt()).addRecoveryBit(r).recoverPublicKey(e.buffer).toHex(!1);return Ic.from(a,"hex")}(e,t);return function(e){const t=rl(e.subarray(1));return new Nc(t.subarray(12))}(n)}var Qc=i(8891).Buffer;class jc{constructor(e){if(this.value=e,e>2**(8*jc.SIZE)-1)throw new Error(`Selector must fit in ${jc.SIZE} bytes (got value ${e}).`)}isEmpty(){return 0===this.value}toBuffer(e=jc.SIZE){return m(BigInt(this.value),e)}toString(){return Ds(this.toBuffer())}[f.inspect.custom](){return`Selector<${this.toString()}>`}equals(e){return this.value===e.value}toField(){return new si(BigInt(this.value))}}jc.SIZE=4;var Hc=i(8891).Buffer;class Uc extends jc{static fromBuffer(e){const t=Js.asReader(e),n=Number(p(t.readBytes(jc.SIZE)));return new Uc(n)}static fromField(e){return new Uc(Number(e.toBigInt()))}static async fromSignature(e){if(/\s/.test(e))throw new Error("Signature cannot contain whitespace");const t=(await xi(Hc.from(e))).toBuffer().slice(-jc.SIZE);return Uc.fromBuffer(t)}static fromString(e){const t=g(e);if(t.length!==jc.SIZE)throw new Error(`Invalid EventSelector length ${t.length} (expected ${jc.SIZE}).`);return Uc.fromBuffer(t)}static empty(){return new Uc(0)}static random(){return Uc.fromBuffer(ot(jc.SIZE))}toJSON(){return this.toString()}static get schema(){return Ys(Uc)}}var Rc=i(8891).Buffer;class Gc{constructor(e){if("length"in e&&32!==e.length)throw new Error(`Invalid AztecAddress length ${e.length}.`);this.xCoord=new si(e)}[f.inspect.custom](){return`AztecAddress<${this.toString()}>`}static isAddress(e){return/^(0x)?[a-fA-F0-9]{64}$/.test(e)}static zero(){return Gc.ZERO}static fromField(e){return new Gc(e)}static fromBuffer(e){return new Gc($s(e,si))}static fromFields(e){const t=vi.asReader(e);return new Gc(t.readField())}static fromBigInt(e){return new Gc(new si(e))}static fromNumber(e){return new Gc(new si(e))}static fromString(e){return new Gc(Os(e))}static async random(){for(;;){const e=new Gc(si.random());if(await e.isValid())return e}}get size(){return this.xCoord.size}equals(e){return this.xCoord.equals(e.xCoord)}isZero(){return this.xCoord.isZero()}async isValid(){return null!==await Ei.YFromX(this.xCoord)}toAddressPoint(){return Ei.fromXAndSign(this.xCoord,!0)}toBuffer(){return this.xCoord.toBuffer()}toBigInt(){return this.xCoord.toBigInt()}toField(){return this.xCoord}toString(){return this.xCoord.toString()}toJSON(){return this.toString()}static get schema(){return Ys(Gc,Gc.isAddress)}}Gc.SIZE_IN_BYTES=si.SIZE_IN_BYTES,Gc.ZERO=new Gc(Rc.alloc(32,0)),Xs.register("AztecAddress",Gc);class Zc{constructor(e){if("bigint"!=typeof e&&(e=BigInt(e)),e<0n||e>=2n**128n)throw new Error(`Value ${e} is not within 128 bits and hence cannot be converted to U128.`);this.value=e}static fromU64sLE(e,t){if(e<0n||e>=2n**64n)throw new Error(`Lower limb ${e} is not within valid range (0 to 2^64-1)`);if(t<0n||t>=2n**64n)throw new Error(`Higher limb ${t} is not within valid range (0 to 2^64-1)`);return new Zc(t<<64n|e)}get lo(){return 0xffffffffffffffffn&this.value}get hi(){return this.value>>64n}toInteger(){return this.value}toFields(){return[new si(this.lo),new si(this.hi)]}static fromFields(e){if(2!==e.length)throw new Error(`Expected 2 fields for U128, got ${e.length}`);return Zc.fromU64sLE(e[0].toBigInt(),e[1].toBigInt())}static getLimbNames(){return["lo","hi"]}}var Jc=i(8891).Buffer;function Xc(e){return"struct"===e.kind&&e.path.endsWith("address::AztecAddress")}function Wc(e){return"struct"===e.kind&&e.path.endsWith("U128")}class Vc{constructor(e,t){this.types=e,this.flattened=t}decodeNext(e){switch(e.kind){case"field":return this.getNextField().toBigInt();case"integer":{const t=this.getNextField();return"signed"===e.sign?function(e,t){const n=Jc.from(e),s=void 0!==t?n.subarray(-t/8):n;if(128&s.subarray(0,1).readUInt8()){for(let e=0;e<s.length;e++)s[e]=~s[e];return-(BigInt(`0x${s.toString("hex")}`)+1n)}return BigInt(`0x${s.toString("hex")}`)}(t.toBuffer(),e.width):t.toBigInt()}case"boolean":return!this.getNextField().isZero();case"array":{const t=[];for(let n=0;n<e.length;n+=1)t.push(this.decodeNext(e.type));return t}case"struct":{if(Wc(e)){const e=[new si(this.decodeNext({kind:"field"})),new si(this.decodeNext({kind:"field"}))];return Zc.fromFields(e).toInteger()}const t={};if(Xc(e))return new Gc(this.getNextField().toBuffer());for(const n of e.fields)t[n.name]=this.decodeNext(n.type);return t}case"string":{const t=[];for(let n=0;n<e.length;n+=1)t.push(this.getNextField().toBigInt());return t}case"tuple":{const t=[];for(const n of e.fields)t.push(this.decodeNext(n));return t}default:throw new Error(`Unsupported type: ${e}`)}}getNextField(){const e=this.flattened.shift();if(!e)throw new Error("Not enough return values");return e}decode(){if(this.types.length>1)throw new Error("Multiple types not supported");return 0===this.types.length?[]:this.decodeNext(this.types[0])}}function qc(e,t){return new Vc(e,t.slice()).decode()}class Kc{constructor(e,t,n=!1){this.name=e,this.parameters=t,this.includeNames=n,this.separator=n?", ":","}getParameterType(e){switch(e.kind){case"field":return"Field";case"integer":if("signed"===e.sign)throw new Error("Unsupported type: signed integer");return`u${e.width}`;case"boolean":return"bool";case"array":return`[${this.getParameterType(e.type)};${e.length}]`;case"string":return`str<${e.length}>`;case"struct":return`(${e.fields.map((e=>`${this.decodeParameter(e)}`)).join(this.separator)})`;default:throw new Error(`Unsupported type: ${e}`)}}decodeParameter(e){const t=this.getParameterType(e.type);return this.includeNames?`${e.name}: ${t}`:t}decode(){return`${this.name}(${this.parameters.map((e=>this.decodeParameter(e))).join(this.separator)})`}}var $c=i(8891).Buffer;class ed extends jc{static fromBuffer(e){const t=Js.asReader(e),n=Number(p(t.readBytes(jc.SIZE)));return new ed(n)}static fromField(e){return new ed(Number(e.toBigInt()))}static fromFields(e){const t=vi.asReader(e);return ed.fromField(t.readField())}static async fromSignature(e){if(/\s/.test(e))throw new Error("Signature cannot contain whitespace");const t=(await xi($c.from(e))).toBuffer().slice(-jc.SIZE);return ed.fromBuffer(t)}static fromString(e){const t=g(e);if(t.length!==jc.SIZE)throw new Error(`Invalid FunctionSelector length ${t.length} (expected ${jc.SIZE}).`);return ed.fromBuffer(t)}static empty(){return new ed(0)}static async fromNameAndParameters(e,t){const{name:n,parameters:s}="string"==typeof e?{name:e,parameters:t}:e,i=function(e,t){return new Kc(e,t).decode()}(n,s);return await this.fromSignature(i)}static random(){return ed.fromBuffer(ot(jc.SIZE))}toJSON(){return this.toString()}static get schema(){return Ys(ed)}}Xs.register("FunctionSelector",ed);var td=i(8891).Buffer;class nd extends jc{static fromBuffer(e){const t=Js.asReader(e),n=Number(p(t.readBytes(jc.SIZE)));if(n>=128)throw new Error(`Invalid note selector: ${n}`);return new nd(n)}static fromString(e){const t=e.replace(/^0x/i,"").slice(-8),n=td.from(t,"hex");return nd.fromBuffer(n)}static fromField(e){return new nd(Number(e.toBigInt()))}static empty(){return new nd(0)}static random(){const e=lt(128);return nd.fromField(new si(e))}toJSON(){return this.toString()}static get schema(){return Ys(nd)}}Xs.register("NoteSelector",nd);var sd=i(8891).Buffer;const id={EthAddress:Nc.schema,AztecAddress:Gc.schema,FunctionSelector:ed.schema,NoteSelector:nd.schema,EventSelector:Uc.schema,Fr:si.schema,Fq:ii.schema,Point:Ei.schema,BigInt:zs.union([zs.bigint(),zs.number(),zs.string()]).pipe(zs.coerce.bigint()),Integer:zs.union([zs.bigint(),zs.number(),zs.string()]).pipe(zs.coerce.number().int()),UInt32:zs.union([zs.bigint(),zs.number(),zs.string()]).pipe(zs.coerce.number().int().min(0).max(2**32-1)),Buffer32:zs.string().refine(Cs,"Not a valid hex string").transform(il.fromString),Buffer:zs.union([Ns,zs.object({type:zs.literal("Buffer"),data:zs.array(zs.number().int().min(0).max(255))}).transform((({data:e})=>sd.from(e)))]),BufferHex:zs.string().refine(Cs,"Not a valid hex string").transform(ks).transform((e=>sd.from(e,"hex"))),HexString:Ts},rd=zs.union([id.BigInt,zs.boolean(),id.AztecAddress,zs.array(zs.lazy((()=>rd))),zs.record(zs.lazy((()=>rd)))]);var ad=i(8891).Buffer;const od=Pe("aztec:foundation:abi"),ld=zs.discriminatedUnion("kind",[zs.object({kind:zs.literal("boolean"),value:zs.boolean()}),zs.object({kind:zs.literal("string"),value:zs.string()}),zs.object({kind:zs.literal("array"),value:zs.array(zs.lazy((()=>ld)))}),zs.object({kind:zs.literal("tuple"),fields:zs.array(zs.lazy((()=>ld)))}),zs.object({kind:zs.literal("integer"),value:zs.string(),sign:zs.boolean()}),zs.object({kind:zs.literal("struct"),fields:zs.array(zs.object({name:zs.string(),value:zs.lazy((()=>ld))}))})]),cd=["public","private","databus"],dd=zs.discriminatedUnion("kind",[zs.object({kind:zs.literal("field")}),zs.object({kind:zs.literal("boolean")}),zs.object({kind:zs.literal("integer"),sign:zs.enum(["unsigned","signed"]),width:zs.number()}),zs.object({kind:zs.literal("array"),length:zs.number(),type:zs.lazy((()=>dd))}),zs.object({kind:zs.literal("string"),length:zs.number()}),zs.object({kind:zs.literal("struct"),fields:zs.array(zs.lazy((()=>ud))),path:zs.string()}),zs.object({kind:zs.literal("tuple"),fields:zs.array(zs.lazy((()=>dd)))})]),ud=zs.object({name:zs.string(),type:dd}),fd=(ud.and(zs.object({visibility:zs.enum(cd)})),zs.union([zs.object({error_kind:zs.literal("string"),string:zs.string()}),zs.object({error_kind:zs.literal("fmtstring"),length:zs.number(),item_types:zs.array(dd)}),zs.object({error_kind:zs.literal("custom")}).and(dd)]));var hd,pd;(pd=hd||(hd={})).PRIVATE="private",pd.PUBLIC="public",pd.UNCONSTRAINED="unconstrained";const md=zs.object({name:zs.string(),functionType:zs.nativeEnum(hd),isInternal:zs.boolean(),isStatic:zs.boolean(),isInitializer:zs.boolean(),parameters:zs.array(zs.object({name:zs.string(),type:dd,visibility:zs.enum(cd)})),returnTypes:zs.array(dd),errorTypes:zs.record(fd)}),gd=zs.object({debugSymbols:zs.object({locations:zs.record(zs.array(zs.object({span:zs.object({start:zs.number(),end:zs.number()}),file:zs.number()}))),brillig_locations:zs.record(zs.record(zs.array(zs.object({span:zs.object({start:zs.number(),end:zs.number()}),file:zs.number()}))))}),files:zs.record(zs.object({source:zs.string(),path:zs.string()}))}),_d=md.and(zs.object({bytecode:id.Buffer,verificationKey:zs.string().optional(),debugSymbols:zs.string(),debug:gd.optional()})),bd=zs.object({name:zs.string(),index:zs.number(),nullable:zs.boolean()}),yd=zs.object({id:id.NoteSelector,typ:zs.string(),fields:zs.array(bd)}),Ad=zs.object({name:zs.string(),aztecNrVersion:zs.string().optional(),functions:zs.array(_d),outputs:zs.object({structs:zs.record(zs.array(dd)).transform((e=>{for(const[t,n]of Object.entries(e))"events"!==t&&"functions"!==t||(e[t]=n.sort(((e,t)=>e.path>t.path?-1:1)));return e})),globals:zs.record(zs.array(ld))}),storageLayout:zs.record(zs.object({slot:id.Fr})),notes:zs.record(yd),fileMap:zs.record(zs.coerce.number(),zs.object({source:zs.string(),path:zs.string()}))});function wd(e){const t=e.functions.filter((e=>e.isInitializer));return t.length>1?t.find((e=>"constructor"===e.name))??t.find((e=>"initializer"===e.name))??t.find((e=>0===e.parameters?.length))??t.find((e=>e.functionType===hd.PRIVATE))??t[0]:t[0]}var xd=i(4247),vd=i(8891).Buffer;function Ed(e,t){const n=[new si(e.length),...xd(e,si.SIZE_IN_BYTES-1).map((e=>{const t=vd.alloc(si.SIZE_IN_BYTES);return vd.from(e).copy(t,1),si.fromBuffer(t)}))];if(n.length>t)throw new Error(`Input buffer exceeds maximum size: got ${n.length} but max is ${t}`);return[...n,...Array(t-n.length).fill(si.ZERO)]}var Md=i(8891).Buffer;class zd{constructor(e,t){this.abi=e,this.args=t,this.flattened=[]}static typeSize(e){switch(e.kind){case"field":case"boolean":case"integer":return 1;case"string":return e.length;case"array":return e.length*zd.typeSize(e.type);case"struct":return e.fields.reduce(((e,t)=>e+zd.typeSize(t.type)),0);case"tuple":return e.fields.reduce(((e,t)=>e+zd.typeSize(t)),0);default:throw new Error(`Unhandled abi type: ${e}`)}}encodeArgument(e,t,n){if(void 0===t||null==t)throw new Error(`Undefined argument ${n??"unnamed"} of type ${e.kind}`);switch(e.kind){case"field":if("number"==typeof t)this.flattened.push(new si(BigInt(t)));else if("bigint"==typeof t)this.flattened.push(new si(t));else if("string"==typeof t)this.flattened.push(si.fromString(t));else if("boolean"==typeof t)this.flattened.push(new si(t?1n:0n));else{if("object"!=typeof t)throw new Error(`Invalid argument "${t}" of type ${e.kind}`);if(Md.isBuffer(t))this.flattened.push(si.fromBuffer(t));else if("function"==typeof t.toField)this.flattened.push(t.toField());else{if("string"!=typeof t.value)throw new Error(`Argument for ${n} cannot be serialized to a field`);this.flattened.push(si.fromHexString(t.value))}}break;case"boolean":this.flattened.push(new si(t?1n:0n));break;case"array":for(let s=0;s<e.length;s+=1)this.encodeArgument(e.type,t[s],`${n}[${s}]`);break;case"string":for(let n=0;n<e.length;n+=1){const e=n<t.length?BigInt(t.charCodeAt(n)):0n;this.flattened.push(new si(e))}break;case"struct":{if(void 0!==t.encodeToNoir){this.flattened.push(...t.encodeToNoir());break}const s=function(e){return function(e){return"struct"===e.kind&&e.path.endsWith("address::EthAddress")}(e)||Xc(e)}(e);if(s&&void 0===t.address&&void 0===t.inner){this.encodeArgument({kind:"field"},t,`${n}.inner`);break}if(s&&void 0!==t.address){this.encodeArgument({kind:"field"},t.address,`${n}.address`);break}if(function(e){return"struct"===e.kind&&e.path.endsWith("types::abis::function_selector::FunctionSelector")}(e)){this.encodeArgument({kind:"integer",sign:"unsigned",width:32},t.value??t,`${n}.inner`);break}if(Wc(e)){const e=new Zc(t).toFields(),s=Zc.getLimbNames();this.encodeArgument({kind:"field"},e[0],`${n}.${s[0]}`),this.encodeArgument({kind:"field"},e[1],`${n}.${s[1]}`);break}if(function(e){return"struct"===e.kind&&1===e.fields.length&&"inner"===e.fields[0].name&&"field"===e.fields[0].type.kind}(e)){this.encodeArgument({kind:"field"},t.inner??t,`${n}.inner`);break}for(const s of e.fields)this.encodeArgument(s.type,t[s.name],`${n}.${s.name}`);break}case"integer":if("string"==typeof t){const e=BigInt(t);this.flattened.push(new si(e))}else this.flattened.push(new si(t));break;default:throw new Error(`Unsupported type: ${e}`)}}encode(){for(let e=0;e<this.abi.parameters.length;e+=1){const t=this.abi.parameters[e];this.encodeArgument(t.type,this.args[e],t.name)}return this.flattened}}function Bd(e,t){return new zd(e,t).encode()}var Fd=i(8891).Buffer;class kd{constructor(e,t){this.height=e,this.nodes=t;const n=2**(e+1)-1;if(t.length!==n)throw new Error(`Invalid node count for Merkle tree: got ${t.length} but expected ${n}`)}get root(){return this.nodes[this.nodes.length-1]}get leaves(){return this.nodes.slice(0,2**this.height)}getSiblingPath(e){if(Fd.isBuffer(e))return this.getSiblingPath(this.getIndex(e));const t=e;if(t<0||t>=2**this.height)throw new Error(`Invalid leaf index: got ${t} but leaves count is ${2**this.height}`);const n=this.nodes;let s=Math.ceil(n.length/2),i=0,r=t;const a=[];for(;s>1;){const e=1&r;a.push(n[i+r+(e?-1:1)]),i+=s,s>>=1,r>>=1}return a}getIndex(e){return this.leaves.findIndex((t=>t.equals(e)))}drawTree(e=8){const t=[],n=this.nodes,s=Math.ceil(n.length/2);let i=1,r=s,a=0;for(;r>0;)t.push(n.slice(a,a+r).map((t=>t.toString("hex").slice(0,e)+" ".repeat((i-1)*(e+1))))),a+=r,i<<=1,r>>=1;return t.reverse().map((e=>e.join(" "))).join("\n")}}var Cd=i(8891).Buffer;class Od{constructor(e,t,n){this.height=e,this.zeroHashes=t,this.hasher=n,this.hasher=n}static async create(e,t=Cd.alloc(32),n=(async(e,t)=>(await pl([e,t])).toBuffer())){const s=[t];for(let t=0;t<e;t++)s.push(await n(s[t],s[t]));return new Od(e,s,n)}async computeTree(e=[]){0===e.length&&(e=new Array(2**this.height).fill(this.zeroHashes[0]));let t=e.slice();for(let n=0;n<this.height;++n){const s=2**(this.height-n),i=[];for(let t=0;t<e.length/2;++t){const s=e[2*t],r=e[2*t+1]||this.zeroHashes[n];i[t]=await this.hasher(s,r)}t=t.concat(new Array(s-e.length).fill(this.zeroHashes[n]),i),e=i}return new kd(this.height,t)}async computeTreeRoot(e=[]){if(0===e.length)return this.zeroHashes[this.zeroHashes.length-1];e=e.slice();for(let t=0;t<this.height;++t){let n=0;for(;n<e.length/2;++n){const s=e[2*n],i=e[2*n+1]||this.zeroHashes[t];e[n]=await this.hasher(s,i)}e=e.slice(0,n)}return e[0]}}var Dd=i(8891).Buffer;const Ld=1,Td=(Sd=cl,Nd=si,e=>ei(Sd(e),Nd));var Sd,Nd;async function Pd(e){if("privateFunctionRoot"in e&&"unconstrainedFunctionRoot"in e&&"metadataHash"in e){const{privateFunctionRoot:t,unconstrainedFunctionRoot:n,metadataHash:s}=e,i=[t,n,s].map((e=>e.toBuffer()));return Td(Dd.concat([di(Ld),...i]))}const t=await async function(e){const t=await Id(e,hd.PRIVATE),n=await Id(e,hd.UNCONSTRAINED),s=function(e){return Td(Dd.from(JSON.stringify({name:e.name,outputs:e.outputs}),"utf-8"))}(e);return{privateFunctionRoot:t,unconstrainedFunctionRoot:n,metadataHash:s}}(e),n=Pd(t);return Pe("circuits:artifact_hash").trace("Computed artifact hash",{artifactHash:n,...t}),n}async function Id(e,t){const n=await async function(e,t){const n=await async function(e,t){const n=await Promise.all(e.functions.filter((e=>e.functionType===t)).map((async e=>({...e,selector:await ed.fromNameAndParameters(e.name,e.parameters)}))));return n.sort(((e,t)=>e.selector.value-t.selector.value)),await Promise.all(n.map(Yd))}(e,t);if(0===n.length)return;const s=Math.ceil(Math.log2(n.length));return(await Od.create(s,Dd.alloc(32),((e,t)=>Promise.resolve(Td(Dd.concat([e,t])).toBuffer())))).computeTree(n.map((e=>e.toBuffer())))}(e,t);return n?.root?si.fromBuffer(n.root):si.ZERO}async function Yd(e){const t="selector"in e?e.selector:await ed.fromNameAndParameters(e),n=Td(e.bytecode).toBuffer(),s="functionMetadataHash"in e?e.functionMetadataHash:function(e){return Td(Dd.from(JSON.stringify(e.returnTypes),"utf8"))}(e);return Td(Dd.concat([di(Ld),t.toBuffer(),s.toBuffer(),n]))}function Qd(e){return 0===e.length?Promise.resolve(si.ZERO):wi(e,Ri.FUNCTION_ARGS)}i(8891).Buffer;var jd=i(8891).Buffer;class Hd{generator(){return Hd.generator}async mul(e,t){const n=await c.initSingleton(),[s]=n.getWasm().callWasmExport("ecc_grumpkin__mul",[e.toBuffer(),t.toBuffer()],[64]);return Ei.fromBuffer(jd.from(s))}async add(e,t){const n=await c.initSingleton(),[s]=n.getWasm().callWasmExport("ecc_grumpkin__add",[e.toBuffer(),t.toBuffer()],[64]);return Ei.fromBuffer(jd.from(s))}async batchMul(e,t){const n=jd.concat(e.map((e=>e.toBuffer()))),s=e.length*Ei.SIZE_IN_BYTES,i=await c.initSingleton(),[r]=i.getWasm().callWasmExport("ecc_grumpkin__batch_mul",[n,t.toBuffer(),e.length],[s]),a=[];for(let e=0;e<s;e+=64)a.push(Ei.fromBuffer(jd.from(r.subarray(e,e+64))));return a}async getRandomFr(){const e=await c.initSingleton(),[t]=e.getWasm().callWasmExport("ecc_grumpkin__get_random_scalar_mod_circuit_modulus",[],[32]);return si.fromBuffer(jd.from(t))}async reduce512BufferToFr(e){const t=await c.initSingleton(),[n]=t.getWasm().callWasmExport("ecc_grumpkin__reduce512_buffer_mod_circuit_modulus",[e],[32]);return si.fromBuffer(jd.from(n))}}Hd.generator=Ei.fromBuffer(jd.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,207,19,94,117,6,164,93,99,45,39,13,69,241,24,18,148,131,63,196,141,130,63,39,44]));var Ud=i(8891).Buffer;class Rd{constructor(e,t,n,s){this.masterNullifierPublicKey=e,this.masterIncomingViewingPublicKey=t,this.masterOutgoingViewingPublicKey=n,this.masterTaggingPublicKey=s}static get schema(){return zs.object({masterNullifierPublicKey:id.Point,masterIncomingViewingPublicKey:id.Point,masterOutgoingViewingPublicKey:id.Point,masterTaggingPublicKey:id.Point}).transform(Rd.from)}static from(e){return new Rd(e.masterNullifierPublicKey,e.masterIncomingViewingPublicKey,e.masterOutgoingViewingPublicKey,e.masterTaggingPublicKey)}hash(){return this.isEmpty()?si.ZERO:wi([this.masterNullifierPublicKey,this.masterIncomingViewingPublicKey,this.masterOutgoingViewingPublicKey,this.masterTaggingPublicKey],Ri.PUBLIC_KEYS_HASH)}isEmpty(){return this.masterNullifierPublicKey.isZero()&&this.masterIncomingViewingPublicKey.isZero()&&this.masterOutgoingViewingPublicKey.isZero()&&this.masterTaggingPublicKey.isZero()}static default(){return new Rd(new Ei(new si(582240093077765400562621227108555700500271598878376310175765873770292988861n),new si(10422444662424639723529825114205836958711284159673861467999592572974769103684n),!1),new Ei(new si(339708709767762472786445938838804872781183545349360029270386718856175781484n),new si(12719619215050539905199178334954929730355853796706924300730604757520758976849n),!1),new Ei(new si(12212787719617305570587928860288475454328008955283046946846066128763901043335n),new si(3646747884782549389807830220601404629716007431341772952958971658285958854707n),!1),new Ei(new si(728059161893070741164607238299536939695876538801885465230641192969135857403n),new si(14575718736702206050102425029229426215631664471161015518982549597389390371695n),!1))}static async random(){return new Rd(await Ei.random(),await Ei.random(),await Ei.random(),await Ei.random())}equals(e){return this.masterNullifierPublicKey.equals(e.masterNullifierPublicKey)&&this.masterIncomingViewingPublicKey.equals(e.masterIncomingViewingPublicKey)&&this.masterOutgoingViewingPublicKey.equals(e.masterOutgoingViewingPublicKey)&&this.masterTaggingPublicKey.equals(e.masterTaggingPublicKey)}toBuffer(){return _i([this.masterNullifierPublicKey,this.masterIncomingViewingPublicKey,this.masterOutgoingViewingPublicKey,this.masterTaggingPublicKey])}static fromBuffer(e){const t=Js.asReader(e),n=t.readObject(Ei),s=t.readObject(Ei),i=t.readObject(Ei),r=t.readObject(Ei);return new Rd(n,s,i,r)}toNoirStruct(){return{npk_m:this.masterNullifierPublicKey.toWrappedNoirStruct(),ivpk_m:this.masterIncomingViewingPublicKey.toWrappedNoirStruct(),ovpk_m:this.masterOutgoingViewingPublicKey.toWrappedNoirStruct(),tpk_m:this.masterTaggingPublicKey.toWrappedNoirStruct()}}toFields(){return[...this.masterNullifierPublicKey.toFields(),...this.masterIncomingViewingPublicKey.toFields(),...this.masterOutgoingViewingPublicKey.toFields(),...this.masterTaggingPublicKey.toFields()]}encodeToNoir(){return this.toFields()}static fromFields(e){const t=vi.asReader(e);return new Rd(t.readObject(Ei),t.readObject(Ei),t.readObject(Ei),t.readObject(Ei))}toString(){return Ds(this.toBuffer())}static fromString(e){return Rd.fromBuffer(Ud.from(ks(e),"hex"))}}function Gd(e){return fl([e,Ri.IVSK_M])}function Zd(e,t){return wi([e,t],Ri.CONTRACT_ADDRESS_V1)}async function Jd(e,t){const n=await Zd(await e.hash(),t),s=await(new Hd).add(await Xd(new ii(n.toBigInt())),e.masterIncomingViewingPublicKey);return new Gc(s.x)}function Xd(e){const t=new Hd;return t.mul(t.generator(),e)}async function Wd(e){const t=function(e){return fl([e,Ri.NSK_M])}(e),n=Gd(e),s=function(e){return fl([e,Ri.OVSK_M])}(e),i=fl([e,Ri.TSK_M]),r=await Xd(t),a=await Xd(n),o=await Xd(s),l=await Xd(i);return{masterNullifierSecretKey:t,masterIncomingViewingSecretKey:n,masterOutgoingViewingSecretKey:s,masterTaggingSecretKey:i,publicKeys:new Rd(r,a,o,l)}}async function Vd(e){const t=await qd(e);return Jd(e.publicKeys,t)}async function qd(e){const t="saltedInitializationHash"in e?e.saltedInitializationHash:await function(e){return wi([e.salt,e.initializationHash,e.deployer],Ri.PARTIAL_ADDRESS)}(e);return wi([e.contractClassId,t],Ri.PARTIAL_ADDRESS)}async function Kd(e,t){return wi([e,await Qd(t)],Ri.CONSTRUCTOR)}var $d=i(5949);let eu;const tu=2;async function nu(e){return(await wi([e.selector,e.vkHash],Ri.FUNCTION_LEAF)).toBuffer()}async function su(e){const t=e.artifactHash,n="privateFunctionsRoot"in e?e.privateFunctionsRoot:await async function(e){const t=await async function(){if(!eu){const e=(await pl(new Array(tu).fill(0))).toBuffer();eu=await Od.create(ki,e,(async(e,t)=>(await Ai([e,t])).toBuffer()))}return eu}(),n=await function(e){const t=[...e].sort(((e,t)=>e.selector.value-t.selector.value));return Promise.all(t.map(nu))}(e);return si.fromBuffer(await t.computeTreeRoot(n))}(e.privateFunctions),s="publicBytecodeCommitment"in e?e.publicBytecodeCommitment:await async function(e){const t=Ed(e,Qi),n=Math.ceil(t[0].toNumber()/(si.SIZE_IN_BYTES-1));return(0,$d.strict)(n<Qi,"Bytecode exceeds maximum deployable size"),0==n?new si(0):await async function(e){const t=gi(e),n=(await c.initSingleton()).poseidon2HashAccumulate(t.map((e=>new d(e.toBuffer()))));return si.fromBuffer(yi.from(n.toBuffer()))}(t.slice(0,n+1))}(e.packedBytecode);return{id:await wi([t,n,s],Ri.CONTRACT_LEAF),artifactHash:t,privateFunctionsRoot:n,publicBytecodeCommitment:s}}var iu=i(8891).Buffer;const ru=(e,t)=>e.selector.toField().cmp(t.selector.toField());async function au(e){const t="artifactHash"in e?e.artifactHash:await Pd(e),n=e.functions.filter((e=>e.functionType===hd.PUBLIC)),s=await Promise.all(n.map((async e=>({selector:await ed.fromNameAndParameters(e.name,e.parameters),bytecode:e.bytecode}))));s.sort(ru);let i,r=iu.alloc(0);if(s.length>0){if(i=s.find((e=>e.selector.equals(ed.fromField(new si(Yi))))),!i)throw new Error(`A contract with public functions should define a public_dispatch(Field) function as its public entrypoint. Contract: ${e.name}`);r=i.bytecode}const a=e.functions.filter((e=>e.functionType===hd.PRIVATE)),o=await Promise.all(a.map(ou));o.sort(ru);const l={version:1,artifactHash:t,publicFunctions:i?[i]:[],packedBytecode:r,privateFunctions:o};return{...l,...await su(l)}}async function ou(e){return{selector:await ed.fromNameAndParameters(e.name,e.parameters),vkHash:await lu(e)}}async function lu(e){if(!e.verificationKey)throw new Error(`Private function ${e.name} must have a verification key`);return Ai(await async function(e){return(await c.initSingleton()).acirVkAsFieldsMegaHonk(new u(e)).map((e=>si.fromBuffer(Qc.from(e.toBuffer()))))}(iu.from(e.verificationKey,"base64")))}async function cu(e,t){const n=t.constructorArgs??[],s=t.salt??si.random(),i=function(e,t){if("string"==typeof t){const n=e.functions.find((e=>e.name===t));if(!n)throw new Error(`No constructor found with name ${t}`);return n}return t??wd(e)}(e,t.constructorArtifact),r=t.deployer??Gc.ZERO,a=await au(e),o=await async function(e){return(await su(e)).id}(a),l=i&&t?.skipArgsDecoding?await Kd(await ed.fromNameAndParameters(i?.name,i?.parameters),n):await async function(e,t){return e?Kd(await ed.fromNameAndParameters(e.name,e.parameters),Bd(e,t)):si.ZERO}(i,n),c={contractClassId:o,initializationHash:l,publicKeys:t.publicKeys??Rd.default(),salt:s,deployer:r,version:1};return{...c,address:await Vd(c)}}const du=zs.object({selector:id.FunctionSelector,vkHash:id.Fr}),uu=du.and(zs.object({bytecode:id.Buffer})),fu=zs.object({selector:id.FunctionSelector,bytecode:id.Buffer}),hu=zs.object({selector:id.FunctionSelector,bytecode:id.Buffer}),pu=zs.object({artifactMetadataHash:id.Fr,functionMetadataHash:id.Fr,unconstrainedFunctionsArtifactTreeRoot:id.Fr,privateFunctionTreeSiblingPath:zs.array(id.Fr),privateFunctionTreeLeafIndex:id.Integer,artifactTreeSiblingPath:zs.array(id.Fr),artifactTreeLeafIndex:id.Integer}),mu=zs.object({artifactMetadataHash:id.Fr,functionMetadataHash:id.Fr,privateFunctionsArtifactTreeRoot:id.Fr,artifactTreeSiblingPath:zs.array(id.Fr),artifactTreeLeafIndex:id.Integer}),gu=zs.object({version:zs.literal(1),artifactHash:id.Fr,privateFunctions:zs.array(du),publicFunctions:zs.array(fu),packedBytecode:id.Buffer}),_u=gu.extend({id:id.Fr}),bu=zs.object({id:id.Fr,privateFunctionsRoot:id.Fr,privateFunctions:zs.array(uu.and(pu)),unconstrainedFunctions:zs.array(hu.and(mu))}).and(gu.omit({privateFunctions:!0})),yu=zs.object({version:zs.literal(1),salt:id.Fr,deployer:id.AztecAddress,contractClassId:id.Fr,initializationHash:id.Fr,publicKeys:Rd.schema}).and(zs.object({address:id.AztecAddress})),Au=zs.object({rollupAddress:id.EthAddress,registryAddress:id.EthAddress,inboxAddress:id.EthAddress,outboxAddress:id.EthAddress,feeJuiceAddress:id.EthAddress,stakingAssetAddress:id.EthAddress,feeJuicePortalAddress:id.EthAddress,coinIssuerAddress:id.EthAddress,rewardDistributorAddress:id.EthAddress,governanceProposerAddress:id.EthAddress,governanceAddress:id.EthAddress,slashFactoryAddress:id.EthAddress}),wu=zs.object({classRegisterer:id.AztecAddress,feeJuice:id.AztecAddress,instanceDeployer:id.AztecAddress,multiCallEntrypoint:id.AztecAddress}),xu=zs.object({nodeVersion:zs.string(),l1ChainId:zs.number(),protocolVersion:zs.number(),enr:zs.string().optional(),l1ContractAddresses:Au,protocolContractAddresses:wu}).transform((e=>({enr:void 0,...e})));var vu,Eu,Mu,zu=i(8891).Buffer;try{vu=new TextDecoder}catch(e){}var Bu=0;const Fu=[];var ku,Cu,Ou,Du,Lu,Tu=Fu,Su=0,Nu={},Pu=0,Iu=0,Yu=[],Qu={useRecords:!1,mapsAsObjects:!0};class ju{}const Hu=new ju;Hu.name="MessagePack 0xC1";var Uu,Ru=!1,Gu=2;try{new Function("")}catch(e){Gu=1/0}class Zu{constructor(e){e&&(!1===e.useRecords&&void 0===e.mapsAsObjects&&(e.mapsAsObjects=!0),e.sequential&&!1!==e.trusted&&(e.trusted=!0,e.structures||0==e.useRecords||(e.structures=[],e.maxSharedStructures||(e.maxSharedStructures=0))),e.structures?e.structures.sharedLength=e.structures.length:e.getStructures&&((e.structures=[]).uninitialized=!0,e.structures.sharedLength=0),e.int64AsNumber&&(e.int64AsType="number")),Object.assign(this,e)}unpack(e,t){if(Eu)return xf((()=>(vf(),this?this.unpack(e,t):Zu.prototype.unpack.call(Qu,e,t))));e.buffer||e.constructor!==ArrayBuffer||(e=void 0!==zu?zu.from(e):new Uint8Array(e)),"object"==typeof t?(Mu=t.end||e.length,Bu=t.start||0):(Bu=0,Mu=t>-1?t:e.length),Su=0,Iu=0,Cu=null,Tu=Fu,Ou=null,Eu=e;try{Lu=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(Eu=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof Zu){if(Nu=this,this.structures)return ku=this.structures,Ju(t);(!ku||ku.length>0)&&(ku=[])}else Nu=Qu,(!ku||ku.length>0)&&(ku=[]);return Ju(t)}unpackMultiple(e,t){let n,s=0;try{Ru=!0;let i=e.length,r=this?this.unpack(e,i):Mf.unpack(e,i);if(!t){for(n=[r];Bu<i;)s=Bu,n.push(Ju());return n}if(!1===t(r,s,Bu))return;for(;Bu<i;)if(s=Bu,!1===t(Ju(),s,Bu))return}catch(e){throw e.lastPosition=s,e.values=n,e}finally{Ru=!1,vf()}}_mergeStructures(e,t){e=e||[],Object.isFrozen(e)&&(e=e.map((e=>e.slice(0))));for(let t=0,n=e.length;t<n;t++){let n=e[t];n&&(n.isShared=!0,t>=32&&(n.highByte=t-32>>5))}e.sharedLength=e.length;for(let n in t||[])if(n>=0){let s=e[n],i=t[n];i&&(s&&((e.restoreStructures||(e.restoreStructures=[]))[n]=s),e[n]=i)}return this.structures=e}decode(e,t){return this.unpack(e,t)}}function Ju(e){try{if(!Nu.trusted&&!Ru){let e=ku.sharedLength||0;e<ku.length&&(ku.length=e)}let e;if(Nu.randomAccessStructure&&Eu[Bu]<64&&Eu[Bu],e=Wu(),Ou&&(Bu=Ou.postBundlePosition,Ou=null),Ru&&(ku.restoreStructures=null),Bu==Mu)ku&&ku.restoreStructures&&Xu(),ku=null,Eu=null,Du&&(Du=null);else{if(Bu>Mu)throw new Error("Unexpected end of MessagePack data");if(!Ru){let t;try{t=JSON.stringify(e,((e,t)=>"bigint"==typeof t?`${t}n`:t)).slice(0,100)}catch(e){t="(JSON view not available "+e+")"}throw new Error("Data read, but end of buffer not reached "+t)}}return e}catch(e){throw ku&&ku.restoreStructures&&Xu(),vf(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer")||Bu>Mu)&&(e.incomplete=!0),e}}function Xu(){for(let e in ku.restoreStructures)ku[e]=ku.restoreStructures[e];ku.restoreStructures=null}function Wu(){let e=Eu[Bu++];if(e<160){if(e<128){if(e<64)return e;{let t=ku[63&e]||Nu.getStructures&&$u()[63&e];return t?(t.read||(t.read=qu(t,63&e)),t.read()):e}}if(e<144){if(e-=128,Nu.mapsAsObjects){let t={};for(let n=0;n<e;n++){let e=mf();"__proto__"===e&&(e="__proto_"),t[e]=Wu()}return t}{let t=new Map;for(let n=0;n<e;n++)t.set(Wu(),Wu());return t}}{e-=144;let t=new Array(e);for(let n=0;n<e;n++)t[n]=Wu();return Nu.freezeData?Object.freeze(t):t}}if(e<192){let t=e-160;if(Iu>=Bu)return Cu.slice(Bu-Pu,(Bu+=t)-Pu);if(0==Iu&&Mu<140){let e=t<16?df(t):cf(t);if(null!=e)return e}return ef(t)}{let t;switch(e){case 192:return null;case 193:return Ou?(t=Wu(),t>0?Ou[1].slice(Ou.position1,Ou.position1+=t):Ou[0].slice(Ou.position0,Ou.position0-=t)):Hu;case 194:return!1;case 195:return!0;case 196:if(t=Eu[Bu++],void 0===t)throw new Error("Unexpected end of buffer");return ff(t);case 197:return t=Lu.getUint16(Bu),Bu+=2,ff(t);case 198:return t=Lu.getUint32(Bu),Bu+=4,ff(t);case 199:return hf(Eu[Bu++]);case 200:return t=Lu.getUint16(Bu),Bu+=2,hf(t);case 201:return t=Lu.getUint32(Bu),Bu+=4,hf(t);case 202:if(t=Lu.getFloat32(Bu),Nu.useFloat32>2){let e=Ef[(127&Eu[Bu])<<1|Eu[Bu+1]>>7];return Bu+=4,(e*t+(t>0?.5:-.5)|0)/e}return Bu+=4,t;case 203:return t=Lu.getFloat64(Bu),Bu+=8,t;case 204:return Eu[Bu++];case 205:return t=Lu.getUint16(Bu),Bu+=2,t;case 206:return t=Lu.getUint32(Bu),Bu+=4,t;case 207:return"number"===Nu.int64AsType?(t=4294967296*Lu.getUint32(Bu),t+=Lu.getUint32(Bu+4)):"string"===Nu.int64AsType?t=Lu.getBigUint64(Bu).toString():"auto"===Nu.int64AsType?(t=Lu.getBigUint64(Bu),t<=BigInt(2)<<BigInt(52)&&(t=Number(t))):t=Lu.getBigUint64(Bu),Bu+=8,t;case 208:return Lu.getInt8(Bu++);case 209:return t=Lu.getInt16(Bu),Bu+=2,t;case 210:return t=Lu.getInt32(Bu),Bu+=4,t;case 211:return"number"===Nu.int64AsType?(t=4294967296*Lu.getInt32(Bu),t+=Lu.getUint32(Bu+4)):"string"===Nu.int64AsType?t=Lu.getBigInt64(Bu).toString():"auto"===Nu.int64AsType?(t=Lu.getBigInt64(Bu),t>=BigInt(-2)<<BigInt(52)&&t<=BigInt(2)<<BigInt(52)&&(t=Number(t))):t=Lu.getBigInt64(Bu),Bu+=8,t;case 212:if(t=Eu[Bu++],114==t)return _f(63&Eu[Bu++]);{let e=Yu[t];if(e)return e.read?(Bu++,e.read(Wu())):e.noBuffer?(Bu++,e()):e(Eu.subarray(Bu,++Bu));throw new Error("Unknown extension "+t)}case 213:return t=Eu[Bu],114==t?(Bu++,_f(63&Eu[Bu++],Eu[Bu++])):hf(2);case 214:return hf(4);case 215:return hf(8);case 216:return hf(16);case 217:return t=Eu[Bu++],Iu>=Bu?Cu.slice(Bu-Pu,(Bu+=t)-Pu):tf(t);case 218:return t=Lu.getUint16(Bu),Iu>=(Bu+=2)?Cu.slice(Bu-Pu,(Bu+=t)-Pu):nf(t);case 219:return t=Lu.getUint32(Bu),Iu>=(Bu+=4)?Cu.slice(Bu-Pu,(Bu+=t)-Pu):sf(t);case 220:return t=Lu.getUint16(Bu),Bu+=2,af(t);case 221:return t=Lu.getUint32(Bu),Bu+=4,af(t);case 222:return t=Lu.getUint16(Bu),Bu+=2,of(t);case 223:return t=Lu.getUint32(Bu),Bu+=4,of(t);default:if(e>=224)return e-256;if(void 0===e){let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}throw new Error("Unknown MessagePack token "+e)}}}const Vu=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;function qu(e,t){function n(){if(n.count++>Gu){let n=e.read=new Function("r","return function(){return "+(Nu.freezeData?"Object.freeze":"")+"({"+e.map((e=>"__proto__"===e?"__proto_:r()":Vu.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()")).join(",")+"})}")(Wu);return 0===e.highByte&&(e.read=Ku(t,e.read)),n()}let s={};for(let t=0,n=e.length;t<n;t++){let n=e[t];"__proto__"===n&&(n="__proto_"),s[n]=Wu()}return Nu.freezeData?Object.freeze(s):s}return n.count=0,0===e.highByte?Ku(t,n):n}const Ku=(e,t)=>function(){let n=Eu[Bu++];if(0===n)return t();let s=e<32?-(e+(n<<5)):e+(n<<5),i=ku[s]||$u()[s];if(!i)throw new Error("Record id is not defined for "+s);return i.read||(i.read=qu(i,e)),i.read()};function $u(){let e=xf((()=>(Eu=null,Nu.getStructures())));return ku=Nu._mergeStructures(e,ku)}var ef=rf,tf=rf,nf=rf,sf=rf;function rf(e){let t;if(e<16&&(t=df(e)))return t;if(e>64&&vu)return vu.decode(Eu.subarray(Bu,Bu+=e));const n=Bu+e,s=[];for(t="";Bu<n;){const e=Eu[Bu++];if(128&e)if(192==(224&e)){const t=63&Eu[Bu++];s.push((31&e)<<6|t)}else if(224==(240&e)){const t=63&Eu[Bu++],n=63&Eu[Bu++];s.push((31&e)<<12|t<<6|n)}else if(240==(248&e)){let t=(7&e)<<18|(63&Eu[Bu++])<<12|(63&Eu[Bu++])<<6|63&Eu[Bu++];t>65535&&(t-=65536,s.push(t>>>10&1023|55296),t=56320|1023&t),s.push(t)}else s.push(e);else s.push(e);s.length>=4096&&(t+=lf.apply(String,s),s.length=0)}return s.length>0&&(t+=lf.apply(String,s)),t}function af(e){let t=new Array(e);for(let n=0;n<e;n++)t[n]=Wu();return Nu.freezeData?Object.freeze(t):t}function of(e){if(Nu.mapsAsObjects){let t={};for(let n=0;n<e;n++){let e=mf();"__proto__"===e&&(e="__proto_"),t[e]=Wu()}return t}{let t=new Map;for(let n=0;n<e;n++)t.set(Wu(),Wu());return t}}var lf=String.fromCharCode;function cf(e){let t=Bu,n=new Array(e);for(let s=0;s<e;s++){const e=Eu[Bu++];if((128&e)>0)return void(Bu=t);n[s]=e}return lf.apply(String,n)}function df(e){if(e<4){if(e<2){if(0===e)return"";{let e=Eu[Bu++];return(128&e)>1?void(Bu-=1):lf(e)}}{let t=Eu[Bu++],n=Eu[Bu++];if((128&t)>0||(128&n)>0)return void(Bu-=2);if(e<3)return lf(t,n);let s=Eu[Bu++];return(128&s)>0?void(Bu-=3):lf(t,n,s)}}{let t=Eu[Bu++],n=Eu[Bu++],s=Eu[Bu++],i=Eu[Bu++];if((128&t)>0||(128&n)>0||(128&s)>0||(128&i)>0)return void(Bu-=4);if(e<6){if(4===e)return lf(t,n,s,i);{let e=Eu[Bu++];return(128&e)>0?void(Bu-=5):lf(t,n,s,i,e)}}if(e<8){let r=Eu[Bu++],a=Eu[Bu++];if((128&r)>0||(128&a)>0)return void(Bu-=6);if(e<7)return lf(t,n,s,i,r,a);let o=Eu[Bu++];return(128&o)>0?void(Bu-=7):lf(t,n,s,i,r,a,o)}{let r=Eu[Bu++],a=Eu[Bu++],o=Eu[Bu++],l=Eu[Bu++];if((128&r)>0||(128&a)>0||(128&o)>0||(128&l)>0)return void(Bu-=8);if(e<10){if(8===e)return lf(t,n,s,i,r,a,o,l);{let e=Eu[Bu++];return(128&e)>0?void(Bu-=9):lf(t,n,s,i,r,a,o,l,e)}}if(e<12){let c=Eu[Bu++],d=Eu[Bu++];if((128&c)>0||(128&d)>0)return void(Bu-=10);if(e<11)return lf(t,n,s,i,r,a,o,l,c,d);let u=Eu[Bu++];return(128&u)>0?void(Bu-=11):lf(t,n,s,i,r,a,o,l,c,d,u)}{let c=Eu[Bu++],d=Eu[Bu++],u=Eu[Bu++],f=Eu[Bu++];if((128&c)>0||(128&d)>0||(128&u)>0||(128&f)>0)return void(Bu-=12);if(e<14){if(12===e)return lf(t,n,s,i,r,a,o,l,c,d,u,f);{let e=Eu[Bu++];return(128&e)>0?void(Bu-=13):lf(t,n,s,i,r,a,o,l,c,d,u,f,e)}}{let h=Eu[Bu++],p=Eu[Bu++];if((128&h)>0||(128&p)>0)return void(Bu-=14);if(e<15)return lf(t,n,s,i,r,a,o,l,c,d,u,f,h,p);let m=Eu[Bu++];return(128&m)>0?void(Bu-=15):lf(t,n,s,i,r,a,o,l,c,d,u,f,h,p,m)}}}}}function uf(){let e,t=Eu[Bu++];if(t<192)e=t-160;else switch(t){case 217:e=Eu[Bu++];break;case 218:e=Lu.getUint16(Bu),Bu+=2;break;case 219:e=Lu.getUint32(Bu),Bu+=4;break;default:throw new Error("Expected string")}return rf(e)}function ff(e){return Nu.copyBuffers?Uint8Array.prototype.slice.call(Eu,Bu,Bu+=e):Eu.subarray(Bu,Bu+=e)}function hf(e){let t=Eu[Bu++];if(Yu[t]){let n;return Yu[t](Eu.subarray(Bu,n=Bu+=e),(e=>{Bu=e;try{return Wu()}finally{Bu=n}}))}throw new Error("Unknown extension type "+t)}var pf=new Array(4096);function mf(){let e=Eu[Bu++];if(!(e>=160&&e<192))return Bu--,gf(Wu());if(e-=160,Iu>=Bu)return Cu.slice(Bu-Pu,(Bu+=e)-Pu);if(!(0==Iu&&Mu<180))return ef(e);let t,n=4095&(e<<5^(e>1?Lu.getUint16(Bu):e>0?Eu[Bu]:0)),s=pf[n],i=Bu,r=Bu+e-3,a=0;if(s&&s.bytes==e){for(;i<r;){if(t=Lu.getUint32(i),t!=s[a++]){i=1879048192;break}i+=4}for(r+=3;i<r;)if(t=Eu[i++],t!=s[a++]){i=1879048192;break}if(i===r)return Bu=i,s.string;r-=3,i=Bu}for(s=[],pf[n]=s,s.bytes=e;i<r;)t=Lu.getUint32(i),s.push(t),i+=4;for(r+=3;i<r;)t=Eu[i++],s.push(t);let o=e<16?df(e):cf(e);return s.string=null!=o?o:ef(e)}function gf(e){if("string"==typeof e)return e;if("number"==typeof e||"boolean"==typeof e||"bigint"==typeof e)return e.toString();if(null==e)return e+"";throw new Error("Invalid property type for record",typeof e)}const _f=(e,t)=>{let n=Wu().map(gf),s=e;void 0!==t&&(e=e<32?-((t<<5)+e):(t<<5)+e,n.highByte=t);let i=ku[e];return i&&(i.isShared||Ru)&&((ku.restoreStructures||(ku.restoreStructures=[]))[e]=i),ku[e]=n,n.read=qu(n,s),n.read()};Yu[0]=()=>{},Yu[0].noBuffer=!0,Yu[66]=e=>{let t=e.length,n=BigInt(128&e[0]?e[0]-256:e[0]);for(let s=1;s<t;s++)n<<=BigInt(8),n+=BigInt(e[s]);return n};let bf={Error,TypeError,ReferenceError};Yu[101]=()=>{let e=Wu();return(bf[e[0]]||Error)(e[1],{cause:e[2]})},Yu[105]=e=>{if(!1===Nu.structuredClone)throw new Error("Structured clone extension is disabled");let t=Lu.getUint32(Bu-4);Du||(Du=new Map);let n,s=Eu[Bu];n=s>=144&&s<160||220==s||221==s?[]:{};let i={target:n};Du.set(t,i);let r=Wu();return i.used?Object.assign(n,r):(i.target=r,r)},Yu[112]=e=>{if(!1===Nu.structuredClone)throw new Error("Structured clone extension is disabled");let t=Lu.getUint32(Bu-4),n=Du.get(t);return n.used=!0,n.target},Yu[115]=()=>new Set(Wu());const yf=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map((e=>e+"Array"));let Af="object"==typeof globalThis?globalThis:window;Yu[116]=e=>{let t=e[0],n=yf[t];if(!n){if(16===t){let t=new ArrayBuffer(e.length-1);return new Uint8Array(t).set(e.subarray(1)),t}throw new Error("Could not find typed array for code "+t)}return new Af[n](Uint8Array.prototype.slice.call(e,1).buffer)},Yu[120]=()=>{let e=Wu();return new RegExp(e[0],e[1])};const wf=[];function xf(e){Uu&&Uu();let t=Mu,n=Bu,s=Su,i=Pu,r=Iu,a=Cu,o=Tu,l=Du,c=Ou,d=new Uint8Array(Eu.slice(0,Mu)),u=ku,f=ku.slice(0,ku.length),h=Nu,p=Ru,m=e();return Mu=t,Bu=n,Su=s,Pu=i,Iu=r,Cu=a,Tu=o,Du=l,Ou=c,Eu=d,Ru=p,(ku=u).splice(0,ku.length,...f),Nu=h,Lu=new DataView(Eu.buffer,Eu.byteOffset,Eu.byteLength),m}function vf(){Eu=null,Du=null,ku=null}Yu[98]=e=>{let t=(e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3],n=Bu;return Bu+=t-e.length,Ou=wf,(Ou=[uf(),uf()]).position0=0,Ou.position1=0,Ou.postBundlePosition=Bu,Bu=n,Wu()},Yu[255]=e=>4==e.length?new Date(1e3*(16777216*e[0]+(e[1]<<16)+(e[2]<<8)+e[3])):8==e.length?new Date(((e[0]<<22)+(e[1]<<14)+(e[2]<<6)+(e[3]>>2))/1e6+1e3*(4294967296*(3&e[3])+16777216*e[4]+(e[5]<<16)+(e[6]<<8)+e[7])):12==e.length?new Date(((e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3])/1e6+1e3*((128&e[4]?-281474976710656:0)+1099511627776*e[6]+4294967296*e[7]+16777216*e[8]+(e[9]<<16)+(e[10]<<8)+e[11])):new Date("invalid");const Ef=new Array(147);for(let e=0;e<256;e++)Ef[e]=+("1e"+Math.floor(45.15-.30103*e));var Mf=new Zu({useRecords:!1});Mf.unpack,Mf.unpackMultiple,Mf.unpack;let zf=new Float32Array(1);new Uint8Array(zf.buffer,0,4);var Bf=i(8891).Buffer;let Ff,kf,Cf;try{Ff=new TextEncoder}catch(e){}const Of=void 0!==Bf,Df=Of?function(e){return Bf.allocUnsafeSlow(e)}:Uint8Array,Lf=Of?Bf:Uint8Array,Tf=Of?4294967296:2144337920;let Sf,Nf,Pf,If,Yf=0,Qf=null;const jf=/[\u0080-\uFFFF]/,Hf=Symbol("record-id");class Uf extends Zu{constructor(e){let t,n,s,i;super(e),this.offset=0;let r=Lf.prototype.utf8Write?function(e,t){return Sf.utf8Write(e,t,Sf.byteLength-t)}:!(!Ff||!Ff.encodeInto)&&function(e,t){return Ff.encodeInto(e,Sf.subarray(t)).written},a=this;e||(e={});let o=e&&e.sequential,l=e.structures||e.saveStructures,c=e.maxSharedStructures;if(null==c&&(c=l?32:0),c>8160)throw new Error("Maximum maxSharedStructure is 8160");e.structuredClone&&null==e.moreTypes&&(this.moreTypes=!0);let d=e.maxOwnStructures;null==d&&(d=l?32:64),this.structures||0==e.useRecords||(this.structures=[]);let u=c>32||d+c>64,f=c+64,h=c+d+64;if(h>8256)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let p=[],m=0,g=0;this.pack=this.encode=function(e,r){if(Sf||(Sf=new Df(8192),Pf=Sf.dataView||(Sf.dataView=new DataView(Sf.buffer,0,8192)),Yf=0),If=Sf.length-10,If-Yf<2048?(Sf=new Df(Sf.length),Pf=Sf.dataView||(Sf.dataView=new DataView(Sf.buffer,0,Sf.length)),If=Sf.length-10,Yf=0):Yf=Yf+7&2147483640,t=Yf,r&sh&&(Yf+=255&r),i=a.structuredClone?new Map:null,a.bundleStrings&&"string"!=typeof e?(Qf=[],Qf.size=1/0):Qf=null,s=a.structures,s){s.uninitialized&&(s=a._mergeStructures(a.getStructures()));let e=s.sharedLength||0;if(e>c)throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+s.sharedLength);if(!s.transitions){s.transitions=Object.create(null);for(let t=0;t<e;t++){let e=s[t];if(!e)continue;let n,i=s.transitions;for(let t=0,s=e.length;t<s;t++){let s=e[t];n=i[s],n||(n=i[s]=Object.create(null)),i=n}i[Hf]=t+64}this.lastNamedStructuresLength=e}o||(s.nextId=e+64)}let l;n&&(n=!1);try{a.randomAccessStructure&&e&&e.constructor&&e.constructor===Object?B(e):y(e);let n=Qf;if(Qf&&Jf(t,y,0),i&&i.idsToInsert){let e=i.idsToInsert.sort(((e,t)=>e.offset>t.offset?1:-1)),s=e.length,r=-1;for(;n&&s>0;){let i=e[--s].offset+t;i<n.stringsPosition+t&&-1===r&&(r=0),i>n.position+t?r>=0&&(r+=6):(r>=0&&(Pf.setUint32(n.position+t,Pf.getUint32(n.position+t)+r),r=-1),n=n.previous,s++)}r>=0&&n&&Pf.setUint32(n.position+t,Pf.getUint32(n.position+t)+r),Yf+=6*e.length,Yf>If&&E(Yf),a.offset=Yf;let o=function(e,t){let n,s=6*t.length,i=e.length-s;for(;n=t.pop();){let t=n.offset,r=n.id;e.copyWithin(t+s,t,i),s-=6;let a=t+s;e[a++]=214,e[a++]=105,e[a++]=r>>24,e[a++]=r>>16&255,e[a++]=r>>8&255,e[a++]=255&r,i=t}return e}(Sf.subarray(t,Yf),e);return i=null,o}return a.offset=Yf,r&th?(Sf.start=t,Sf.end=Yf,Sf):Sf.subarray(t,Yf)}catch(e){throw l=e,e}finally{if(s&&(_(),n&&a.saveStructures)){let n=s.sharedLength||0,i=Sf.subarray(t,Yf),o=function(e,t){return e.isCompatible=e=>{let n=!e||(t.lastNamedStructuresLength||0)===e.length;return n||t._mergeStructures(e),n},e}(s,a);if(!l)return!1===a.saveStructures(o,o.isCompatible)?a.pack(e,r):(a.lastNamedStructuresLength=n,Sf.length>1073741824&&(Sf=null),i)}Sf.length>1073741824&&(Sf=null),r&nh&&(Yf=t)}};const _=()=>{g<10&&g++;let e=s.sharedLength||0;if(s.length>e&&!o&&(s.length=e),m>1e4)s.transitions=null,g=0,m=0,p.length>0&&(p=[]);else if(p.length>0&&!o){for(let e=0,t=p.length;e<t;e++)p[e][Hf]=0;p=[]}},b=e=>{var t=e.length;t<16?Sf[Yf++]=144|t:t<65536?(Sf[Yf++]=220,Sf[Yf++]=t>>8,Sf[Yf++]=255&t):(Sf[Yf++]=221,Pf.setUint32(Yf,t),Yf+=4);for(let n=0;n<t;n++)y(e[n])},y=e=>{Yf>If&&(Sf=E(Yf));var n,s=typeof e;if("string"===s){let s,i=e.length;if(Qf&&i>=4&&i<4096){if((Qf.size+=i)>21760){let e,n,s=(Qf[0]?3*Qf[0].length+Qf[1].length:0)+10;Yf+s>If&&(Sf=E(Yf+s)),Qf.position?(n=Qf,Sf[Yf]=200,Yf+=3,Sf[Yf++]=98,e=Yf-t,Yf+=4,Jf(t,y,0),Pf.setUint16(e+t-3,Yf-t-e)):(Sf[Yf++]=214,Sf[Yf++]=98,e=Yf-t,Yf+=4),Qf=["",""],Qf.previous=n,Qf.size=0,Qf.position=e}let n=jf.test(e);return Qf[n?0:1]+=e,Sf[Yf++]=193,void y(n?-i:i)}s=i<32?1:i<256?2:i<65536?3:5;let a=3*i;if(Yf+a>If&&(Sf=E(Yf+a)),i<64||!r){let t,r,a,o=Yf+s;for(t=0;t<i;t++)r=e.charCodeAt(t),r<128?Sf[o++]=r:r<2048?(Sf[o++]=r>>6|192,Sf[o++]=63&r|128):55296==(64512&r)&&56320==(64512&(a=e.charCodeAt(t+1)))?(r=65536+((1023&r)<<10)+(1023&a),t++,Sf[o++]=r>>18|240,Sf[o++]=r>>12&63|128,Sf[o++]=r>>6&63|128,Sf[o++]=63&r|128):(Sf[o++]=r>>12|224,Sf[o++]=r>>6&63|128,Sf[o++]=63&r|128);n=o-Yf-s}else n=r(e,Yf+s);n<32?Sf[Yf++]=160|n:n<256?(s<2&&Sf.copyWithin(Yf+2,Yf+1,Yf+1+n),Sf[Yf++]=217,Sf[Yf++]=n):n<65536?(s<3&&Sf.copyWithin(Yf+3,Yf+2,Yf+2+n),Sf[Yf++]=218,Sf[Yf++]=n>>8,Sf[Yf++]=255&n):(s<5&&Sf.copyWithin(Yf+5,Yf+3,Yf+3+n),Sf[Yf++]=219,Pf.setUint32(Yf,n),Yf+=4),Yf+=n}else if("number"===s)if(e>>>0===e)e<32||e<128&&!1===this.useRecords||e<64&&!this.randomAccessStructure?Sf[Yf++]=e:e<256?(Sf[Yf++]=204,Sf[Yf++]=e):e<65536?(Sf[Yf++]=205,Sf[Yf++]=e>>8,Sf[Yf++]=255&e):(Sf[Yf++]=206,Pf.setUint32(Yf,e),Yf+=4);else if((0|e)===e)e>=-32?Sf[Yf++]=256+e:e>=-128?(Sf[Yf++]=208,Sf[Yf++]=e+256):e>=-32768?(Sf[Yf++]=209,Pf.setInt16(Yf,e),Yf+=2):(Sf[Yf++]=210,Pf.setInt32(Yf,e),Yf+=4);else{let t;if((t=this.useFloat32)>0&&e<4294967296&&e>=-2147483648){let n;if(Sf[Yf++]=202,Pf.setFloat32(Yf,e),t<4||(0|(n=e*Ef[(127&Sf[Yf])<<1|Sf[Yf+1]>>7]))===n)return void(Yf+=4);Yf--}Sf[Yf++]=203,Pf.setFloat64(Yf,e),Yf+=8}else if("object"===s||"function"===s)if(e){if(i){let n=i.get(e);if(n){if(!n.id){let e=i.idsToInsert||(i.idsToInsert=[]);n.id=e.push(n)}return Sf[Yf++]=214,Sf[Yf++]=112,Pf.setUint32(Yf,n.id),void(Yf+=4)}i.set(e,{offset:Yf-t})}let r=e.constructor;if(r===Object)v(e);else if(r===Array)b(e);else if(r===Map)if(this.mapAsEmptyObject)Sf[Yf++]=128;else{(n=e.size)<16?Sf[Yf++]=128|n:n<65536?(Sf[Yf++]=222,Sf[Yf++]=n>>8,Sf[Yf++]=255&n):(Sf[Yf++]=223,Pf.setUint32(Yf,n),Yf+=4);for(let[t,n]of e)y(t),y(n)}else{for(let t=0,n=kf.length;t<n;t++)if(e instanceof Cf[t]){let n=kf[t];if(n.write){n.type&&(Sf[Yf++]=212,Sf[Yf++]=n.type,Sf[Yf++]=0);let t=n.write.call(this,e);return void(t===e?Array.isArray(e)?b(e):v(e):y(t))}let s,i=Sf,r=Pf,a=Yf;Sf=null;try{s=n.pack.call(this,e,(e=>(Sf=i,i=null,Yf+=e,Yf>If&&E(Yf),{target:Sf,targetView:Pf,position:Yf-e})),y)}finally{i&&(Sf=i,Pf=r,Yf=a,If=Sf.length-10)}return void(s&&(s.length+Yf>If&&E(s.length+Yf),Yf=Zf(s,Sf,Yf,n.type)))}if(Array.isArray(e))b(e);else{if(e.toJSON){const t=e.toJSON();if(t!==e)return y(t)}if("function"===s)return y(this.writeFunction&&this.writeFunction(e));v(e)}}}else Sf[Yf++]=192;else if("boolean"===s)Sf[Yf++]=e?195:194;else if("bigint"===s){if(e<BigInt(1)<<BigInt(63)&&e>=-(BigInt(1)<<BigInt(63)))Sf[Yf++]=211,Pf.setBigInt64(Yf,e);else if(e<BigInt(1)<<BigInt(64)&&e>0)Sf[Yf++]=207,Pf.setBigUint64(Yf,e);else{if(!this.largeBigIntToFloat){if(this.largeBigIntToString)return y(e.toString());if(this.useBigIntExtension&&e<BigInt(2)**BigInt(1023)&&e>-(BigInt(2)**BigInt(1023))){Sf[Yf++]=199,Yf++,Sf[Yf++]=66;let t,n=[];do{let s=e&BigInt(255);t=(s&BigInt(128))===(e<BigInt(0)?BigInt(128):BigInt(0)),n.push(s),e>>=BigInt(8)}while(e!==BigInt(0)&&e!==BigInt(-1)||!t);Sf[Yf-2]=n.length;for(let e=n.length;e>0;)Sf[Yf++]=Number(n[--e]);return}throw new RangeError(e+" was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set largeBigIntToString to convert to string")}Sf[Yf++]=203,Pf.setFloat64(Yf,Number(e))}Yf+=8}else{if("undefined"!==s)throw new Error("Unknown type: "+s);this.encodeUndefinedAsNil?Sf[Yf++]=192:(Sf[Yf++]=212,Sf[Yf++]=0,Sf[Yf++]=0)}},A=this.variableMapSize||this.coercibleKeyAsNumber||this.skipValues?e=>{let t;if(this.skipValues){t=[];for(let n in e)"function"==typeof e.hasOwnProperty&&!e.hasOwnProperty(n)||this.skipValues.includes(e[n])||t.push(n)}else t=Object.keys(e);let n,s=t.length;if(s<16?Sf[Yf++]=128|s:s<65536?(Sf[Yf++]=222,Sf[Yf++]=s>>8,Sf[Yf++]=255&s):(Sf[Yf++]=223,Pf.setUint32(Yf,s),Yf+=4),this.coercibleKeyAsNumber)for(let i=0;i<s;i++){n=t[i];let s=Number(n);y(isNaN(s)?n:s),y(e[n])}else for(let i=0;i<s;i++)y(n=t[i]),y(e[n])}:e=>{Sf[Yf++]=222;let n=Yf-t;Yf+=2;let s=0;for(let t in e)("function"!=typeof e.hasOwnProperty||e.hasOwnProperty(t))&&(y(t),y(e[t]),s++);if(s>65535)throw new Error('Object is too large to serialize with fast 16-bit map size, use the "variableMapSize" option to serialize this object');Sf[n+++t]=s>>8,Sf[n+t]=255&s},w=!1===this.useRecords?A:e.progressiveRecords&&!u?e=>{let n,i,r=s.transitions||(s.transitions=Object.create(null)),a=Yf++-t;for(let o in e)if("function"!=typeof e.hasOwnProperty||e.hasOwnProperty(o)){if(n=r[o],n)r=n;else{let l=Object.keys(e),c=r;r=s.transitions;let d=0;for(let e=0,t=l.length;e<t;e++){let t=l[e];n=r[t],n||(n=r[t]=Object.create(null),d++),r=n}a+t+1==Yf?(Yf--,M(r,l,d)):z(r,l,a,d),i=!0,r=c[o]}y(e[o])}if(!i){let n=r[Hf];n?Sf[a+t]=n:z(r,Object.keys(e),a,0)}}:e=>{let t,n=s.transitions||(s.transitions=Object.create(null)),i=0;for(let s in e)("function"!=typeof e.hasOwnProperty||e.hasOwnProperty(s))&&(t=n[s],t||(t=n[s]=Object.create(null),i++),n=t);let r=n[Hf];r?r>=96&&u?(Sf[Yf++]=96+(31&(r-=96)),Sf[Yf++]=r>>5):Sf[Yf++]=r:M(n,n.__keys__||Object.keys(e),i);for(let t in e)("function"!=typeof e.hasOwnProperty||e.hasOwnProperty(t))&&y(e[t])},x="function"==typeof this.useRecords&&this.useRecords,v=x?e=>{x(e)?w(e):A(e)}:w,E=e=>{let n;if(e>16777216){if(e-t>Tf)throw new Error("Packed buffer would be larger than maximum buffer size");n=Math.min(Tf,4096*Math.round(Math.max((e-t)*(e>67108864?1.25:2),4194304)/4096))}else n=1+(Math.max(e-t<<2,Sf.length-1)>>12)<<12;let s=new Df(n);return Pf=s.dataView||(s.dataView=new DataView(s.buffer,0,n)),e=Math.min(e,Sf.length),Sf.copy?Sf.copy(s,0,t,e):s.set(Sf.slice(t,e)),Yf-=t,t=0,If=s.length-10,Sf=s},M=(e,t,i)=>{let r=s.nextId;r||(r=64),r<f&&this.shouldShareStructure&&!this.shouldShareStructure(t)?(r=s.nextOwnId,r<h||(r=f),s.nextOwnId=r+1):(r>=h&&(r=f),s.nextId=r+1);let a=t.highByte=r>=96&&u?r-96>>5:-1;e[Hf]=r,e.__keys__=t,s[r-64]=t,r<f?(t.isShared=!0,s.sharedLength=r-63,n=!0,a>=0?(Sf[Yf++]=96+(31&r),Sf[Yf++]=a):Sf[Yf++]=r):(a>=0?(Sf[Yf++]=213,Sf[Yf++]=114,Sf[Yf++]=96+(31&r),Sf[Yf++]=a):(Sf[Yf++]=212,Sf[Yf++]=114,Sf[Yf++]=r),i&&(m+=g*i),p.length>=d&&(p.shift()[Hf]=0),p.push(e),y(t))},z=(e,n,s,i)=>{let r=Sf,a=Yf,o=If,l=t;Sf=Nf,Yf=0,t=0,Sf||(Nf=Sf=new Df(8192)),If=Sf.length-10,M(e,n,i),Nf=Sf;let c=Yf;if(Sf=r,Yf=a,If=o,t=l,c>1){let e=Yf+c-1;e>If&&E(e);let n=s+t;Sf.copyWithin(n+c,n+1,Yf),Sf.set(Nf.slice(0,c),n),Yf=e}else Sf[s+t]=Nf[0]},B=e=>{let i=undefined(e,Sf,t,Yf,s,E,((e,t,s)=>{if(s)return n=!0;Yf=t;let i=Sf;return y(e),_(),i!==Sf?{position:Yf,targetView:Pf,target:Sf}:Yf}),this);if(0===i)return v(e);Yf=i}}useBuffer(e){Sf=e,Sf.dataView||(Sf.dataView=new DataView(Sf.buffer,Sf.byteOffset,Sf.byteLength)),Yf=0}set position(e){Yf=e}get position(){return Yf}clearSharedData(){this.structures&&(this.structures=[]),this.typedStructs&&(this.typedStructs=[])}}function Rf(e,t,n,s){let i=e.byteLength;if(i+1<256){var{target:r,position:a}=n(4+i);r[a++]=199,r[a++]=i+1}else if(i+1<65536){var{target:r,position:a}=n(5+i);r[a++]=200,r[a++]=i+1>>8,r[a++]=i+1&255}else{var{target:r,position:a,targetView:o}=n(7+i);r[a++]=201,o.setUint32(a,i+1),a+=4}r[a++]=116,r[a++]=t,e.buffer||(e=new Uint8Array(e)),r.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),a)}function Gf(e,t){let n=e.byteLength;var s,i;if(n<256){var{target:s,position:i}=t(n+2);s[i++]=196,s[i++]=n}else if(n<65536){var{target:s,position:i}=t(n+3);s[i++]=197,s[i++]=n>>8,s[i++]=255&n}else{var{target:s,position:i,targetView:r}=t(n+5);s[i++]=198,r.setUint32(i,n),i+=4}s.set(e,i)}function Zf(e,t,n,s){let i=e.length;switch(i){case 1:t[n++]=212;break;case 2:t[n++]=213;break;case 4:t[n++]=214;break;case 8:t[n++]=215;break;case 16:t[n++]=216;break;default:i<256?(t[n++]=199,t[n++]=i):i<65536?(t[n++]=200,t[n++]=i>>8,t[n++]=255&i):(t[n++]=201,t[n++]=i>>24,t[n++]=i>>16&255,t[n++]=i>>8&255,t[n++]=255&i)}return t[n++]=s,t.set(e,n),n+i}function Jf(e,t,n){if(Qf.length>0){Pf.setUint32(Qf.position+e,Yf+n-Qf.position-e),Qf.stringsPosition=Yf-e;let s=Qf;Qf=null,t(s[0]),t(s[1])}}function Xf(e){if(e.Class){if(!e.pack&&!e.write)throw new Error("Extension has no pack or write function");if(e.pack&&!e.type)throw new Error("Extension has no type (numeric code to identify the extension)");Cf.unshift(e.Class),kf.unshift(e)}!function(e){e.unpack?Yu[e.type]=e.unpack:Yu[e.type]=e}(e)}Cf=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor,ju],kf=[{pack(e,t,n){let s=e.getTime()/1e3;if((this.useTimestamp32||0===e.getMilliseconds())&&s>=0&&s<4294967296){let{target:e,targetView:n,position:i}=t(6);e[i++]=214,e[i++]=255,n.setUint32(i,s)}else if(s>0&&s<4294967296){let{target:n,targetView:i,position:r}=t(10);n[r++]=215,n[r++]=255,i.setUint32(r,4e6*e.getMilliseconds()+(s/1e3/4294967296|0)),i.setUint32(r+4,s)}else if(isNaN(s)){if(this.onInvalidDate)return t(0),n(this.onInvalidDate());let{target:e,targetView:s,position:i}=t(3);e[i++]=212,e[i++]=255,e[i++]=255}else{let{target:n,targetView:i,position:r}=t(15);n[r++]=199,n[r++]=12,n[r++]=255,i.setUint32(r,1e6*e.getMilliseconds()),i.setBigInt64(r+4,BigInt(Math.floor(s)))}}},{pack(e,t,n){if(this.setAsEmptyObject)return t(0),n({});let s=Array.from(e),{target:i,position:r}=t(this.moreTypes?3:0);this.moreTypes&&(i[r++]=212,i[r++]=115,i[r++]=0),n(s)}},{pack(e,t,n){let{target:s,position:i}=t(this.moreTypes?3:0);this.moreTypes&&(s[i++]=212,s[i++]=101,s[i++]=0),n([e.name,e.message,e.cause])}},{pack(e,t,n){let{target:s,position:i}=t(this.moreTypes?3:0);this.moreTypes&&(s[i++]=212,s[i++]=120,s[i++]=0),n([e.source,e.flags])}},{pack(e,t){this.moreTypes?Rf(e,16,t):Gf(Of?Bf.from(e):new Uint8Array(e),t)}},{pack(e,t){let n=e.constructor;n!==Lf&&this.moreTypes?Rf(e,yf.indexOf(n.name),t):Gf(e,t)}},{pack(e,t){let{target:n,position:s}=t(1);n[s]=193}}];let Wf=new Uf({useRecords:!1});Wf.pack,Wf.pack;const Vf=Uf,{NEVER:qf,ALWAYS:Kf,DECIMAL_ROUND:$f,DECIMAL_FIT:eh}={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4},th=512,nh=1024,sh=2048;i(8891).Buffer;class ih{constructor(e){this.items=e}toBuffer(){return _i(this.items.length,this.items)}toFriendlyJSON(){return this.items}}var rh,ah,oh;!function(e){e[e.STANDARD=0]="STANDARD",e[e.ULTRA=1]="ULTRA"}(rh||(rh={})),(oh=ah||(ah={}))[oh.Base=0]="Base",oh[oh.Merge=1]="Merge",oh[oh.Root=2]="Root";var lh=i(8891).Buffer;class ch{constructor(e,t,n){this.nullifier=e,this.nextNullifier=t,this.nextIndex=n}static get schema(){return zs.object({nullifier:id.Fr,nextNullifier:id.Fr,nextIndex:id.BigInt}).transform((({nullifier:e,nextNullifier:t,nextIndex:n})=>new ch(e,t,n)))}getKey(){return this.nullifier.toBigInt()}getNextKey(){return this.nextNullifier.toBigInt()}getNextIndex(){return this.nextIndex}asLeaf(){return new dh(this.nullifier)}toBuffer(){return lh.concat(this.toHashInputs())}toHashInputs(){return[lh.from(this.nullifier.toBuffer()),lh.from(this.nextNullifier.toBuffer()),lh.from(m(this.nextIndex,32))]}toFields(){return this.toHashInputs().map((e=>si.fromBuffer(e)))}clone(){return new ch(this.nullifier,this.nextNullifier,this.nextIndex)}static random(){return new ch(si.random(),si.random(),BigInt(Math.floor(1e3*Math.random())))}static empty(){return new ch(si.ZERO,si.ZERO,0n)}static fromBuffer(e){const t=Js.asReader(e);return new ch(t.readObject(si),t.readObject(si),p(t.readBytes(32)))}static fromLeaf(e,t,n){return new ch(e.nullifier,new si(t),n)}static clone(e){return new ch(e.nullifier,e.nextNullifier,e.nextIndex)}}class dh{constructor(e){this.nullifier=e}getKey(){return this.nullifier.toBigInt()}toBuffer(){return this.nullifier.toBuffer()}isEmpty(){return this.nullifier.isZero()}updateTo(e){throw new Error("Nullifiers are create only")}static buildDummy(e){return new dh(new si(e))}static fromBuffer(e){return new dh(si.fromBuffer(e))}}function uh(e,t,n=0){return Array.from({length:e},((e,s)=>t(s+n)))}const fh=["da","l2"];class hh{constructor(e,t){this.daGas=e,this.l2Gas=t}static get schema(){return zs.object({daGas:id.UInt32,l2Gas:id.UInt32}).transform(hh.from)}clone(){return new hh(this.daGas,this.l2Gas)}get(e){return this[`${e}Gas`]}equals(e){return this.daGas===e.daGas&&this.l2Gas===e.l2Gas}static from(e){return new hh(e.daGas??0,e.l2Gas??0)}static empty(){return new hh(0,0)}static random(){return new hh(Math.floor(1e9*Math.random()),Math.floor(1e9*Math.random()))}isEmpty(){return 0===this.daGas&&0===this.l2Gas}static fromBuffer(e){const t=Js.asReader(e);return new hh(t.readNumber(),t.readNumber())}toBuffer(){return _i(this.daGas,this.l2Gas)}[f.inspect.custom](){return`Gas { daGas=${this.daGas} l2Gas=${this.l2Gas} }`}add(e){return new hh(this.daGas+e.daGas,this.l2Gas+e.l2Gas)}sub(e){return new hh(this.daGas-e.daGas,this.l2Gas-e.l2Gas)}mul(e){return new hh(Math.ceil(this.daGas*e),Math.ceil(this.l2Gas*e))}gtAny(e){return this.daGas>e.daGas||this.l2Gas>e.l2Gas}computeFee(e){return fh.reduce(((t,n)=>t.add(e.get(n).mul(new si(this.get(n))))),si.ZERO)}toFields(){return gi(this.daGas,this.l2Gas)}static fromFields(e){const t=vi.asReader(e);return new hh(t.readU32(),t.readU32())}}class ph{constructor(e,t){this.feePerDaGas=new si(e),this.feePerL2Gas=new si(t)}static get schema(){return zs.object({feePerDaGas:id.Fr,feePerL2Gas:id.Fr}).transform(ph.from)}clone(){return new ph(this.feePerDaGas,this.feePerL2Gas)}equals(e){return this.feePerDaGas.equals(e.feePerDaGas)&&this.feePerL2Gas.equals(e.feePerL2Gas)}get(e){switch(e){case"da":return this.feePerDaGas;case"l2":return this.feePerL2Gas}}mul(e){return 1===e||1n===e?this.clone():"bigint"==typeof e?new ph(new si(this.feePerDaGas.toBigInt()*e),new si(this.feePerL2Gas.toBigInt()*e)):new ph(new si(this.feePerDaGas.toNumberUnsafe()*e),new si(this.feePerL2Gas.toNumberUnsafe()*e))}static from(e){return new ph(e.feePerDaGas,e.feePerL2Gas)}static random(){return new ph(si.random(),si.random())}static empty(){return new ph(si.ZERO,si.ZERO)}isEmpty(){return this.feePerDaGas.isZero()&&this.feePerL2Gas.isZero()}static fromBuffer(e){const t=Js.asReader(e);return new ph(t.readObject(si),t.readObject(si))}toBuffer(){return _i(this.feePerDaGas,this.feePerL2Gas)}static fromFields(e){const t=vi.asReader(e);return new ph(t.readField(),t.readField())}toFields(){return gi(this.feePerDaGas,this.feePerL2Gas)}[f.inspect.custom](){return`GasFees { feePerDaGas=${this.feePerDaGas} feePerL2Gas=${this.feePerL2Gas} }`}}class mh{constructor(e,t,n,s){this.gasLimits=e,this.teardownGasLimits=t,this.maxFeesPerGas=n,this.maxPriorityFeesPerGas=s}static get schema(){return zs.object({gasLimits:hh.schema,teardownGasLimits:hh.schema,maxFeesPerGas:ph.schema,maxPriorityFeesPerGas:ph.schema}).transform(mh.from)}getSize(){return this.toBuffer().length}static from(e){return new mh(hh.from(e.gasLimits),hh.from(e.teardownGasLimits),ph.from(e.maxFeesPerGas),ph.from(e.maxPriorityFeesPerGas))}clone(){return new mh(this.gasLimits.clone(),this.teardownGasLimits.clone(),this.maxFeesPerGas.clone(),this.maxPriorityFeesPerGas.clone())}getFeeLimit(){return fh.reduce(((e,t)=>this.maxFeesPerGas.get(t).mul(new si(this.gasLimits.get(t))).add(e)),si.ZERO)}static empty(){return new mh(hh.empty(),hh.empty(),ph.empty(),ph.empty())}static default(e){return mh.from({gasLimits:e.gasLimits??{l2Gas:Hi,daGas:Hi},teardownGasLimits:e.teardownGasLimits??{l2Gas:Ui,daGas:Ui},maxFeesPerGas:e.maxFeesPerGas,maxPriorityFeesPerGas:e.maxPriorityFeesPerGas??ph.empty()})}isEmpty(){return this.gasLimits.isEmpty()&&this.teardownGasLimits.isEmpty()&&this.maxFeesPerGas.isEmpty()&&this.maxPriorityFeesPerGas.isEmpty()}equals(e){return this.gasLimits.equals(e.gasLimits)&&this.teardownGasLimits.equals(e.teardownGasLimits)&&this.maxFeesPerGas.equals(e.maxFeesPerGas)&&this.maxPriorityFeesPerGas.equals(e.maxPriorityFeesPerGas)}static fromBuffer(e){const t=Js.asReader(e);return new mh(t.readObject(hh),t.readObject(hh),t.readObject(ph),t.readObject(ph))}toBuffer(){return _i(...mh.getFields(this))}static fromFields(e){const t=vi.asReader(e);return new mh(t.readObject(hh),t.readObject(hh),t.readObject(ph),t.readObject(ph))}toFields(){const e=gi(...mh.getFields(this));if(8!==e.length)throw new Error(`Invalid number of fields for GasSettings. Expected 8 but got ${e.length}`);return e}static getFields(e){return[e.gasLimits,e.teardownGasLimits,e.maxFeesPerGas,e.maxPriorityFeesPerGas]}}var gh=i(8891);function _h(e,t){return JSON.stringify(e,((e,t)=>"bigint"==typeof t?t.toString():"object"==typeof t&&t&&"Buffer"===t.type&&Array.isArray(t.data)?gh.Buffer.from(t.data).toString("base64"):"object"==typeof t&&t&&gh.Buffer.isBuffer(t)?t.toString("base64"):"object"==typeof t&&t instanceof Map?Array.from(t.entries()):"object"==typeof t&&t instanceof Set?Array.from(t.values()):t),t?2:0)}class bh{constructor(e,t,n,s,i,r,a,o){this.chainId=e,this.version=t,this.blockNumber=n,this.slotNumber=s,this.timestamp=i,this.coinbase=r,this.feeRecipient=a,this.gasFees=o}static get schema(){return zs.object({chainId:id.Fr,version:id.Fr,blockNumber:id.Fr,slotNumber:id.Fr,timestamp:id.Fr,coinbase:id.EthAddress,feeRecipient:id.AztecAddress,gasFees:ph.schema}).transform(bh.from)}getSize(){return this.toBuffer().length}static from(e){return new bh(...bh.getFields(e))}static empty(){return new bh(si.ZERO,si.ZERO,si.ZERO,si.ZERO,si.ZERO,Nc.ZERO,Gc.ZERO,ph.empty())}static fromBuffer(e){const t=Js.asReader(e);return new bh(si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),t.readObject(Nc),t.readObject(Gc),t.readObject(ph))}static fromFields(e){const t=vi.asReader(e);return new bh(t.readField(),t.readField(),t.readField(),t.readField(),t.readField(),Nc.fromField(t.readField()),Gc.fromField(t.readField()),ph.fromFields(t))}static getFields(e){return[e.chainId,e.version,e.blockNumber,e.slotNumber,e.timestamp,e.coinbase,e.feeRecipient,e.gasFees]}toBuffer(){return _i(...bh.getFields(this))}toFields(){const e=gi(...bh.getFields(this));if(9!==e.length)throw new Error(`Invalid number of fields for GlobalVariables. Expected 9, got ${e.length}`);return e}toFriendlyJSON(){return{blockNumber:this.blockNumber.toNumber(),slotNumber:this.slotNumber.toNumber(),timestamp:this.timestamp.toString(),coinbase:this.coinbase.toString(),gasFees:_h(this.gasFees)}}clone(){return bh.fromBuffer(this.toBuffer())}isEmpty(){return this.chainId.isZero()&&this.version.isZero()&&this.blockNumber.isZero()&&this.slotNumber.isZero()&&this.timestamp.isZero()&&this.coinbase.isZero()&&this.feeRecipient.isZero()&&this.gasFees.isEmpty()}toInspect(){return{chainId:this.chainId.toNumber(),version:this.version.toNumber(),blockNumber:this.blockNumber.toNumber(),slotNumber:this.slotNumber.toNumber(),timestamp:this.timestamp.toNumber(),coinbase:this.coinbase.toString(),feeRecipient:this.feeRecipient.toString(),feePerDaGas:this.gasFees.feePerDaGas.toNumber(),feePerL2Gas:this.gasFees.feePerL2Gas.toNumber()}}[f.inspect.custom](){return`GlobalVariables ${(0,f.inspect)(this.toInspect())}`}equals(e){return this.chainId.equals(e.chainId)&&this.version.equals(e.version)&&this.blockNumber.equals(e.blockNumber)&&this.slotNumber.equals(e.slotNumber)&&this.timestamp.equals(e.timestamp)&&this.coinbase.equals(e.coinbase)&&this.feeRecipient.equals(e.feeRecipient)&&this.gasFees.equals(e.gasFees)}}class yh{constructor(e,t,n){this.recipient=e,this.content=t,this.counter=n}static empty(){return new yh(Nc.ZERO,si.zero(),0)}equals(e){return this.recipient.equals(e.recipient)&&this.content.equals(e.content)&&this.counter===e.counter}toBuffer(){return _i(this.recipient,this.content,this.counter)}toFields(){const e=[this.recipient.toField(),this.content,new si(this.counter)];if(3!==e.length)throw new Error(`Invalid number of fields for L2ToL1Message. Expected 3, got ${e.length}`);return e}static fromFields(e){const t=vi.asReader(e);return new yh(t.readObject(Nc),t.readField(),t.readU32())}static fromBuffer(e){const t=Js.asReader(e);return new yh(t.readObject(Nc),t.readObject(si),t.readNumber())}isEmpty(){return this.recipient.isZero()&&this.content.isZero()&&!this.counter}scope(e){return new Ah(this,e)}}class Ah{constructor(e,t){this.message=e,this.contractAddress=t}static getFields(e){return[e.message,e.contractAddress]}static empty(){return new Ah(yh.empty(),Gc.ZERO)}equals(e){return this.message.equals(e.message)&&this.contractAddress.equals(e.contractAddress)}toBuffer(){return _i(this.message,this.contractAddress)}static fromBuffer(e){const t=Js.asReader(e);return new Ah(t.readObject(yh),t.readObject(Gc))}static fromFields(e){const t=vi.asReader(e);return new Ah(t.readObject(yh),t.readObject(Gc))}toFields(){const e=gi(...Ah.getFields(this));if(4!==e.length)throw new Error(`Invalid number of fields for ScopedL2ToL1Message. Expected 4, got ${e.length}`);return e}isEmpty(){return this.message.isEmpty()&&this.contractAddress.isZero()}}class wh{constructor(e,t,n){this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=n}getSize(){return Me(this.noteHashes)+Me(this.nullifiers)+Me(this.l2ToL1Msgs)}static getFields(e){return[e.noteHashes,e.nullifiers,e.l2ToL1Msgs]}static fromFields(e){const t=vi.asReader(e);return new this(t.readFieldArray(Di),t.readFieldArray(Li),t.readArray(8,Ah))}toFields(){const e=gi(...wh.getFields(this));if(160!==e.length)throw new Error(`Invalid number of fields for PrivateToAvmAccumulatedData. Expected 160, got ${e.length}`);return e}static from(e){return new wh(...wh.getFields(e))}static fromBuffer(e){const t=Js.asReader(e);return new wh(t.readArray(Di,si),t.readArray(Li,si),t.readArray(8,Ah))}toBuffer(){return _i(...wh.getFields(this))}static empty(){return new wh(uh(Di,si.zero),uh(Li,si.zero),uh(8,Ah.empty))}[f.inspect.custom](){return`PrivateToAvmAccumulatedData {\n      noteHashes: [${this.noteHashes.filter((e=>!e.isZero())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      nullifiers: [${this.nullifiers.filter((e=>!e.isZero())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      l2ToL1Msgs: [${this.l2ToL1Msgs.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n    }`}}class xh{constructor(e,t,n){this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=n}getSize(){return 12}static getFields(e){return[e.noteHashes,e.nullifiers,e.l2ToL1Msgs]}static fromFields(e){const t=vi.asReader(e);return new this(t.readU32(),t.readU32(),t.readU32())}static from(e){return new xh(...xh.getFields(e))}static fromBuffer(e){const t=Js.asReader(e);return new xh(t.readNumber(),t.readNumber(),t.readNumber())}toBuffer(){return _i(...xh.getFields(this))}static empty(){return new xh(0,0,0)}[f.inspect.custom](){return`PrivateToAvmAccumulatedDataArrayLengths {\n      noteHashes: ${this.noteHashes},\n      nullifiers: ${this.nullifiers},\n      l2ToL1Msgs: ${this.l2ToL1Msgs},\n    }`}}class vh{constructor(e,t,n,s,i){this.msgSender=e,this.contractAddress=t,this.functionSelector=n,this.isStaticCall=s,this.argsHash=i}getSize(){return this.isEmpty()?0:this.toBuffer().length}static from(e){return new vh(...vh.getFields(e))}static getFields(e){return[e.msgSender,e.contractAddress,e.functionSelector,e.isStaticCall,e.argsHash]}static fromFields(e){const t=vi.asReader(e);return new vh(t.readObject(Gc),t.readObject(Gc),t.readObject(ed),t.readBoolean(),t.readField())}toFields(){const e=gi(...vh.getFields(this));if(5!==e.length)throw new Error(`Invalid number of fields for PublicCallRequest. Expected 5, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new vh(t.readObject(Gc),t.readObject(Gc),t.readObject(ed),t.readBoolean(),t.readObject(si))}toBuffer(){return _i(...vh.getFields(this))}static empty(){return new vh(Gc.ZERO,Gc.ZERO,ed.empty(),!1,si.ZERO)}isEmpty(){return this.msgSender.isZero()&&this.contractAddress.isZero()&&this.functionSelector.isEmpty()&&!this.isStaticCall&&this.argsHash.isEmpty()}[f.inspect.custom](){return`PublicCallRequest {\n      msgSender: ${this.msgSender}\n      contractAddress: ${this.contractAddress}\n      functionSelector: ${this.functionSelector}\n      isStaticCall: ${this.isStaticCall}\n      argsHash: ${this.argsHash}\n    }`}}class Eh{constructor(e,t){this.inner=e,this.counter=t}getSize(){return this.isEmpty()?0:this.toBuffer().length}static getFields(e){return[e.inner,e.counter]}static fromFields(e){const t=vi.asReader(e);return new Eh(t.readObject(vh),t.readU32())}toFields(){const e=gi(...Eh.getFields(this));if(6!==e.length)throw new Error(`Invalid number of fields for CountedPublicCallRequest. Expected 6, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new Eh(t.readObject(vh),t.readNumber())}toBuffer(){return _i(...Eh.getFields(this))}static empty(){return new Eh(vh.empty(),0)}isEmpty(){return this.inner.isEmpty()&&0==this.counter}}class Mh{constructor(e,t){this.root=e,this.nextAvailableLeafIndex=t}static get schema(){return zs.object({root:id.Fr,nextAvailableLeafIndex:id.UInt32}).transform((({root:e,nextAvailableLeafIndex:t})=>new Mh(e,t)))}getSize(){return this.root.size+4}toBuffer(){return _i(this.root,this.nextAvailableLeafIndex)}toFields(){return[this.root,new si(this.nextAvailableLeafIndex)]}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new Mh(si.fromBuffer(t),t.readNumber())}static fromString(e){return Mh.fromBuffer(Os(e))}static fromFields(e){const t=vi.asReader(e);return new Mh(t.readField(),Number(t.readField().toBigInt()))}static zero(){return new Mh(si.ZERO,0)}isZero(){return this.root.isZero()&&0===this.nextAvailableLeafIndex}[f.inspect.custom](){return`AppendOnlyTreeSnapshot { root: ${this.root.toString()}, nextAvailableLeafIndex: ${this.nextAvailableLeafIndex} }`}equals(e){return this.root.equals(e.root)&&this.nextAvailableLeafIndex===e.nextAvailableLeafIndex}static random(){return new Mh(si.random(),Math.floor(1e3*Math.random()))}}class zh{constructor(e,t,n,s){this.l1ToL2MessageTree=e,this.noteHashTree=t,this.nullifierTree=n,this.publicDataTree=s}getSize(){return this.l1ToL2MessageTree.getSize()+this.noteHashTree.getSize()+this.nullifierTree.getSize()+this.publicDataTree.getSize()}static fromBuffer(e){const t=Js.asReader(e);return new zh(t.readObject(Mh),t.readObject(Mh),t.readObject(Mh),t.readObject(Mh))}toBuffer(){return _i(this.l1ToL2MessageTree,this.noteHashTree,this.nullifierTree,this.publicDataTree)}static fromFields(e){const t=vi.asReader(e),n=Mh.fromFields(t),s=Mh.fromFields(t),i=Mh.fromFields(t),r=Mh.fromFields(t);return new zh(n,s,i,r)}toFields(){const e=[...this.l1ToL2MessageTree.toFields(),...this.noteHashTree.toFields(),...this.nullifierTree.toFields(),...this.publicDataTree.toFields()];if(8!==e.length)throw new Error(`Invalid number of fields for TreeSnapshots. Expected 8, got ${e.length}`);return e}static empty(){return new zh(Mh.zero(),Mh.zero(),Mh.zero(),Mh.zero())}isEmpty(){return this.l1ToL2MessageTree.isZero()&&this.noteHashTree.isZero()&&this.nullifierTree.isZero()&&this.publicDataTree.isZero()}[f.inspect.custom](){return`TreeSnapshots {\n  l1ToL2MessageTree: ${(0,f.inspect)(this.l1ToL2MessageTree)},\n  noteHashTree: ${(0,f.inspect)(this.noteHashTree)},\n  nullifierTree: ${(0,f.inspect)(this.nullifierTree)},\n  publicDataTree: ${(0,f.inspect)(this.publicDataTree)},\n}`}}class Bh{constructor(e,t){this.leafSlot=e,this.value=t}static get schema(){return zs.object({leafSlot:id.Fr,value:id.Fr}).transform(Bh.from)}static from(e){return new Bh(...Bh.getFields(e))}static getFields(e){return[e.leafSlot,e.value]}static fromFields(e){const t=vi.asReader(e);return new Bh(t.readField(),t.readField())}static fromBuffer(e){const t=Js.asReader(e);return new Bh(si.fromBuffer(t),si.fromBuffer(t))}toBuffer(){return _i(...Bh.getFields(this))}static fromString(e){return Bh.fromBuffer(Os(e))}toString(){return Ds(this.toBuffer())}static empty(){return new Bh(si.ZERO,si.ZERO)}static isEmpty(e){return e.isEmpty()}isEmpty(){return this.leafSlot.isZero()&&this.value.isZero()}}Bh.SIZE_IN_BYTES=2*si.SIZE_IN_BYTES;class Fh{constructor(e,t){this.contractAddress=e,this.log=t}toFields(){return gi(...Fh.getFields(this))}static getFields(e){return[e.contractAddress,e.log]}static fromFields(e){const t=vi.asReader(e);return new Fh(t.readObject(Gc),t.readFieldArray(13))}isEmpty(){return this.contractAddress.isZero()&&this.log.every((e=>e.isZero()))}static empty(){return new Fh(Gc.ZERO,uh(13,si.zero))}toBuffer(){return _i(...Fh.getFields(this))}static fromBuffer(e){const t=Js.asReader(e);return new Fh(t.readObject(Gc),t.readArray(13,si))}static async random(){return new Fh(await Gc.random(),uh(13,si.random))}equals(e){return this.contractAddress.equals(e.contractAddress)&&this.log.reduce(((t,n,s)=>t&&n.equals(e.log[s])),!0)}toHumanReadable(){return`PublicLog: (contractAddress: ${this.contractAddress} log: ${this.log})`}static get schema(){return zs.object({contractAddress:Gc.schema,log:zs.array(id.Fr)}).transform((({contractAddress:e,log:t})=>Fh.fromFields([e.toField(),...t])))}[f.inspect.custom](){return`PublicLog {\n      contractAddress: ${(0,f.inspect)(this.contractAddress)},\n      log: [${this.log.map((e=>(0,f.inspect)(e))).join(", ")}],\n    }`}}Fh.SIZE_IN_BYTES=14*si.SIZE_IN_BYTES;class kh{constructor(e,t,n,s,i){this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=n,this.publicLogs=s,this.publicDataWrites=i}getSize(){return Me(this.noteHashes)+Me(this.nullifiers)+Me(this.l2ToL1Msgs)+Me(this.publicLogs)+Me(this.publicDataWrites)}static fromBuffer(e){const t=Js.asReader(e);return new this(t.readArray(Di,si),t.readArray(Li,si),t.readArray(8,Ah),t.readArray(8,Fh),t.readArray(Si,Bh))}toBuffer(){return _i(this.noteHashes,this.nullifiers,this.l2ToL1Msgs,this.publicLogs,this.publicDataWrites)}static fromFields(e){const t=vi.asReader(e);return new this(t.readFieldArray(Di),t.readFieldArray(Li),t.readArray(8,Ah),t.readArray(8,Fh),t.readArray(Si,Bh))}static fromString(e){return this.fromBuffer(Os(e))}toString(){return Ds(this.toBuffer())}static empty(){return new this(uh(Di,si.zero),uh(Li,si.zero),uh(8,Ah.empty),uh(8,Fh.empty),uh(Si,Bh.empty))}isEmpty(){return this.noteHashes.every((e=>e.isZero()))&&this.nullifiers.every((e=>e.isZero()))&&this.l2ToL1Msgs.every((e=>e.isEmpty()))&&this.publicLogs.every((e=>e.isEmpty()))&&this.publicDataWrites.every((e=>e.isEmpty()))}[f.inspect.custom](){return`AvmAccumulatedData {\n  noteHashes: [${this.noteHashes.filter((e=>!e.isZero())).map((e=>(0,f.inspect)(e))).join(", ")}],\n  nullifiers: [${this.nullifiers.filter((e=>!e.isZero())).map((e=>(0,f.inspect)(e))).join(", ")}],\n  l2ToL1Msgs: [${this.l2ToL1Msgs.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n  publicLogs: [${this.publicLogs.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n  publicDataWrites: [${this.publicDataWrites.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n}`}}class Ch{constructor(e,t,n,s,i,r,a,o,l,c,d,u,f,h,p,m,g){this.globalVariables=e,this.startTreeSnapshots=t,this.startGasUsed=n,this.gasSettings=s,this.feePayer=i,this.publicSetupCallRequests=r,this.publicAppLogicCallRequests=a,this.publicTeardownCallRequest=o,this.previousNonRevertibleAccumulatedDataArrayLengths=l,this.previousRevertibleAccumulatedDataArrayLengths=c,this.previousNonRevertibleAccumulatedData=d,this.previousRevertibleAccumulatedData=u,this.endTreeSnapshots=f,this.endGasUsed=h,this.accumulatedData=p,this.transactionFee=m,this.reverted=g}static fromBuffer(e){const t=Js.asReader(e);return new Ch(t.readObject(bh),t.readObject(zh),t.readObject(hh),t.readObject(mh),t.readObject(Gc),t.readArray(Ti,vh),t.readArray(Ti,vh),t.readObject(vh),t.readObject(xh),t.readObject(xh),t.readObject(wh),t.readObject(wh),t.readObject(zh),t.readObject(hh),t.readObject(kh),t.readObject(si),t.readBoolean())}toBuffer(){return _i(this.globalVariables,this.startTreeSnapshots,this.startGasUsed,this.gasSettings,this.feePayer,this.publicSetupCallRequests,this.publicAppLogicCallRequests,this.publicTeardownCallRequest,this.previousNonRevertibleAccumulatedDataArrayLengths,this.previousRevertibleAccumulatedDataArrayLengths,this.previousNonRevertibleAccumulatedData,this.previousRevertibleAccumulatedData,this.endTreeSnapshots,this.endGasUsed,this.accumulatedData,this.transactionFee,this.reverted)}static fromString(e){return Ch.fromBuffer(Os(e))}toString(){return Ds(this.toBuffer())}static fromFields(e){const t=vi.asReader(e);return new Ch(bh.fromFields(t),zh.fromFields(t),hh.fromFields(t),mh.fromFields(t),Gc.fromFields(t),t.readArray(Ti,vh),t.readArray(Ti,vh),vh.fromFields(t),xh.fromFields(t),xh.fromFields(t),wh.fromFields(t),wh.fromFields(t),zh.fromFields(t),hh.fromFields(t),kh.fromFields(t),t.readField(),t.readBoolean())}static empty(){return new Ch(bh.empty(),zh.empty(),hh.empty(),mh.empty(),Gc.zero(),uh(Ti,vh.empty),uh(Ti,vh.empty),vh.empty(),xh.empty(),xh.empty(),wh.empty(),wh.empty(),zh.empty(),hh.empty(),kh.empty(),si.zero(),!1)}[f.inspect.custom](){return`AvmCircuitPublicInputs {\n      globalVariables: ${(0,f.inspect)(this.globalVariables)},\n      startTreeSnapshots: ${(0,f.inspect)(this.startTreeSnapshots)},\n      startGasUsed: ${(0,f.inspect)(this.startGasUsed)},\n      gasSettings: ${(0,f.inspect)(this.gasSettings)},\n      feePayer: ${(0,f.inspect)(this.feePayer)},\n      publicSetupCallRequests: [${this.publicSetupCallRequests.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}]},\n      publicAppLogicCallRequests: [${this.publicAppLogicCallRequests.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}]},\n      publicTeardownCallRequest: ${(0,f.inspect)(this.publicTeardownCallRequest)},\n      previousNonRevertibleAccumulatedDataArrayLengths: ${(0,f.inspect)(this.previousNonRevertibleAccumulatedDataArrayLengths)},\n      previousRevertibleAccumulatedDataArrayLengths: ${(0,f.inspect)(this.previousRevertibleAccumulatedDataArrayLengths)},\n      previousNonRevertibleAccumulatedData: ${(0,f.inspect)(this.previousNonRevertibleAccumulatedData)},\n      previousRevertibleAccumulatedData: ${(0,f.inspect)(this.previousRevertibleAccumulatedData)},\n      endTreeSnapshots: ${(0,f.inspect)(this.endTreeSnapshots)},\n      endGasUsed: ${(0,f.inspect)(this.endGasUsed)},\n      accumulatedData: ${(0,f.inspect)(this.accumulatedData)},\n      transactionFee: ${(0,f.inspect)(this.transactionFee)},\n      reverted: ${this.reverted},\n      }`}}var Oh=i(8891).Buffer;class Dh{constructor(e,t){this.contractAddress=e,this.calldata=new ih(t)}toBuffer(){return _i(...Dh.getFields(this))}toString(){return Ds(this.toBuffer())}isEmpty(){return this.contractAddress.isZero()&&0==this.calldata.items.length}static from(e){return new Dh(e.contractAddress,e.calldata.items)}static getFields(e){return[e.contractAddress,e.calldata]}static fromBuffer(e){const t=Js.asReader(e);return new Dh(Gc.fromBuffer(t),t.readVector(si))}static fromString(e){return Dh.fromBuffer(Os(e))}}class Lh{constructor(e,t,n,s,i,r,a,o=Ph.empty()){this.address=e,this.exists=t,this.salt=n,this.deployer=s,this.contractClassId=i,this.initializationHash=r,this.publicKeys=a,this.membershipHint=o}toBuffer(){return _i(...Lh.getFields(this))}toString(){return Ds(this.toBuffer())}isEmpty(){return this.address.isZero()&&!this.exists&&this.salt.isZero()&&this.deployer.isZero()&&this.contractClassId.isZero()&&this.initializationHash.isZero()&&this.publicKeys.isEmpty()&&this.membershipHint.isEmpty()}static from(e){return new Lh(...Lh.getFields(e))}static getFields(e){return[e.address,e.exists,e.salt,e.deployer,e.contractClassId,e.initializationHash,e.publicKeys,e.membershipHint]}static fromBuffer(e){const t=Js.asReader(e);return new Lh(Gc.fromBuffer(t),t.readBoolean(),si.fromBuffer(t),Gc.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),Rd.fromBuffer(t),Ph.fromBuffer(t))}static fromString(e){return Lh.fromBuffer(Os(e))}}class Th{constructor(e,t,n){this.bytecode=e,this.contractInstanceHint=t,this.contractClassHint=n}toBuffer(){return _i(...Th.getFields(this))}toString(){return Ds(this.toBuffer())}isEmpty(){return 0==this.bytecode.length}static from(e){return new Th(e.bytecode,e.contractInstanceHint,e.contractClassHint)}static getFields(e){const t=Oh.alloc(e.bytecode.length+4);return t.writeUInt32BE(e.bytecode.length),e.bytecode.copy(t,4),[t,e.contractInstanceHint,e.contractClassHint.artifactHash,e.contractClassHint.privateFunctionsRoot,e.contractClassHint.publicBytecodeCommitment]}static fromBuffer(e){const t=Js.asReader(e),n=t.readBuffer(),s=Lh.fromBuffer(t),i={artifactHash:si.fromBuffer(t),privateFunctionsRoot:si.fromBuffer(t),publicBytecodeCommitment:si.fromBuffer(t)};return new Th(n,s,i)}static fromString(e){return Th.fromBuffer(Os(e))}}class Sh{constructor(e,t,n){this.leafIndex=e,this.value=t,this._siblingPath=n,this.siblingPath=new ih(n)}toBuffer(){return _i(...Sh.getFields(this))}toString(){return this.toBuffer().toString("hex")}isEmpty(){return this.value.isZero()&&0==this.siblingPath.items.length}static from(e){return new Sh(e.leafIndex,e.value,e.siblingPath.items)}static getFields(e){return[e.leafIndex,e.value,e.siblingPath]}static fromBuffer(e){return new Sh(si.fromBuffer(e),si.fromBuffer(e),Js.asReader(e).readVector(si))}static fromString(e){return Sh.fromBuffer(Oh.from(e,"hex"))}}class Nh{constructor(e,t){this.lowLeafRead=e,this._insertionPath=t,this.insertionPath=new ih(t)}toBuffer(){return _i(...Nh.getFields(this))}toString(){return this.toBuffer().toString("hex")}isEmpty(){return 0==this.insertionPath.items.length}static from(e){return new Nh(e.lowLeafRead,e.insertionPath.items)}static getFields(e){return[...Ph.getFields(e.lowLeafRead),e.insertionPath]}static fromBuffer(e){const t=Js.asReader(e),n=Ph.fromBuffer(t),s=t.readVector(si);return new Nh(n,s)}static fromString(e){return Nh.fromBuffer(Oh.from(e,"hex"))}}class Ph{constructor(e,t,n){this.lowLeafPreimage=e,this.lowLeafIndex=t,this._lowLeafSiblingPath=n,this.lowLeafSiblingPath=new ih(n)}toBuffer(){return _i(...Ph.getFields(this))}toString(){return this.toBuffer().toString("hex")}isEmpty(){return 0==this.lowLeafSiblingPath.items.length}static from(e){return new Ph(e.lowLeafPreimage,e.lowLeafIndex,e.lowLeafSiblingPath.items)}static empty(){return new Ph(ch.empty(),si.ZERO,[])}static getFields(e){return[e.lowLeafPreimage.nullifier,e.lowLeafPreimage.nextNullifier,new si(e.lowLeafPreimage.nextIndex),e.lowLeafIndex,e.lowLeafSiblingPath]}static fromBuffer(e){const t=Js.asReader(e),n=t.readObject(ch),s=si.fromBuffer(t),i=t.readVector(si);return new Ph(n,s,i)}static fromString(e){return Ph.fromBuffer(Oh.from(e,"hex"))}}class Ih{constructor(e,t,n){this.leafPreimage=e,this.leafIndex=t,this._siblingPath=n,this.siblingPath=new ih(n)}toBuffer(){return _i(...Ih.getFields(this))}toString(){return this.toBuffer().toString("hex")}isEmpty(){return 0==this.siblingPath.items.length}static from(e){return new Ih(e.leafPreimage,e.leafIndex,e.siblingPath.items)}static getFields(e){return[e.leafPreimage.slot,e.leafPreimage.value,new si(e.leafPreimage.nextIndex),e.leafPreimage.nextSlot,e.leafIndex,e.siblingPath]}static fromBuffer(e){const t=Js.asReader(e),n=t.readObject(Ip),s=si.fromBuffer(t),i=t.readVector(si);return new Ih(n,s,i)}static fromString(e){return Ih.fromBuffer(Oh.from(e,"hex"))}}class Yh{constructor(e,t,n){this.lowLeafRead=e,this.newLeafPreimage=t,this._insertionPath=n,this.insertionPath=new ih(n)}toBuffer(){return _i(...Yh.getFields(this))}toString(){return this.toBuffer().toString("hex")}isEmpty(){return 0==this.insertionPath.items.length}static from(e){return new Yh(e.lowLeafRead,e.newLeafPreimage,e.insertionPath.items)}static getFields(e){return[...Ih.getFields(e.lowLeafRead),e.newLeafPreimage.slot,e.newLeafPreimage.value,new si(e.newLeafPreimage.nextIndex),e.newLeafPreimage.nextSlot,e.insertionPath]}static fromBuffer(e){const t=Js.asReader(e),n=t.readObject(Ih),s=t.readObject(Ip),i=t.readVector(si);return new Yh(n,s,i)}static fromString(e){return Yh.fromBuffer(Oh.from(e,"hex"))}}class Qh{constructor(e,t,n,s,i,r,a,o,l,c){this.contractBytecodeHints=n,this.enqueuedCalls=new ih(e),this.contractInstances=new ih(t),this.publicDataReads=new ih(s),this.publicDataWrites=new ih(i),this.nullifierReads=new ih(r),this.nullifierWrites=new ih(a),this.noteHashReads=new ih(o),this.noteHashWrites=new ih(l),this.l1ToL2MessageReads=new ih(c)}static empty(){return new Qh([],[],new Map,[],[],[],[],[],[],[])}toBuffer(){return _i(...Qh.getFields(this))}toString(){return Ds(this.toBuffer())}isEmpty(){return 0==this.enqueuedCalls.items.length&&0==this.contractInstances.items.length&&0==this.contractBytecodeHints.size&&0==this.publicDataReads.items.length&&0==this.publicDataWrites.items.length&&0==this.nullifierReads.items.length&&0==this.nullifierWrites.items.length&&0==this.noteHashReads.items.length&&0==this.noteHashWrites.items.length&&0==this.l1ToL2MessageReads.items.length}static from(e){return new Qh(e.enqueuedCalls.items,e.contractInstances.items,e.contractBytecodeHints,e.publicDataReads.items,e.publicDataWrites.items,e.nullifierReads.items,e.nullifierWrites.items,e.noteHashReads.items,e.noteHashWrites.items,e.l1ToL2MessageReads.items)}static getFields(e){return[e.enqueuedCalls,e.contractInstances,new ih(Array.from(e.contractBytecodeHints.values())),e.publicDataReads,e.publicDataWrites,e.nullifierReads,e.nullifierWrites,e.noteHashReads,e.noteHashWrites,e.l1ToL2MessageReads]}static fromBuffer(e){const t=Js.asReader(e);return new Qh(t.readVector(Dh),t.readVector(Lh),(e=>{const t=new Map,n=e.readVector(Th);for(const e of n)t.set(e.contractInstanceHint.address.toString(),e);return t})(t),t.readVector(Ih),t.readVector(Yh),t.readVector(Ph),t.readVector(Nh),t.readVector(Sh),t.readVector(Sh),t.readVector(Sh))}static fromString(e){return jh.fromBuffer(Os(e))}}class jh{constructor(e,t,n,s){this.functionName=e,this.calldata=t,this.avmHints=n,this.publicInputs=s}toBuffer(){const e=Oh.from(this.functionName);return _i(e.length,e,this.calldata.length,this.calldata,this.avmHints.toBuffer(),this.publicInputs)}toString(){return Ds(this.toBuffer())}static empty(){return new jh("",[],Qh.empty(),Ch.empty())}static from(e){return new jh(...jh.getFields(e))}static getFields(e){return[e.functionName,e.calldata,e.avmHints,e.publicInputs]}static fromBuffer(e){const t=Js.asReader(e);return new jh(t.readBuffer().toString(),t.readVector(si),Qh.fromBuffer(t),Ch.fromBuffer(t))}static fromString(e){return jh.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(jh)}serializeForAvm2(){const e={contractInstances:[],contractClasses:[],initialTreeRoots:{publicDataTree:this.publicInputs.startTreeSnapshots.publicDataTree.root,nullifierTree:this.publicInputs.startTreeSnapshots.nullifierTree.root,noteHashTree:this.publicInputs.startTreeSnapshots.noteHashTree.root,l1ToL2MessageTree:this.publicInputs.startTreeSnapshots.l1ToL2MessageTree.root}},t={hints:e,enqueuedCalls:[],publicInputs:{dummy:[]}};for(const t of this.avmHints.contractBytecodeHints.values())e.contractInstances.push(t.contractInstanceHint),e.contractClasses.push({artifactHash:t.contractClassHint.artifactHash,privateFunctionsRoot:t.contractClassHint.privateFunctionsRoot,publicBytecodeCommitment:t.contractClassHint.publicBytecodeCommitment,packedBytecode:t.bytecode});for(const e of this.avmHints.enqueuedCalls.items)t.enqueuedCalls.push({contractAddress:e.contractAddress,sender:new si(0),args:e.calldata.items,isStatic:!1});const n=(s=t,Xf({Class:si,write:e=>e.toBuffer()}),Xf({Class:ii,write:e=>e.toBuffer()}),Xf({Class:Gc,write:e=>e.toField()}),Xf({Class:ih,write:e=>e.items}),Xf({Class:Ei,write:e=>((0,$d.strict)(!e.inf,"Cannot serialize infinity"),{x:new ii(e.x.toBigInt()),y:new ii(e.y.toBigInt())})}),new Vf({useRecords:!1,int64AsType:"bigint"}).encode(s));var s;return n}}class Hh{constructor(e,t,n,s){this.msgSender=e,this.contractAddress=t,this.functionSelector=n,this.isStaticCall=s}static empty(){return new Hh(Gc.ZERO,Gc.ZERO,ed.empty(),!1)}static async random(){return new Hh(await Gc.random(),await Gc.random(),ed.random(),Math.random()>.5)}static get schema(){return zs.object({msgSender:id.AztecAddress,contractAddress:id.AztecAddress,functionSelector:id.FunctionSelector,isStaticCall:zs.boolean()}).transform(Hh.from)}isEmpty(){return this.msgSender.isZero()&&this.contractAddress.isZero()&&this.functionSelector.isEmpty()&&!this.isStaticCall}static from(e){return new Hh(...Hh.getFields(e))}static getFields(e){return[e.msgSender,e.contractAddress,e.functionSelector,e.isStaticCall]}toBuffer(){return _i(...Hh.getFields(this))}toFields(){const e=gi(...Hh.getFields(this));if(4!==e.length)throw new Error(`Invalid number of fields for CallContext. Expected 4, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new Hh(t.readObject(Gc),t.readObject(Gc),t.readObject(ed),t.readBoolean())}static fromFields(e){const t=vi.asReader(e);return new Hh(t.readObject(Gc),t.readObject(Gc),t.readObject(ed),t.readBoolean())}equals(e){return e.msgSender.equals(this.msgSender)&&e.contractAddress.equals(this.contractAddress)&&e.functionSelector.equals(this.functionSelector)&&e.isStaticCall===this.isStaticCall}[f.inspect.custom](){return`CallContext {\n      msgSender: ${this.msgSender}\n      contractAddress: ${this.contractAddress}\n      functionSelector: ${this.functionSelector}\n      isStaticCall: ${this.isStaticCall}\n    }`}}var Uh=i(8891).Buffer;class Rh{constructor(e,t){this.clientIvcProofBuffer=e,this.clientIvcVkBuffer=t}isEmpty(){return 0===this.clientIvcProofBuffer.length}static empty(){return new Rh(Uh.from(""),Uh.from(""))}static fake(e=Math.floor(255*Math.random())){return new Rh(Uh.alloc(1,e),Uh.alloc(1,e))}static get schema(){return Qs(Rh)}toJSON(){return this.toBuffer()}static fromBuffer(e){const t=Js.asReader(e);return new Rh(t.readBuffer(),t.readBuffer())}toBuffer(){return _i(this.clientIvcProofBuffer.length,this.clientIvcProofBuffer,this.clientIvcVkBuffer.length,this.clientIvcVkBuffer)}}var Gh=i(8891).Buffer;class Zh{constructor(e,t,n){this.address=e,this.publicKeys=t,this.partialAddress=n}static async create(e,t,n){const s=new Zh(e,t,n);return await s.validate(),s}static get schema(){return Ys(Zh)}toJSON(){return this.toString()}static async random(){return await this.fromSecretKeyAndPartialAddress(si.random(),si.random())}static async fromSecretKeyAndPartialAddress(e,t){const{publicKeys:n}=await Wd(e),s=await Jd(n,t);return new Zh(s,n,t)}async getPreaddress(){return Zd(await this.publicKeys.hash(),this.partialAddress)}static async fromSecretKeyAndInstance(e,t){const n=await qd(t);return Zh.fromSecretKeyAndPartialAddress(e,n)}async validate(){const e=await Jd(this.publicKeys,this.partialAddress);if(!e.equals(this.address))throw new Error(`Address cannot be derived from public keys and partial address (received ${this.address.toString()}, derived ${e.toString()})`)}toReadableString(){return`Address: ${this.address.toString()}\nMaster Nullifier Public Key: ${this.publicKeys.masterNullifierPublicKey.toString()}\nMaster Incoming Viewing Public Key: ${this.publicKeys.masterIncomingViewingPublicKey.toString()}\nMaster Outgoing Viewing Public Key: ${this.publicKeys.masterOutgoingViewingPublicKey.toString()}\nMaster Tagging Public Key: ${this.publicKeys.masterTaggingPublicKey.toString()}\nPartial Address: ${this.partialAddress.toString()}\n`}equals(e){return this.address.equals(e.address)&&this.publicKeys.equals(e.publicKeys)&&this.partialAddress.equals(e.partialAddress)}toBuffer(){return _i([this.address,this.publicKeys,this.partialAddress])}static fromBuffer(e){const t=Js.asReader(e),n=t.readObject(Gc),s=t.readObject(Rd),i=t.readObject(si);return Zh.create(n,s,i)}static fromString(e){return Zh.fromBuffer(Gh.from(e.replace(/^0x/i,""),"hex"))}toString(){return Ds(this.toBuffer())}}Zh.SIZE_IN_BYTES=320;var Jh=i(8891).Buffer;const Xh=32;class Wh{constructor(e,t,n,s){if(this.numTxs=e,this.blobsHash=t,this.inHash=n,this.outHash=s,t.length!==Xh)throw new Error("blobsHash buffer must be 32 bytes");if(0!==t[0])throw new Error("blobsHash buffer should be truncated and left padded");if(n.length!==Xh)throw new Error("inHash buffer must be 32 bytes");if(0!==n[0])throw new Error("inHash buffer should be truncated and left padded");if(s.length!==Xh)throw new Error("outHash buffer must be 32 bytes");if(0!==s[0])throw new Error("outHash buffer should be truncated and left padded")}static get schema(){return zs.object({numTxs:id.Fr,blobsHash:id.Buffer,inHash:id.Buffer,outHash:id.Buffer}).transform((({numTxs:e,blobsHash:t,inHash:n,outHash:s})=>new Wh(e,t,n,s)))}getSize(){return this.toBuffer().length}toBuffer(){return _i(this.numTxs,this.blobsHash,this.inHash,this.outHash)}toInspect(){return{numTxs:this.numTxs.toNumber(),blobsHash:Ds(this.blobsHash),inHash:Ds(this.inHash),outHash:Ds(this.outHash)}}toFields(){const e=[this.numTxs,si.fromBuffer(this.blobsHash),si.fromBuffer(this.inHash),si.fromBuffer(this.outHash)];if(4!==e.length)throw new Error(`Expected content commitment to have 4 fields, but it has ${e.length} fields`);return e}static fromBuffer(e){const t=Js.asReader(e);return new Wh(t.readObject(si),t.readBytes(Xh),t.readBytes(Xh),t.readBytes(Xh))}static fromFields(e){const t=vi.asReader(e);return new Wh(t.readField(),t.readField().toBuffer(),t.readField().toBuffer(),t.readField().toBuffer())}static empty(){return new Wh(si.zero(),Jh.alloc(Xh),Jh.alloc(Xh),Jh.alloc(Xh))}isEmpty(){return this.numTxs.isZero()&&this.blobsHash.equals(Jh.alloc(Xh))&&this.inHash.equals(Jh.alloc(Xh))&&this.outHash.equals(Jh.alloc(Xh))}toString(){return Ds(this.toBuffer())}static fromString(e){const t=Jh.from(e.replace(/^0x/i,""),"hex");return Wh.fromBuffer(t)}equals(e){return this.inHash.equals(e.inHash)&&this.outHash.equals(e.outHash)&&this.numTxs.equals(e.numTxs)&&this.blobsHash.equals(e.blobsHash)}}class Vh{constructor(e,t,n){this.noteHashTree=e,this.nullifierTree=t,this.publicDataTree=n}static get schema(){return zs.object({noteHashTree:Mh.schema,nullifierTree:Mh.schema,publicDataTree:Mh.schema}).transform((({noteHashTree:e,nullifierTree:t,publicDataTree:n})=>new Vh(e,t,n)))}getSize(){return this.noteHashTree.getSize()+this.nullifierTree.getSize()+this.publicDataTree.getSize()}static fromBuffer(e){const t=Js.asReader(e);return new Vh(t.readObject(Mh),t.readObject(Mh),t.readObject(Mh))}static fromFields(e){const t=vi.asReader(e),n=Mh.fromFields(t),s=Mh.fromFields(t),i=Mh.fromFields(t);return new Vh(n,s,i)}static empty(){return new Vh(Mh.zero(),Mh.zero(),Mh.zero())}toBuffer(){return _i(this.noteHashTree,this.nullifierTree,this.publicDataTree)}toFields(){const e=[...this.noteHashTree.toFields(),...this.nullifierTree.toFields(),...this.publicDataTree.toFields()];if(6!==e.length)throw new Error(`Invalid number of fields for PartialStateReference. Expected 6, got ${e.length}`);return e}isEmpty(){return this.noteHashTree.isZero()&&this.nullifierTree.isZero()&&this.publicDataTree.isZero()}equals(e){return this.noteHashTree.equals(e.noteHashTree)&&this.nullifierTree.equals(e.nullifierTree)&&this.publicDataTree.equals(e.publicDataTree)}}class qh{constructor(e,t){this.l1ToL2MessageTree=e,this.partial=t}static get schema(){return zs.object({l1ToL2MessageTree:Mh.schema,partial:Vh.schema}).transform((({l1ToL2MessageTree:e,partial:t})=>new qh(e,t)))}getSize(){return this.l1ToL2MessageTree.getSize()+this.partial.getSize()}toBuffer(){return _i(this.l1ToL2MessageTree,this.partial)}toFields(){const e=[...this.l1ToL2MessageTree.toFields(),...this.partial.toFields()];if(8!==e.length)throw new Error(`Invalid number of fields for StateReference. Expected 8, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new qh(t.readObject(Mh),t.readObject(Vh))}static fromFields(e){const t=vi.asReader(e),n=Mh.fromFields(t),s=Vh.fromFields(t);return new qh(n,s)}static empty(){return new qh(Mh.zero(),Vh.empty())}isEmpty(){return this.l1ToL2MessageTree.isZero()&&this.partial.isEmpty()}toInspect(){return{l1ToL2MessageTree:this.l1ToL2MessageTree.root.toString(),noteHashTree:this.partial.noteHashTree.root.toString(),nullifierTree:this.partial.nullifierTree.root.toString(),publicDataTree:this.partial.publicDataTree.root.toString()}}[f.inspect.custom](){return`StateReference {\n  l1ToL2MessageTree: ${(0,f.inspect)(this.l1ToL2MessageTree)},\n  noteHashTree: ${(0,f.inspect)(this.partial.noteHashTree)},\n  nullifierTree: ${(0,f.inspect)(this.partial.nullifierTree)},\n  publicDataTree: ${(0,f.inspect)(this.partial.publicDataTree)},\n}`}equals(e){return this.l1ToL2MessageTree.root.equals(e.l1ToL2MessageTree.root)&&this.partial.equals(e.partial)}}class Kh{constructor(e,t,n,s,i,r){this.lastArchive=e,this.contentCommitment=t,this.state=n,this.globalVariables=s,this.totalFees=i,this.totalManaUsed=r}static get schema(){return zs.object({lastArchive:Mh.schema,contentCommitment:Wh.schema,state:qh.schema,globalVariables:bh.schema,totalFees:id.Fr,totalManaUsed:id.Fr}).transform(Kh.from)}static getFields(e){return[e.lastArchive,e.contentCommitment,e.state,e.globalVariables,e.totalFees,e.totalManaUsed]}static from(e){return new Kh(...Kh.getFields(e))}getSize(){return this.lastArchive.getSize()+this.contentCommitment.getSize()+this.state.getSize()+this.globalVariables.getSize()+this.totalFees.size+this.totalManaUsed.size}toBuffer(){return _i(...Kh.getFields(this))}toFields(){const e=gi(...Kh.getFields(this));if(25!==e.length)throw new Error(`Invalid number of fields for Header. Expected 25, got ${e.length}`);return e}clone(){return Kh.fromBuffer(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new Kh(t.readObject(Mh),t.readObject(Wh),t.readObject(qh),t.readObject(bh),t.readObject(si),t.readObject(si))}static fromFields(e){const t=vi.asReader(e);return new Kh(Mh.fromFields(t),Wh.fromFields(t),qh.fromFields(t),bh.fromFields(t),t.readField(),t.readField())}static empty(e={}){return Kh.from({lastArchive:Mh.zero(),contentCommitment:Wh.empty(),state:qh.empty(),globalVariables:bh.empty(),totalFees:si.ZERO,totalManaUsed:si.ZERO,...e})}isEmpty(){return this.lastArchive.isZero()&&this.contentCommitment.isEmpty()&&this.state.isEmpty()&&this.globalVariables.isEmpty()&&this.totalFees.isZero()&&this.totalManaUsed.isZero()}toString(){return Ds(this.toBuffer())}static fromString(e){return Kh.fromBuffer(Os(e))}hash(){return wi(this.toFields(),Ri.BLOCK_HASH)}toInspect(){return{lastArchive:this.lastArchive.root.toString(),contentCommitment:this.contentCommitment.toInspect(),state:this.state.toInspect(),globalVariables:this.globalVariables.toInspect(),totalFees:this.totalFees.toBigInt(),totalManaUsed:this.totalManaUsed.toBigInt()}}[f.inspect.custom](){return`Header {\n  lastArchive: ${(0,f.inspect)(this.lastArchive)},\n  contentCommitment.numTxs: ${this.contentCommitment.numTxs.toNumber()},\n  contentCommitment.blobsHash: ${this.contentCommitment.blobsHash.toString("hex")},\n  contentCommitment.inHash: ${this.contentCommitment.inHash.toString("hex")},\n  contentCommitment.outHash: ${this.contentCommitment.outHash.toString("hex")},\n  state.l1ToL2MessageTree: ${(0,f.inspect)(this.state.l1ToL2MessageTree)},\n  state.noteHashTree: ${(0,f.inspect)(this.state.partial.noteHashTree)},\n  state.nullifierTree: ${(0,f.inspect)(this.state.partial.nullifierTree)},\n  state.publicDataTree: ${(0,f.inspect)(this.state.partial.publicDataTree)},\n  globalVariables: ${(0,f.inspect)(this.globalVariables)},\n  totalFees: ${this.totalFees},\n  totalManaUsed: ${this.totalManaUsed},\n}`}equals(e){return this.contentCommitment.equals(e.contentCommitment)&&this.state.equals(e.state)&&this.globalVariables.equals(e.globalVariables)&&this.totalFees.equals(e.totalFees)&&this.totalManaUsed.equals(e.totalManaUsed)&&this.lastArchive.equals(e.lastArchive)}}class $h{constructor(e,t,n){this.gasSettings=n,this.chainId=new si(e),this.version=new si(t)}static get schema(){return zs.object({chainId:id.Fr,version:id.Fr,gasSettings:mh.schema}).transform($h.from)}getSize(){return this.chainId.size+this.version.size+this.gasSettings.getSize()}clone(){return new $h(this.chainId,this.version,this.gasSettings.clone())}toBuffer(){return _i(...$h.getFields(this))}static fromFields(e){const t=vi.asReader(e);return new $h(t.readField(),t.readField(),t.readObject(mh))}toFields(){const e=gi(...$h.getFields(this));if(10!==e.length)throw new Error(`Invalid number of fields for TxContext. Expected 10, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new $h(si.fromBuffer(t),si.fromBuffer(t),t.readObject(mh))}static empty(e=0,t=0){return new $h(new si(e),new si(t),mh.empty())}isEmpty(){return this.chainId.isZero()&&this.version.isZero()&&this.gasSettings.isEmpty()}static from(e){return new $h(...$h.getFields(e))}static getFields(e){return[e.chainId,e.version,e.gasSettings]}}class ep{constructor(e,t){this.selector=e,this.isPrivate=t}static async fromAbi(e){return new ep(await ed.fromNameAndParameters(e.name,e.parameters),e.functionType===hd.PRIVATE)}static get schema(){return zs.object({selector:id.FunctionSelector,isPrivate:zs.boolean()}).transform((({selector:e,isPrivate:t})=>new ep(e,t)))}toBuffer(){return _i(this.selector,this.isPrivate)}toFields(){const e=[this.selector.toField(),new si(this.isPrivate)];if(2!==e.length)throw new Error(`Invalid number of fields for FunctionData. Expected 2, got ${e.length}`);return e}isEmpty(){return this.selector.isEmpty()}equals(e){return this.selector.equals(e.selector)&&this.isPrivate===e.isPrivate}static empty(e){return new ep(ed.empty(),e?.isPrivate??!1)}static fromBuffer(e){const t=Js.asReader(e);return new ep(t.readObject(ed),t.readBoolean())}static fromFields(e){const t=vi.asReader(e),n=ed.fromFields(t),s=t.readBoolean();return new ep(n,s)}}var tp=i(8891).Buffer;class np{constructor(e,t,n){this.value=e,this.counter=t,this.length=n}toFields(){return[this.value,new si(this.counter),this.length]}static fromFields(e){const t=vi.asReader(e);return new np(t.readField(),t.readU32(),t.readField())}isEmpty(){return this.value.isZero()&&this.length.isZero()&&!this.counter}static empty(){return new np(si.zero(),0,si.zero())}toBuffer(){return _i(this.value,this.counter,this.length)}static fromBuffer(e){const t=Js.asReader(e);return new np(si.fromBuffer(t),t.readNumber(),si.fromBuffer(t))}toString(){return`value=${this.value} counter=${this.counter} length=${this.length}`}scope(e){return new sp(this,e)}[f.inspect.custom](){return`LogHash { ${this.toString()} }`}}class sp{constructor(e,t){this.logHash=e,this.contractAddress=t}get counter(){return this.logHash.counter}get value(){return this.logHash.value}toFields(){return[...this.logHash.toFields(),this.contractAddress.toField()]}static fromFields(e){const t=vi.asReader(e);return new sp(t.readObject(np),Gc.fromField(t.readField()))}isEmpty(){return this.logHash.isEmpty()&&this.contractAddress.isZero()}static empty(){return new sp(np.empty(),Gc.ZERO)}toBuffer(){return _i(this.logHash,this.contractAddress)}static fromBuffer(e){const t=Js.asReader(e);return new sp(np.fromBuffer(t),Gc.fromBuffer(t))}toString(){return`logHash=${this.logHash} contractAddress=${this.contractAddress}`}getSiloedHash(){return dl(tp.concat([this.contractAddress.toBuffer(),this.value.toBuffer()]))}}class ip{constructor(e){this.fields=e}toFields(){return this.fields}static fromFields(e){const t=vi.asReader(e);return new ip(t.readFieldArray(Pi))}isEmpty(){return this.fields.every((e=>e.isZero()))}static empty(){return new ip(uh(Pi,si.zero))}toBuffer(){return _i(this.fields)}static fromBuffer(e){const t=Js.asReader(e);return new ip(t.readArray(Pi,si))}static random(){return new ip(uh(Pi,si.random))}static get schema(){return zs.object({fields:zs.array(id.Fr)}).transform((({fields:e})=>ip.fromFields(e)))}[f.inspect.custom](){return`PrivateLog {\n      fields: [${this.fields.map((e=>(0,f.inspect)(e))).join(", ")}],\n    }`}}ip.SIZE_IN_BYTES=si.SIZE_IN_BYTES*Pi;class rp{constructor(e,t,n,s,i,r){this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=n,this.privateLogs=s,this.contractClassLogsHashes=i,this.contractClassLogPreimagesLength=r}getSize(){return Me(this.noteHashes)+Me(this.nullifiers)+Me(this.l2ToL1Msgs)+Me(this.privateLogs)+Me(this.contractClassLogsHashes)+this.contractClassLogPreimagesLength.size}static getFields(e){return[e.noteHashes,e.nullifiers,e.l2ToL1Msgs,e.privateLogs,e.contractClassLogsHashes,e.contractClassLogPreimagesLength]}static from(e){return new rp(...rp.getFields(e))}static get schema(){return Qs(rp)}toJSON(){return this.toBuffer()}toBuffer(){return _i(...rp.getFields(this))}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new rp(t.readArray(Di,si),t.readArray(Li,si),t.readArray(8,Ah),t.readArray(Ni,ip),t.readArray(1,sp),si.fromBuffer(t))}static fromString(e){return rp.fromBuffer(Os(e))}static empty(){return new rp(uh(Di,si.zero),uh(Li,si.zero),uh(8,Ah.empty),uh(Ni,ip.empty),uh(1,sp.empty),si.zero())}toFields(){const e=gi(...rp.getFields(this));if(741!==e.length)throw new Error(`Invalid number of fields for PrivateToRollupAccumulatedData. Expected 741, got ${e.length}`);return e}[f.inspect.custom](){return`PrivateToRollupAccumulatedData {\n      noteHashes: [${this.noteHashes.filter((e=>!e.isZero())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      nullifiers: [${this.nullifiers.filter((e=>!e.isZero())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      l2ToL1Msgs: [${this.l2ToL1Msgs.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      privateLogs:  [${this.privateLogs.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}]\n      contractClassLogsHashes: : [${this.contractClassLogsHashes.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      contractClassLogPreimagesLength: ${this.contractClassLogPreimagesLength.toString()},\n    }`}}class ap{constructor(e,t,n,s,i){this.historicalHeader=e,this.txContext=t,this.vkTreeRoot=n,this.protocolContractTreeRoot=s,this.globalVariables=i}static combine(e,t){return new ap(e.historicalHeader,e.txContext,e.vkTreeRoot,e.protocolContractTreeRoot,t)}static get schema(){return zs.object({historicalHeader:Kh.schema,txContext:$h.schema,vkTreeRoot:id.Fr,protocolContractTreeRoot:id.Fr,globalVariables:bh.schema}).transform(ap.from).or(Ys(ap))}toBuffer(){return _i(this.historicalHeader,this.txContext,this.vkTreeRoot,this.protocolContractTreeRoot,this.globalVariables)}clone(){return ap.fromBuffer(this.toBuffer())}getSize(){return this.historicalHeader.getSize()+this.txContext.getSize()+this.vkTreeRoot.size+this.protocolContractTreeRoot.size+this.globalVariables.getSize()}static from({historicalHeader:e,txContext:t,vkTreeRoot:n,protocolContractTreeRoot:s,globalVariables:i}){return new ap(e,t,n,s,i)}static fromBuffer(e){const t=Js.asReader(e);return new ap(t.readObject(Kh),t.readObject($h),si.fromBuffer(t),si.fromBuffer(t),t.readObject(bh))}static fromFields(e){const t=vi.asReader(e);return new ap(t.readObject(Kh),t.readObject($h),t.readField(),t.readField(),t.readObject(bh))}static empty(){return new ap(Kh.empty(),$h.empty(),si.ZERO,si.ZERO,bh.empty())}}class op{constructor(e,t){this.isSome=e,this.value=t}toBuffer(){return _i(...op.getFields(this))}toFields(){const e=gi(...op.getFields(this));if(2!==e.length)throw new Error(`Invalid number of fields for MaxBlockNumber. Expected 2, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new op(t.readBoolean(),si.fromBuffer(t))}static fromFields(e){const t=vi.asReader(e);return new op(t.readBoolean(),t.readField())}static empty(){return new op(!1,si.ZERO)}isEmpty(){return!this.isSome&&this.value.isZero()}static from(e){return new op(...op.getFields(e))}static getFields(e){return[e.isSome,e.value]}}class lp{constructor(e){this.maxBlockNumber=e}getSize(){return this.toBuffer().length}toBuffer(){return _i(this.maxBlockNumber)}toString(){return Ds(this.toBuffer())}static getFields(e){return[e.maxBlockNumber]}static fromFields(e){const t=vi.asReader(e);return new lp(op.fromFields(t))}toFields(){const e=gi(...lp.getFields(this));if(2!==e.length)throw new Error(`Invalid number of fields for RollupValidationRequests. Expected 2, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new lp(t.readObject(op))}static fromString(e){return lp.fromBuffer(Os(e))}static empty(){return new lp(op.empty())}}class cp{constructor(e,t,n,s){this.historicalHeader=e,this.txContext=t,this.vkTreeRoot=n,this.protocolContractTreeRoot=s}static from(e){return new cp(...cp.getFields(e))}static getFields(e){return[e.historicalHeader,e.txContext,e.vkTreeRoot,e.protocolContractTreeRoot]}static fromFields(e){const t=vi.asReader(e);return new cp(t.readObject(Kh),t.readObject($h),t.readField(),t.readField())}toFields(){const e=gi(...cp.getFields(this));if(37!==e.length)throw new Error(`Invalid number of fields for TxConstantData. Expected 37, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new cp(t.readObject(Kh),t.readObject($h),si.fromBuffer(t),si.fromBuffer(t))}toBuffer(){return _i(...cp.getFields(this))}static empty(){return new cp(Kh.empty(),$h.empty(),si.ZERO,si.ZERO)}getSize(){return this.historicalHeader.getSize()+this.txContext.getSize()+this.vkTreeRoot.size+this.protocolContractTreeRoot.size}clone(){return cp.fromBuffer(this.toBuffer())}}class dp{constructor(e,t,n,s,i){this.constants=e,this.rollupValidationRequests=t,this.end=n,this.gasUsed=s,this.feePayer=i}getNonEmptyNullifiers(){return this.end.nullifiers.filter((e=>!e.isZero()))}toBuffer(){return _i(this.constants,this.rollupValidationRequests,this.end,this.gasUsed,this.feePayer)}static fromBuffer(e){const t=Js.asReader(e);return new dp(t.readObject(cp),t.readObject(lp),t.readObject(rp),t.readObject(hh),t.readObject(Gc))}static empty(){return new dp(cp.empty(),lp.empty(),rp.empty(),hh.empty(),Gc.ZERO)}toString(){return Ds(this.toBuffer())}static fromString(e){return dp.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static getFields(e){return[e.constants,e.rollupValidationRequests,e.end,e.gasUsed,e.feePayer]}static get schema(){return Qs(dp)}toFields(){const e=gi(...dp.getFields(this));if(783!==e.length)throw new Error(`Invalid number of fields for PrivateToRollupKernelCircuitPublicInputs. Expected 783, got ${e.length}`);return e}hash(){return wi(this.toFields(),Ri.PRIVATE_TX_HASH)}}class up{constructor(e,t){this.value=e,this.counter=t}toFields(){return[this.value,new si(this.counter)]}static fromFields(e){const t=vi.asReader(e);return new up(t.readField(),t.readU32())}isEmpty(){return this.value.isZero()&&!this.counter}static empty(){return new up(si.zero(),0)}toBuffer(){return _i(this.value,this.counter)}static fromBuffer(e){const t=Js.asReader(e);return new up(si.fromBuffer(t),t.readNumber())}toString(){return`value=${this.value} counter=${this.counter}`}scope(e){return new fp(this,e)}}class fp{constructor(e,t){this.noteHash=e,this.contractAddress=t}get counter(){return this.noteHash.counter}get value(){return this.noteHash.value}toFields(){return[...this.noteHash.toFields(),this.contractAddress.toField()]}static fromFields(e){const t=vi.asReader(e);return new fp(t.readObject(up),Gc.fromField(t.readField()))}isEmpty(){return this.noteHash.isEmpty()&&this.contractAddress.isZero()}static empty(){return new fp(up.empty(),Gc.ZERO)}toBuffer(){return _i(this.noteHash,this.contractAddress)}static fromBuffer(e){const t=Js.asReader(e);return new fp(up.fromBuffer(t),Gc.fromBuffer(t))}toString(){return`noteHash=${this.noteHash} contractAddress=${this.contractAddress}`}}class hp{constructor(e,t,n){this.value=e,this.counter=t,this.noteHash=n}toFields(){return[this.value,new si(this.counter),this.noteHash]}static fromFields(e){const t=vi.asReader(e);return new hp(t.readField(),t.readU32(),t.readField())}isEmpty(){return this.value.isZero()&&!this.counter&&this.noteHash.isZero()}static empty(){return new hp(si.zero(),0,si.zero())}toBuffer(){return _i(this.value,this.counter,this.noteHash)}static fromBuffer(e){const t=Js.asReader(e);return new hp(si.fromBuffer(t),t.readNumber(),si.fromBuffer(t))}toString(){return`value=${this.value} counter=${this.counter} noteHash=${this.noteHash}`}scope(e){return new pp(this,e)}}class pp{constructor(e,t){this.nullifier=e,this.contractAddress=t}get counter(){return this.nullifier.counter}get value(){return this.nullifier.value}get nullifiedNoteHash(){return this.nullifier.noteHash}toFields(){return[...this.nullifier.toFields(),this.contractAddress.toField()]}static fromFields(e){const t=vi.asReader(e);return new pp(t.readObject(hp),Gc.fromField(t.readField()))}isEmpty(){return this.nullifier.isEmpty()&&this.contractAddress.isZero()}static empty(){return new pp(hp.empty(),Gc.ZERO)}toBuffer(){return _i(this.nullifier,this.contractAddress)}static fromBuffer(e){const t=Js.asReader(e);return new pp(hp.fromBuffer(t),Gc.fromBuffer(t))}toString(){return`nullifier=${this.nullifier} contractAddress=${this.contractAddress}`}}class mp{constructor(e,t,n,s,i){this.callContext=e,this.argsHash=t,this.returnsHash=n,this.startSideEffectCounter=s,this.endSideEffectCounter=i}toFields(){return gi([this.callContext,this.argsHash,this.returnsHash,this.startSideEffectCounter,this.endSideEffectCounter])}static fromFields(e){const t=vi.asReader(e);return new mp(t.readObject(Hh),t.readField(),t.readField(),t.readU32(),t.readU32())}toBuffer(){return _i(this.callContext,this.argsHash,this.returnsHash,this.startSideEffectCounter,this.endSideEffectCounter)}static fromBuffer(e){const t=Js.asReader(e);return new mp(t.readObject(Hh),si.fromBuffer(t),si.fromBuffer(t),t.readNumber(),t.readNumber())}isEmpty(){return this.callContext.isEmpty()&&this.argsHash.isZero()&&this.returnsHash.isZero()&&0===this.startSideEffectCounter&&0===this.endSideEffectCounter}static empty(){return new mp(Hh.empty(),si.ZERO,si.ZERO,0,0)}equals(e){return e.callContext.equals(this.callContext)&&e.argsHash.equals(this.argsHash)&&e.returnsHash.equals(this.returnsHash)&&e.startSideEffectCounter===this.startSideEffectCounter&&e.endSideEffectCounter===this.endSideEffectCounter}toString(){return`PrivateCallRequest(callContext: ${this.callContext}, argsHash: ${this.argsHash}, returnsHash: ${this.returnsHash}, startSideEffectCounter: ${this.startSideEffectCounter}, endSideEffectCounter: ${this.endSideEffectCounter})`}}class gp{constructor(e,t,n){this.log=e,this.noteHashCounter=t,this.counter=n}static from(e){return new gp(...gp.getFields(e))}static getFields(e){return[e.log,e.noteHashCounter,e.counter]}static fromFields(e){const t=vi.asReader(e);return new gp(t.readObject(ip),t.readU32(),t.readU32())}toFields(){const e=gi(...gp.getFields(this));if(20!==e.length)throw new Error(`Invalid number of fields for PrivateLogData. Expected 20, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new gp(t.readObject(ip),t.readNumber(),t.readNumber())}toBuffer(){return _i(...gp.getFields(this))}static empty(){return new gp(ip.empty(),0,0)}isEmpty(){return this.log.isEmpty()&&!this.noteHashCounter&&!this.counter}[f.inspect.custom](){return`PrivateLogData {\n      log: ${this.log}\n      noteHashCounter: ${this.noteHashCounter}\n      counter: ${this.counter}\n    }`}}f.inspect.custom;class _p{constructor(e,t,n){this.leafIndex=t,this.siblingPath=n,function(e,t,n){if(e[t].length!==n)throw new Error(`Expected ${t} to have length ${n} but was ${e[t].length}`)}(this,"siblingPath",e)}toBuffer(){return _i(m(this.leafIndex,32),...this.siblingPath)}static random(e){return new _p(e,0n,Array(e).fill(0).map((()=>si.random())))}static empty(e,t=0n){const n=Array(e).fill(0).map((()=>si.ZERO));return new _p(e,t,n)}static fromBufferArray(e,t){return new _p(t.length,e,t.map((e=>si.fromBuffer(e))))}static fromBuffer(e,t){const n=Js.asReader(e),s=p(n.readBytes(32)),i=n.readArray(t,si);return new _p(t,s,i)}static deserializer(e){return{fromBuffer:t=>{const n=Js.asReader(t),s=p(n.readBytes(32)),i=n.readArray(e,si);return new _p(e,s,i)}}}}function bp(e){return e.reduce(((e,t,n)=>{if(!t.isEmpty()){if(e!==n)throw new Error("Non-empty items must be placed continuously from index 0.");return e+1}return e}),0)}function yp(e,t,n=e.length){const s=bp(e),i=bp(t);if(s+i>n)throw new Error("Combined non-empty items exceeded the maximum allowed.");const r=[...e];return t.slice(0,i).forEach(((e,t)=>r[t+s]=e)),r}function Ap(e,t){return e.counter-t.counter}function wp(e,t=!0){return function(e,t,n=!0){return[...e].sort(((e,s)=>e.isEmpty()?1:s.isEmpty()?-1:n?t(e,s):t(s,e)))}(e,Ap,t)}function xp(e){return e.every((e=>e.isEmpty()))}class vp{constructor(e,t){this.pkM=e,this.skApp=t instanceof si?t:new si(t.toBigInt())}toBuffer(){return _i(this.pkM,this.skApp)}get skAppAsGrumpkinScalar(){return new ai(this.skApp.toBigInt())}static fromBuffer(e){const t=Js.asReader(e);return new vp(Ei.fromBuffer(t),si.fromBuffer(t))}toFields(){const e=[this.pkM.toFields(),this.skApp].flat();if(4!==e.length)throw new Error(`Invalid number of fields for KeyValidationRequest. Expected 4, got ${e.length}`);return e}static fromFields(e){const t=vi.asReader(e);return new vp(Ei.fromFields(t),t.readField())}isEmpty(){return this.pkM.isZero()&&this.skApp.isZero()}static empty(){return new vp(Ei.ZERO,si.ZERO)}static async random(){return new vp(await Ei.random(),si.random())}}class Ep{constructor(e,t){this.request=e,this.skAppGenerator=t}toBuffer(){return _i(this.request,this.skAppGenerator)}static fromBuffer(e){const t=Js.asReader(e);return new Ep(t.readObject(vp),si.fromBuffer(t))}toFields(){const e=[...this.request.toFields(),this.skAppGenerator];if(5!==e.length)throw new Error(`Invalid number of fields for KeyValidationRequestAndGenerator. Expected 5, got ${e.length}`);return e}static fromFields(e){const t=vi.asReader(e);return new Ep(vp.fromFields(t),t.readField())}isEmpty(){return this.request.isEmpty()&&this.skAppGenerator.isZero()}static empty(){return new Ep(vp.empty(),si.ZERO)}}class Mp{constructor(e,t){this.value=e,this.counter=t}toBuffer(){return _i(this.value,this.counter)}static fromBuffer(e){const t=Js.asReader(e);return new Mp(si.fromBuffer(t),t.readNumber())}toFields(){return[this.value,new si(this.counter)]}static fromFields(e){const t=vi.asReader(e);return new Mp(t.readField(),t.readU32())}isEmpty(){return this.value.isZero()&&!this.counter}static empty(){return new Mp(si.zero(),0)}scope(e){return new zp(this,e)}}class zp{constructor(e,t){this.readRequest=e,this.contractAddress=t}get value(){return this.readRequest.value}get counter(){return this.readRequest.counter}toBuffer(){return _i(this.readRequest,this.contractAddress)}static fromBuffer(e){const t=Js.asReader(e);return new zp(Mp.fromBuffer(t),Gc.fromBuffer(t))}toFields(){return[...this.readRequest.toFields(),this.contractAddress.toField()]}static fromFields(e){const t=vi.asReader(e);return new zp(t.readObject(Mp),Gc.fromField(t.readField()))}isEmpty(){return this.readRequest.isEmpty()&&this.contractAddress.isZero()}static empty(){return new zp(Mp.empty(),Gc.ZERO)}}class Bp{constructor(e,t,n,s,i,r,a,o,l,c,d,u,f,h,p,m,g,_,b,y,A){this.callContext=e,this.argsHash=t,this.returnsHash=n,this.minRevertibleSideEffectCounter=s,this.isFeePayer=i,this.maxBlockNumber=r,this.noteHashReadRequests=a,this.nullifierReadRequests=o,this.keyValidationRequestsAndGenerators=l,this.noteHashes=c,this.nullifiers=d,this.privateCallRequests=u,this.publicCallRequests=f,this.publicTeardownCallRequest=h,this.l2ToL1Msgs=p,this.privateLogs=m,this.contractClassLogsHashes=g,this.startSideEffectCounter=_,this.endSideEffectCounter=b,this.historicalHeader=y,this.txContext=A}static from(e){return new Bp(...Bp.getFields(e))}static fromBuffer(e){const t=Js.asReader(e);return new Bp(t.readObject(Hh),t.readObject(si),t.readObject(si),t.readObject(si),t.readBoolean(),t.readObject(op),t.readArray(16,Mp),t.readArray(16,Mp),t.readArray(16,Ep),t.readArray(16,up),t.readArray(16,hp),t.readArray(5,mp),t.readArray(16,Eh),t.readObject(vh),t.readArray(2,yh),t.readArray(16,gp),t.readArray(1,np),t.readObject(si),t.readObject(si),t.readObject(Kh),t.readObject($h))}static fromFields(e){const t=vi.asReader(e);return new Bp(t.readObject(Hh),t.readField(),t.readField(),t.readField(),t.readBoolean(),t.readObject(op),t.readArray(16,Mp),t.readArray(16,Mp),t.readArray(16,Ep),t.readArray(16,up),t.readArray(16,hp),t.readArray(5,mp),t.readArray(16,Eh),t.readObject(vh),t.readArray(2,yh),t.readArray(16,gp),t.readArray(1,np),t.readField(),t.readField(),t.readObject(Kh),t.readObject($h))}static empty(){return new Bp(Hh.empty(),si.ZERO,si.ZERO,si.ZERO,!1,op.empty(),uh(16,Mp.empty),uh(16,Mp.empty),uh(16,Ep.empty),uh(16,up.empty),uh(16,hp.empty),uh(5,mp.empty),uh(16,Eh.empty),vh.empty(),uh(2,yh.empty),uh(16,gp.empty),uh(1,np.empty),si.ZERO,si.ZERO,Kh.empty(),$h.empty())}isEmpty(){return this.callContext.isEmpty()&&this.argsHash.isZero()&&this.returnsHash.isZero()&&this.minRevertibleSideEffectCounter.isZero()&&!this.isFeePayer&&this.maxBlockNumber.isEmpty()&&xp(this.noteHashReadRequests)&&xp(this.nullifierReadRequests)&&xp(this.keyValidationRequestsAndGenerators)&&xp(this.noteHashes)&&xp(this.nullifiers)&&xp(this.privateCallRequests)&&xp(this.publicCallRequests)&&this.publicTeardownCallRequest.isEmpty()&&xp(this.l2ToL1Msgs)&&xp(this.privateLogs)&&xp(this.contractClassLogsHashes)&&this.startSideEffectCounter.isZero()&&this.endSideEffectCounter.isZero()&&this.historicalHeader.isEmpty()&&this.txContext.isEmpty()}static getFields(e){return[e.callContext,e.argsHash,e.returnsHash,e.minRevertibleSideEffectCounter,e.isFeePayer,e.maxBlockNumber,e.noteHashReadRequests,e.nullifierReadRequests,e.keyValidationRequestsAndGenerators,e.noteHashes,e.nullifiers,e.privateCallRequests,e.publicCallRequests,e.publicTeardownCallRequest,e.l2ToL1Msgs,e.privateLogs,e.contractClassLogsHashes,e.startSideEffectCounter,e.endSideEffectCounter,e.historicalHeader,e.txContext]}toBuffer(){return _i(...Bp.getFields(this))}toFields(){const e=gi(...Bp.getFields(this));if(741!==e.length)throw new Error(`Invalid number of fields for PrivateCircuitPublicInputs. Expected 741, got ${e.length}`);return e}toJSON(){return this.toBuffer()}static get schema(){return Qs(Bp)}}var Fp,kp,Cp=i(8891).Buffer;class Op{constructor(e,t){this.x="bigint"==typeof e?new ii(e):e,this.y="bigint"==typeof t?new ii(t):t}toBuffer(){return _i(this.x,this.y)}static fromBuffer(e){const t=Js.asReader(e);return new Op(ii.fromBuffer(t),ii.fromBuffer(t))}}class Dp{constructor(e){this.record=e}toBuffer(){const e=Object.entries(this.record);return _i(e.length,...e.flat())}static fromBuffer(e){const t=Js.asReader(e);return new Dp(t.readMap(Op))}}class Lp{constructor(e,t){this.key=e,this.hash=t}get numPublicInputs(){return Number(this.key[1])}get circuitSize(){return Number(this.key[0])}get isRecursive(){return this.key[3].equals(si.ONE)}static get schema(){return Qs(Lp)}toJSON(){return this.toBuffer()}toBuffer(){return _i(...this.toFields())}toFields(){return[this.key.length,...this.key,this.hash]}static fromBuffer(e){const t=Js.asReader(e);return new Lp(t.readVector(si),t.readObject(si))}static makeFake(e,t=1){return new Lp(uh(e,si.random,t),si.random())}static makeFakeHonk(e=1){return new Lp(uh(128,si.random,e),si.random())}static makeFakeRollupHonk(e=1){return new Lp(uh(139,si.random,e),si.random())}static makeEmpty(e){return new Lp(uh(e,si.zero),si.zero())}}class Tp{constructor(e,t,n,s,i,r){this.circuitType=e,this.circuitSize=t,this.numPublicInputs=n,this.commitments=s,this.containsRecursiveProof=i,this.recursiveProofPublicInputIndices=r}toBuffer(){return _i(this.circuitType,this.circuitSize,this.numPublicInputs,new Dp(this.commitments),this.containsRecursiveProof,_i(this.recursiveProofPublicInputIndices.length,this.recursiveProofPublicInputIndices))}static fromBuffer(e){const t=Js.asReader(e);return new Tp(t.readNumber(),t.readNumber(),t.readNumber(),t.readObject(Dp).record,t.readBoolean(),t.readNumberVector())}static makeRollupFake(){return new Tp(rh.ULTRA,2048,116,{},!1,ve(16,(e=>e)))}static makeFake(){return new Tp(rh.ULTRA,2048,116,{},!1,ve(16,(e=>e)))}}class Sp{constructor(e,t){this.keyAsFields=e,this.keyAsBytes=t}get numPublicInputs(){return this.keyAsFields.numPublicInputs}get circuitSize(){return this.keyAsFields.circuitSize}get isRecursive(){return this.keyAsFields.isRecursive}static empty(){return new Sp(Lp.makeEmpty(0),Cp.alloc(0))}static makeFakeHonk(){return new Sp(Lp.makeFakeHonk(),Tp.makeFake().toBuffer())}static makeFakeRollupHonk(){return new Sp(Lp.makeFakeRollupHonk(),Tp.makeRollupFake().toBuffer())}static makeFake(e=139){return new Sp(Lp.makeFake(e),Tp.makeFake().toBuffer())}toBuffer(){return _i(this.keyAsFields,this.keyAsBytes.length,this.keyAsBytes)}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e),n=t.readObject(Lp),s=t.readNumber(),i=t.readBytes(s);return new Sp(n,i)}static fromString(e){return Sp.fromBuffer(Os(e))}clone(){return Sp.fromBuffer(this.toBuffer())}toJSON(){return this.toBuffer()}static get schema(){return Qs(Sp)}}f.inspect.custom;class Np{constructor(e,t,n,s){this.origin=e,this.functionData=t,this.argsHash=n,this.txContext=s}static getFields(e){return[e.origin,e.functionData,e.argsHash,e.txContext]}static from(e){return new Np(...Np.getFields(e))}toBuffer(){return _i([...Np.getFields(this)])}toFields(){const e=gi(...Np.getFields(this));if(14!==e.length)throw new Error(`Invalid number of fields for TxRequest. Expected 14, got ${e.length}`);return e}static fromBuffer(e){const t=Js.asReader(e);return new Np(t.readObject(Gc),t.readObject(ep),si.fromBuffer(t),t.readObject($h))}hash(){return wi(this.toFields(),Ri.TX_REQUEST)}static empty(){return new Np(Gc.ZERO,ep.empty(),si.zero(),$h.empty())}isEmpty(){return this.origin.isZero()&&this.functionData.isEmpty()&&this.argsHash.isZero()&&this.txContext.isEmpty()}}(kp=Fp||(Fp={}))[kp.NADA=0]="NADA",kp[kp.PENDING=1]="PENDING",kp[kp.SETTLED=2]="SETTLED";var Pp=i(8891).Buffer;class Ip{constructor(e,t,n,s){this.slot=e,this.value=t,this.nextSlot=n,this.nextIndex=s}static get schema(){return zs.object({slot:id.Fr,value:id.Fr,nextSlot:id.Fr,nextIndex:id.BigInt}).transform((({slot:e,value:t,nextSlot:n,nextIndex:s})=>new Ip(e,t,n,s)))}getKey(){return this.slot.toBigInt()}getNextKey(){return this.nextSlot.toBigInt()}getNextIndex(){return this.nextIndex}asLeaf(){return new Yp(this.slot,this.value)}toBuffer(){return Pp.concat(this.toHashInputs())}toHashInputs(){return[Pp.from(this.slot.toBuffer()),Pp.from(this.value.toBuffer()),Pp.from(m(this.nextIndex,32)),Pp.from(this.nextSlot.toBuffer())]}clone(){return new Ip(this.slot,this.value,this.nextSlot,this.nextIndex)}static random(){return new Ip(si.random(),si.random(),si.random(),BigInt(Math.floor(1e3*Math.random())))}static empty(){return new Ip(si.ZERO,si.ZERO,si.ZERO,0n)}static fromBuffer(e){const t=Js.asReader(e),n=si.fromBuffer(t),s=si.fromBuffer(t),i=p(t.readBytes(32)),r=si.fromBuffer(t);return new Ip(n,s,r,i)}static fromLeaf(e,t,n){return new Ip(e.slot,e.value,new si(t),n)}static clone(e){return new Ip(e.slot,e.value,e.nextSlot,e.nextIndex)}}class Yp{constructor(e,t){this.slot=e,this.value=t}getKey(){return this.slot.toBigInt()}toBuffer(){return _i([this.slot,this.value])}static fromBuffer(e){const t=Js.asReader(e);return new Yp(si.fromBuffer(t),si.fromBuffer(t))}equals(e){return this.slot.equals(e.slot)&&this.value.equals(e.value)}toString(){return`PublicDataTreeLeaf(${this.slot.toString()}, ${this.value.toString()})`}isEmpty(){return this.slot.isZero()&&this.value.isZero()}updateTo(e){if(!this.slot.equals(e.slot))throw new Error("Invalid update: slots do not match");return new Yp(this.slot,e.value)}static buildDummy(e){return new Yp(new si(e),new si(0))}static empty(){return new Yp(si.ZERO,si.ZERO)}}f.inspect.custom;class Qp{constructor(e,t,n,s,i,r){this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=n,this.privateLogs=s,this.contractClassLogsHashes=i,this.publicCallRequests=r}getSize(){return Me(this.noteHashes)+Me(this.nullifiers)+Me(this.l2ToL1Msgs)+Me(this.privateLogs)+Me(this.contractClassLogsHashes)+Me(this.publicCallRequests)}static getFields(e){return[e.noteHashes,e.nullifiers,e.l2ToL1Msgs,e.privateLogs,e.contractClassLogsHashes,e.publicCallRequests]}static fromFields(e){const t=vi.asReader(e);return new this(t.readFieldArray(Di),t.readFieldArray(Li),t.readArray(8,Ah),t.readArray(Ni,ip),t.readArray(1,sp),t.readArray(Ti,vh))}static from(e){return new Qp(...Qp.getFields(e))}static fromBuffer(e){const t=Js.asReader(e);return new Qp(t.readArray(Di,si),t.readArray(Li,si),t.readArray(8,Ah),t.readArray(Ni,ip),t.readArray(1,sp),t.readArray(Ti,vh))}toBuffer(){return _i(...Qp.getFields(this))}toFields(){const e=gi(...Qp.getFields(this));if(900!==e.length)throw new Error(`Invalid number of fields for PrivateToPublicAccumulatedData. Expected 900, got ${e.length}`);return e}static empty(){return new Qp(uh(Di,si.zero),uh(Li,si.zero),uh(8,Ah.empty),uh(Ni,ip.empty),uh(1,sp.empty),uh(Ti,vh.empty))}[f.inspect.custom](){return`PrivateToPublicAccumulatedData {\n      noteHashes: [${this.noteHashes.filter((e=>!e.isZero())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      nullifiers: [${this.nullifiers.filter((e=>!e.isZero())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      l2ToL1Msgs: [${this.l2ToL1Msgs.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      privateLogs: [${this.privateLogs.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      contractClassLogsHashes: [${this.contractClassLogsHashes.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n      publicCallRequests: [${this.publicCallRequests.filter((e=>!e.isEmpty())).map((e=>(0,f.inspect)(e))).join(", ")}],\n    }`}}class jp{constructor(e,t,n,s,i,r,a){this.constants=e,this.rollupValidationRequests=t,this.nonRevertibleAccumulatedData=n,this.revertibleAccumulatedData=s,this.publicTeardownCallRequest=i,this.gasUsed=r,this.feePayer=a}toBuffer(){return _i(this.constants,this.rollupValidationRequests,this.nonRevertibleAccumulatedData,this.revertibleAccumulatedData,this.publicTeardownCallRequest,this.gasUsed,this.feePayer)}static getFields(e){return[e.constants,e.rollupValidationRequests,e.nonRevertibleAccumulatedData,e.revertibleAccumulatedData,e.publicTeardownCallRequest,e.gasUsed,e.feePayer]}static fromBuffer(e){const t=Js.asReader(e);return new jp(t.readObject(cp),t.readObject(lp),t.readObject(Qp),t.readObject(Qp),t.readObject(vh),t.readObject(hh),t.readObject(Gc))}static empty(){return new jp(cp.empty(),lp.empty(),Qp.empty(),Qp.empty(),vh.empty(),hh.empty(),Gc.ZERO)}static fromString(e){return jp.fromBuffer(Os(e))}toString(){return Ds(this.toBuffer())}toFields(){const e=gi(...jp.getFields(this));if(1847!==e.length)throw new Error(`Invalid number of fields for PrivateToPublicKernelCircuitPublicInputs. Expected 1847, got ${e.length}`);return e}hash(){return wi(this.toFields(),Ri.PUBLIC_TX_HASH)}}class Hp{constructor(e,t,n){this.nonRevertibleAccumulatedData=e,this.revertibleAccumulatedData=t,this.publicTeardownCallRequest=n}getSize(){return this.nonRevertibleAccumulatedData.getSize()+this.revertibleAccumulatedData.getSize()+this.publicTeardownCallRequest.getSize()}get needsSetup(){return!this.nonRevertibleAccumulatedData.publicCallRequests[0].isEmpty()}get needsAppLogic(){return!this.revertibleAccumulatedData.publicCallRequests[0].isEmpty()}get needsTeardown(){return!this.publicTeardownCallRequest.isEmpty()}static fromBuffer(e){const t=Js.asReader(e);return new Hp(t.readObject(Qp),t.readObject(Qp),t.readObject(vh))}toBuffer(){return _i(this.nonRevertibleAccumulatedData,this.revertibleAccumulatedData,this.publicTeardownCallRequest)}static empty(){return new Hp(Qp.empty(),Qp.empty(),vh.empty())}}class Up{constructor(e){this.end=e}static fromBuffer(e){const t=Js.asReader(e);return new Up(t.readObject(rp))}getSize(){return this.end.getSize()}toBuffer(){return _i(this.end)}static empty(){return new Up(rp.empty())}}class Rp{constructor(e,t,n,s,i,r){if(this.constants=e,this.rollupValidationRequests=t,this.gasUsed=n,this.feePayer=s,this.forPublic=i,this.forRollup=r,!i&&!r)throw new Error("Missing partial public inputs for private tail circuit.");if(i&&r)throw new Error("Cannot create PrivateKernelTailCircuitPublicInputs that is for both public kernel circuit and rollup circuit.")}static get schema(){return Qs(Rp)}toJSON(){return this.toBuffer()}getSize(){return(this.forPublic?.getSize()??0)+(this.forRollup?.getSize()??0)+this.constants.getSize()+this.rollupValidationRequests.getSize()+this.feePayer.size}toPrivateToPublicKernelCircuitPublicInputs(){if(!this.forPublic)throw new Error("Private tail public inputs is not for public circuit.");return new jp(this.constants,this.rollupValidationRequests,this.forPublic.nonRevertibleAccumulatedData,this.forPublic.revertibleAccumulatedData,this.forPublic.publicTeardownCallRequest,this.gasUsed,this.feePayer)}toPrivateToRollupKernelCircuitPublicInputs(){if(!this.forRollup)throw new Error("Private tail public inputs is not for rollup circuit.");const e=new cp(this.constants.historicalHeader,this.constants.txContext,this.constants.vkTreeRoot,this.constants.protocolContractTreeRoot);return new dp(e,this.rollupValidationRequests,this.forRollup.end,this.gasUsed,this.feePayer)}numberOfPublicCallRequests(){return this.numberOfNonRevertiblePublicCallRequests()+this.numberOfRevertiblePublicCallRequests()+(this.hasTeardownPublicCallRequest()?1:0)}numberOfNonRevertiblePublicCallRequests(){return this.forPublic?bp(this.forPublic.nonRevertibleAccumulatedData.publicCallRequests):0}numberOfRevertiblePublicCallRequests(){return this.forPublic?bp(this.forPublic.revertibleAccumulatedData.publicCallRequests):0}hasTeardownPublicCallRequest(){return!!this.forPublic&&!this.forPublic.publicTeardownCallRequest.isEmpty()}getNonRevertiblePublicCallRequests(){return this.forPublic?this.forPublic.nonRevertibleAccumulatedData.publicCallRequests.filter((e=>!e.isEmpty())):[]}getRevertiblePublicCallRequests(){return this.forPublic?this.forPublic.revertibleAccumulatedData.publicCallRequests.filter((e=>!e.isEmpty())):[]}getTeardownPublicCallRequest(){const e=this.forPublic?.publicTeardownCallRequest;return e?.isEmpty()?void 0:e}getNonEmptyNoteHashes(){return(this.forPublic?yp(this.forPublic.nonRevertibleAccumulatedData.noteHashes,this.forPublic.revertibleAccumulatedData.noteHashes):this.forRollup.end.noteHashes).filter((e=>!e.isZero()))}getNonEmptyNullifiers(){return(this.forPublic?yp(this.forPublic.nonRevertibleAccumulatedData.nullifiers,this.forPublic.revertibleAccumulatedData.nullifiers):this.forRollup.end.nullifiers).filter((e=>!e.isZero()))}getNonEmptyPrivateLogs(){return(this.forPublic?yp(this.forPublic.nonRevertibleAccumulatedData.privateLogs,this.forPublic.revertibleAccumulatedData.privateLogs):this.forRollup.end.privateLogs).filter((e=>!e.isEmpty()))}static fromBuffer(e){const t=Js.asReader(e),n=t.readBoolean();return new Rp(t.readObject(cp),t.readObject(lp),t.readObject(hh),t.readObject(Gc),n?t.readObject(Hp):void 0,n?void 0:t.readObject(Up))}toBuffer(){const e=!!this.forPublic;return _i(e,this.constants,this.rollupValidationRequests,this.gasUsed,this.feePayer,e?this.forPublic.toBuffer():this.forRollup.toBuffer())}static empty(){return new Rp(cp.empty(),lp.empty(),hh.empty(),Gc.ZERO,void 0,Up.empty())}static emptyWithNullifier(){const e=rp.empty();return e.nullifiers[0]=si.random(),new Rp(cp.empty(),lp.empty(),hh.empty(),Gc.ZERO,void 0,new Up(e))}}class Gp{constructor(e,t){this.msgs=e,this.vkTreeRoot=t}static fromSlice(e,t,n){const s=4*t,i=s+4,r=e.slice(s,i);return new Gp(r,n)}toBuffer(){return _i(this.msgs,this.vkTreeRoot)}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new Gp(t.readArray(4,si),si.fromBuffer(t))}static fromString(e){return Gp.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Gp)}}class Zp{constructor(e,t,n){if(this.shaRoot=e,this.convertedRoot=t,this.vkTreeRoot=n,0!=e.toBuffer()[0])throw new Error("shaRoot buffer must be 31 bytes. Got 32 bytes")}toBuffer(){return _i(...Zp.getFields(this))}toString(){return Ds(this.toBuffer())}toJSON(){return this.toBuffer()}static from(e){return new Zp(...Zp.getFields(e))}static getFields(e){return[e.shaRoot,e.convertedRoot,e.vkTreeRoot]}static fromBuffer(e){const t=Js.asReader(e);return new Zp(t.readObject(si),t.readObject(si),si.fromBuffer(t))}static fromString(e){return Zp.fromBuffer(Os(e))}static get schema(){return Qs(Zp)}}var Jp=i(8891).Buffer;const Xp=42;class Wp{constructor(e,t){this.buffer=e,this.numPublicInputs=t,this.metadataOffset=4,this.publicInputsOffset=100}static fromBuffer(e){const t=Js.asReader(e),n=t.readNumber(),s=t.readBytes(n),i=t.readNumber();return new Wp(s,i)}toBuffer(){return _i(this.buffer.length,this.buffer,this.numPublicInputs)}toString(){return Ds(this.toBuffer())}withoutPublicInputs(){return Jp.concat([this.buffer.subarray(this.metadataOffset,this.publicInputsOffset),this.buffer.subarray(this.publicInputsOffset+si.SIZE_IN_BYTES*this.numPublicInputs)])}extractPublicInputs(){return Js.asReader(this.buffer.subarray(this.publicInputsOffset,this.publicInputsOffset+si.SIZE_IN_BYTES*this.numPublicInputs)).readArray(this.numPublicInputs,si)}extractAggregationObject(){return this.extractPublicInputs().slice(-16)}static fromString(e){return Wp.fromBuffer(Os(e))}isEmpty(){return this.buffer.length===Xp&&this.buffer.every((e=>0===e))&&0===this.numPublicInputs}static empty(){return Vp()}}function Vp(){return new Wp(Jp.alloc(Xp,0),0)}class qp{constructor(e,t,n,s){if(this.proof=e,this.binaryProof=t,this.fieldsValid=n,this.proofLength=s,e.length!==s)throw new Error(`Proof length ${e.length} does not match expected length ${s}.`)}static fromBuffer(e,t){const n=Js.asReader(e),s=n.readNumber();if("number"==typeof t&&t!==s)throw new Error(`Expected proof length ${t}, got ${s}`);return new qp(n.readArray(s,si),Wp.fromBuffer(n),n.readBoolean(),s)}toBuffer(){return _i(this.proof.length,this.proof,this.binaryProof,this.fieldsValid)}toString(){return Ds(this.toBuffer())}static fromString(e,t){return qp.fromBuffer(Os(e),t)}toJSON(){return this.toBuffer()}static schemaFor(e){return id.Buffer.transform((t=>qp.fromBuffer(t,e)))}}function Kp(e){return new qp(uh(e,si.zero),Vp(),!0,e)}class $p{constructor(e,t,n,s){this.proof=e,this.verificationKey=t,this.vkPath=n,this.publicInputs=s}toBuffer(){return _i(...$p.getFields(this))}toString(){return Ds(this.toBuffer())}static from(e){return new $p(...$p.getFields(e))}static getFields(e){return[e.proof,e.verificationKey,e.vkPath,e.publicInputs]}static fromBuffer(e,t){const n=Js.asReader(e);return new $p(qp.fromBuffer(n,t),n.readObject(Lp),n.readArray(6,si),n.readObject(Zp))}static fromString(e,t){return $p.fromBuffer(Os(e),t)}toJSON(){return this.toBuffer()}static schemaFor(e){return id.Buffer.transform((t=>$p.fromBuffer(t,e)))}}class em{constructor(e){this.children=e}toBuffer(){return _i(...this.children)}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e),n=Array.from({length:4},(()=>$p.fromBuffer(t,459)));return new em(n)}static fromString(e){return em.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(em)}}var tm,nm=i(8891).Buffer;function sm(e){return e===tm.OK||e===tm.APP_LOGIC_REVERTED||e===tm.TEARDOWN_REVERTED||e===tm.BOTH_REVERTED}!function(e){e[e.OK=0]="OK",e[e.APP_LOGIC_REVERTED=1]="APP_LOGIC_REVERTED",e[e.TEARDOWN_REVERTED=2]="TEARDOWN_REVERTED",e[e.BOTH_REVERTED=3]="BOTH_REVERTED"}(tm||(tm={}));class im{constructor(e){this.code=e.valueOf()}getCode(){return this.code}equals(e){return this.code===e.code}isOK(){return this.equals(im.OK)}getDescription(){switch(this.code){case tm.OK:return"OK";case tm.APP_LOGIC_REVERTED:return"Application logic reverted";case tm.TEARDOWN_REVERTED:return"Teardown reverted";case tm.BOTH_REVERTED:return"Both reverted";default:return`Unknown RevertCode: ${this.code}`}}toJSON(){return this.code}static get schema(){return zs.nativeEnum(tm).transform((e=>new im(e)))}toHashPreimage(){const e=nm.alloc(im.PREIMAGE_SIZE_IN_BYTES-im.PACKED_SIZE_IN_BYTES);return nm.concat([e,this.toBuffer()])}toBuffer(){const e=nm.alloc(im.PACKED_SIZE_IN_BYTES);return e.writeUInt8(this.code,0),e}toField(){return new si(this.toBuffer())}getSerializedLength(){return this.toBuffer().length}static fromField(e){if(!sm(e.toNumber()))throw new Error(`Invalid RevertCode: ${e.toNumber()}`);return new im(e.toNumber())}static fromFields(e){const t=vi.asReader(e);return im.fromField(t.readField())}static fromBuffer(e){const t=Js.asReader(e).readBytes(im.PACKED_SIZE_IN_BYTES).readUInt8(0);if(!sm(t))throw new Error(`Invalid RevertCode: ${t}`);return new im(t)}static random(){return new im(Math.floor(Math.random()*im.NUM_OPTIONS))}[f.inspect.custom](){return`RevertCode<${this.code.toString()}>`}}im.OK=new im(tm.OK),im.APP_LOGIC_REVERTED=new im(tm.APP_LOGIC_REVERTED),im.TEARDOWN_REVERTED=new im(tm.TEARDOWN_REVERTED),im.BOTH_REVERTED=new im(tm.BOTH_REVERTED),im.PREIMAGE_SIZE_IN_BYTES=32,im.PACKED_SIZE_IN_BYTES=1,im.NUM_OPTIONS=4;class rm{constructor(e,t,n,s){this.leafSlot=e,this.value=t,this.membershipWitness=n,this.leafPreimage=s}static empty(){return new rm(si.ZERO,si.ZERO,_p.empty(Ci),Ip.empty())}static fromBuffer(e){const t=Js.asReader(e);return new rm(t.readObject(si),t.readObject(si),_p.fromBuffer(t,Ci),t.readObject(Ip))}toBuffer(){return _i(this.leafSlot,this.value,this.membershipWitness,this.leafPreimage)}}f.inspect.custom,f.inspect.custom;class am{constructor(e,t,n){this.vk=e,this.vkIndex=t,this.vkPath=n}static empty(){return new am(Sp.empty(),0,uh(6,si.zero))}static fromBuffer(e){const t=Js.asReader(e);return new am(t.readObject(Sp),t.readNumber(),t.readArray(6,si))}toBuffer(){return _i(this.vk,this.vkIndex,this.vkPath)}toString(){return Ds(this.toBuffer())}}class om{async encryptBufferCBC(e,t,n){const s=16-e.length%16,i=gh.Buffer.alloc(s);i.fill(s);const r=gh.Buffer.concat([e,i]),a=await c.initSingleton();return gh.Buffer.from(a.aesEncryptBufferCbc(new u(r),new u(t),new u(n),r.length))}async decryptBufferCBC(e,t,n){const s=await c.initSingleton(),i=gh.Buffer.from(s.aesDecryptBufferCbc(new u(e),new u(t),new u(n),e.length)),r=i[i.length-1];return i.subarray(0,i.length-r)}}function lm(e){const t=e.reduce(((e,t)=>e+t.length),0),n=new Uint8Array(t);let s=0;for(const t of e)n.set(t,s),s+=t.length;return n}i(8891).Buffer,i(8891).Buffer;var cm=i(8891).Buffer;class dm{generator(){return dm.generator}async mul(e,t){const n=await c.initSingleton(),[s]=n.getWasm().callWasmExport("ecc_secp256k1__mul",[e,t],[64]);return cm.from(s)}async getRandomFr(){const e=await c.initSingleton(),[t]=e.getWasm().callWasmExport("ecc_secp256k1__get_random_scalar_mod_circuit_modulus",[],[32]);return cm.from(t)}async reduce512BufferToFr(e){const t=await c.initSingleton(),[n]=t.getWasm().callWasmExport("ecc_secp256k1__reduce512_buffer_mod_circuit_modulus",[e],[32]);return cm.from(n)}}dm.generator=cm.from([121,190,102,126,249,220,187,172,85,160,98,149,206,135,11,7,2,155,252,219,45,206,40,217,89,242,129,91,22,248,23,152,72,58,218,119,38,163,196,101,93,164,251,252,14,17,8,168,253,23,180,72,166,133,84,25,156,71,208,143,251,16,212,184]);var um=i(8891).Buffer;class fm{constructor(e){if(this.buffer=e,e.length!==fm.SIZE)throw new Error(`Invalid signature buffer of length ${e.length}.`)}static isSignature(e){return/^(0x)?[0-9a-f]{128}$/i.test(e)}static fromString(e){if(!fm.isSignature(e))throw new Error(`Invalid signature string: ${e}`);return new fm(um.from(e.replace(/^0x/i,""),"hex"))}static random(){return new fm(ot(64))}get s(){return this.buffer.subarray(0,32)}get e(){return this.buffer.subarray(32)}toBuffer(){return this.buffer}static fromBuffer(e){const t=Js.asReader(e);return new fm(t.readBytes(fm.SIZE))}toString(){return`0x${this.buffer.toString("hex")}`}toFields(){const e=this.toBuffer(),t=um.alloc(32),n=um.alloc(32),s=um.alloc(32);return e.copy(t,1,0,31),e.copy(n,1,31,62),e.copy(s,1,62,64),function(e,t){return e.map(t)}([t,n,s],si.fromBuffer)}}fm.SIZE=64,fm.EMPTY=new fm(um.alloc(64));var hm=i(8891).Buffer;class pm{async computePublicKey(e){const t=await c.initSingleton(),[n]=t.getWasm().callWasmExport("schnorr_compute_public_key",[e.toBuffer()],[64]);return Ei.fromBuffer(hm.from(n))}async constructSignature(e,t){const n=await c.initSingleton(),s=lm([ci(e.length),e]),[i,r]=n.getWasm().callWasmExport("schnorr_construct_signature",[s,t.toBuffer()],[32,32]);return new fm(hm.from([...i,...r]))}async verifySignature(e,t,n){const s=await c.initSingleton(),i=lm([ci(e.length),e]),[r]=s.getWasm().callWasmExport("schnorr_verify_signature",[i,t.toBuffer(),n.s,n.e],[1]);return 1===r[0]}}var mm=i(8891).Buffer;function gm(e){return cl(mm.concat([e.toCompressedBuffer(),di(Ri.SYMMETRIC_KEY)]))}function _m(e){return function(e,t){const n=t(e);return[n.subarray(0,16),n.subarray(16,32)]}(e,gm)}function bm(e,t,n){return(new om).encryptBufferCBC(e,t,n)}function ym(e,t,n){return(new om).decryptBufferCBC(e,t,n)}async function Am(e,t){if(t.isZero())throw new Error("Attempting to derive a shared secret with a zero public key. You have probably passed a zero public key in your Noir code somewhere thinking that the note won't be broadcast... but it was.");const n=new Hd;return await n.mul(t,e)}var wm,xm,vm=i(8891).Buffer;function Em(e){const t=[],n=Math.ceil(e.length/31);for(let s=0;s<n;s++)t.push(new si(e.subarray(31*s,31*(s+1))));return t}class Mm{constructor(e,t,n){this.tag=e,this.contractAddress=t,this.incomingBodyPlaintext=n}async generatePayload(e,t,n=ot){const s=await Xd(e),[i,r]=s.toXAndSign(),a=vm.from([Number(r)]),o=await async function(e,t){const n=await t.toAddressPoint();return await Am(e,n)}(e,t),[l,c]=_m(o);if(this.incomingBodyPlaintext.length>448)throw new Error("Incoming body plaintext cannot be more than 448 bytes.");const d=this.incomingBodyPlaintext,u=await bm(d,c,l),f=_i(this.contractAddress.toBuffer(),function(e,t=2){const n=oi.alloc(t);return n.writeUInt16BE(e,t-2),n}(u.length)),h=await bm(f,c,l);if(48!==h.length)throw new Error(`Invalid header ciphertext size: ${h.length}`);const p=49+u.length,m=_i(a,h,u,n(31*Math.ceil(p/31)-p));if(m.length%31!=0)throw new Error(`logBytes.length should be divisible by 31, got: ${m.length}`);const g=Array.from({length:16-m.length/31},(()=>si.fromBuffer(n(32)))),_=[this.tag,i,...Em(m),...g];if(_.length!==Pi)throw new Error(`Expected private log payload to have 18 fields. Got ${_.length}.`);return new ip(_)}static async decryptAsIncoming(e,t){try{const s=e,i=s[0],r=s[1],a=Js.asReader((n=s.slice(2),vm.concat(n.map((e=>e.toBuffer().subarray(1)))))),o=!!a.readBytes(1)[0],l=await Ei.fromXAndSign(r,o),c=a.readBytes(48);let d=Gc.ZERO;if(!t)throw new Error("Cannot decrypt without an address secret.");const u=await Am(t,l),[f,h]=_m(u),p=await ym(c,h,f),m=Js.asReader(p),g=m.readBytes(32);d=Gc.fromBuffer(g);const _=m.readBytes(2),b=(_[0]<<8)+_[1],y=a.readBytes(b),A=await ym(y,h,f);return new Mm(i,d,A)}catch(e){if(!this.isAcceptableError(e))throw e;return}var n}static isAcceptableError(e){return e instanceof Mi||e.message.endsWith("is greater or equal to field modulus.")||e.message.startsWith("Invalid AztecAddress length")||e.message.startsWith("Selector must fit in")||e.message.startsWith("Attempted to read beyond buffer length")||e.message.startsWith("RangeError [ERR_BUFFER_OUT_OF_BOUNDS]:")}toBuffer(){return _i(this.tag,this.contractAddress.toBuffer(),this.incomingBodyPlaintext)}}class zm extends ih{toJSON(){return this.toBuffer()}static get schema(){return id.Buffer.transform(zm.fromBuffer)}static fromBuffer(e){const t=Js.asReader(e);return new zm(t.readVector(si))}static random(){const e=lt(10)+1,t=Array.from({length:e},(()=>si.random()));return new zm(t)}toString(){return Ds(this.toBuffer())}static fromString(e){return zm.fromBuffer(Os(e))}get length(){return this.items.length}equals(e){return this.items.every(((t,n)=>t.equals(e.items[n])))}}class Bm extends zm{static get schema(){return id.Buffer.transform(Bm.fromBuffer)}static fromBuffer(e){const t=Js.asReader(e);return new Bm(t.readVector(si))}}class Fm extends zm{static get schema(){return id.Buffer.transform(Fm.fromBuffer)}static fromBuffer(e){const t=Js.asReader(e);return new Fm(t.readVector(si))}}wm=class{constructor(e,t,n){this.event=e,this.contractAddress=t,this.eventTypeId=n}static async decryptAsIncoming(e,t){const n=await Mm.decryptAsIncoming(e.fields,t);if(n)return Hs(this,wm,"m",xm).call(this,n.incomingBodyPlaintext,n.contractAddress)}toIncomingBodyPlaintext(){return _i([this.eventTypeId.toField(),...this.event.items])}static async random(e){return new wm(Bm.random(),e??await Gc.random(),Uc.random())}equals(e){return this.event.equals(e.event)&&this.contractAddress.equals(e.contractAddress)&&this.eventTypeId.equals(e.eventTypeId)}},xm=function(e,t){let n;try{const s=Js.asReader(e).readArray(e.length/si.SIZE_IN_BYTES,si),i=Uc.fromField(s[0]),r=new Bm(s.slice(1));n=new wm(r,t,i)}catch(e){return}return n};class km{constructor(e){this.hash=e}static random(){return new km(si.random())}static fromBuffer(e){return new this(Js.asReader(e).readObject(si))}static fromString(e){return new km(si.fromString(e))}static fromBigInt(e){return new km(new si(e))}toBuffer(){return this.hash.toBuffer()}toString(){return this.hash.toString()}toBigInt(){return this.hash.toBigInt()}toJSON(){return this.toString()}equals(e){return this.hash.equals(e.hash)}static get schema(){return id.BufferHex.transform((e=>new km(si.fromBuffer(e))))}static zero(){return new km(si.ZERO)}static get SIZE(){return si.SIZE_IN_BYTES}}var Cm=i(7842),Om=i(8891).Buffer;class Dm{constructor(e,t,n){if(this.blockNumber=e,this.txIndex=t,this.logIndex=n,!Number.isInteger(e)||e<1)throw new Error(`Invalid block number: ${e}`);if(!Number.isInteger(t))throw new Error(`Invalid tx index: ${t}`);if(!Number.isInteger(n))throw new Error(`Invalid log index: ${n}`)}static random(){return new Dm(Math.floor(1e3*Math.random())+1,Math.floor(1e3*Math.random()),Math.floor(100*Math.random()))}static get schema(){return zs.object({blockNumber:id.Integer,txIndex:id.Integer,logIndex:id.Integer}).transform((({blockNumber:e,txIndex:t,logIndex:n})=>new Dm(e,t,n)))}toBuffer(){return Om.concat([m(BigInt(this.blockNumber),4),m(BigInt(this.txIndex),4),m(BigInt(this.logIndex),4)])}static fromBuffer(e){const t=Js.asReader(e),n=t.readNumber(),s=t.readNumber(),i=t.readNumber();return new Dm(n,s,i)}toString(){return`${this.blockNumber}-${this.txIndex}-${this.logIndex}`}static fromString(e){const[t,n,s]=e.split("-"),i=Number(t),r=Number(n),a=Number(s);return new Dm(i,r,a)}toHumanReadable(){return`logId: (blockNumber: ${this.blockNumber}, txIndex: ${this.txIndex}, logIndex: ${this.logIndex})`}}var Lm=i(8891).Buffer;class Tm{constructor(e,t){this.id=e,this.log=t}static async random(){return new Tm(Dm.random(),await Fh.random())}static get schema(){return zs.object({id:Dm.schema,log:Fh.schema}).transform(Tm.from)}static from(e){return new Tm(e.id,e.log)}toBuffer(){return Lm.concat([this.id.toBuffer(),this.log.toBuffer()])}toString(){return Ds(this.toBuffer())}toHumanReadable(){return`${this.id.toHumanReadable()}, ${this.log.toHumanReadable()}`}equals(e){return Cm(this,e)}static fromBuffer(e){const t=Js.asReader(e),n=Dm.fromBuffer(t),s=Fh.fromBuffer(t);return new Tm(n,s)}static fromString(e){return Tm.fromBuffer(Os(e))}}var Sm=i(8891).Buffer;class Nm{constructor(e,t){this.contractAddress=e,this.data=t}get length(){return this.data.length+Gc.SIZE_IN_BYTES+4}toBuffer(){return Sm.concat([this.contractAddress.toBuffer(),ui(this.data)])}toHumanReadable(){const e=function(e,t){const n=e.every((e=>e>=32&&e<=126))?e.toString("ascii"):`0x${e.toString("hex")}`;return n}(this.data);return`UnencryptedL2Log(contractAddress: ${this.contractAddress.toString()}, data: ${e})`}static get schema(){return zs.object({contractAddress:id.AztecAddress,data:id.Buffer}).transform((({contractAddress:e,data:t})=>new Nm(e,t)))}static fromBuffer(e){const t=Js.asReader(e),n=Gc.fromBuffer(t),s=t.readBuffer();return new Nm(n,s)}hash(){return dl(this.toBuffer())}getSiloedHash(){const e=this.hash();return dl(Sm.concat([this.contractAddress.toBuffer(),e]))}static async random(){const e=await Gc.random(),t=ot(1)[0],n=ot(t);return new Nm(e,n)}}var Pm=i(8891).Buffer;class Im{constructor(e,t){this.id=e,this.log=t}static async random(){return new Im(Dm.random(),await Nm.random())}static get schema(){return zs.object({id:Dm.schema,log:Nm.schema}).transform(Im.from)}static from(e){return new Im(e.id,e.log)}toBuffer(){return Pm.concat([this.id.toBuffer(),this.log.toBuffer()])}toString(){return Ds(this.toBuffer())}toHumanReadable(){return`${this.id.toHumanReadable()}, ${this.log.toHumanReadable()}`}equals(e){return Cm(this,e)}static fromBuffer(e){const t=Js.asReader(e),n=Dm.fromBuffer(t),s=Nm.fromBuffer(t);return new Im(n,s)}static fromString(e){return Im.fromBuffer(Os(e))}}var Ym=i(8891).Buffer;const Qm=zs.object({logs:zs.array(Im.schema),maxLogsHit:zs.boolean()}),jm=zs.object({logs:zs.array(Tm.schema),maxLogsHit:zs.boolean()});class Hm{constructor(e,t,n,s,i){this.txHash=e,this.dataStartIndexForTx=t,this.blockNumber=n,this.isFromPublic=s,this.logData=i}static get schema(){return zs.object({txHash:km.schema,dataStartIndexForTx:zs.number(),blockNumber:zs.number(),isFromPublic:zs.boolean(),logData:id.Buffer}).transform((({txHash:e,dataStartIndexForTx:t,blockNumber:n,isFromPublic:s,logData:i})=>new Hm(e,t,n,s,i)))}toBuffer(){return Ym.concat([this.txHash.toBuffer(),li(this.dataStartIndexForTx),li(this.blockNumber),pi(this.isFromPublic),this.logData])}static fromBuffer(e){const t=Js.asReader(e);return new Hm(t.readObject(km),t.readNumber(),t.readNumber(),t.readBoolean(),t.readToEnd())}static random(){return new Hm(km.random(),1,1,!1,si.random().toBuffer())}equals(e){return this.txHash.equals(e.txHash)&&this.dataStartIndexForTx===e.dataStartIndexForTx&&this.blockNumber===e.blockNumber&&this.isFromPublic===e.isFromPublic&&this.logData.equals(e.logData)}}var Um=i(8891).Buffer;class Rm{constructor(e){this.logs=e}toBuffer(){const e=this.logs.map((e=>ui(e.toBuffer())));return ui(Um.concat(e))}getSerializedLength(){return this.getKernelLength()+4}getKernelLength(){return this.logs.reduce(((e,t)=>e+t.length+4),0)}hash(){return dl(Um.concat(this.logs.map((e=>e.hash()))))}static get schema(){return zs.object({logs:zs.array(Nm.schema)}).transform((({logs:e})=>new Rm(e)))}static empty(){return new Rm([])}static fromBuffer(e,t=!0){const n=new Js(e,0),s=t?n.readNumber():-1,i=n.readBufferArray(s);return new Rm(i.map(Nm.fromBuffer))}static async random(e){if(e>1)throw new Error(`Trying to create ${e} logs for one call (max: 1)`);const t=[];for(let n=0;n<e;n++)t.push(await Nm.random());return new Rm(t)}}var Gm=i(8891).Buffer;class Zm{constructor(e){this.functionLogs=e}toBuffer(){const e=this.functionLogs.map((e=>e.toBuffer()));return ui(Gm.concat(e))}getSerializedLength(){return this.functionLogs.reduce(((e,t)=>e+t.getSerializedLength()),0)+4}getKernelLength(){return this.functionLogs.reduce(((e,t)=>e+t.getKernelLength()),0)}getTotalLogCount(){return this.functionLogs.reduce(((e,t)=>e+t.logs.length),0)}addFunctionLogs(e){this.functionLogs.push(...e)}unrollLogs(){return this.functionLogs.flatMap((e=>e.logs))}equals(e){return Cm(this,e)}filter(e,t){for(const n of this.functionLogs){let s=!1;for(const t of n.logs)-1!==e.findIndex((e=>e.value.equals(si.fromBuffer(t.getSiloedHash()))))&&(s=!0);s&&t.addFunctionLogs([n])}return t}filterScoped(e,t){for(const n of this.functionLogs){let s=!1;for(const t of n.logs){let n;if(!("contractAddress"in t))throw new Error("Can't run filterScoped in logs without contractAddress or maskedContractAddress");n=t.contractAddress,-1!=e.findIndex((e=>e.contractAddress.equals(n)&&e.value.equals(si.fromBuffer(t.hash()))))&&(s=!0)}s&&t.addFunctionLogs([n])}return t}}class Jm extends Zm{static get schema(){return zs.object({functionLogs:zs.array(Rm.schema)}).transform((({functionLogs:e})=>new Jm(e)))}static empty(){return new Jm([])}static fromBuffer(e,t=!0){const n=Js.asReader(e),s=t?n.readNumber():-1,i=n.readBufferArray(s).map((e=>Rm.fromBuffer(e,!1)));return new Jm(i)}static async random(e,t){if(e*t>1)throw new Error(`Trying to create ${e*t} logs for one tx (max: 1)`);const n=[];for(let s=0;s<e;s++)n.push(await Rm.random(t));return new Jm(n)}hash(){const e=this.unrollLogs();return Jm.hashSiloedLogs(e.map((e=>e.getSiloedHash())))}static hashSiloedLogs(e){if(0==e.length)return Gm.alloc(32);let t=Gm.alloc(0);for(const n of e)t=Gm.concat([t,n]);for(let n=0;n<1-e.length;n++)t=Gm.concat([t,Gm.alloc(32)]);return dl(t)}}var Xm=i(8891).Buffer;class Wm{constructor(e){this.txLogs=e}toBuffer(){const e=this.txLogs.map((e=>e.toBuffer()));return ui(Xm.concat(e))}getSerializedLength(){return this.txLogs.reduce(((e,t)=>e+t.getSerializedLength()),0)+4}getTotalLogCount(){return this.txLogs.reduce(((e,t)=>e+t.getTotalLogCount()),0)}toString(){return Ds(this.toBuffer())}equals(e){return Cm(this,e)}static getTotalLogCount(e){return e.reduce(((e,t)=>e+t.getTotalLogCount()),0)}}class Vm extends Wm{static get schema(){return zs.object({txLogs:zs.array(Jm.schema)}).transform((({txLogs:e})=>new Vm(e)))}get type(){return"ContractClass"}static fromBuffer(e){const t=Js.asReader(e),n=t.readNumber(),s=t.readBufferArray(n).map((e=>Jm.fromBuffer(e,!1)));return new Vm(s)}static fromString(e){return Vm.fromBuffer(Os(e))}static async random(e,t,n){const s=[];for(let i=0;i<e;i++)s.push(await Jm.random(t,n));return new Vm(s)}static unrollLogs(e){const t=[];for(const n of e)if(n)for(const e of n.txLogs)t.push(...e.unrollLogs());return t}}const qm=zs.object({txHash:km.schema.optional(),fromBlock:id.Integer.optional(),toBlock:id.Integer.optional(),afterLog:Dm.schema.optional(),contractAddress:id.AztecAddress.optional()});class Km{constructor(e,t){this.callContext=e,this.args=t}getSize(){return this.isEmpty()?0:this.toBuffer().length}toBuffer(){return _i(this.callContext,new ih(this.args))}static get schema(){return zs.object({callContext:Hh.schema,args:zs.array(id.Fr)}).transform(Km.from)}static fromBuffer(e){const t=Js.asReader(e);return new Km(Hh.fromBuffer(t),t.readVector(si))}static from(e){return new Km(...Km.getFields(e))}static getFields(e){return[e.callContext,e.args]}static empty(){return new Km(Hh.empty(),[])}static async random(){return new Km(await Hh.random(),[si.random(),si.random()])}isEmpty(){return this.callContext.isEmpty()&&0===this.args.length}async isForCallRequest(e){return this.callContext.msgSender.equals(e.msgSender)&&this.callContext.contractAddress.equals(e.contractAddress)&&this.callContext.functionSelector.equals(e.functionSelector)&&this.callContext.isStaticCall==e.isStaticCall&&(await Qd(this.args)).equals(e.argsHash)}async toCallRequest(){return new vh(this.callContext.msgSender,this.callContext.contractAddress,this.callContext.functionSelector,this.callContext.isStaticCall,await Qd(this.args))}[f.inspect.custom](){return`PublicExecutionRequest {\n      callContext: ${(0,f.inspect)(this.callContext)}\n      args: ${this.args}\n    }`}}class $m{constructor(e,t,n){this.note=e,this.storageSlot=t,this.noteTypeId=n}static get schema(){return zs.object({note:Fm.schema,storageSlot:id.Fr,noteTypeId:id.NoteSelector}).transform($m.from)}static from(e){return new $m(e.note,e.storageSlot,e.noteTypeId)}static random(){return new $m(Fm.random(),si.random(),nd.random())}}class eg{constructor(e,t){this.log=e,this.counter=t}static get schema(){return zs.object({log:Nm.schema,counter:id.Integer}).transform(eg.from)}static from(e){return new eg(e.log,e.counter)}isEmpty(){return!this.log.data.length&&!this.counter}}class tg{constructor(e,t){this.request=e,this.counter=t}static get schema(){return zs.object({request:Km.schema,counter:id.Integer}).transform(tg.from)}static from(e){return new tg(e.request,e.counter)}isEmpty(){return this.request.isEmpty()&&!this.counter}static async random(){return new tg(await Km.random(),0)}}class ng{constructor(e,t){this.entrypoint=e,this.firstNullifier=t}static get schema(){return zs.object({entrypoint:sg.schema,firstNullifier:si.schema}).transform(ng.from)}static from(e){return new ng(e.entrypoint,e.firstNullifier)}static async random(e=1){return new ng(await sg.random(e),si.random())}}class sg{constructor(e,t,n,s,i,r,a,o,l,c,d,u){this.acir=e,this.vk=t,this.partialWitness=n,this.publicInputs=s,this.noteHashLeafIndexMap=i,this.newNotes=r,this.noteHashNullifierCounterMap=a,this.returnValues=o,this.nestedExecutions=l,this.enqueuedPublicFunctionCalls=c,this.publicTeardownFunctionCall=d,this.contractClassLogs=u}static get schema(){return zs.object({acir:id.Buffer,vk:id.Buffer,partialWitness:js(zs.coerce.number(),zs.string()),publicInputs:Bp.schema,noteHashLeafIndexMap:js(id.BigInt,id.BigInt),newNotes:zs.array($m.schema),noteHashNullifierCounterMap:js(zs.coerce.number(),zs.number()),returnValues:zs.array(id.Fr),nestedExecutions:zs.array(zs.lazy((()=>sg.schema))),enqueuedPublicFunctionCalls:zs.array(tg.schema),publicTeardownFunctionCall:Km.schema,contractClassLogs:zs.array(eg.schema)}).transform(sg.from)}static from(e){return new sg(e.acir,e.vk,e.partialWitness,e.publicInputs,e.noteHashLeafIndexMap,e.newNotes,e.noteHashNullifierCounterMap,e.returnValues,e.nestedExecutions,e.enqueuedPublicFunctionCalls,e.publicTeardownFunctionCall,e.contractClassLogs)}static async random(e=1){return new sg(ot(4),ot(4),new Map([[1,"one"]]),Bp.empty(),new Map([[1n,1n]]),[$m.random()],new Map([[0,0]]),[si.random()],await Ee(e,(()=>sg.random(0))),[await tg.random()],await Km.random(),[new eg(await Nm.random(),lt(10))])}}function ig(e){return[e.contractClassLogs,...e.nestedExecutions.flatMap(ig)].flat()}function rg(e){const t=wp(ig(e.entrypoint));return new Rm(t.map((e=>e.log)))}function ag(e){return[...e.enqueuedPublicFunctionCalls,...e.nestedExecutions.flatMap(ag)]}function og(e){return wp(ag(e.entrypoint),!1).map((e=>e.request))}function lg(e){const t=e=>[e.publicTeardownFunctionCall,...e.nestedExecutions.flatMap(t)].filter((e=>!e.isEmpty())),n=t(e.entrypoint);if(1===n.length)return n[0];if(n.length>1)throw new Error("Multiple public teardown calls detected");return Km.empty()}const cg=zs.object({l1StartBlock:id.BigInt,l1GenesisTime:id.BigInt,slotDuration:zs.number(),epochDuration:zs.number(),ethereumSlotDuration:zs.number()});function dg(e){return zs.object({data:e,l2BlockNumber:id.Integer,l2BlockHash:zs.string()})}var ug=i(8891).Buffer;const fg=8392562855083340404n,hg=fg.toString(16).length/2,pg=hg+7;class mg{constructor(e,t,n,s,i,r,a,o,l,c,d){if(this.revertCode=e,this.txHash=t,this.transactionFee=n,this.noteHashes=s,this.nullifiers=i,this.l2ToL1Msgs=r,this.publicDataWrites=a,this.privateLogs=o,this.publicLogs=l,this.contractClassLogsLength=c,this.contractClassLogs=d,s.length>Di)throw new Error(`Too many note hashes: ${s.length}, max: 64`);if(s.forEach((e=>{if(e.isZero())throw new Error("Note hash is zero")})),i.length>Li)throw new Error(`Too many nullifiers: ${i.length}, max: 64`);if(i.forEach((e=>{if(e.isZero())throw new Error("Nullifier is zero")})),r.length>8)throw new Error(`Too many L2 to L1 messages: ${r.length}, max: 8`);if(r.forEach((e=>{if(e.isZero())throw new Error("L2 to L1 message is zero")})),a.length>Si)throw new Error(`Too many public data writes: ${a.length}, max: 64`);if(a.forEach((e=>{if(e.isEmpty())throw new Error("Public data write is empty")})),o.length>Ni)throw new Error(`Too many private logs: ${o.length}, max: 32`);o.forEach((e=>{if(e.isEmpty())throw new Error("Private log is empty")}))}toBuffer(){return _i([this.revertCode,this.txHash,this.transactionFee,hi(this.noteHashes,1),hi(this.nullifiers,1),hi(this.l2ToL1Msgs,1),hi(this.publicDataWrites,1),hi(this.privateLogs,1),hi(this.publicLogs,1),this.contractClassLogsLength,this.contractClassLogs])}getDASize(){return this.toBlobFields().length*si.SIZE_IN_BYTES}static fromBuffer(e){const t=Js.asReader(e);return new mg(im.fromBuffer(t),km.fromBuffer(t),si.fromBuffer(t),t.readVectorUint8Prefix(si),t.readVectorUint8Prefix(si),t.readVectorUint8Prefix(si),t.readVectorUint8Prefix(Bh),t.readVectorUint8Prefix(ip),t.readVectorUint8Prefix(Fh),si.fromBuffer(t),t.readObject(Jm))}txOutHash(){const{l2ToL1Msgs:e}=this;if(0==e.length)return ug.alloc(32);const t=1==e.length?1:Math.ceil(Math.log2(e.length));let n=xe(e.map((e=>e.toBuffer())),ug.alloc(32),2**t),s=[];for(let e=0;e<t;e++){for(let e=0;e<n.length;e+=2)s[e/2]=dl(ug.concat([n[e],n[e+1]]));n=s,s=[]}return n[0]}static async random(e=3,t=1){const n=await Jm.random(1,1);return new mg(im.random(),km.random(),new si(Math.floor(1e5*Math.random())),uh(Di,si.random),uh(Li,si.random),uh(8,si.random),uh(Si,(()=>new Bh(si.random(),si.random()))),uh(Ni,(()=>new ip(uh(Pi,si.random)))),await async function(e,t,n=0){return await Promise.all(Array(e).fill(0).map((async(e,s)=>await t(s+n))))}(e*t,Fh.random),new si(n.getKernelLength()),n)}static empty(){return new mg(im.OK,km.zero(),si.ZERO,[],[],[],[],[],[],si.ZERO,Jm.empty())}isEmpty(){return 0===this.nullifiers.length}toString(){return Ds(this.toBuffer())}toPrefix(e,t){const n=ug.alloc(4);return n.writeUint8(e),n.writeUInt16BE(t,2),new si(n)}static fromPrefix(e){const t=e.toBuffer().subarray(-4);return{type:t[0],length:new si(t.subarray(-2)).toNumber()}}encodeFirstField(e,t){const n=ug.alloc(2);return n.writeUInt16BE(e,0),new si(ug.concat([m(fg,hg),ug.alloc(1),n,ug.alloc(1),ug.from([1]),ug.alloc(1),t.toBuffer()]))}static decodeFirstField(e){const t=e.toBuffer().subarray(-pg);return{length:new si(t.subarray(hg+1,hg+3)).toNumber(),revertCode:t[t.length-1]}}static isFirstField(e){const t=e.toBuffer();if(!t.subarray(0,e.size-pg).equals(ug.alloc(e.size-pg)))return!1;const n=t.subarray(-pg);return!(!new si(n.subarray(0,hg)).equals(new si(fg))||1!==n[n.length-3]||n[n.length-1]>4)}toBlobFields(){if(this.isEmpty())return[];const e=[];return e.push(si.ZERO),e.push(this.txHash.hash),e.push(new si(ug.concat([ug.from([2]),ug.alloc(1),this.transactionFee.toBuffer().subarray(3)]))),this.noteHashes.length&&(e.push(this.toPrefix(3,this.noteHashes.length)),e.push(...this.noteHashes)),this.nullifiers.length&&(e.push(this.toPrefix(4,this.nullifiers.length)),e.push(...this.nullifiers)),this.l2ToL1Msgs.length&&(e.push(this.toPrefix(5,this.l2ToL1Msgs.length)),e.push(...this.l2ToL1Msgs)),this.publicDataWrites.length&&(e.push(this.toPrefix(6,2*this.publicDataWrites.length)),e.push(...this.publicDataWrites.map((e=>[e.leafSlot,e.value])).flat())),this.privateLogs.length&&(e.push(this.toPrefix(7,this.privateLogs.length*Pi)),e.push(...this.privateLogs.map((e=>e.fields)).flat())),this.publicLogs.length&&(e.push(this.toPrefix(8,14*this.publicLogs.length)),e.push(...this.publicLogs.map((e=>e.toFields())).flat())),this.contractClassLogs.unrollLogs().length&&(e.push(this.toPrefix(9,this.contractClassLogs.unrollLogs().length)),e.push(...this.contractClassLogs.unrollLogs().map((e=>si.fromBuffer(e.getSiloedHash()))))),e[0]=this.encodeFirstField(e.length,this.revertCode),e}static fromBlobFields(e,t){const n=e=>{if(e.length)throw new Error("Invalid fields given to TxEffect.fromBlobFields(): Attempted to assign property twice.")},s=this.empty();if(!(e instanceof vi||e.length))return s;const i=vi.asReader(e),r=i.readField();if(!this.isFirstField(r))throw new Error("Invalid fields given to TxEffect.fromBlobFields(): First field invalid.");const{length:a,revertCode:o}=this.decodeFirstField(r);s.revertCode=im.fromField(new si(o)),s.txHash=new km(i.readField());const l=i.readField();for(s.transactionFee=si.fromBuffer(ug.concat([ug.alloc(3),l.toBuffer().subarray(3)]));!i.isFinished();){const{type:e,length:r}=this.fromPrefix(i.readField());switch(e){case 3:n(s.noteHashes),s.noteHashes=i.readFieldArray(r);break;case 4:n(s.nullifiers),s.nullifiers=i.readFieldArray(r);break;case 5:n(s.l2ToL1Msgs),s.l2ToL1Msgs=i.readFieldArray(r);break;case 6:{n(s.publicDataWrites);const e=i.readFieldArray(r);for(let t=0;t<r;t+=2)s.publicDataWrites.push(new Bh(e[t],e[t+1]));break}case 7:{n(s.privateLogs);const e=i.readFieldArray(r);for(let t=0;t<r;t+=Pi)s.privateLogs.push(ip.fromFields(e.slice(t,t+Pi)));break}case 8:{n(s.publicLogs);const e=i.readFieldArray(r);for(let t=0;t<r;t+=14)s.publicLogs.push(Fh.fromFields(e.slice(t,t+14)));break}case 9:if(n(s.contractClassLogs.functionLogs),!t)throw new Error("Tx effect has contractClassLogs logs, but they were not passed raw to .fromBlobFields()");this.checkInjectedLogs(t,i.readFieldArray(r)),s.contractClassLogs=t,s.contractClassLogsLength=new si(t.getKernelLength());break;default:throw new Error("Too many fields to decode given to TxEffect.fromBlobFields()")}}return s.contractClassLogs=!s.contractClassLogs.getTotalLogCount()&&t?t:s.contractClassLogs,s}static checkInjectedLogs(e,t){e.unrollLogs().forEach(((e,n)=>{const s=e.getSiloedHash();if(!si.fromBuffer(s).equals(t[n]))throw new Error(`Log hash mismatch when reconstructing tx effect. Expected: ${si.fromBuffer(s)}, Got: ${t[n]}`)}))}static from(e){return new mg(e.revertCode,e.txHash,e.transactionFee,e.noteHashes,e.nullifiers,e.l2ToL1Msgs,e.publicDataWrites,e.privateLogs,e.publicLogs,e.contractClassLogsLength,e.contractClassLogs)}static get schema(){return zs.object({revertCode:im.schema,txHash:km.schema,transactionFee:id.Fr,noteHashes:zs.array(id.Fr),nullifiers:zs.array(id.Fr),l2ToL1Msgs:zs.array(id.Fr),publicDataWrites:zs.array(Bh.schema),privateLogs:zs.array(ip.schema),publicLogs:zs.array(Fh.schema),contractClassLogsLength:id.Fr,contractClassLogs:Jm.schema}).transform(mg.from)}[f.inspect.custom](){return`TxEffect {\n      revertCode: ${this.revertCode},\n      txHash: ${this.txHash},\n      transactionFee: ${this.transactionFee},\n      note hashes: [${this.noteHashes.map((e=>e.toString())).join(", ")}],\n      nullifiers: [${this.nullifiers.map((e=>e.toString())).join(", ")}],\n      l2ToL1Msgs: [${this.l2ToL1Msgs.map((e=>e.toString())).join(", ")}],\n      publicDataWrites: [${this.publicDataWrites.map((e=>e.toString())).join(", ")}],\n      privateLogs: [${this.privateLogs.map((e=>e.toString())).join(", ")}],\n      publicLogs: [${this.publicLogs.map((e=>e.toString())).join(", ")}],\n      contractClassLogsLength: ${this.contractClassLogsLength},\n      contractClassLogs: ${_h(this.contractClassLogs)}\n     }`}static fromString(e){return mg.fromBuffer(Os(e))}}class gg{constructor(e){this.txEffects=e,e.forEach((e=>{if(e.isEmpty())throw new Error("Empty tx effect not allowed in Body")}))}static get schema(){return zs.object({txEffects:zs.array(mg.schema)}).transform((({txEffects:e})=>new gg(e)))}toBuffer(){return _i(this.txEffects.length,this.txEffects)}static fromBuffer(e){return new this(Js.asReader(e).readVector(mg))}toBlobFields(){let e=[];return this.txEffects.forEach((t=>{e=e.concat(t.toBlobFields())})),e}static fromBlobFields(e,t){const n=[];let s=0;for(;s!==e.length;){if(!mg.isFirstField(e[s]))throw new Error("Invalid fields given to Body.fromBlobFields(): First field invalid.");const t=mg.decodeFirstField(e[s]).length;n.push(e.slice(s,s+t)),s+=t}return new this(n.filter((e=>e.length)).map(((e,n)=>mg.fromBlobFields(e,t?.txLogs[n]))))}[f.inspect.custom](){return`Body {\n  txEffects: ${(0,f.inspect)(this.txEffects)},\n}`}get contractClassLogs(){const e=this.txEffects.map((e=>e.contractClassLogs));return new Vm(e)}static async random(e=4,t=3,n=1){const s=await Ee(e,(()=>mg.random(t,n)));return new gg(s)}static empty(){return new gg([])}}var _g=i(8891).Buffer;class bg{constructor(e,t,n){this.z=e,this.y=t,this.kzgCommitment=n}static empty(){return new bg(si.ZERO,0n,[si.ZERO,si.ZERO])}isEmpty(){return this.z.isZero()&&0n==this.y&&this.kzgCommitment[0].isZero()&&this.kzgCommitment[1].isZero()}static fromBuffer(e){const t=Js.asReader(e);return new bg(si.fromBuffer(t),p(t.readBytes(32)),t.readArray(2,si))}toBuffer(){return _i(...bg.getFields(this))}static fromFields(e){const t=vi.asReader(e);return new bg(t.readField(),(n=t.readFieldArray(3),BigInt(n[2].toString().concat(n[1].toString().substring(2),n[0].toString().substring(2)))),t.readFieldArray(2));var n}toFields(){const e=function(e,t=!1){const n=e.toString(16),s=n.length%2==0?n.length:n.length+1;return`0x${n.padStart(t?64:s,"0")}`}(this.y,!0),t=[si.fromString("0x"+e.substring(36)),si.fromString("0x"+e.substring(6,36)),si.fromString(e.substring(0,6))];return[this.z,...t,...this.kzgCommitment]}static getFields(e){return[e.z,e.y,e.kzgCommitment]}static fromBlob(e){return new bg(e.challengeZ,p(e.evaluationY),e.commitmentToFields())}getBlobHash(){const e=cl(this.commitmentToBuffer());return e[0]=1,e}commitmentToBuffer(){return _g.concat([this.kzgCommitment[0].toBuffer().subarray(1),this.kzgCommitment[1].toBuffer().subarray(-17)])}equals(e){return this.z.equals(e.z)&&this.y==e.y&&this.kzgCommitment[0].equals(e.kzgCommitment[0])&&this.kzgCommitment[1].equals(e.kzgCommitment[1])}}class yg{constructor(e){this.inner=e}static empty(){return new yg(uh(3,bg.empty))}static fromBuffer(e){const t=Js.asReader(e);return new yg(t.readArray(3,bg))}toBuffer(){return _i(...yg.getFields(this))}static fromFields(e){const t=vi.asReader(e);return new yg(t.readArray(3,bg))}toFields(){return this.inner.map((e=>e.toFields())).flat()}static getFields(e){return[e.inner]}static fromBlobs(e){const t=uh(3,bg.empty);if(e.length>3)throw new Error(`Can only fit 3 in one BlockBlobPublicInputs instance (given ${e.length})`);return e.forEach(((e,n)=>{t[n]=bg.fromBlob(e)})),new yg(t)}getBlobsHash(){return dl(_i(this.inner.map((e=>e.isEmpty()?_g.alloc(0):e.getBlobHash()))))}toString(){const e=this.inner.filter((e=>!e.isEmpty()));let t=_g.alloc(1);return t.writeUInt8(e.length),e.forEach((e=>{t=_g.concat([t,e.z.toBuffer(),m(e.y,32),e.commitmentToBuffer()])})),t.toString("hex")}}class Ag{constructor(e,t,n){this.sponge=e,this.fields=t,this.expectedFields=n}static fromBuffer(e){const t=Js.asReader(e);return new Ag(t.readObject(wg),t.readNumber(),t.readNumber())}toBuffer(){return _i(this.sponge,this.fields,this.expectedFields)}static getFields(e){return[e.sponge,e.fields,e.expectedFields]}toFields(){return gi(...Ag.getFields(this))}static fromFields(e){const t=vi.asReader(e);return new Ag(t.readObject(wg),t.readField().toNumber(),t.readField().toNumber())}clone(){return Ag.fromBuffer(this.toBuffer())}async absorb(e){if(this.fields+e.length>this.expectedFields)throw new Error(`Attempted to fill spongeblob with ${this.fields+e.length}, but it has a max of ${this.expectedFields}`);await this.sponge.absorb(e),this.fields+=e.length}async squeeze(){return this.fields!=this.expectedFields&&await this.sponge.absorb([si.ONE]),this.sponge.squeeze()}static empty(){return new Ag(wg.empty(),0,0)}static init(e){return new Ag(wg.init(e),0,e)}}class wg{constructor(e,t,n,s){this.cache=e,this.state=t,this.cacheSize=n,this.squeezeMode=s}static fromBuffer(e){const t=Js.asReader(e);return new wg(t.readArray(3,si),t.readArray(4,si),t.readNumber(),t.readBoolean())}toBuffer(){return _i(this.cache,this.state,this.cacheSize,this.squeezeMode)}static getFields(e){return[e.cache,e.state,e.cacheSize,e.squeezeMode]}toFields(){return gi(...wg.getFields(this))}static fromFields(e){const t=vi.asReader(e);return new wg(t.readFieldArray(3),t.readFieldArray(4),t.readField().toNumber(),t.readBoolean())}static empty(){return new wg(uh(3,(()=>si.ZERO)),uh(4,(()=>si.ZERO)),0,!1)}static init(e){const t=new si(e).mul(new si(BigInt("18446744073709551616"))),n=wg.empty();return n.state[3]=t,n}async performDuplex(){for(let e=0;e<this.cache.length;e++)e<this.cacheSize&&(this.state[e]=this.state[e].add(this.cache[e]));const e=await async function(e){const t=gi(e);return(await c.initSingleton()).poseidon2Permutation(t.map((e=>new d(e.toBuffer())))).map((e=>si.fromBuffer(yi.from(e.toBuffer()))))}(this.state);this.state=[e[0],e[1],e[2],e[3]]}async absorb(e){if(this.squeezeMode)throw new Error("Poseidon sponge is not able to absorb more inputs.");for(const t of e)this.cacheSize==this.cache.length?(await this.performDuplex(),this.cache[0]=t,this.cacheSize=1):this.cache[this.cacheSize++]=t}async squeeze(){if(this.squeezeMode)throw new Error("Poseidon sponge has already been squeezed.");return await this.performDuplex(),this.squeezeMode=!0,this.state[0]}}class xg{constructor(e,t,n){this.publicInputs=e,this.proof=t,this.vkData=n}static fromBuffer(e){const t=Js.asReader(e);return new xg(t.readObject(Ch),qp.fromBuffer(t),t.readObject(am))}toBuffer(){return _i(this.publicInputs,this.proof,this.vkData)}static empty(){return new xg(Ch.empty(),Kp(4154),am.empty())}}class vg{constructor(e,t,n,s){this.lastArchive=e,this.vkTreeRoot=t,this.protocolContractTreeRoot=n,this.globalVariables=s}static from(e){return new vg(...vg.getFields(e))}static fromBuffer(e){const t=Js.asReader(e);return new vg(t.readObject(Mh),si.fromBuffer(t),si.fromBuffer(t),t.readObject(bh))}static getFields(e){return[e.lastArchive,e.vkTreeRoot,e.protocolContractTreeRoot,e.globalVariables]}static empty(){return new vg(Mh.zero(),si.ZERO,si.ZERO,bh.empty())}toBuffer(){return _i(...vg.getFields(this))}}class Eg{constructor(e,t,n,s,i,r,a,o,l,c){this.rollupType=e,this.numTxs=t,this.constants=n,this.start=s,this.end=i,this.startSpongeBlob=r,this.endSpongeBlob=a,this.outHash=o,this.accumulatedFees=l,this.accumulatedManaUsed=c}static empty(){return new Eg(ah.Base,0,vg.empty(),Vh.empty(),Vh.empty(),Ag.empty(),Ag.empty(),si.zero(),si.zero(),si.zero())}static fromBuffer(e){const t=Js.asReader(e);return new Eg(t.readNumber(),t.readNumber(),t.readObject(vg),t.readObject(Vh),t.readObject(Vh),t.readObject(Ag),t.readObject(Ag),si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t))}toBuffer(){return _i(this.rollupType,this.numTxs,this.constants,this.start,this.end,this.startSpongeBlob,this.endSpongeBlob,this.outHash,this.accumulatedFees,this.accumulatedManaUsed)}toString(){return Ds(this.toBuffer())}static fromString(e){return Eg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Eg)}}class Mg{constructor(e,t,n,s,i,r,a,o,l){this.nullifierPredecessorPreimages=e,this.nullifierPredecessorMembershipWitnesses=t,this.sortedNullifiers=n,this.sortedNullifierIndexes=s,this.noteHashSubtreeSiblingPath=i,this.nullifierSubtreeSiblingPath=r,this.feeWriteLowLeafPreimage=a,this.feeWriteLowLeafMembershipWitness=o,this.feeWriteSiblingPath=l}static from(e){return new Mg(...Mg.getFields(e))}static getFields(e){return[e.nullifierPredecessorPreimages,e.nullifierPredecessorMembershipWitnesses,e.sortedNullifiers,e.sortedNullifierIndexes,e.noteHashSubtreeSiblingPath,e.nullifierSubtreeSiblingPath,e.feeWriteLowLeafPreimage,e.feeWriteLowLeafMembershipWitness,e.feeWriteSiblingPath]}toBuffer(){return _i(...Mg.getFields(this))}static fromBuffer(e){const t=Js.asReader(e);return new Mg(t.readArray(Li,ch),t.readArray(Li,{fromBuffer:e=>_p.fromBuffer(e,Oi)}),t.readArray(Li,si),t.readNumbers(Li),t.readArray(34,si),t.readArray(34,si),t.readObject(Ip),_p.fromBuffer(t,Ci),t.readArray(Ci,si))}static empty(){return new Mg(uh(Li,ch.empty),uh(Li,(()=>_p.empty(Oi))),uh(Li,si.zero),uh(Li,(()=>0)),uh(34,si.zero),uh(34,si.zero),Ip.empty(),_p.empty(Ci),uh(Ci,si.zero))}}class zg{constructor(e,t,n,s,i,r,a,o,l){this.nullifierPredecessorPreimages=e,this.nullifierPredecessorMembershipWitnesses=t,this.sortedNullifiers=n,this.sortedNullifierIndexes=s,this.noteHashSubtreeSiblingPath=i,this.nullifierSubtreeSiblingPath=r,this.lowPublicDataWritesPreimages=a,this.lowPublicDataWritesMembershipWitnesses=o,this.publicDataTreeSiblingPaths=l}static from(e){return new zg(...zg.getFields(e))}static getFields(e){return[e.nullifierPredecessorPreimages,e.nullifierPredecessorMembershipWitnesses,e.sortedNullifiers,e.sortedNullifierIndexes,e.noteHashSubtreeSiblingPath,e.nullifierSubtreeSiblingPath,e.lowPublicDataWritesPreimages,e.lowPublicDataWritesMembershipWitnesses,e.publicDataTreeSiblingPaths]}toBuffer(){return _i(...zg.getFields(this))}static fromBuffer(e){const t=Js.asReader(e);return new zg(t.readArray(Li,ch),t.readArray(Li,{fromBuffer:e=>_p.fromBuffer(e,Oi)}),t.readArray(Li,si),t.readNumbers(Li),t.readArray(34,si),t.readArray(34,si),t.readArray(Si,Ip),t.readArray(Si,{fromBuffer:e=>_p.fromBuffer(e,Ci)}),t.readArray(Si,{fromBuffer:e=>Js.asReader(e).readArray(Ci,si)}))}static empty(){return new zg(uh(Li,ch.empty),uh(Li,(()=>_p.empty(Oi))),uh(Li,si.zero),uh(Li,(()=>0)),uh(34,si.zero),uh(34,si.zero),uh(Si,Ip.empty),uh(Si,(()=>_p.empty(Ci))),uh(Si,(()=>uh(Ci,si.zero))))}}class Bg{constructor(e,t,n,s,i,r){this.start=e,this.startSpongeBlob=t,this.stateDiffHints=n,this.feePayerFeeJuiceBalanceReadHint=s,this.archiveRootMembershipWitness=i,this.constants=r}static from(e){return new Bg(...Bg.getFields(e))}static getFields(e){return[e.start,e.startSpongeBlob,e.stateDiffHints,e.feePayerFeeJuiceBalanceReadHint,e.archiveRootMembershipWitness,e.constants]}toBuffer(){return _i(...Bg.getFields(this))}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new Bg(t.readObject(Vh),t.readObject(Ag),t.readObject(Mg),t.readObject(rm),_p.fromBuffer(t,Fi),t.readObject(vg))}static fromString(e){return Bg.fromBuffer(Os(e))}static empty(){return new Bg(Vh.empty(),Ag.empty(),Mg.empty(),rm.empty(),_p.empty(Fi),vg.empty())}}class Fg{constructor(e,t,n,s,i){this.start=e,this.startSpongeBlob=t,this.stateDiffHints=n,this.archiveRootMembershipWitness=s,this.constants=i}static from(e){return new Fg(...Fg.getFields(e))}static getFields(e){return[e.start,e.startSpongeBlob,e.stateDiffHints,e.archiveRootMembershipWitness,e.constants]}toBuffer(){return _i(...Fg.getFields(this))}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new Fg(t.readObject(Vh),t.readObject(Ag),t.readObject(zg),_p.fromBuffer(t,Fi),t.readObject(vg))}static fromString(e){return Fg.fromBuffer(Os(e))}static empty(){return new Fg(Vh.empty(),Ag.empty(),zg.empty(),_p.empty(Fi),vg.empty())}}class kg{constructor(e,t,n,s,i,r,a,o,l,c,d,u){this.previousArchive=e,this.newArchive=t,this.previousBlockHash=n,this.endBlockHash=s,this.startGlobalVariables=i,this.endGlobalVariables=r,this.outHash=a,this.fees=o,this.vkTreeRoot=l,this.protocolContractTreeRoot=c,this.proverId=d,this.blobPublicInputs=u}static fromBuffer(e){const t=Js.asReader(e);return new kg(t.readObject(Mh),t.readObject(Mh),si.fromBuffer(t),si.fromBuffer(t),t.readObject(bh),t.readObject(bh),si.fromBuffer(t),t.readArray(Ii,Cg),si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),t.readArray(Ii,yg))}toBuffer(){return _i(this.previousArchive,this.newArchive,this.previousBlockHash,this.endBlockHash,this.startGlobalVariables,this.endGlobalVariables,this.outHash,this.fees,this.vkTreeRoot,this.protocolContractTreeRoot,this.proverId,this.blobPublicInputs)}toString(){return Ds(this.toBuffer())}static fromString(e){return kg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(kg)}}class Cg{constructor(e,t){this.recipient=e,this.value=t}static fromBuffer(e){const t=Js.asReader(e);return new Cg(t.readObject(Nc),si.fromBuffer(t))}toBuffer(){return _i(this.recipient,this.value)}static getFields(e){return[e.recipient,e.value]}toFields(){return gi(...Cg.getFields(this))}isEmpty(){return this.value.isZero()&&this.recipient.isZero()}toFriendlyJSON(){return this.isEmpty()?{}:{recipient:this.recipient.toString(),value:this.value.toString()}}static random(){return new Cg(Nc.random(),si.random())}}class Og{constructor(e,t,n,s){this.blockRootOrBlockMergePublicInputs=e,this.proof=t,this.vk=n,this.vkWitness=s}toBuffer(){return _i(this.blockRootOrBlockMergePublicInputs,this.proof,this.vk,this.vkWitness)}static fromBuffer(e){const t=Js.asReader(e);return new Og(t.readObject(kg),qp.fromBuffer(t,ji),t.readObject(Lp),_p.fromBuffer(t,6))}}class Dg{constructor(e){this.previousRollupData=e}toBuffer(){return _i(this.previousRollupData)}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new Dg([t.readObject(Og),t.readObject(Og)])}static fromString(e){return Dg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Dg)}}class Lg{constructor(e,t,n,s){this.baseOrMergeRollupPublicInputs=e,this.proof=t,this.vk=n,this.vkWitness=s}toBuffer(){return _i(this.baseOrMergeRollupPublicInputs,this.proof,this.vk,this.vkWitness)}static fromBuffer(e){const t=Js.asReader(e);return new Lg(t.readObject(Eg),qp.fromBuffer(t,ji),t.readObject(Lp),_p.fromBuffer(t,6))}}class Tg{constructor(e,t,n,s,i){this.l1ToL2Roots=e,this.l1ToL2MessageSubtreeSiblingPath=t,this.newArchiveSiblingPath=n,this.previousBlockHeader=s,this.proverId=i}toBuffer(){return _i(...Tg.getFields(this))}toString(){return Ds(this.toBuffer())}static from(e){return new Tg(...Tg.getFields(e))}static getFields(e){return[e.l1ToL2Roots,e.l1ToL2MessageSubtreeSiblingPath,e.newArchiveSiblingPath,e.previousBlockHeader,e.proverId]}static fromBuffer(e){const t=Js.asReader(e);return new Tg($p.fromBuffer(t,459),t.readArray(35,si),t.readArray(Fi,si),Kh.fromBuffer(t),si.fromBuffer(t))}static fromString(e){return Tg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Tg)}}class Sg{constructor(e,t,n){this.blobFields=e,this.blobCommitments=t,this.blobsHash=n}toBuffer(){return _i(...Sg.getFields(this))}toString(){return Ds(this.toBuffer())}static from(e){return new Sg(...Sg.getFields(e))}static getFields(e){return[e.blobFields,e.blobCommitments,e.blobsHash]}static fromBuffer(e){const t=Js.asReader(e);return new Sg(Array.from({length:12288},(()=>si.fromBuffer(t))),t.readArray(3,{fromBuffer:()=>t.readArray(2,si)}),si.fromBuffer(t))}static fromString(e){return Sg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Sg)}}class Ng{constructor(e,t,n){this.previousRollupData=e,this.data=t,this.blobData=n}toBuffer(){return _i(...Ng.getFields(this))}toString(){return Ds(this.toBuffer())}static from(e){return new Ng(...Ng.getFields(e))}static getFields(e){return[e.previousRollupData,e.data,e.blobData]}static fromBuffer(e){const t=Js.asReader(e);return new Ng([t.readObject(Lg),t.readObject(Lg)],t.readObject(Tg),t.readObject(Sg))}static fromString(e){return Ng.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Ng)}}class Pg{constructor(e,t,n){this.previousRollupData=e,this.data=t,this.blobData=n}toBuffer(){return _i(...Pg.getFields(this))}toString(){return Ds(this.toBuffer())}static from(e){return new Pg(...Pg.getFields(e))}static getFields(e){return[e.previousRollupData,e.data,e.blobData]}static fromBuffer(e){const t=Js.asReader(e);return new Pg([t.readObject(Lg)],t.readObject(Tg),t.readObject(Sg))}static fromString(e){return Pg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Pg)}}class Ig{constructor(e,t,n){this.data=e,this.constants=t,this.isPadding=n}toBuffer(){return _i(...Ig.getFields(this))}toString(){return Ds(this.toBuffer())}static from(e){return new Ig(...Ig.getFields(e))}static getFields(e){return[e.data,e.constants,e.isPadding]}static fromBuffer(e){const t=Js.asReader(e);return new Ig(t.readObject(Tg),t.readObject(vg),t.readBoolean())}static fromString(e){return Ig.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Ig)}}class Yg{constructor(e){this.previousRollupData=e}toBuffer(){return _i(this.previousRollupData)}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new Yg([t.readObject(Lg),t.readObject(Lg)])}static fromString(e){return Yg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Yg)}}class Qg{constructor(e,t,n){this.publicInputs=e,this.proof=t,this.vkData=n}static empty(){return new Qg(dp.empty(),Kp(ji),am.empty())}static fromBuffer(e){const t=Js.asReader(e);return new Qg(t.readObject(dp),qp.fromBuffer(t,ji),t.readObject(am))}toBuffer(){return _i(this.publicInputs,this.proof,this.vkData)}}class jg{constructor(e,t){this.tubeData=e,this.hints=t}static from(e){return new jg(...jg.getFields(e))}static getFields(e){return[e.tubeData,e.hints]}static fromBuffer(e){const t=Js.asReader(e);return new jg(t.readObject(Qg),t.readObject(Bg))}toBuffer(){return _i(...jg.getFields(this))}static fromString(e){return jg.fromBuffer(Os(e))}toString(){return Ds(this.toBuffer())}static empty(){return new jg(Qg.empty(),Bg.empty())}toJSON(){return this.toBuffer()}static get schema(){return Qs(jg)}}class Hg{constructor(e,t,n){this.publicInputs=e,this.proof=t,this.vkData=n}static empty(){return new Hg(jp.empty(),Kp(ji),am.empty())}static fromBuffer(e){const t=Js.asReader(e);return new Hg(t.readObject(jp),qp.fromBuffer(t,ji),t.readObject(am))}toBuffer(){return _i(this.publicInputs,this.proof,this.vkData)}}class Ug{constructor(e,t,n){this.tubeData=e,this.avmProofData=t,this.hints=n}static from(e){return new Ug(...Ug.getFields(e))}static getFields(e){return[e.tubeData,e.avmProofData,e.hints]}static fromBuffer(e){const t=Js.asReader(e);return new Ug(t.readObject(Hg),t.readObject(xg),t.readObject(Fg))}toBuffer(){return _i(...Ug.getFields(this))}static fromString(e){return Ug.fromBuffer(Os(e))}toString(){return Ds(this.toBuffer())}static empty(){return new Ug(Hg.empty(),xg.empty(),Fg.empty())}toJSON(){return this.toBuffer()}static get schema(){return Qs(Ug)}}class Rg{constructor(e,t){this.previousRollupData=e,this.proverId=t}toBuffer(){return _i(...Rg.getFields(this))}toString(){return Ds(this.toBuffer())}static from(e){return new Rg(...Rg.getFields(e))}static getFields(e){return[e.previousRollupData,e.proverId]}static fromBuffer(e){const t=Js.asReader(e);return new Rg([t.readObject(Og),t.readObject(Og)],si.fromBuffer(t))}static fromString(e){return Rg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Rg)}}class Gg{constructor(e,t,n,s,i,r,a,o,l,c,d,u){this.previousArchive=e,this.endArchive=t,this.previousBlockHash=n,this.endBlockHash=s,this.endTimestamp=i,this.endBlockNumber=r,this.outHash=a,this.fees=o,this.vkTreeRoot=l,this.protocolContractTreeRoot=c,this.proverId=d,this.blobPublicInputs=u}static getFields(e){return[e.previousArchive,e.endArchive,e.previousBlockHash,e.endBlockHash,e.endTimestamp,e.endBlockNumber,e.outHash,e.fees,e.vkTreeRoot,e.protocolContractTreeRoot,e.proverId,e.blobPublicInputs]}toBuffer(){return _i(...Gg.getFields(this))}toFields(){return gi(...Gg.getFields(this))}static from(e){return new Gg(...Gg.getFields(e))}static fromBuffer(e){const t=Js.asReader(e);return new Gg(t.readObject(Mh),t.readObject(Mh),si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),t.readArray(Ii,Cg),si.fromBuffer(t),si.fromBuffer(t),si.fromBuffer(t),t.readArray(Ii,yg))}toString(){return Ds(this.toBuffer())}static fromString(e){return Gg.fromBuffer(Os(e))}toJSON(){return this.toBuffer()}static get schema(){return Qs(Gg)}static random(){return new Gg(Mh.random(),Mh.random(),si.random(),si.random(),si.random(),si.random(),si.random(),uh(Ii,Cg.random),si.random(),si.random(),si.random(),uh(Ii,yg.empty))}}function Zg(e){return new si(BigInt(e))}function Jg(e=1){return new Mh(new si(e),e)}i(8891).Buffer;class Xg{constructor(e,t,n){this.archive=e,this.header=t,this.body=n}static get schema(){return zs.object({archive:Mh.schema,header:Kh.schema,body:gg.schema}).transform((({archive:e,header:t,body:n})=>new Xg(e,t,n)))}static fromBuffer(e){const t=Js.asReader(e),n=t.readObject(Kh),s=t.readObject(Mh),i=t.readObject(gg);return new Xg(s,n,i)}toBuffer(){return _i(this.header,this.archive,this.body)}static fromString(e){return Xg.fromBuffer(Os(e))}toString(){return Ds(this.toBuffer())}static async random(e,t=4,n=3,s=1,i=void 0,r=void 0){const a=await gg.random(t,n,s);return new Xg(Jg(e+1),function(e=0,t,n,s,i){return new Kh(Jg(e+256),function(e=0,t,n){return new Wh(new si(t||e),m(BigInt(e+256),Xh),n??m(BigInt(e+512),Xh),m(BigInt(e+768),Xh))}(e+512,t,i),function(e=0){return new qh(Jg(e),function(e=0){return new Vh(Jg(e),Jg(e+1),Jg(e+2))}(e+1))}(e+1536),function(e=1,t,n){return new bh(new si(e),new si(e+1),new si(t??e+2),new si(n??e+3),new si(e+4),Nc.fromField(new si(e+5)),Gc.fromField(new si(e+6)),new ph(new si(e+7),new si(e+8)))}(e+=1792,n,s??n),Zg(e+2048),Zg(e+2304))}(0,t,e,r??e,i),a)}static empty(){return new Xg(Mh.zero(),Kh.empty(),gg.empty())}get number(){return Number(this.header.globalVariables.blockNumber.toBigInt())}hash(){return this.header.hash()}getPublicInputsHash(){return function(e){const t=_i(e);return si.fromBuffer(dl(t))}([this.header.globalVariables,Mh.zero(),Mh.zero(),Mh.zero(),Mh.zero(),this.header.lastArchive,this.header.state.partial.noteHashTree,this.header.state.partial.nullifierTree,this.header.state.partial.publicDataTree,this.header.state.l1ToL2MessageTree,this.archive])}getStartStateHash(){return cl(_i(new si(Number(this.header.globalVariables.blockNumber.toBigInt())-1),Mh.zero(),Mh.zero(),Mh.zero(),Mh.zero(),this.header.lastArchive))}getEndStateHash(){return cl(_i(this.header.globalVariables.blockNumber,this.header.state.partial.noteHashTree,this.header.state.partial.nullifierTree,this.header.state.partial.publicDataTree,this.header.state.l1ToL2MessageTree,this.archive))}getStats(){const e={privateLogCount:this.body.txEffects.reduce(((e,t)=>e+t.privateLogs.length),0),publicLogCount:this.body.txEffects.reduce(((e,t)=>e+t.publicLogs.length),0),contractClassLogCount:this.body.txEffects.reduce(((e,t)=>e+t.contractClassLogs.getTotalLogCount()),0),contractClassLogSize:this.body.txEffects.reduce(((e,t)=>e+t.contractClassLogs.getSerializedLength()),0)};return{txCount:this.body.txEffects.length,blockNumber:this.number,blockTimestamp:this.header.globalVariables.timestamp.toNumber(),...e}}}const Wg=zs.union([zs.object({number:zs.literal(0),hash:zs.undefined()}),zs.object({number:zs.number(),hash:zs.string()})]),Vg=zs.object({latest:Wg,proven:Wg,finalized:Wg});class qg extends il{constructor(e){super(e)}static random(){return new qg(si.random().toBuffer())}static get schema(){return id.BufferHex.transform((e=>new qg(e)))}static zero(){return new qg(il.ZERO.toBuffer())}static fromField(e){return new qg(e.toBuffer())}}var Kg;!function(e){e.DROPPED="dropped",e.PENDING="pending",e.SUCCESS="success",e.APP_LOGIC_REVERTED="app_logic_reverted",e.TEARDOWN_REVERTED="teardown_reverted",e.BOTH_REVERTED="both_reverted"}(Kg||(Kg={}));class $g{constructor(e,t,n,s,i,r,a){this.txHash=e,this.status=t,this.error=n,this.transactionFee=s,this.blockHash=i,this.blockNumber=r,this.debugInfo=a}static empty(){return new $g(km.zero(),Kg.DROPPED,"")}static get schema(){return zs.object({txHash:km.schema,status:zs.nativeEnum(Kg),error:zs.string(),blockHash:qg.schema.optional(),blockNumber:zs.number().optional(),transactionFee:id.BigInt.optional(),debugInfo:e_.optional()}).transform($g.from)}static from(e){return new $g(e.txHash,e.status,e.error,e.transactionFee,e.blockHash,e.blockNumber,e.debugInfo)}static statusFromRevertCode(e){if(e.equals(im.OK))return Kg.SUCCESS;if(e.equals(im.APP_LOGIC_REVERTED))return Kg.APP_LOGIC_REVERTED;if(e.equals(im.TEARDOWN_REVERTED))return Kg.TEARDOWN_REVERTED;if(e.equals(im.BOTH_REVERTED))return Kg.BOTH_REVERTED;throw new Error(`Unknown revert code: ${e}`)}}const e_=zs.object({noteHashes:zs.array(id.Fr),nullifiers:zs.array(id.Fr),publicDataWrites:zs.array(Bh.schema),l2ToL1Msgs:zs.array(id.Fr)});zs.function().args().returns(id.EthAddress),zs.function().args().returns(id.EthAddress),zs.function().args().returns(id.Integer),zs.function().args().returns(id.Integer),zs.function().args().returns(id.Integer.optional()),zs.function().args(id.Integer).returns(Xg.schema.optional()),zs.function().args(zs.union([id.Integer,zs.literal("latest")])).returns(Kh.schema.optional()),zs.function().args(id.Integer,id.Integer,Is(zs.boolean())).returns(zs.array(Xg.schema)),zs.function().args(km.schema).returns(dg(mg.schema).optional()),zs.function().args(km.schema).returns($g.schema.optional()),zs.function().args().returns(id.BigInt),zs.function().args().returns(id.BigInt),zs.function().args(id.BigInt).returns(zs.array(Xg.schema)),zs.function().args(id.BigInt).returns(zs.boolean()),zs.function().args().returns(Vg),zs.function().args(zs.number(),zs.number()).returns(zs.array(ip.schema)),zs.function().args(zs.array(id.Fr)).returns(zs.array(zs.array(Hm.schema))),zs.function().args(zs.number(),zs.array(id.Fr)).returns(zs.array(Is(dg(id.BigInt)))),zs.function().args(qm).returns(jm),zs.function().args(qm).returns(Qm),zs.function().args(id.AztecAddress,id.FunctionSelector).returns(fu.optional()),zs.function().args(id.Fr).returns(bu.optional()),zs.function().args(id.Fr).returns(id.Fr),zs.function().args(id.AztecAddress).returns(yu.optional()),zs.function().args().returns(zs.array(id.Fr)),zs.function().args(id.AztecAddress,zs.array(zs.string())).returns(zs.void()),zs.function().args(id.BigInt).returns(zs.array(id.Fr)),zs.function().args(id.Fr).returns(id.BigInt.optional()),zs.function().args(bu).returns(zs.void()),zs.function().args(id.AztecAddress,id.FunctionSelector).returns(Is(zs.string())),zs.function().args().returns(cg),Error;class t_ extends Error{constructor(){super(...arguments),this.name="TimeoutError"}}function n_(e,t){return new Promise((n=>setTimeout((()=>n(t)),e)))}Error;class s_{constructor(){this.start=performance?performance.now():Date.now()}us(){return 1e3*this.ms()}ms(){return(performance?performance.now():Date.now())-this.start}s(){return this.ms()/1e3}}class i_ extends Error{}async function r_(e,t="",n=0,s=1){const i=new s_;for(;;){const r=await e();if(r)return r;if(await n_(1e3*s),n&&i.s()>n)throw new t_(t?`Timeout awaiting ${t}`:"Timeout")}}const a_=Pe("json-rpc:json_rpc_client");async function o_(e,t,n,s,i={},r=!1){let a,o;a_.debug((0,f.format)("JsonRpcClient.fetch",e,t,"->",n));try{a=s?await fetch(`${e}/${t}`,{method:"POST",body:_h(n),headers:{"content-type":"application/json",...i}}):await fetch(e,{method:"POST",body:_h({...n,method:t}),headers:{"content-type":"application/json",...i}})}catch(n){const s=`Error fetching from host ${e} with method ${t}: ${(0,f.inspect)(n)}`;throw new Error(s)}try{o=await a.json()}catch(e){if(!a.ok)throw new Error(a.statusText);throw new Error(`Failed to parse body as JSON: ${a.text()}`)}if(!a.ok){const n=`Error ${a.status} from server ${e} on ${t}: ${o.error.message}`;throw r||a.status>=400&&a.status<500?new i_(n):new Error(n)}return o}var l_,c_,d_,u_,f_;(c_=l_||(l_={}))[c_.NULLIFIER_TREE=0]="NULLIFIER_TREE",c_[c_.NOTE_HASH_TREE=1]="NOTE_HASH_TREE",c_[c_.PUBLIC_DATA_TREE=2]="PUBLIC_DATA_TREE",c_[c_.L1_TO_L2_MESSAGE_TREE=3]="L1_TO_L2_MESSAGE_TREE",c_[c_.ARCHIVE=4]="ARCHIVE",l_.NOTE_HASH_TREE,l_.ARCHIVE,l_.L1_TO_L2_MESSAGE_TREE,l_.NULLIFIER_TREE,l_.PUBLIC_DATA_TREE;class h_{}function p_(e){return"/aztec/"+e+"/0.1.0"}(f_=d_||(d_={}))[f_.Full=0]="Full",f_[f_.Prover=1]="Prover",function(e){e.tx="tx",e.block_proposal="block_proposal",e.block_attestation="block_attestation",e.epoch_proof_quote="epoch_proof_quote"}(u_||(u_={}));var m_,g_=i(7563);class __{constructor(e,t,n,s,i){if(this.epochToProve=e,this.validUntilSlot=t,this.bondAmount=n,this.prover=s,this.basisPointFee=i,i<0||i>1e4)throw new Error(`Invalid basisPointFee ${i}`)}static empty(){return new __(0n,0n,0n,Nc.ZERO,0)}static random(){return new __(BigInt(Math.floor(1e3*Math.random())),BigInt(Math.floor(1e6*Math.random())),BigInt(Math.floor(1e9*Math.random())),Nc.random(),Math.floor(1e4*Math.random()))}static getFields(e){return[e.epochToProve,e.validUntilSlot,e.bondAmount,e.prover,e.basisPointFee]}toBuffer(){return this.asBuffer||(this.asBuffer=_i(...__.getFields(this)),this.size=this.asBuffer.length),this.asBuffer}static fromBuffer(e){const t=Js.asReader(e);return new __(t.readUInt256(),t.readUInt256(),t.readUInt256(),t.readObject(Nc),t.readNumber())}static from(e){return new __(e.epochToProve,e.validUntilSlot,e.bondAmount,e.prover,e.basisPointFee)}toJSON(){return g_(this,"asBuffer","size")}static get schema(){return zs.object({epochToProve:id.BigInt,validUntilSlot:id.BigInt,bondAmount:id.BigInt,prover:id.EthAddress,basisPointFee:id.Integer}).transform(__.from)}toViemArgs(){return{epochToProve:this.epochToProve,validUntilSlot:this.validUntilSlot,bondAmount:this.bondAmount,prover:this.prover.toString(),basisPointFee:this.basisPointFee}}toInspect(){return{epochToProve:Number(this.epochToProve),validUntilSlot:this.validUntilSlot.toString(),bondAmount:this.bondAmount.toString(),prover:this.prover.toString(),basisPointFee:this.basisPointFee}}getSize(){return this.size||this.toBuffer(),this.size}[f.inspect.custom](){return`EpochProofQuotePayload { epochToProve: ${this.epochToProve}, validUntilSlot: ${this.validUntilSlot}, bondAmount: ${this.bondAmount}, prover: ${this.prover}, basisPointFee: ${this.basisPointFee} }`}}class b_ extends h_{constructor(e,t){super(),this.payload=e,this.signature=t}static empty(){return new b_(__.empty(),Pc.empty())}static random(){return new b_(__.random(),Pc.random())}static getFields(e){return[e.payload,e.signature]}p2pMessageIdentifier(){return Promise.resolve(new il(rl(this.signature.toBuffer())))}toBuffer(){return _i(...b_.getFields(this))}static fromBuffer(e){const t=Js.asReader(e);return new b_(t.readObject(__),t.readObject(Pc))}static get schema(){return zs.object({payload:__.schema,signature:Pc.schema}).transform((({payload:e,signature:t})=>new b_(e,t)))}static new(e,t,n){if(!t.prover.equals(n.address))throw new Error(`Quote prover does not match signer. Prover [${t.prover}], Signer [${n.address}]`);const s=n.sign(e);return new b_(t,s)}toViemArgs(){return{quote:this.payload.toViemArgs(),signature:this.signature.toViemSignature()}}toInspect(){return{signature:this.signature.toString(),...this.payload.toInspect()}}getSize(){return this.payload.getSize()+this.signature.getSize()}}b_.p2pTopic=p_(u_.epoch_proof_quote);class y_{constructor(e,t){this.pathSize=e,this.data=function(e,t){if(e.length!==t)throw new Error(`Wrong 'fixed array' size. Expected ${t}, got ${e.length}.`);return e}(t,e)}static get schema(){return id.Buffer.transform((e=>y_.fromBuffer(e)))}static schemaFor(e){return id.Buffer.transform((e=>y_.fromBuffer(e))).refine((t=>t.pathSize===e),(t=>({message:`Expected sibling path size ${e} but got ${t.pathSize}`})))}toJSON(){return this.toBuffer()}static ZERO(e,t,n){const s=[];let i=t;for(let t=0;t<e;++t)s.push(i),i=n.hash(i,i);return new y_(e,s)}static random(e){const t=Array.from({length:e},(()=>si.random().toBuffer()));return new y_(e,t)}toBuffer(){return hi(this.data)}toBufferArray(){return this.data}toFields(){return this.data.map((e=>si.fromBuffer(e)))}toTuple(){const e=this.toFields();return uh(e.length,(t=>e[t]),0)}static fromBuffer(e,t=0){const{elem:n}=y_.deserialize(e,t);return n}static deserialize(e,t=0){const{elem:n,adv:s}=function(e,t,n=0){let s=n;const i=t.readUInt32BE(s);s+=4;const r=new Array(i);for(let n=0;n<i;++n){const{elem:i,adv:a}=e(t,s);s+=a,r[n]=i}return{elem:r,adv:s-n}}(((e,t)=>({elem:e.slice(t,t+32),adv:32})),e,t),i=n.length;return{elem:new y_(i,n),adv:s}}toString(){return Ds(this.toBuffer())}static fromString(e){return y_.fromBuffer(Os(e))}getSubtreeSiblingPath(e){const t=this.data.slice(e),n=this.pathSize-e;return new y_(n,t)}}class A_{constructor(e,t,n){this.index=e,this.leafPreimage=t,this.siblingPath=n}static get schema(){return zs.object({index:id.BigInt,leafPreimage:Ip.schema,siblingPath:y_.schemaFor(Ci)}).transform((({index:e,leafPreimage:t,siblingPath:n})=>new A_(e,t,n)))}toFields(){return[new si(this.index),new si(this.leafPreimage.slot),new si(this.leafPreimage.value),new si(this.leafPreimage.nextIndex),new si(this.leafPreimage.nextSlot),...this.siblingPath.toFields()]}toBuffer(){return _i([this.index,this.leafPreimage,this.siblingPath])}toString(){return Ds(this.toBuffer())}static random(){return new A_(BigInt(Math.floor(1e3*Math.random())),Ip.random(),y_.random(Ci))}static fromBuffer(e){const t=Js.asReader(e);return new A_(p(t.readBytes(32)),t.readObject(Ip),y_.fromBuffer(t.readBytes(1284)))}static fromString(e){return A_.fromBuffer(Os(e))}}!function(e){e[e.SETUP=0]="SETUP",e[e.APP_LOGIC=1]="APP_LOGIC",e[e.TEARDOWN=2]="TEARDOWN"}(m_||(m_={}));var w_=i(5732);const x_=zs.object({filePath:zs.string(),line:zs.number(),column:zs.number(),fileSource:zs.string(),locationText:zs.string()}),v_=zs.union([zs.array(x_),zs.array(zs.string())]);class E_ extends Error{constructor(e,t,n=[],s,i){super(e,i),this.originalMessage=e,this.functionErrorStack=t,this.revertData=n,this.noirErrorStack=s,this.aztecContext="";const r=()=>this.getMessage(),a=()=>this.getStack();Object.defineProperties(this,{message:{configurable:!1,enumerable:!0,get:()=>r()},stack:{configurable:!1,enumerable:!0,get:()=>a(),set(e){}}})}getMessage(){return this.noirErrorStack&&"string"!=typeof this.noirErrorStack[0]&&this.noirErrorStack.length?`${this.originalMessage} '${this.noirErrorStack[this.noirErrorStack.length-1].locationText}'${this.aztecContext}`:this.originalMessage}getOriginalMessage(){return this.originalMessage}setOriginalMessage(e){this.originalMessage=e}enrichWithContractName(e,t){this.functionErrorStack.forEach((n=>{n.contractAddress.equals(e)&&(n.contractName=t)}))}enrichWithFunctionName(e,t,n){this.functionErrorStack.forEach((s=>{s.contractAddress.equals(e)&&s.functionSelector&&s.functionSelector.equals(t)&&(s.functionName=n)}))}getStack(){const e=this.getCallStack(),t=this.getNoirCallStack(),n=[...e.map((e=>`at ${e.contractName??e.contractAddress.toString()}.${e.functionName??e.functionSelector?.toString()??"unknown"}`)),...t.map((e=>"string"==typeof e?`at opcode ${e}`:`at ${e.locationText} (${e.filePath}:${e.line}:${e.column})`))];return[`Simulation error: ${this.message}`,...n.reverse()].join("\n")}getCallStack(){return this.functionErrorStack}getNoirCallStack(){return this.noirErrorStack||[]}setNoirCallStack(e){this.noirErrorStack=e}setAztecContext(e){this.aztecContext=e}toJSON(){return{originalMessage:this.originalMessage,functionErrorStack:this.functionErrorStack,noirErrorStack:this.noirErrorStack,revertData:this.revertData.map((e=>e.toString()))}}static get schema(){return zs.object({originalMessage:zs.string(),functionErrorStack:zs.array(zs.object({contractAddress:id.AztecAddress,contractName:zs.string().optional(),functionSelector:id.FunctionSelector,functionName:zs.string().optional()})),noirErrorStack:v_.optional(),revertData:zs.array(id.Fr)}).transform((({originalMessage:e,functionErrorStack:t,noirErrorStack:n,revertData:s})=>new E_(e,t,s,n)))}static async random(){return new E_("Random simulation error",[{contractAddress:await Gc.random(),functionSelector:ed.random()}])}}class M_{constructor(e,t){this.values=e,this.nested=t??[]}static get schema(){return zs.object({values:zs.array(id.Fr).optional(),nested:zs.array(zs.lazy((()=>M_.schema)))}).transform((({values:e,nested:t})=>new M_(e,t)))}static empty(){return new M_([])}static random(e=1){return new M_(w_(3,si.random),e>0?[M_.random(e-1)]:[])}}class z_{constructor(e,t,n,s,i){this.revertReason=e,this.constants=t,this.txEffect=n,this.publicReturnValues=s,this.gasUsed=i}static get schema(){return zs.object({revertReason:E_.schema.optional(),constants:ap.schema,txEffect:mg.schema,publicReturnValues:zs.array(M_.schema),gasUsed:zs.object({totalGas:hh.schema,teardownGas:hh.schema,publicGas:hh.schema})}).transform((e=>new z_(e.revertReason,e.constants,e.txEffect,e.publicReturnValues,e.gasUsed)))}static async random(){return new z_(await E_.random(),ap.empty(),mg.empty(),w_(2,M_.random),{teardownGas:hh.random(),totalGas:hh.random(),publicGas:hh.random()})}}const B_=zs.object({gateCounts:zs.array(zs.object({circuitName:zs.string(),gateCount:zs.number()}))});var F_;class k_ extends h_{constructor(e,t,n,s,i){super(),this.data=e,this.clientIvcProof=t,this.contractClassLogs=n,this.enqueuedPublicFunctionCalls=s,this.publicTeardownFunctionCall=i}async p2pMessageIdentifier(){return new il((await this.getTxHash()).toBuffer())}hasPublicCalls(){return this.data.numberOfPublicCallRequests()>0}getNonRevertiblePublicExecutionRequests(){const e=this.data.numberOfRevertiblePublicCallRequests();return this.enqueuedPublicFunctionCalls.slice(e)}getRevertiblePublicExecutionRequests(){const e=this.data.numberOfRevertiblePublicCallRequests();return this.enqueuedPublicFunctionCalls.slice(0,e)}getPublicTeardownExecutionRequest(){return this.publicTeardownFunctionCall.isEmpty()?void 0:this.publicTeardownFunctionCall}getGasSettings(){return this.data.constants.txContext.gasSettings}static fromBuffer(e){const t=Js.asReader(e);return new F_(t.readObject(Rp),t.readObject(Rh),t.readObject(Jm),t.readVectorUint8Prefix(Km),t.readObject(Km))}static newWithTxData(e,t){return new F_(e,Rh.empty(),Jm.empty(),[],t||Km.empty())}toBuffer(){return _i([this.data,this.clientIvcProof,this.contractClassLogs,hi(this.enqueuedPublicFunctionCalls,1),this.publicTeardownFunctionCall])}static get schema(){return zs.object({data:Rp.schema,clientIvcProof:Rh.schema,contractClassLogs:Jm.schema,enqueuedPublicFunctionCalls:zs.array(Km.schema),publicTeardownFunctionCall:Km.schema}).transform(F_.from)}static from(e){return new F_(e.data,e.clientIvcProof,e.contractClassLogs,e.enqueuedPublicFunctionCalls,e.publicTeardownFunctionCall)}async getPublicLogs(e){return e.getPublicLogs({txHash:await this.getTxHash()})}async getTxHash(e=!1){if(!this.txHash||e){const e=this.data.forPublic?await this.data.toPrivateToPublicKernelCircuitPublicInputs().hash():await this.data.toPrivateToRollupKernelCircuitPublicInputs().hash();this.txHash=new km(e)}return this.txHash}setTxHash(e){this.txHash=e}async getStats(){return{txHash:(await this.getTxHash()).toString(),noteHashCount:this.data.getNonEmptyNoteHashes().length,nullifierCount:this.data.getNonEmptyNullifiers().length,privateLogCount:this.data.getNonEmptyPrivateLogs().length,proofSize:this.clientIvcProof.clientIvcProofBuffer.length,size:this.toBuffer().length,feePaymentMethod:this.data.forPublic?.needsTeardown?this.data.forPublic?.needsSetup?0x43417bb1n===this.data.getNonRevertiblePublicCallRequests().at(-1).functionSelector.toField().toBigInt()?"fpc_public":"fpc_private":"fee_juice":"none",classRegisteredCount:this.contractClassLogs.unrollLogs().length,contractClassLogSize:this.contractClassLogs.getSerializedLength()}}getSize(){return this.data.getSize()+this.clientIvcProof.clientIvcProofBuffer.length+this.contractClassLogs.getSerializedLength()+Me(this.enqueuedPublicFunctionCalls)+Me([this.publicTeardownFunctionCall])}getEstimatedPrivateTxEffectsSize(){return this.contractClassLogs.getSerializedLength()+this.data.getNonEmptyNoteHashes().length*si.SIZE_IN_BYTES+this.data.getNonEmptyNullifiers().length*si.SIZE_IN_BYTES+this.data.getNonEmptyPrivateLogs().length*ip.SIZE_IN_BYTES}static async getHash(e){return function(e){return void 0!==e.hash}(e)?e.hash:await e.getTxHash()}static async getHashes(e){return await Promise.all(e.map(F_.getHash))}static clone(e){const t=Rp.fromBuffer(e.data.toBuffer()),n=Rh.fromBuffer(e.clientIvcProof.toBuffer()),s=Jm.fromBuffer(e.contractClassLogs.toBuffer()),i=e.enqueuedPublicFunctionCalls.map((e=>Km.fromBuffer(e.toBuffer()))),r=Km.fromBuffer(e.publicTeardownFunctionCall.toBuffer()),a=new F_(t,n,s,i,r);return e.txHash&&a.setTxHash(km.fromBuffer(e.txHash.toBuffer())),a}static async random(){return new F_(Rp.emptyWithNullifier(),Rh.empty(),await Jm.random(1,1),[await Km.random()],await Km.random())}filterRevertedLogs(e){this.contractClassLogs=this.contractClassLogs.filterScoped(e.contractClassLogsHashes,Jm.empty())}}(F_=k_).p2pTopic=p_(u_.tx);class C_{constructor(e,t){this.privateExecutionResult=e,this.publicInputs=t}getPrivateReturnValues(){return function(e){const t=e=>{const n=new M_(e.returnValues);return n.nested=e.nestedExecutions.map((e=>t(e))),n};return t(e.entrypoint)}(this.privateExecutionResult)}toSimulatedTx(){const e=new Jm([rg(this.privateExecutionResult)]),t=og(this.privateExecutionResult),n=lg(this.privateExecutionResult);return new k_(this.publicInputs,Rh.empty(),e,t,n)}}class O_ extends C_{constructor(e,t,n,s){super(e,t),this.publicOutput=n,this.profileResult=s}get gasUsed(){return this.publicOutput?.gasUsed??{totalGas:this.publicInputs.gasUsed,teardownGas:hh.empty(),publicGas:hh.empty()}}static get schema(){return zs.object({privateExecutionResult:ng.schema,publicInputs:Rp.schema,publicOutput:z_.schema.optional(),profileResult:B_.optional()}).transform(O_.from)}static from(e){return new O_(e.privateExecutionResult,e.publicInputs,e.publicOutput,e.profileResult)}getPublicReturnValues(){return this.publicOutput?this.publicOutput.publicReturnValues:[]}static fromPrivateSimulationResultAndPublicOutput(e,t,n){return new O_(e.privateExecutionResult,e.publicInputs,t,n)}static async random(){return new O_(await ng.random(),Rp.empty(),await z_.random())}}class D_{constructor(e,t,n){this.privateExecutionResult=e,this.publicInputs=t,this.clientIvcProof=n}toTx(){const e=new Jm([rg(this.privateExecutionResult)]),t=og(this.privateExecutionResult),n=lg(this.privateExecutionResult);return new k_(this.publicInputs,this.clientIvcProof,e,t,n)}static get schema(){return zs.object({privateExecutionResult:ng.schema,publicInputs:Rp.schema,clientIvcProof:Rh.schema}).transform(D_.from)}static from(e){return new D_(e.privateExecutionResult,e.publicInputs,e.clientIvcProof)}static async random(){return new D_(await ng.random(),Rp.empty(),Rh.empty())}}const L_=zs.discriminatedUnion("result",[zs.object({result:zs.literal("valid"),reason:zs.array(zs.string()).optional()}),zs.object({result:zs.literal("invalid"),reason:zs.array(zs.string())}),zs.object({result:zs.literal("skipped"),reason:zs.array(zs.string())})]),T_=zs.union([zs.object({address:id.AztecAddress,selector:id.FunctionSelector}),zs.object({address:id.AztecAddress}),zs.object({classId:id.Fr,selector:id.FunctionSelector}),zs.object({classId:id.Fr})]),S_=zs.object({transactionPollingIntervalMS:zs.number().optional(),maxTxsPerBlock:zs.number().optional(),minTxsPerBlock:zs.number().optional(),maxL2BlockGas:zs.number().optional(),maxDABlockGas:zs.number().optional(),coinbase:id.EthAddress.optional(),feeRecipient:id.AztecAddress.optional(),acvmWorkingDirectory:zs.string().optional(),acvmBinaryPath:zs.string().optional(),allowedInSetup:zs.array(T_).optional(),maxBlockSizeInBytes:zs.number().optional(),enforceFees:zs.boolean().optional(),governanceProposerPayload:id.EthAddress.optional(),maxL1TxInclusionTimeIntoSlot:zs.number().optional(),enforceTimeTable:zs.boolean().optional()}),N_=zs.union([id.Integer,zs.literal("latest")]);class P_{constructor(e,t,n){this.index=e,this.leafPreimage=t,this.siblingPath=n}static get schema(){return zs.object({index:id.BigInt,leafPreimage:ch.schema,siblingPath:y_.schemaFor(Oi)}).transform((({index:e,leafPreimage:t,siblingPath:n})=>new P_(e,t,n)))}static random(){return new P_(BigInt(Math.floor(1e3*Math.random())),ch.random(),y_.random(Oi))}toFields(){return[new si(this.index),...this.leafPreimage.toFields(),...this.siblingPath.toFields()]}}var I_,Y_;i(8891).Buffer;const Q_=zs.object({nodeUrl:zs.string().optional(),realProofs:zs.boolean(),proverId:id.Fr,proverTestDelayMs:zs.number(),proverAgentCount:zs.number()});si.ZERO,ze(0),ze(1);class j_ extends Error{constructor(e,t){super(e),this.txHashes=t,this.name=Hs(I_,I_,"f",Y_)}static isBlockProofError(e){return e&&"object"==typeof e&&e.name===Hs(I_,I_,"f",Y_)}}I_=j_,Y_={value:"BlockProofError"},zs.function().args().returns(Vg),zs.function().args(N_,zs.nativeEnum(l_),zs.array(id.Fr)).returns(zs.array(Is(id.BigInt))),zs.function().args(N_,zs.nativeEnum(l_),zs.array(id.BigInt)).returns(zs.array(Is(id.BigInt))),zs.function().args(N_,zs.array(id.Fr)).returns(zs.array(Is(dg(id.BigInt)))),zs.function().args(N_,id.BigInt).returns(y_.schemaFor(Oi)),zs.function().args(N_,id.BigInt).returns(y_.schemaFor(40)),zs.function().args(N_,id.Fr).returns(zs.tuple([id.BigInt,y_.schemaFor(39)]).optional()),zs.function().args(id.Fr).returns(zs.boolean()),zs.function().args(N_,id.Fr).returns(zs.tuple([id.BigInt,y_.schema])),zs.function().args(N_,id.BigInt).returns(y_.schemaFor(Fi)),zs.function().args(N_,id.BigInt).returns(y_.schemaFor(Ci)),zs.function().args(N_,id.Fr).returns(P_.schema.optional()),zs.function().args(N_,id.Fr).returns(P_.schema.optional()),zs.function().args(N_,id.Fr).returns(A_.schema.optional()),zs.function().args(zs.number()).returns(Xg.schema.optional()),zs.function().returns(zs.number()),zs.function().returns(zs.number()),zs.function().returns(zs.boolean()),zs.function().returns(xu),zs.function().args(zs.number(),zs.number()).returns(zs.array(Xg.schema)),zs.function().returns(ph.schema),zs.function().returns(zs.string()),zs.function().returns(zs.number()),zs.function().returns(zs.number()),zs.function().returns(Au),zs.function().returns(wu),zs.function().args(id.AztecAddress,zs.array(zs.string())).returns(zs.void()),zs.function().args(zs.number(),zs.number()).returns(zs.array(ip.schema)),zs.function().args(qm).returns(jm),zs.function().args(qm).returns(Qm),zs.function().args(zs.array(id.Fr)).returns(zs.array(zs.array(Hm.schema))),zs.function().args(k_.schema).returns(zs.void()),zs.function().args(km.schema).returns($g.schema),zs.function().args(km.schema).returns(dg(mg.schema).optional()),zs.function().returns(zs.array(k_.schema)),zs.function().returns(zs.number()),zs.function().args(km.schema).returns(k_.schema.optional()),zs.function().args(zs.array(km.schema)).returns(zs.array(k_.schema)),zs.function().args(id.AztecAddress,id.Fr,N_).returns(id.Fr),zs.function().args(Is(N_)).returns(Kh.schema),zs.function().args(k_.schema,Is(zs.boolean())).returns(z_.schema),zs.function().args(k_.schema,Is(zs.boolean())).returns(L_),zs.function().args(S_.merge(Q_).partial()).returns(zs.void()),zs.function().args(id.Fr).returns(bu.optional()),zs.function().args(id.AztecAddress).returns(yu.optional()),zs.function().returns(zs.void()),zs.function().returns(zs.string().optional()),zs.function().args(b_.schema).returns(zs.void()),zs.function().args(id.BigInt).returns(zs.array(b_.schema)),zs.function().args(bu).returns(zs.void()),zs.function().args(zs.number().min(1).int()).returns(zs.void()),zs.function().args().returns(zs.boolean()),zs.function().args().returns(zs.array(zs.object({id:zs.string(),type:zs.string()}))),zs.function().args(km.schema).returns(k_.schema.optional()),zs.function().args(zs.array(km.schema)).returns(zs.array(k_.schema)),zs.function().args(b_.schema).returns(zs.void()),zs.function().args().returns(zs.array(zs.object({uuid:zs.string(),status:zs.enum(["initialized","processing","awaiting-prover","publishing-proof","completed","failed","stopped","timed-out"])}))),zs.function().args(id.Integer).returns(zs.void()),zs.function().args(id.Integer).returns(zs.void()),zs.function().args(b_.schema).returns(zs.void());class H_{constructor(e){this.clientIVCData=e}static from(e){return new H_(...H_.getFields(e))}static getFields(e){return[e.clientIVCData]}toBuffer(){return _i(...H_.getFields(this))}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new H_(t.readObject(Rh))}isEmpty(){return this.clientIVCData.isEmpty()}static fromString(e){return H_.fromBuffer(Os(e))}static empty(){return new H_(Rh.empty())}toJSON(){return this.toBuffer()}static get schema(){return Qs(H_)}}function U_(e){return zs.object({proof:qp.schemaFor(e),verificationKey:Sp.schema})}function R_(e,t){return zs.object({inputs:e,proof:qp.schemaFor(t),verificationKey:Sp.schema})}var G_;!function(e){e[e.PUBLIC_VM=0]="PUBLIC_VM",e[e.PRIVATE_BASE_ROLLUP=1]="PRIVATE_BASE_ROLLUP",e[e.PUBLIC_BASE_ROLLUP=2]="PUBLIC_BASE_ROLLUP",e[e.MERGE_ROLLUP=3]="MERGE_ROLLUP",e[e.EMPTY_BLOCK_ROOT_ROLLUP=4]="EMPTY_BLOCK_ROOT_ROLLUP",e[e.BLOCK_ROOT_ROLLUP=5]="BLOCK_ROOT_ROLLUP",e[e.SINGLE_TX_BLOCK_ROOT_ROLLUP=6]="SINGLE_TX_BLOCK_ROOT_ROLLUP",e[e.BLOCK_MERGE_ROLLUP=7]="BLOCK_MERGE_ROLLUP",e[e.ROOT_ROLLUP=8]="ROOT_ROLLUP",e[e.BASE_PARITY=9]="BASE_PARITY",e[e.ROOT_PARITY=10]="ROOT_PARITY",e[e.TUBE_PROOF=11]="TUBE_PROOF"}(G_||(G_={}));const Z_=zs.object({type:zs.literal(G_.PUBLIC_VM),inputs:jh.schema});zs.discriminatedUnion("type",[Z_,zs.object({type:zs.literal(G_.BASE_PARITY),inputs:Gp.schema}),zs.object({type:zs.literal(G_.ROOT_PARITY),inputs:em.schema}),zs.object({type:zs.literal(G_.PRIVATE_BASE_ROLLUP),inputs:jg.schema}),zs.object({type:zs.literal(G_.PUBLIC_BASE_ROLLUP),inputs:Ug.schema}),zs.object({type:zs.literal(G_.MERGE_ROLLUP),inputs:Yg.schema}),zs.object({type:zs.literal(G_.BLOCK_ROOT_ROLLUP),inputs:Ng.schema}),zs.object({type:zs.literal(G_.SINGLE_TX_BLOCK_ROOT_ROLLUP),inputs:Pg.schema}),zs.object({type:zs.literal(G_.EMPTY_BLOCK_ROOT_ROLLUP),inputs:Ig.schema}),zs.object({type:zs.literal(G_.BLOCK_MERGE_ROLLUP),inputs:Dg.schema}),zs.object({type:zs.literal(G_.ROOT_ROLLUP),inputs:Rg.schema}),zs.object({type:zs.literal(G_.TUBE_PROOF),inputs:H_.schema})]);const J_=zs.discriminatedUnion("type",[zs.object({type:zs.literal(G_.PUBLIC_VM),result:U_(4154)}),zs.object({type:zs.literal(G_.PRIVATE_BASE_ROLLUP),result:R_(Eg.schema,ji)}),zs.object({type:zs.literal(G_.PUBLIC_BASE_ROLLUP),result:R_(Eg.schema,ji)}),zs.object({type:zs.literal(G_.MERGE_ROLLUP),result:R_(Eg.schema,ji)}),zs.object({type:zs.literal(G_.EMPTY_BLOCK_ROOT_ROLLUP),result:R_(kg.schema,ji)}),zs.object({type:zs.literal(G_.BLOCK_ROOT_ROLLUP),result:R_(kg.schema,ji)}),zs.object({type:zs.literal(G_.SINGLE_TX_BLOCK_ROOT_ROLLUP),result:R_(kg.schema,ji)}),zs.object({type:zs.literal(G_.BLOCK_MERGE_ROLLUP),result:R_(kg.schema,ji)}),zs.object({type:zs.literal(G_.ROOT_ROLLUP),result:R_(Gg.schema,459)}),zs.object({type:zs.literal(G_.BASE_PARITY),result:R_(Zp.schema,459)}),zs.object({type:zs.literal(G_.ROOT_PARITY),result:R_(Zp.schema,459)}),zs.object({type:zs.literal(G_.TUBE_PROOF),result:U_(538)})]),X_=zs.string(),W_=zs.string().brand("ProvingJobUri"),V_=zs.object({id:X_,type:zs.nativeEnum(G_),epochNumber:zs.number(),inputsUri:W_}),q_=zs.object({status:zs.literal("fulfilled"),value:W_}),K_=zs.object({status:zs.literal("rejected"),reason:zs.string()});zs.discriminatedUnion("status",[q_,K_]),zs.discriminatedUnion("status",[zs.object({status:zs.literal("in-queue")}),zs.object({status:zs.literal("in-progress")}),zs.object({status:zs.literal("not-found")}),q_,K_]),zs.function().args().returns(V_.optional()),zs.function().args(X_).returns(zs.void()),zs.function().args(X_,J_).returns(zs.void()),zs.function().args(X_,zs.string()).returns(zs.void());class $_{constructor(e,t){this.requestHash=e,this.witness=t.map((e=>new si(e)))}static get schema(){return Ys($_)}toJSON(){return this.toString()}toBuffer(){return _i(this.requestHash,new ih(this.witness))}static fromBuffer(e){const t=Js.asReader(e);return new $_(si.fromBuffer(t),t.readVector(si))}toString(){return Ds(this.toBuffer())}static fromString(e){return $_.fromBuffer(Os(e))}static random(){return new $_(si.random(),[si.random(),si.random(),si.random()])}}var eb,tb;!function(e){e[e.EQ=1]="EQ",e[e.NEQ=2]="NEQ",e[e.LT=3]="LT",e[e.LTE=4]="LTE",e[e.GT=5]="GT",e[e.GTE=6]="GTE"}(eb||(eb={}));class nb{constructor(e,t,n,s,i,r){this.note=e,this.owner=t,this.contractAddress=n,this.storageSlot=s,this.noteTypeId=i,this.txHash=r}toBuffer(){return _i([this.note,this.owner,this.contractAddress,this.storageSlot,this.noteTypeId,this.txHash])}static fromBuffer(e){const t=Js.asReader(e);return new this(t.readObject(Fm),t.readObject(Gc),t.readObject(Gc),t.readObject(si),t.readObject(nd),t.readObject(km))}static get schema(){return zs.object({note:Fm.schema,owner:id.AztecAddress,contractAddress:id.AztecAddress,storageSlot:id.Fr,noteTypeId:id.NoteSelector,txHash:km.schema}).transform((({note:e,owner:t,contractAddress:n,storageSlot:s,noteTypeId:i,txHash:r})=>new nb(e,t,n,s,i,r)))}toString(){return Ds(this.toBuffer())}static fromString(e){return nb.fromBuffer(Os(e))}static async random(){return new nb(Fm.random(),await Gc.random(),await Gc.random(),si.random(),nd.random(),km.random())}}class sb extends nb{constructor(e,t,n,s,i,r,a){super(e,t,n,s,i,r),this.nonce=a}static get schema(){return zs.object({note:Fm.schema,owner:id.AztecAddress,contractAddress:id.AztecAddress,storageSlot:id.Fr,noteTypeId:id.NoteSelector,txHash:km.schema,nonce:id.Fr}).transform((({note:e,owner:t,contractAddress:n,storageSlot:s,noteTypeId:i,txHash:r,nonce:a})=>new sb(e,t,n,s,i,r,a)))}toBuffer(){return _i([this.note,this.owner,this.contractAddress,this.storageSlot,this.noteTypeId,this.txHash,this.nonce])}static async random(){return new sb(Fm.random(),await Gc.random(),await Gc.random(),si.random(),nd.random(),km.random(),si.random())}static fromBuffer(e){const t=Js.asReader(e);return new this(t.readObject(Fm),t.readObject(Gc),t.readObject(Gc),t.readObject(si),t.readObject(nd),t.readObject(km),t.readObject(si))}static fromString(e){return sb.fromBuffer(Os(e))}}!function(e){e[e.ACTIVE=1]="ACTIVE",e[e.ACTIVE_OR_NULLIFIED=2]="ACTIVE_OR_NULLIFIED"}(tb||(tb={}));const ib=zs.object({txHash:km.schema.optional(),contractAddress:id.AztecAddress.optional(),storageSlot:id.Fr.optional(),owner:id.AztecAddress.optional(),status:zs.nativeEnum(tb).optional(),siloedNullifier:id.Fr.optional(),scopes:zs.array(id.AztecAddress).optional()});class rb{constructor(e,t){this.values=e,this.hash=t}static get schema(){return zs.array(id.Fr).transform(rb.fromValues)}toJSON(){return this.values}static random(){return rb.fromValues([si.random(),si.random()])}static async fromValues(e){return new rb(e,await Qd(e))}toBuffer(){return _i(new ih(this.values),this.hash)}static fromBuffer(e){const t=Js.asReader(e);return new rb(t.readVector(si),si.fromBuffer(t))}}class ab{constructor(e,t,n,s,i,r){this.origin=e,this.functionSelector=t,this.firstCallArgsHash=n,this.txContext=s,this.argsOfCalls=i,this.authWitnesses=r}static get schema(){return zs.object({origin:id.AztecAddress,functionSelector:id.FunctionSelector,firstCallArgsHash:id.Fr,txContext:$h.schema,argsOfCalls:zs.array(rb.schema),authWitnesses:zs.array($_.schema)}).transform(ab.from)}toTxRequest(){return new Np(this.origin,new ep(this.functionSelector,!0),this.firstCallArgsHash,this.txContext)}static getFields(e){return[e.origin,e.functionSelector,e.firstCallArgsHash,e.txContext,e.argsOfCalls,e.authWitnesses]}static from(e){return new ab(...ab.getFields(e))}toBuffer(){return _i(this.origin,this.functionSelector,this.firstCallArgsHash,this.txContext,new ih(this.argsOfCalls),new ih(this.authWitnesses))}toString(){return Ds(this.toBuffer())}static fromBuffer(e){const t=Js.asReader(e);return new ab(t.readObject(Gc),t.readObject(ed),si.fromBuffer(t),t.readObject($h),t.readVector(rb),t.readVector($_))}static fromString(e){return ab.fromBuffer(Os(e))}static async random(){return new ab(await Gc.random(),ed.random(),si.random(),$h.empty(),[await rb.random()],[$_.random()])}[f.inspect.custom](){return`TxExecutionRequest(${this.origin} called ${this.functionSelector})`}}const ob=zs.object({eventSelector:id.EventSelector,abiType:dd,fieldNames:zs.array(zs.string())});var lb;!function(e){e.Encrypted="Encrypted",e.Unencrypted="Unencrypted"}(lb||(lb={}));const cb=zs.object({contractInstance:zs.union([yu,zs.undefined()]),isContractInitialized:zs.boolean(),isContractPubliclyDeployed:zs.boolean()}),db=zs.object({contractClass:zs.union([_u,zs.undefined()]),isContractClassPubliclyRegistered:zs.boolean(),artifact:zs.union([Ad,zs.undefined()])}),ub=zs.object({pxeVersion:zs.string(),protocolContractAddresses:wu}),fb={isL1ToL2MessageSynced:zs.function().args(id.Fr).returns(zs.boolean()),addAuthWitness:zs.function().args($_.schema).returns(zs.void()),getAuthWitness:zs.function().args(id.Fr).returns(zs.union([zs.undefined(),zs.array(id.Fr)])),addCapsule:zs.function().args(zs.array(id.Fr)).returns(zs.void()),registerAccount:zs.function().args(id.Fr,id.Fr).returns(Zh.schema),getRegisteredAccounts:zs.function().returns(zs.array(Zh.schema)),registerSender:zs.function().args(id.AztecAddress).returns(id.AztecAddress),getSenders:zs.function().returns(zs.array(id.AztecAddress)),removeSender:zs.function().args(id.AztecAddress).returns(zs.void()),registerContractClass:zs.function().args(Ad).returns(zs.void()),registerContract:zs.function().args(zs.object({instance:yu,artifact:zs.optional(Ad)})).returns(zs.void()),getContracts:zs.function().returns(zs.array(id.AztecAddress)),proveTx:zs.function().args(ab.schema,ng.schema).returns(D_.schema),simulateTx:zs.function().args(ab.schema,zs.boolean(),Is(id.AztecAddress),Is(zs.boolean()),Is(zs.boolean()),Is(zs.boolean()),Is(zs.array(id.AztecAddress))).returns(O_.schema),sendTx:zs.function().args(k_.schema).returns(km.schema),getTxReceipt:zs.function().args(km.schema).returns($g.schema),getTxEffect:zs.function().args(km.schema).returns(zs.union([dg(mg.schema),zs.undefined()])),getPublicStorageAt:zs.function().args(id.AztecAddress,id.Fr).returns(id.Fr),getNotes:zs.function().args(ib).returns(zs.array(sb.schema)),getL1ToL2MembershipWitness:zs.function().args(id.AztecAddress,id.Fr,id.Fr).returns(zs.tuple([id.BigInt,y_.schemaFor(39)])),getL2ToL1MembershipWitness:zs.function().args(zs.number(),id.Fr).returns(zs.tuple([id.BigInt,y_.schema])),addNote:zs.function().args(nb.schema,Is(id.AztecAddress)).returns(zs.void()),addNullifiedNote:zs.function().args(nb.schema).returns(zs.void()),getBlock:zs.function().args(zs.number()).returns(zs.union([Xg.schema,zs.undefined()])),getCurrentBaseFees:zs.function().returns(ph.schema),simulateUnconstrained:zs.function().args(zs.string(),zs.array(zs.any()),id.AztecAddress,Is(id.AztecAddress),Is(zs.array(id.AztecAddress))).returns(rd),getPublicLogs:zs.function().args(qm).returns(jm),getContractClassLogs:zs.function().args(qm).returns(Qm),getBlockNumber:zs.function().returns(zs.number()),getProvenBlockNumber:zs.function().returns(zs.number()),getNodeInfo:zs.function().returns(xu),getPXEInfo:zs.function().returns(ub),getContractMetadata:zs.function().args(id.AztecAddress).returns(cb),getContractClassMetadata:zs.function().args(id.Fr,Is(zs.boolean())).returns(db),getPrivateEvents:zs.function().args(ob,zs.number(),zs.number(),zs.array(id.Point)).returns(zs.array(rd)),getPublicEvents:zs.function().args(ob,zs.number(),zs.number()).returns(zs.array(rd))};var hb;!function(e){e[e.IDLE=0]="IDLE",e[e.SYNCHING=1]="SYNCHING",e[e.RUNNING=2]="RUNNING",e[e.STOPPED=3]="STOPPED"}(hb||(hb={}));var pb,mb,gb=i(4246),_b=i(3021),bb=(i(7775),i(1542)),yb=i(2142);class Ab{constructor(e,t,n){this.header=e,this.archive=t,this.txHashes=n}static get schema(){return zs.object({header:Kh.schema,archive:si.schema,txHashes:zs.array(km.schema)}).transform((e=>new Ab(e.header,e.archive,e.txHashes)))}static getFields(e){return[e.header,e.archive,e.txHashes]}async getPayloadToSign(e){const t=function(e){const t=[];{const n=(0,bb.NV)(e),s=n.length;for(let e=0;e<s;e++)t.push((0,bb.Pj)(n[e],{modifiers:_b.Dv}))}if(0===t.length)throw new gb.A9({params:e});return t}("uint8, (bytes32, bytes32, (uint256, uint256), bytes, bytes32[])"),n=this.txHashes.map((e=>e.toString()));return Os((0,yb.h)(t,[e,[this.archive.toString(),(await this.header.hash()).toString(),[0n,0n],this.header.toString(),n]]))}toBuffer(){const e=_i([this.header,this.archive,this.txHashes.length,this.txHashes]);return this.size=e.length,e}static fromBuffer(e){const t=Js.asReader(e);return new Ab(t.readObject(Kh),t.readObject(si),t.readArray(t.readNumber(),km))}static fromFields(e){return new Ab(e.header,e.archive,e.txHashes)}static empty(){return new Ab(Kh.empty(),si.ZERO,[])}getSize(){return this.size||(this.size=this.toBuffer().length),this.size}}async function wb(e,t){return il.fromBuffer(rl(await e.getPayloadToSign(t)))}async function xb(e,t){return function(e){const t=Ic.from("Ethereum Signed Message:\n32");return il.fromBuffer(rl(Ic.concat([t,e.buffer])))}(await wb(e,t))}(mb=pb||(pb={}))[mb.blockProposal=0]="blockProposal",mb[mb.blockAttestation=1]="blockAttestation";class vb extends il{constructor(e){super(e)}}class Eb extends h_{constructor(e,t){super(),this.payload=e,this.signature=t}static get schema(){return zs.object({payload:Ab.schema,signature:Pc.schema}).transform((e=>new Eb(e.payload,e.signature)))}p2pMessageIdentifier(){return Promise.resolve(new vb(rl(this.signature.toBuffer())))}get archive(){return this.payload.archive}get slotNumber(){return this.payload.header.globalVariables.slotNumber}get blockNumber(){return this.payload.header.globalVariables.blockNumber}async getSender(){if(!this.sender){const e=await xb(this.payload,pb.blockAttestation);this.sender=Yc(e,this.signature)}return this.sender}getPayload(){return this.payload.getPayloadToSign(pb.blockAttestation)}toBuffer(){return _i([this.payload,this.signature])}static fromBuffer(e){const t=Js.asReader(e);return new Eb(t.readObject(Ab),t.readObject(Pc))}static empty(){return new Eb(Ab.empty(),Pc.empty())}getSize(){return this.payload.getSize()+this.signature.getSize()}}Eb.p2pTopic=p_(u_.block_attestation);const Mb=zs.discriminatedUnion("status",[zs.object({status:zs.literal("connected"),score:zs.number(),id:zs.string()}),zs.object({status:zs.literal("dialing"),dialStatus:zs.string(),id:zs.string(),addresses:zs.array(zs.string())}),zs.object({status:zs.literal("cached"),id:zs.string(),addresses:zs.array(zs.string()),enr:zs.string(),dialAttempts:zs.number()})]);function zb(e,t=function(e,t,n){return async(t,n,s,i,r={},a)=>await async function(e,t="Operation",n=function*(){const e=[1,1,1,2,4,8,16,32,64];let t=0;for(;;)yield e[Math.min(t++,e.length-1)]}(),s=Pe("foundation:retry"),i=!1){for(;;)try{return await e()}catch(e){if(e instanceof i_)throw e;const r=n.next().value;if(void 0===r)throw e;s.verbose(`${t} failed. Will retry in ${r}s...`),!i&&s.error(`Error while retrying ${t}`,e),await n_(1e3*r);continue}}((()=>o_(t,n,s,i,r,a??false)),`JsonRpcClient request ${n} to ${t}`,function*(e){for(const t of e)yield t}(e),undefined,!1)}([1,2,3])){return function(e,t,n=!1,s,i=o_,r=Pe("json-rpc:client")){let a=0;const o=async(o,l)=>{if(!function(e,t){return"string"==typeof t&&Object.hasOwn(e,t)&&"function"==typeof e[t].parameters&&"function"==typeof e[t].returnType}(t,o))throw new Error(`Unspecified method ${o} in client schema`);const c=s?`${s}_${o}`:o,d={jsonrpc:"2.0",id:a++,method:c,params:l};r.debug((0,f.format)("request",c,l));const u=await i(e,c,d,n);if(r.debug((0,f.format)("result",c,u)),u.error)throw u.error;if(![null,void 0,"null","undefined"].includes(u.result))return t[o].returnType().parseAsync(u.result)},l={};for(const e of Object.keys(t))l[e]=(...t)=>o(e,t);return l}(e,fb,!1,"pxe",t)}zs.function().args(id.BigInt,Is(zs.string())).returns(zs.array(Eb.schema)),zs.function().args(id.BigInt).returns(zs.array(b_.schema)),zs.function().returns(zs.array(k_.schema)),zs.function().returns(zs.string().optional()),zs.function().args(Is(zs.boolean())).returns(zs.array(Mb)),zs.function().returns(zs.string()),zs.function().returns(zs.array(zs.string())),i(9331);class Bb{constructor(e,t,n,s,i,r,a){this.name=e,this.to=t,this.selector=n,this.type=s,this.isStatic=i,this.args=r,this.returnTypes=a}static getFields(e){return[e.name,e.to,e.selector,e.type,e.isStatic,e.args,e.returnTypes]}static from(e){return new Bb(...Bb.getFields(e))}static empty(){return{name:"",to:Gc.ZERO,selector:ed.empty(),type:hd.PUBLIC,isStatic:!1,args:[],returnTypes:[]}}}Pe("types:l2_block_downloader"),i(8891).Buffer,i(8891).Buffer;class Fb extends il{constructor(e){super(e)}}class kb extends h_{constructor(e,t){super(),this.payload=e,this.signature=t}p2pMessageIdentifier(){return Promise.resolve(new Fb(rl(this.signature.toBuffer())))}get archive(){return this.payload.archive}get slotNumber(){return this.payload.header.globalVariables.slotNumber}get blockNumber(){return this.payload.header.globalVariables.blockNumber}static async createProposalFromSigner(e,t){const n=await wb(e,pb.blockProposal),s=await t(n);return new kb(e,s)}async getSender(){if(!this.sender){const e=await xb(this.payload,pb.blockProposal);this.sender=Yc(e,this.signature)}return this.sender}getPayload(){return this.payload.getPayloadToSign(pb.blockProposal)}toBuffer(){return _i([this.payload,this.signature])}static fromBuffer(e){const t=Js.asReader(e);return new kb(t.readObject(Ab),t.readObject(Pc))}getSize(){return this.payload.getSize()+this.signature.getSize()}}var Cb;kb.p2pTopic=p_(u_.block_proposal),u_.tx,u_.block_proposal,u_.block_attestation,u_.epoch_proof_quote,k_.p2pTopic,k_.fromBuffer,kb.p2pTopic,kb.fromBuffer,Eb.p2pTopic,Eb.fromBuffer,b_.p2pTopic,b_.fromBuffer,function(e){e.LowToleranceError="LowToleranceError",e.MidToleranceError="MidToleranceError",e.HighToleranceError="HighToleranceError"}(Cb||(Cb={}));class Ob extends Error{constructor(e,t,n=!1){super(e),this.retry=n,this.name=Ob.NAME,this.cause=t}}Ob.NAME="ProvingError";const Db={ignoreDroppedReceiptsFor:5,timeout:60,provenTimeout:600,interval:1,debug:!1};class Lb{constructor(e,t){this.pxe=e,this.txHashPromise=t}getTxHash(){return this.txHashPromise}async getReceipt(){const e=await this.getTxHash();return await this.pxe.getTxReceipt(e)}async wait(e){const t=await this.waitForReceipt(e);if(t.status!==Kg.SUCCESS&&!e?.dontThrowOnRevert)throw new Error(`Transaction ${await this.getTxHash()} was ${t.status}. Reason: ${t.error??"unknown"}`);if(e?.proven&&void 0!==t.blockNumber&&await this.waitForProven(t.blockNumber,e),e?.debug){const e=await this.getTxHash(),{data:n}=await this.pxe.getTxEffect(e);t.debugInfo={noteHashes:n.noteHashes,nullifiers:n.nullifiers,publicDataWrites:n.publicDataWrites,l2ToL1Msgs:n.l2ToL1Msgs}}return t}async getPublicLogs(){return await this.wait(),this.pxe.getPublicLogs({txHash:await this.getTxHash()})}async waitForReceipt(e){const t=await this.getTxHash(),n=Date.now(),s=e?.ignoreDroppedReceiptsFor??Db.ignoreDroppedReceiptsFor;return await r_((async()=>{const e=await this.pxe.getTxReceipt(t);if(e.status!==Kg.PENDING){if(e.status===Kg.DROPPED){const t=(Date.now()-n)/1e3;return!s||t>s?e:void 0}return e}}),"isMined",e?.timeout??Db.timeout,e?.interval??Db.interval)}async waitForProven(e,t){return await r_((async()=>{const t=await this.pxe.getProvenBlockNumber();return t>=e?t:void 0}),"isProven",t?.provenTimeout??Db.provenTimeout,t?.interval??Db.interval)}}var Tb;class Sb{constructor(e,t,n,s){this.functionCalls=e,this._hashedArguments=t,this.generatorIndex=n,this._nonce=s}static async create(e){const t=[];for(const n of e)t.push(await rb.fromValues(n.args));return{encodedFunctionCalls:e.map(((e,n)=>({args_hash:t[n].hash,function_selector:e.selector.toField(),target_address:e.to.toField(),is_public:e.type==hd.PUBLIC,is_static:e.isStatic}))),hashedArguments:t}}get function_calls(){return this.functionCalls}get nonce(){return this._nonce}get hashedArguments(){return this._hashedArguments}hash(){return wi(this.toFields(),this.generatorIndex)}functionCallsToFields(){return this.functionCalls.flatMap((e=>[e.args_hash,e.function_selector,e.target_address,new si(e.is_public),new si(e.is_static)]))}static async fromFunctionCalls(e){const{encodedFunctionCalls:t,hashedArguments:n}=await this.create(e);return new Nb(t,n,0,si.random())}static async fromAppExecution(e,t=si.random()){if(e.length>4)throw new Error(`Expected at most 4 function calls, got ${e.length}`);const n=xe(e,Bb.empty(),4),{encodedFunctionCalls:s,hashedArguments:i}=await this.create(n);return new Nb(s,i,Ri.SIGNATURE_PAYLOAD,t)}static async fromFeeOptions(e,t){const n=await(t?.paymentMethod.getFunctionCalls(t?.gasSettings))??[],s=await(t?.paymentMethod.getFeePayer(t?.gasSettings)),i=!!s&&s.equals(e),r=xe(n,Bb.empty(),2),{encodedFunctionCalls:a,hashedArguments:o}=await this.create(r);return new Pb(a,o,Ri.FEE_PAYLOAD,si.random(),i)}}class Nb extends Sb{toFields(){return[...this.functionCallsToFields(),this.nonce]}}class Pb extends Sb{constructor(e,t,n,s,i){super(e,t,n,s),Tb.set(this,void 0),Us(this,Tb,i,"f")}toFields(){return[...this.functionCallsToFields(),this.nonce,new si(Hs(this,Tb,"f"))]}get is_fee_payer(){return Hs(this,Tb,"f")}}async function Ib(e,t){return wi([await e.hash(),await t.hash()],Ri.COMBINED_PAYLOAD)}Tb=new WeakMap;class Yb{constructor(e,t){this.chainId=e,this.protocolVersion=t}async createTxExecutionRequest(e){const{fee:t,calls:n,authWitnesses:s=[],hashedArguments:i=[]}=e;if(n.length>1)throw new Error(`Expected a single call, got ${n.length}`);const r=n[0];if(r.type!==hd.PRIVATE)throw new Error("Public entrypoints are not allowed");const a=await rb.fromValues(r.args),o=new $h(this.chainId,this.protocolVersion,t.gasSettings);return Promise.resolve(new ab(r.to,r.selector,a.hash,o,[...i,a],s))}}const Qb={AuthRegistry:new si(1),ContractInstanceDeployer:new si(1),ContractClassRegisterer:new si(1),MultiCallEntrypoint:new si(1),FeeJuice:new si(1),Router:new si(1)},jb={AuthRegistry:Gc.fromBigInt(1n),ContractInstanceDeployer:Gc.fromBigInt(2n),ContractClassRegisterer:Gc.fromBigInt(3n),MultiCallEntrypoint:Gc.fromBigInt(4n),FeeJuice:Gc.fromBigInt(5n),Router:Gc.fromBigInt(6n)};si.fromHexString("0x05aacae6775e3a713c38f2a8e39bf013f9cee72e38f3befa36bea9c7eca97122"),si.fromHexString("0x1690597a03eee6329599f421bdbb6b0c43bda1db2e114dcdf039ac5eb4c9dde2"),si.fromHexString("0x05e31fb75618f83df4717ded7456ccff11c6419dd56a58a00eb8df2bcc635516"),si.fromHexString("0x130a8231f562282c5c228a51dcc383b2a3d171715fa3131f30e956d7af9844d7"),si.fromHexString("0x1afcd58afb3ea3f37604fcd481af1a7d6fa353d62598120fc04c85cf29821354"),si.fromHexString("0x158c2016352bbee2941e759f8a687b27f9284e8a78a37c74d1f61b2c3e716d3a"),si.fromHexString("0x0c8b9a6369d51ef4d43bce40898037d472f2362bb45157671b58456c23d8ceb9"),new si(11121068431693264234253912047066709627593769337094408533543930778360n),new si(2889881020989534926461066592611988634597302675057895885580456197069n),new si(24399338136397901754495080759185489776044879232766421623673792970137n),si.fromHexString("0x2ec28b91a5f838506d6042915005ff55cf7a0a5f889a83b11faed33a31b486f2"),i(8891).Buffer;class Hb{constructor(e,t,n=jb.MultiCallEntrypoint){this.chainId=e,this.version=t,this.address=n}async createTxExecutionRequest(e){const{fee:t,calls:n,authWitnesses:s=[],hashedArguments:i=[]}=e,r=await Sb.fromAppExecution(n),a=this.getEntrypointAbi(),o=await rb.fromValues(Bd(a,[r])),l=ab.from({firstCallArgsHash:o.hash,origin:this.address,functionSelector:await ed.fromNameAndParameters(a.name,a.parameters),txContext:new $h(this.chainId,this.version,t.gasSettings),argsOfCalls:[...r.hashedArguments,...i,o],authWitnesses:s});return Promise.resolve(l)}getEntrypointAbi(){return{name:"entrypoint",isInitializer:!1,functionType:"private",isInternal:!1,isStatic:!1,parameters:[{name:"app_payload",type:{kind:"struct",path:"authwit::entrypoint::app::AppPayload",fields:[{name:"function_calls",type:{kind:"array",length:4,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}}]},visibility:"public"}],returnTypes:[],errorTypes:{}}}}class Ub{constructor(){}getAsset(){return Promise.resolve(Gc.ZERO)}getFunctionCalls(){return Promise.resolve([])}getFeePayer(){return Promise.resolve(Gc.ZERO)}}function Rb(e,t=.1){return{totalGas:e.gasUsed.totalGas.mul(1+t),teardownGas:e.gasUsed.teardownGas.mul(1+t)}}class Gb extends k_{constructor(e,t){super(t.data,t.clientIvcProof,t.contractClassLogs,t.enqueuedPublicFunctionCalls,t.publicTeardownFunctionCall),this.wallet=e}getPlainDataTx(){return new k_(this.data,this.clientIvcProof,this.contractClassLogs,this.enqueuedPublicFunctionCalls,this.publicTeardownFunctionCall)}send(){const e=(()=>this.wallet.sendTx(this.getPlainDataTx()))();return new Lb(this.wallet,e)}}class Zb{constructor(e){this.wallet=e,this.log=Pe("aztecjs:contract_interaction")}async proveInternal(e={}){const t=await this.create(e),n=await this.wallet.simulateTx(t,!e.skipPublicSimulation,void 0,!0);return await this.wallet.proveTx(t,n.privateExecutionResult)}async prove(e={}){const t=await this.proveInternal(e);return new Gb(this.wallet,t.toTx())}send(e={}){const t=(async()=>{const t=await this.proveInternal(e);return this.wallet.sendTx(t.toTx())})();return new Lb(this.wallet,t)}async estimateGas(e){const t=await this.create({...e,fee:{...e?.fee,estimateGas:!1}}),n=await this.wallet.simulateTx(t,!0,void 0,void 0,!1),{totalGas:s,teardownGas:i}=Rb(n,e?.fee?.estimatedGasPadding);return{gasLimits:s,teardownGasLimits:i}}async getDefaultFeeOptions(e){const t=e?.gasSettings?.maxFeesPerGas??(await this.wallet.getCurrentBaseFees()).mul(1+(e?.baseFeePadding??.5)),n=e?.paymentMethod??new Ub,s=mh.default({...e?.gasSettings,maxFeesPerGas:t});return this.log.debug("Using L2 gas settings",s),{gasSettings:s,paymentMethod:n}}async getFeeOptions(e){const t=await this.getDefaultFeeOptions(e.fee),n=t.paymentMethod,s=t.gasSettings.maxFeesPerGas,i=t.gasSettings.maxPriorityFeesPerGas;let r=t.gasSettings;if(e.fee?.estimateGas){const t={paymentMethod:n,gasSettings:r},a=await this.wallet.createTxExecutionRequest({...e,fee:t}),o=await this.wallet.simulateTx(a,!0,void 0,void 0,!1),{totalGas:l,teardownGas:c}=Rb(o,e.fee?.estimatedGasPadding);r=mh.from({maxFeesPerGas:s,maxPriorityFeesPerGas:i,gasLimits:l,teardownGasLimits:c}),this.log.verbose(`Estimated gas limits for tx: DA=${l.daGas} L2=${l.l2Gas} teardownDA=${c.daGas} teardownL2=${c.l2Gas}`)}return{gasSettings:r,paymentMethod:n}}}class Jb extends Zb{constructor(e,t,n,s){if(super(e),this.contractAddress=t,this.functionDao=n,this.args=s,s.some((e=>null==e)))throw new Error("All function interaction arguments must be defined and not null. Received: "+s)}async create(e={}){if(this.functionDao.functionType===hd.UNCONSTRAINED)throw new Error("Can't call `create` on an unconstrained function.");const t=[await this.request()],n=await this.getFeeOptions({calls:t,...e}),{nonce:s,cancellable:i}=e;return await this.wallet.createTxExecutionRequest({calls:t,fee:n,nonce:s,cancellable:i})}async request(){const e=Bd(this.functionDao,this.args);return{name:this.functionDao.name,args:e,selector:await ed.fromNameAndParameters(this.functionDao.name,this.functionDao.parameters),type:this.functionDao.functionType,to:this.contractAddress,isStatic:this.functionDao.isStatic,returnTypes:this.functionDao.returnTypes}}async simulate(e={}){if(this.functionDao.functionType==hd.UNCONSTRAINED)return this.wallet.simulateUnconstrained(this.functionDao.name,this.args,this.contractAddress,e?.from);const t=await this.create(),n=await this.wallet.simulateTx(t,!0,e?.from,e?.skipTxValidation);let s;return s=this.functionDao.functionType==hd.PRIVATE?n.getPrivateReturnValues().nested.length>0?n.getPrivateReturnValues().nested[0].values:n.getPrivateReturnValues().values:n.getPublicReturnValues()?.[0].values,s?qc(this.functionDao.returnTypes,s):[]}async simulateWithProfile(e={}){if(this.functionDao.functionType==hd.UNCONSTRAINED)throw new Error("Can't profile an unconstrained function.");const t=await this.create(),n=await this.wallet.simulateTx(t,!0,e?.from,e?.skipTxValidation,void 0,!0),s=this.functionDao.functionType==hd.PRIVATE?n.getPrivateReturnValues().nested?.[0].values:n.getPublicReturnValues()?.[0].values;return{returnValues:s?qc(this.functionDao.returnTypes,s):[],gateCounts:n.profileResult.gateCounts}}}var Xb=i(8891).Buffer;const Wb=async(e,t)=>Vb([e.toField(),t.selector.toField(),(await rb.fromValues(t.args)).hash]),Vb=e=>wi(e,Ri.AUTHWIT_INNER),qb=(e,t,n,s)=>wi([e.toField(),t,n,s],Ri.AUTHWIT_OUTER);class Kb{constructor(e,t){this.pxe=e,this.scopes=t}setScopes(e){this.scopes=e}getScopes(){return this.scopes}getAddress(){return this.getCompleteAddress().address}addCapsule(e){return this.pxe.addCapsule(e)}registerAccount(e,t){return this.pxe.registerAccount(e,t)}getRegisteredAccounts(){return this.pxe.getRegisteredAccounts()}registerSender(e){return this.pxe.registerSender(e)}getSenders(){return this.pxe.getSenders()}async removeSender(e){await this.pxe.removeSender(e)}registerContract(e){return this.pxe.registerContract(e)}registerContractClass(e){return this.pxe.registerContractClass(e)}getContracts(){return this.pxe.getContracts()}proveTx(e,t){return this.pxe.proveTx(e,t)}simulateTx(e,t,n,s,i,r){return this.pxe.simulateTx(e,t,n,s,i,r,this.scopes)}sendTx(e){return this.pxe.sendTx(e)}getTxEffect(e){return this.pxe.getTxEffect(e)}getTxReceipt(e){return this.pxe.getTxReceipt(e)}getNotes(e){return this.pxe.getNotes(e)}getPublicStorageAt(e,t){return this.pxe.getPublicStorageAt(e,t)}addNote(e){return this.pxe.addNote(e,this.getAddress())}addNullifiedNote(e){return this.pxe.addNullifiedNote(e)}getBlock(e){return this.pxe.getBlock(e)}getCurrentBaseFees(){return this.pxe.getCurrentBaseFees()}simulateUnconstrained(e,t,n,s){return this.pxe.simulateUnconstrained(e,t,n,s)}getPublicLogs(e){return this.pxe.getPublicLogs(e)}getContractClassLogs(e){return this.pxe.getContractClassLogs(e)}getBlockNumber(){return this.pxe.getBlockNumber()}getProvenBlockNumber(){return this.pxe.getProvenBlockNumber()}getNodeInfo(){return this.pxe.getNodeInfo()}addAuthWitness(e){return this.pxe.addAuthWitness(e)}getAuthWitness(e){return this.pxe.getAuthWitness(e)}getPXEInfo(){return this.pxe.getPXEInfo()}getContractClassMetadata(e,t=!1){return this.pxe.getContractClassMetadata(e,t)}getContractMetadata(e){return this.pxe.getContractMetadata(e)}getPrivateEvents(e,t,n,s=[this.getCompleteAddress().publicKeys.masterIncomingViewingPublicKey]){return this.pxe.getPrivateEvents(e,t,n,s)}getPublicEvents(e,t,n){return this.pxe.getPublicEvents(e,t,n)}getL1ToL2MembershipWitness(e,t,n){return this.pxe.getL1ToL2MembershipWitness(e,t,n)}getL2ToL1MembershipWitness(e,t){return this.pxe.getL2ToL1MembershipWitness(e,t)}}var $b=i(8891).Buffer;class ey extends Kb{constructor(e,t){super(e,[t.getAddress()]),this.account=t}createTxExecutionRequest(e){return this.account.createTxExecutionRequest(e)}getChainId(){return this.account.getChainId()}getVersion(){return this.account.getVersion()}isL1ToL2MessageSynced(e){return this.pxe.isL1ToL2MessageSynced(e)}async createAuthWit(e){let t;t=$b.isBuffer(e)?si.fromBuffer(e):e instanceof si?e:await this.getMessageHash(e);const n=await this.account.createAuthWit(t);return await this.pxe.addAuthWitness(n),n}async setPublicAuthWit(e,t){let n;return n=$b.isBuffer(e)?si.fromBuffer(e):e instanceof si?e:await this.getMessageHash(e),new Jb(this,jb.AuthRegistry,this.getSetAuthorizedAbi(),[n,t])}async getInnerHashAndConsumer(e){if("caller"in e&&"action"in e){const t=e.action instanceof Jb?await e.action.request():e.action;return{innerHash:await Wb(e.caller,t),consumer:t.to}}return $b.isBuffer(e.innerHash)?{innerHash:si.fromBuffer(e.innerHash),consumer:e.consumer}:{innerHash:e.innerHash,consumer:e.consumer}}getMessageHash(e){return(async(e,t)=>{const n=t.chainId,s=t.version;if("caller"in e){const t=e.action instanceof Jb?await e.action.request():e.action;return qb(t.to,n,s,await Wb(e.caller,t))}{const t=Xb.isBuffer(e.innerHash)?si.fromBuffer(e.innerHash):e.innerHash;return qb(e.consumer,n,s,t)}})(e,{chainId:this.getChainId(),version:this.getVersion()})}async lookupValidity(e,t){const{innerHash:n,consumer:s}=await this.getInnerHashAndConsumer(t),i=await this.getMessageHash(t),r={isValidInPrivate:!1,isValidInPublic:!1};return void 0!==await this.getAuthWitness(i)&&(r.isValidInPrivate=await new Jb(this,e,this.getLookupValidityAbi(),[s,n]).simulate()),r.isValidInPublic=await new Jb(this,jb.AuthRegistry,this.getIsConsumableAbi(),[e,i]).simulate(),r}getCompleteAddress(){return this.account.getCompleteAddress()}getAddress(){return this.getCompleteAddress().address}getSetAuthorizedAbi(){return{name:"set_authorized",isInitializer:!1,functionType:hd.PUBLIC,isInternal:!0,isStatic:!1,parameters:[{name:"message_hash",type:{kind:"field"},visibility:"private"},{name:"authorize",type:{kind:"boolean"},visibility:"private"}],returnTypes:[],errorTypes:{}}}getLookupValidityAbi(){return{name:"lookup_validity",isInitializer:!1,functionType:hd.UNCONSTRAINED,isInternal:!1,isStatic:!1,parameters:[{name:"message_hash",type:{kind:"field"},visibility:"private"}],returnTypes:[{kind:"boolean"}],errorTypes:{}}}getIsConsumableAbi(){return{name:"unconstrained_is_consumable",isInitializer:!1,functionType:hd.UNCONSTRAINED,isInternal:!1,isStatic:!1,parameters:[{name:"address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},visibility:"private"},{name:"message_hash",type:{kind:"field"},visibility:"private"}],returnTypes:[{kind:"boolean"}],errorTypes:{}}}}class ty extends ey{constructor(e,t,n,s){super(e,t),this.secretKey=n,this.salt=s}getSecretKey(){return this.secretKey}async getEncryptionSecret(){return async function(e,t){const n=t.add(new ii(e.toBigInt()));return(await Xd(n)).y.toBigInt()<=(si.MODULUS-1n)/2n?n:new ii(ii.MODULUS-n.toBigInt())}(await this.getCompleteAddress().getPreaddress(),Gd(this.getSecretKey()))}}class ny extends Kb{constructor(e,t){super(e),this.entrypoint=t}async createTxExecutionRequest(e){let t=this.entrypoint;if(!t){const{l1ChainId:e,protocolVersion:n}=await this.pxe.getNodeInfo();t=new Yb(e,n)}return t.createTxExecutionRequest(e)}getChainId(){throw new Error("SignerlessWallet: Method getChainId not implemented.")}getVersion(){throw new Error("SignerlessWallet: Method getVersion not implemented.")}getPublicKeysHash(){throw new Error("SignerlessWallet: Method getPublicKeysHash not implemented.")}getCompleteAddress(){throw new Error("SignerlessWallet: Method getCompleteAddress not implemented.")}createAuthWit(e){throw new Error("SignerlessWallet: Method createAuthWit not implemented.")}isL1ToL2MessageSynced(e){return this.pxe.isL1ToL2MessageSynced(e)}}class sy{constructor(e,t,n){this.instance=e,this.artifact=t,this.wallet=n,this.methods={},t.functions.forEach((e=>{this.methods[e.name]=Object.assign(((...t)=>new Jb(this.wallet,this.instance.address,e,t)),{selector:()=>ed.fromNameAndParameters(e.name,e.parameters)})}))}get address(){return this.instance.address}get partialAddress(){return qd(this.instance)}withWallet(e){return new sy(this.instance,this.artifact,e)}}function iy(e){return t=e.toString("utf-8"),Ad.parseAsync(JSON.parse(t));var t}function ry(e){return function(e){if("object"!=typeof e)return!1;const t=e;if("string"!=typeof t.name)return!1;if(!Array.isArray(t.functions))return!1;for(const e of t.functions){if("string"!=typeof e.name)return!1;if("string"!=typeof e.functionType)return!1}return!0}(e)?e:function(e,t){try{return Ad.parse({name:e.name,functions:e.functions.map((t=>function(e,t){if(void 0===e.custom_attributes)throw new Error(`No custom attributes found for contract function ${e.name}. Try rebuilding the contract with the latest nargo version.`);const n=function(e){return e.custom_attributes.includes("private")?hd.PRIVATE:e.custom_attributes.includes("public")?hd.PUBLIC:e.is_unconstrained?hd.UNCONSTRAINED:hd.PRIVATE}(e),s=e.custom_attributes.includes("internal"),i=e.custom_attributes.includes("view");let r=e.abi.parameters.map(ay);(function(e){const t=e[0];return"struct"===t?.type.kind&&t.type.path.includes("ContextInputs")})(r)&&(r=r.slice(1));let a=[];if(n===hd.UNCONSTRAINED&&e.abi.return_type)a=[e.abi.return_type.abi_type];else{const n=`${t.name}::${e.name}_abi`,s=t.outputs.structs.functions.find((e=>"struct"===e.kind&&e.path===n));if(s){if("struct"!==s.kind)throw new Error("Could not generate contract function artifact");const e=s.fields.find((e=>"return_type"===e.name));e&&(a=[e.type])}}return{name:e.name,functionType:n,isInternal:s,isStatic:i,isInitializer:e.custom_attributes.includes("initializer"),parameters:r,returnTypes:a,bytecode:e.bytecode,debugSymbols:e.debug_symbols,errorTypes:e.abi.error_types,...e.assert_messages?{assertMessages:e.assert_messages}:void 0,...e.verification_key?{verificationKey:e.verification_key}:void 0}}(t,e))),outputs:e.outputs,storageLayout:oy(e),notes:ly(e),fileMap:e.file_map})}catch(t){throw new Error(`Could not generate contract artifact for ${e.name}: ${t}`)}}(e)}function ay(e){const{visibility:t}=e;if("databus"===t)throw new Error(`Unsupported visibility ${e.visibility} for noir contract function parameter ${e.name}.`);return{...e,visibility:t}}function oy(e){const t=(e.outputs.globals.storage?e.outputs.globals.storage:[]).find((t=>{const n=t.fields.find((e=>"contract_name"===e.name))?.value;return n.value===e.name})),n=t?t.fields.find((e=>"fields"==e.name)).value.fields:[];return 0===n.length?{}:n.reduce(((e,t)=>{const n=t.name,s=t.value.fields[0].value;return e[n]={slot:s.value},e}),{})}function ly(e){const t=e.outputs.globals.notes;return t?t.reduce(((e,t)=>{const n=t.fields,s=n.find((e=>"integer"===e.kind)),i=n.find((e=>"string"===e.kind)),r=n.find((e=>"struct"===e.kind));if(!s||!i||!r)throw new Error(`Could not find note type id, name or fields for note ${t}`);const a=s.value,o=i.value,l=r.fields.map((e=>({name:e.name,index:parseInt(e.value.fields[0].value.value,16),nullable:e.value.fields[1].value.value})));return e[o]={id:a,typ:o,fields:l},e}),{}):{}}i(8891).Buffer;const cy=JSON.parse('{"transpiled":true,"noir_version":"1.0.0-beta.1+c4e38215cedb5afb","name":"ContractClassRegisterer","functions":[{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"log_plaintext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/92c927bMBDG5URKIieOndG9927leHeme+/W/dsdfosWAtqHSPu09Zfw7DPDAilCovkqQJCto+9+PFHUiTy6EG1s3cFeMJ9jc5w2R5xfjMY3Kbtqjtn2tqpHXVkoxgIB4wQB4yQBY0zAmBAwThEwThMwzhAwpgSMRQLGWQLGOQLGEgHjPAFjmYCxQsC4EIAxBOciCeeSR04d24fiXY52fhvdRcC4m4BxDwHjXgLGfQSM+wkYDxAwHiRgPETAeJiA8QgB41ECxmMEjMcJGE8QMJ4kYDxFwHiagPEMAeNZAsZzBIznCRgvEDBeJGC8RMB4mYDxCgFjRsBYJWBcIWCsETDWCRgbBIxNAsYWAWObgLFDwHiVgPEaAeN1AsYbBIw3CRhvETCuEjDeJmC8Q8B4l4DxHgHjfQLGBwSMDwkYHxEwPiZgfELA+JSA8RkB43MCxhcEjC8JGF8RML4mYHxDwPg2AGMIzncknO9JOLuBOKMPFvTEYMfCLSyMwsIjLOzBwhksTMHCDyyswMIFLAxA4j0S25E4XhnsSHxGUjESdpEEiyRTJHEiSRJJiEjyQxIdktSQBIYkKyQxIUno6GA/NtiRRIIkDSRBIMkAk/iYJMckNCZ5MYmKSUpMAmKSDZNYmCRCrTDJgUkEDNJjEByDzBjExSApBiExyIdBNAxSYRAIgywYxJBBArzk4iUSL2l4CcJLBoJ4BMkIQhHkIYhCkIIgAA9ZPMTwkEAnjE4OnQhuUtwAaFzd6M+bNJIf5pia44SSe1xEV00tuz71t7POx9RRP4/8tdTonAmiv9ES/WkY/kwW2t7LR/p1XcTupDl285Evu/k4k5RZU2XWrDJSnzDXu14P66/qSsnyUaTqIraLYWzXCpY9fV20TOwXo5Btc2NRsrYnPLZ/pO8oSZl8xFOwZHG+uR4iS5RMri/snFfl7LY1Y8mEBZu035LyjWwfjEyuaax0+muvjXbY9lrP/l17rVf/x/YaW7I431yPv22vum3Z7TWJRpv0pSKbUrKflmxayX7lI9sNxdE0n8P2yRvPYH3v+X6GLTn4tS1s0/nIH9IGJ9W5RPlv3T+6vCVLlSzOx+0UzfdY2dG6hCOxytfN97I5TqnfyO8rDvtTlv0xbsc52y+po3zqKI+2dsl8njU72tA3+U20+d7Fvmq+Z9vamh1XP+lPf6vm6gs98n8R/bNB9NeH+ufC8A/jqlIY/w/1z4fh74v+chj9TdFfCaO/IfoXguhfGcYJ+s927DhhSZ33GNduOU4Q+0WLNVScsGTx2P7RcQJkyw7WikNm9wHLDjvLDjsuXfMedS141FXcoXUsedRV8agr9ajL53Wc86jLp7/KHnXNeNTls9379Jdcx7DjVVnmitOiAPqLYfQP+37po/W7ma6T2E+s8l8tP88F8fNoHEr6M+0LVyzl0/ZWn9div+TgEe6iQ7adP0D70mj3O+1GZxDSV5srnaxg6RdW+5x+L9L9iy7veva74j6Pvs5cYxBl5VdssZLNW7JEyYRRj0G44mKf/Fvxv7Zfccjs/nmr13IxGm9r+n6cjUb3c5z7r3urvfHHLuuMRn8SjY8xRpb9xCr/3Xy3+7rt3iP9Vq/ar/X6vUbv8+f6p96ipV/7EH76DXVGL3ipUwAA","debug_symbols":"tZZBCoMwEEXvknUWzrQa61VKkahRAiFK1EIR794o0kq7/puQCZM3ZPHCX0RjqrkrrW/7URT3Rbi+1pPtfayWVYoqWOdsV56PRbItlPB+YRy03+px0mESRZpLYXwjiiyL11vrTNyqVf41Kj4alfo0prw+ZCRfYOQrjJzCyBmMrGDkHEa+ociUwMgEI8McJJiDBHOQYA4SzEGCOUgwBwnmIMMcZJiDDHOQYQ4yxsE1Vk8drK6cOQJEO/v6lCem12B+osUQ+to0czBbyPjmi+3tV5Yp779+LIgzSReKQ+KgNw==","brillig_names":["process_log"]},{"name":"register","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"artifact_hash","type":{"kind":"field"},"visibility":"private"},{"name":"private_functions_root","type":{"kind":"field"},"visibility":"private"},{"name":"public_bytecode_commitment","type":{"kind":"field"},"visibility":"private"},{"name":"emit","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["pop_capsule","notify_created_nullifier_oracle_wrapper","debug_log_oracle_wrapper","emit_contract_class_unencrypted_log_private","directive_integer_quotient","directive_invert"],"verification_key":"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"},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==","debug_symbols":"bY/dCoMwDIXfJde9aDp101eRIVWjFEortQ6G+O6LQ6T7uQnnhC+HnBV6apexMW7wM1T1CtZ3Ohrv2K2bgDYYa83YpGuQ+8DLm58n7XY7Rx0iVPlNALkeqqLg68FYYnndxA+IEqU6WNaqPHHMsv98iSevUH7w943tQwejW0vH68PiuqRJfE70VWoKvqN+CbTXS5rxrDEXSnIsR78A","brillig_names":["sync_notes"]},{"name":"broadcast_private_function","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"artifact_metadata_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unconstrained_functions_artifact_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"private_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"private_function_tree_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"artifact_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"artifact_function_tree_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"metadata_hash","type":{"kind":"field"}},{"name":"vk_hash","type":{"kind":"field"}}],"kind":"struct","path":"events::private_function_broadcasted::InnerPrivateFunction"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"H4sIAAAAAAAA/+3dBXRU6cKg6+AuDbQL1rglBAnu7u5OcHfrbtqNdnda6cbd3d3d3d2d+9YcmFMnP5x7Z/7kTL93Ta31LirJx67n21WplOzaO1bIP04JUoSEpInzj/OxKM79f2NTuijfe/Bv8Pl4DxmX5CHfS/aQ76V4yPcee8j3nqCSUb6X9iHj0j3ke+kf8r0MD/lelod8r+D97wWfYt3/t+T9f8NDC+TLF1kwb2RYeFir0LyFWkfkD82Xv3WBiLCIsPwR+dvmjQgPj4zIF1GwUOtCBUMLheULjwxrl79QeLvQf5zSxvnnskL/W6e8bWLSme5/2xkWHvU7AVsqihtkDayHu/fPZw355/lsQefT3R/z4P+l5+sMlJFejPPP7z84xYmyDkL/e6ew7NG4rPRxou+6yRRtt6HQ0JhcfzmicVkZonH9ZZasv5zRuKyM0bj+skTj+nvYfUOmoPuGzEHnswSdfzHKfUNWvs5G2SnHf+C+IVc0LitrNF43OSW37dzRuKxs0bj+cknWX55oXFb2aFx/uWP4viFn0H1ArqDzuYPO54hy35CHr0MpjPL+B+4bQqPzeo7G6yZcctsOi87rIhrXXz7J+ssbnddFNK6//DF83xAedB+QL+h8/qDzeaPcNxTg64IUQYX+A/cN4dG4rALReN0Ulty280XjsgpG4/orIll/+aNxWRHRuP6KxvB9Q+Gg+4AiQeeLBp0vFOW+oRhfF6cSAdt/4L6hQDQuq1g0XjelJLftgtG4rOLRuP5KS9ZfRDQuq0Q0rr8yMXzfUCroPqB00PkyQedLRrlvKMvX5ag8VfgP3DcUisZllY3G66ZiDF83FYOug3JB58sHna8Q5bqpxNeVqQpVfch1Ezuar5ssIdG3PqtF3/oMC35vI7DcdCH/dV3ECvp3epJ/nK/O2BpUk2pRbapDdake1acG1JAaUWNqQk2pGTWnFtSSWlFrakNtKZLaUXvqQB2pE3WmLtSVulF36kE9qRf1pj7Ul/pRfxpAA2kQDaYh9BK9TK/QUHqVXqPX6Q16k96it+kdepfeo/dpGH1AH9JH9DF9Qp/SZ/Q5fUFf0lf0NX1D39J39D39QD/STzScfqZf6Ff6jX6nP2gE/Ul/0UgaRaNpDI2lcTSeJtBEmkSTaQpNpWk0nWbQTJpFs2kOzaV5NJ8W0EJaRItpCS2lZbScVtBKWkWraQ2tpXW0njbQRtpEm2kLbaVttJ120E7aRbtpD+2lfbSfDtBBOkSH6QgdpWN0nE7QSTpFp+kMnaVzdJ4u0EW6RJfpCl2la3SdbtBNukW36Q7dpXtx/nFjj0WxKQ7FpXgUnxJQQkpEiSkJJaVklJxSUEp6jFJRakpDj9MT9CQ9RU/TM/QsPUfP0wuUltJRespAGelFykSZKQtlpWyUnXJQTspFuSkPhVIY5aVwykf5qQAVpAgqRIWpCBWlYlScSlBJKkWlqQyVpXJUnipQRapElakKVaVqVJ1qUE2qRbWpDtWlelSfGlBDakSNqQk1pWbUnFpQS2pFrakNtaVIakftqQN1pE7UmbpQV+pG3akH9aRe1Jv6UF/qR/1pAA2kQTSYhtBL9DK9QkPpVXqNXqc36E16i96md+hdeo/ep2H0AX1IH9HH9Al9Sp/R5/QFfUlf0df0DX1L39H39AP9SD/RcPqZfqFf6Tf6nf6gEfQn/UUjaRSNpjE0lsbReJpAE2kSTaYpNJWm0XSaQTNpFs2mOTSX5tF8WkALaREtpiW0lJbRclpBK2kVraY1tJbW0XraQBtpE22mLbSVttF22kE7aRftpj20l/bRfjpAB+kQHaYjdJSO0XE6QSfpFJ2mM3SWztF5ukAX6RJdpit0la7RdbpBN+kW3aY7dJfuUWBjhVgUm+JQXIpH8SkBJaRElJiSUFJKRskpBaWkxygVpaY09Dg9QU/SU/Q0PUPP0nP0PL1AaSkdpacMlJFepEyUmbJQVspG2SkH5aRclJvyUCiFUV4Kp3yUnwpQQYqgQlSYilBRKkbFqQSVpFJUmspQWSpH5akCVaRKVJmqUFWqRtWpBtWkWlSb6lBdqkf1qQE1pEbUmJpQU2pGzakFtaRW1JraUFuKpHbUnjpQR+pEnakLdaVu1J16UE/qRb2pD/WlftSfBtBAGkSDaQi9RC/TKzSUXqXX6HV6g96kt+hteofepffofRpGH9CH9BF9TJ/Qp/QZfU5f0Jf0FX1N39C39B19Tz/Qj/QTDaef6Rf6lX6j3+kPGkF/0l80kkbRaBpDY2kcjacJNJEm0WSaQlNpGk2nGTSTZtFsmkNzaR7NpwW0kBbRYlpCS2kZLacVtJJW0WpaQ2tpHa2nDbSRNtFm2kJbaRttpx20k3bRbtpDe2kf7acDdJAO0WE6QkfpGB2nE3SSTtFpOkNn6Rydpwt0kS7RZbpCV+kaXacbdJNu0W26Q3fpHoXE5/efYlMcikvxKD4loISUiBJTEkpKySg5paCU9BilotSUhh6nJ+hJeoqepmfoWXqOnqcXKC2lo/SUgTLSi5SJMlMWykrZKDvloJyUi3JTHgqlMMpL4ZSP8lMBKkgRVIgKUxEqSsWoOJWgklSKSlMZKkvlqDxVoIpUiSpTFapK1ag61aCaVItqUx2qS/WoPjWghtSIGlMTakrNqDm1oJbUilpTG2pLkdSO2lMH6kidqDN1oa7UjbpTD+pJvag39aG+1I/60wAaSINoMA2hl+hleoWG0qv0Gr1Ob9Cb9Ba9Te/Qu/QevU/D6AP6kD6ij+kT+pQ+o8/pC/qSvqKv6Rv6lr6j7+kH+pF+ouH0M/1Cv9Jv9Dv9QSPoT/qLRtIoGk1jaCyNo/E0gSbSJJpMU2gqTaPpNINm0iyaTXNoLs2j+bSAFtIiWkxLaCkto+W0glbSKlpNa2gtraP1tIE20ibaTFtoK22j7bSDdtIu2k17aC/to/10gA7SITpMR+goHaPjdIJO0ik6TWfoLJ2j83SBLtIlukxX6Cpdo+t0g27SLbpNd+gu3aOQBPz+U2yKQ3EpHsWnBJSQElFiSkJJKRklpxSUkh6jVJSa0tDj9AQ9SU/R0/QMPUvP0fP0AqWldJSeMlBGepEyUWbKQlkpG2WnHJSTclFuykOhFEZ5KZzyUX4qQAUpggpRYSpCRakYFacSVJJKUWkqQ2WpHJWnClSRKlFlqkJVqRpVpxpUk2pRbapDdake1acG1JAaUWNqQk2pGTWnFtSSWlFrakNtKZLaUXvqQB2pE3WmLtSVulF36kE9qRf1pj7Ul/pRfxpAA2kQDaYh9BK9TK/QUHqVXqPX6Q16k96it+kdepfeo/dpGH1AH9JH9DF9Qp/SZ/Q5fUFf0lf0NX1D39J39D39QD/STzScfqZf6Ff6jX6nP2gE/Ul/0UgaRaNpDI2lcTSeJtBEmkSTaQpNpWk0nWbQTJpFs2kOzaV5NJ8W0EJaRItpCS2lZbScVtBKWkWraQ2tpXW0njbQRtpEm2kLbaVttJ120E7aRbtpD+2lfbSfDtBBOkSH6QgdpWN0nE7QSTpFp+kMnaVzdJ4u0EW6RJfpCl2la3SdbtBNukW36Q7dpXsUkpDff4pNcSguxaP4lIASUiJKTEkoKSWj5JSCUtJjlIpSUxp6nJ6gJ+kpepqeoWfpOXqeXqC0lI7SUwbKSC9SJspMWSgrZaPslINyUi7KTXkolMIoL4VTPspPBaggRVAhKkxFqCgVo+JUgkpSKSpNZagslaPyVIEqUiWqTFWoKlWj6lSDalItqk11qC7Vo/rUgBpSI2pMTagpNaPm1IJaUitqTW2oLUVSO2pPHagjdaLO1IW6UjfqTj2oJ/Wi3tSH+lI/6k8DaCANosE0hF6il+kVGkqv0mv0Or1Bb9Jb9Da9Q+/Se/Q+DaMP6EP6iD6mT+hT+ow+py/oS/qKvqZv6Fv6jr6nH+hH+omG08/0C/1Kv9Hv9AeNoD/pLxpJo2g0jaGxNI7G0wSaSJNoMk2hqTSNptMMmkmzaDbNobk0j+bTAlpIi2gxLaGltIyW0wpaSatoNa2htbSO1tMG2kibaDNtoa20jbbTDtpJu2g37aG9tI/20wE6SIfoMB2ho3SMjtMJOkmn6DSdobN0js7TBbpIl+gyXaGrdI2u0w26SbfoNt2hu3SPQhLx+0+xKQ7FpXgUnxJQQkpEiSkJJaVklJxSUEp6jFJRakpDj9MT9CQ9RU/TM/QsPUfP0wuUltJRespAGelFykSZKQtlpWyUnXJQTspFuSkPhVIY5aVwykf5qQAVpAgqRIWpCBWlYlScSlBJKkWlqQyVpXJUnipQRapElakKVaVqVJ1qUE2qRbWpDtWlelSfGlBDakSNqQk1pWbUnFpQS2pFrakNtaVIakftqQN1pE7UmbpQV+pG3akH9aRe1Jv6UF/qR/1pAA2kQTSYhtBL9DK9QkPpVXqNXqc36E16i96md+hdeo/ep2H0AX1IH9HH9Al9Sp/R5/QFfUlf0df0DX1L39H39AP9SD/RcPqZfqFf6Tf6nf6gEfQn/UUjaRSNpjE0lsbReJpAE2kSTaYpNJWm0XSaQTNpFs2mOTSX5tF8WkALaREtpiW0lJbRclpBK2kVraY1tJbW0XraQBtpE22mLbSVttF22kE7aRftpj20l/bRfjpAB+kQHaYjdJSO0XE6QSfpFJ2mM3SWztF5ukAX6RJdpit0la7RdbpBN+kW3aY7dJfuUUhifv8pNsWhuBSP4lMCSkiJKDEloaSUjJJTCkpJj1EqSk1p6HF6gp6kp+hpeoaepefoeXqB0lI6Sk8ZKCO9SJkoM2WhrJSNslMOykm5KDfloVAKo7wUTvkoPxWgghRBhagwFaGiVIyKUwkqSaWoNJWhslSOylMFqkiVqDJVoapUjapTDapJtag21aG6VI/qUwNqSI2oMTWhptSMmlMLakmtqDW1obYUSe2oPXWgjtSJOlMX6krdqDv1oJ7Ui3pTH+pL/ag/DaCBNIgG0xB6iV6mV2govUqv0ev0Br1Jb9Hb9A69S+/R+zSMPqAP6SP6mD6hT+kz+py+oC/pK/qavqFv6Tv6nn6gH+knGk4/0y/0K/1Gv9MfNIL+pL9oJI2i0TSGxtI4Gk8TaCJNosk0habSNJpOM2gmzaLZNIfm0jyaTwtoIS2ixbSEltIyWk4raCWtotW0htbSOlpPG2gjbaLNtIW20jbaTjtoJ+2i3bSH9tI+2k8H6CAdosN0hI7SMTpOJ+gknaLTdIbO0jk6TxfoIl2iy3SFrtI1uk436Cbdott0h+7SPQp8MDEWxaY4FJfiUXxKQAkpESWmJJSUklFySkEp6TFKRakpDT1OT9CT9BQ9Tc/Qs/QcPU8vUFpKR+kpA2WkFykTZaYslJWyUXbKQTkpF+WmPBRKYZSXwikf5acCVJAiqBAVpiJUlIpRcSpBJakUlaYyVJbKUXmqQBWpElWmKlSVqlF1qkE1qRbVpjpUl+pRfWpADakRNaYm1JSaUXNqQS2pFbWmNtSWIqkdtacO1JE6UWfqQl2pG3WnHtSTelFv6kN9qR/1pwE0kAbRYBpCL9HL9AoNpVfpNXqd3qA36S16m96hd+k9ep+G0Qf0IX1EH9Mn9Cl9Rp/TF/QlfUVf0zf0LX1H39MP9CP9RMPpZ/qFfqXf6Hf6g0bQn/QXjaRRNJrG0FgaR+NpAk2kSTSZptBUmpbkH9trzKCZNItm0xyaS/NoPi2ghbSIFtMSWkrLaDmtoJW0ilbTGlpL62g9baCNtIk20xbaSttoO+2gnbSLdtMe2kv7aD8doIN0iA7TETpKx+g4naCTdIpO0xk6S+foPF2gi3SJLtMVukrX6DrdoJt0i27THbpL9ygkKb//FJviUFyKR/EpASWkRJSYklBSSkbJKQWlpMcoFaWmNPQ4PUFP0lP0ND1Dz9Jz9Dy9QGkpHaWnDJSRXqRMlJmyUFbKRtkpB+WkXJSb8lAohVFeCqd8lJ8KUEGKoEJUmIpQUSpGxakElaRSVJrKUFkqR+WpAlWkSlSZqlBVqkbVqQbVpFpUm+pQXapH9akBNaRG1JiaUFNqRs2pBbWkVtSa2lBbiqR21J46UEfqRJ2pC3WlbtSdelBP6kW9qQ/1pX7UnwbQQBpEg2kIvUQv0ys0lF6l1+h1eoPepLfobXqH3qX36H0aRh/Qh/QRfUyf0Kf0GX1OX9CX9BV9Td/Qt/QdfU8/0I/0Ew2nn+kX+pV+o9/pDxpBf9JfNJJG0WgaQ2NpHI2nCTSRJtFkmkJTaRpNpxk0k2bRbJpDc2kezacFtJAW0WJaQktpGS2nFbSSVtFqWkNraR2tpw20kTbRZtpCW2kbbacdtJN20W7aQ3tpH+2nA3SQDtFhOkJH6RgdpxN0kk7RaTpDZ+kcnacLdJEu0WW6QlfpGl2nG3STbtFtukN36R4FdkIQi2JTHIpL8Sg+JaCElIgSUxJKSskoOaWglPQYpaLUlIYepyfoSXqKnqZn6Fl6jp6nFygtpaP0lIEy0ouUiTJTFspK2Sg75aCclItyUx4KpTDKS+GUj/JTASpIEVSIClMRKkrFqDiVoJJUikpTGSpL5ag8VaCKVIkqUxWqStWoOtWgmlSLalMdqkv1qD41oIbUiBpTE2pKzag5taCW1IpaUxtqS5HUjtpTB+pInagzdaGu1I26Uw/qSb2oN/WhvtSP+tMAGkiDaDANoZfoZXqFhtKr9Bq9Tm/Qm/QWvU3v0Lv0Hr1Pw+gD+pA+oo/pE/qUPqPP6Qv6kr6ir+kb+pa+o+/pB/qRfqLh9DP9Qr/Sb/Q7/UEj6E/6i0bSKBpNY2gsjaPxNIEm0iSaTFNoKk2j6TSDZtIsmk1zaC7No/m0gBbSIlpMS2gpLaPltIJW0ipaTWtoLa2j9bSBNtIm2kxbaCtto+20g3bSLtpNe2gv7aP9dIAO0iE6TEfoKB2j43SCTtIpOk1n6Cydo/N0gS7SJbpMV+gqXaPrdINu0i26TXfoLt2jkOT8/lNsikNxKR7FpwSUkBJRYkpCSSkZJacUlJIeo1SUmtLQ4/QEPUlP0dP0DD1Lz9Hz9AKlpXSUnjJQRnqRMlFmykJZKRtlpxyUk3JRbspDoRRGeSmc8lF+KkAFKYIKUWEqQkWpGBWnElSSSlFpKkNlqRyVpwpUkSpRZapCVakaVacaVJNqUW2qQ3WpHtWnBtSQGlFjakJNqRk1pxbUklpRa2pDbSmS2lF76kAdqRN1pi7UlbpRd+pBPakX9aY+1Jf6UX8aQANpEA2mIfQSvUyv0FB6lV6j1+kNepPeorfpHXqX3qP3aRh9QB/SR/QxfUKf0mf0OX1BX9JX9DV9Q9/Sd/Q9/UA/0k80nH6mX+hX+o1+pz9oBP1Jf9FIGkWjaQyNpXE0nibQRJpEk2kKTaVpNJ1m0EyaRbNpDs2leTSfFtBCWkSLaQktpWW0nFbQSlpFq2kNraV1tJ420EbaRJtpC22lbbSddtBO2kW7aQ/tpX20nw7QQTpEh+kIHaVjdJxO0Ek6RafpDJ2lc3SeLtBFukSX6QpdpWt0nW7QTbpFt+kO3aV7FNjhUCyKTXEoLsVLcX8j+FhBHwQInM8Y8vBTyWjZGD9feMwst0CbGFpuWMwst2C4a7n5Q2PImzeGrrdCMeQtEEPemLqd5Yshb/6YWW6+GFq/BWPIWyAyhpYbU/cPMXV7iKHftwLtYmi5MXS95Yuh+7MYu5+MqfUbQ/dnBWLq9htTj0tsjx9kfy9i6vYQ3ipmlps3ph5HtY6h5bYNPCeIH2XZsaL1MkLDskbfskJjyphNYMwuMBYUGAsJjBExYPyXU3TvHSD4E/3/3b0DxE8RM3sHCCw3Xcg/XhiJHfLPvVcEn6L7iowVfcv6H3uOCLyD/bBT1MsIa10wNLJQ/nZtI0M516ptm/DQfIUKtC4U2io8b8FW7Qq0yh8ZHhEeGZo3IrJgq3zhecO4pgq2btM2ptbD//0jED1Gwx+BHAJjToExl8CYW2DMIzCGCoxhAmNegTFcYMwnMOYXGAsIjIYnbRECo+GJZfU4f39jDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTu398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTe398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMST+398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTB398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTh398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTR398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTx398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTJ398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTp398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTZ398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMST5398YS2CMLTDGERjjCozxBMb4AmMCgTGhwJhIYEwsMCYRGJMKjMkExuQCYwqBMaXA+JjAmEpgTC0wphEYHxcYnxAYnxQYnxIYnxYYnxEYnxUYnxMYnxcYXxAY0wqM6QTG9AJjBoExo8D4osCYSWDMLDBmERizCozZBMbsAmMOgTGnwJhLYMwtMOYRGEMFxjCBMa/AGC4w5hMY8wuMBQTGggJjhMBYSGAsLDAWERiLCozFBMbiAmMJgbGkwFhKYCwtMJYRGMsKjOUExvICYwWBsaLAWElgrCwwVhEYqwqM1QTG6gJjDYGxpsBYS2CsLTDWERjrCoz1BMb6AmMDgbGhwNhIYGwsMDYRGJsKjM0ExuYCYwuBsaXA2EpgbC0wthEY2wqMkQJjO4GxvcDYQWDsKDB2Ehg7C4xdBMauAmM3gbG7wNhDYOwpMPYSGHsLjH0Exr4CYz+Bsb/AOEBgHCgwDhIYBwuMQwTGlwTGlwXGVwTGoQLjqwLjawLj6wLjGwLjmwLjWwLj2wLjOwLjuwLjewLj+wLjMIHxA4HxQ4HxI4HxY4HxE4HxU4HxM4Hxc4HxC4HxS4HxK4Hxa4HxG4HxW4HxO4Hxe4HxB4HxR4HxJ4FxuMD4s8D4i8D4q8D4m8D4u8D4h8A4QmD8U2D8S2AcKTCOEhhHC4xjBMaxAuM4gXG8wDhBYJwoME4SGCcLjFMExqkC4zSBcbrAOENgnCkwzhIYZwuMcwTGuQLjPIFxvsC4QGBcKDAuEhgXC4xLBMalAuMygXG5wLhCYFwpMK4SGFcLjGsExrUC4zqBcb3AuEFg3CgwbhIYNwuMWwTGrQLjNoFxu8C4Q2DcKTDuEhh3C4x7BMa9AuM+gXG/wHhAYDwoMB4SGA8LjEcExqMC4zGB8bjAeEJgPCkwnhIYTwuMZwTGswLjOYHxvMB4QWC8KDBeEhgvC4xXBMarAuM1gfG6wHhDYLwpMN4SGG8LjHcExrsC4z2BMSTF398YS2CMLTDGERjjCozxYsAYE85qcaLPGSvImSBFyL+eYkeBh4cWyJcvsmDeyLDwsFaheQu1jsgfmi9/6wIRYRFh+SPyt80bER4eGZEvomCh1oUKhhYKyxceGdYuf6HwdvcvLDpXQuGQmLmyonvOsaJxzkUkc44djXMuKplznGicc7H/0JxD/3unsOLRuP4qxXHc+ZYIcThLSpylJM7SEmcZibOsxFlO4iwvcVaQOCtKnJUkzsoSZxWJs6rEWU3irC5x1pA4a0qctSTO2hJnHYmzrsRZT+KsL3E2kDgbSpyNJM7GEmcTibOpxNlM4mwucbaQOFtKnK0kztYSZxuJs63EGSlxtpM420ucHSTOjhJnJ4mzs8TZReLsKnF2kzi7S5w9JM6eEmcvibO3xNlH4uwrcfaTOPtLnAMkzoES5yCJc7DEOUTifEnifFnifEXiHCpxvipxviZxvi5xviFxvilxviVxvi1xviNxvitxvidxvi9xDpM4P5A4P5Q4P5I4P5Y4P5E4P5U4P5M4P5c4v5A4v5Q4v5I4v5Y4v5E4v5U4v5M4v5c4f5A4f5Q4f5I4h0ucP0ucv0icv0qcv0mcv0ucf0icIyTOPyXOvyTOkRLnKIlztMQ5RuIcK3GOkzjHS5wTJM6JEuckiXOyxDlF4pwqcU6TOKdLnDMkzpkS5yyJc7bEOUfinCtxzpM450ucCyTOhRLnIolzscS5ROJcKnEukziXS5wrJM6VEucqiXO1xLlG4lwrca6TONdLnBskzo0S5yaJc7PEuUXi3CpxbpM4t0ucOyTOnRLnLolzt8S5R+LcK3Hukzj3S5wHJM6DEuchifOwxHlE4jwqcR6TOI9LnCckzpMS5ymJ87TEeUbiPCtxnpM4z0ucFyTOixLnJYnzssR5ReK8KnFekzivS5w3JM6bEuctifO2xHlH4rwrcd6TOAMLNDhjSZyxJc44EmdciTOexBlf4kwgcSaUOBNJnIklziQSZ1KJM5nEmVziTCFxppQ4H5M4U0mcqSXONBLn4xLnExLnkxLnUxLn0xLnMxLnsxLncxLn8xLnCxJnWokzncSZXuLMIHFmlDhflDgzSZyZJc4sEmdWiTObxJld4swhceaUOHNJnLklzjwSZ6jEGSZx5pU4wyXOfBJnfomzgMRZUOKMkDgLSZyFJc4iEmdRibOYxFlc4iwhcZaUOEtJnKUlzjISZ1mJs5zEWV7irCBxVpQ4K0mclSXOKhJnVYmzmsRZXeKsIXHWlDhrSZy1Jc46EmddibOexFlf4mwgcTaUOBtJnI0lziYSZ1OJs5nE2VzibCFxtpQ4W0mcrSXONhJnW4kzUuJsJ3G2lzg7SJwdJc5OEmdnibOLxNlV4uwmcXaXOHtInD0lzl4SZ2+Js4/E2Vfi7Cdx9pc4B0icAyXOQRLnYIlziMT5ksT5ssT5isQ5VOJ8VeJ8TeJ8XeJ8Q+J8U+J8S+J8W+J8R+J8V+J8T+J8X+IcJnF+IHF+KHF+JHF+LHF+InF+KnF+JnF+LnF+IXF+KXF+JXF+LXF+I3F+K3F+J3F+L3H+IHH+KHH+JHEOlzh/ljh/kTh/lTh/kzh/lzj/kDhHSJx/Spx/SZwjJc5REudoiXOMxDlW4hwncY6XOCdInBMlzkkS52SJc4rEOVXinCZxTpc4Z0icMyXOWRLnbIlzjsQ5V+KcJ3HOlzgXSJwLJc5FEudiiXOJxLlU4lwmcS6XOFdInCslzlUS52qJc43EuVbiXCdxrpc4N0icGyXOTRLnZolzi8S5VeLcJnFulzh3SJw7Jc5dEuduiXOPxLlX4twnce6XOA9InAclzkMS52GJ84jEeVTiPCZxHpc4T0icJyXOUxLnaYnzjMR5VuI8J3GelzgvSJwXJc5LEudlifOKxHlV4rwmcV6XOG9InDclzlsS522J847EeVfivCdxhsR2OGNJnLElzjgSZ1yJM57EGV/iTCBxJpQ4E0mciSXOJBJnUokzmcSZXOJMIXGmlDgfkzhTSZypJc40EufjEucTEueTEudTEufTEuczEuezEudzEufzEucLEmdaiTOdxJle4swgcWaUOF+UODNJnJklziwSZ1aJM5vEmV3izCFx5pQ4c0mcuSXOPBJnqMQZJnHmlTjDJc58Emd+ibOAxFlQ4oyQOAtJnIUlziISZ1GJs5jEWVziLCFxlpQ4S0mcpSXOMhJnWYmznMRZXuKsIHFWlDgrSZyVJc4qEmdVibOaxFld4qwhcdaUOGtJnLUlzjoSZ12Js57EWV/ibCBxNpQ4G0mcjSXOJhJnU4mzmcTZXOJsIXG2lDhbSZytJc42EmdbiTNS4mwncbaXODtInB0lzk4SZ2eJs4vE2VXi7CZxdpc4e0icPSXOXhJnb4mzj8TZV+LsJ3H2lzgHSJwDJc5BEudgiXOIxPmSxPmyxPmKxDlU4nxV4nxN4nxd4nxD4nxT4nxL4nxb4nxH4nxX4nxP4nxf4hwmcX4gcX4ocX4kcX4scX4icX4qcX4mcX4ucX4hcX4pcX4lcX4tcX4jcX4rcX4ncX4vcf4gcf4ocf4kcQ6XOH+WOH+ROH+VOH+TOH+XOP+QOEdInH9KnH9JnCMlzlES52iJc4zEOVbiHCdxjpc4J0icEyXOSRLnZIlzisQ5VeKcJnFOlzhnSJwzJc5ZEudsiXOOxDlX4pwncc6XOBdInAslzkUS52KJc4nEuVTiXCZxLpc4V0icKyXOVRLnaolzjcS5VuJcJ3Gulzg3SJwbJc5NEudmiXOLxLlV4twmcW6XOHdInDslzl0S526Jc4/EuVfi3Cdx7pc4D0icByXOQxLnYYnziMR5VOI8JnEelzhPSJwnJc5TEudpifOMxHlW4jwncZ6XOC9InBclzksS52WJ84rEeTWGnLGj2XktyBkeWiBfvsiCeSPDwsNaheYt1Doif2i+/K0LRIRFhOWPyN82b0R4eGREvoiChVoXKhhaKCxfeGRYu/yFwtvdX1iCFI45X4/GOVeL47g93oiGOUe2axcZUaBgoX933fx312eWaJzzTcnv4K1ovD3G/w/9Dv53nXGjcf3dju2Yc7xonPMdyZzjR+Oc70rmnCAa53xPMueE0TjnkDiOOSeKxjnHksw5cTTOObZkzkmicc5xJHNOGo1zjiuZc7JonHM8yZyTR+Oc40vmnCIa55xAMueU0TjnhJI5PxaNc04kmXOqaJxzYsmcU0fjnJNI5pwmGuecVDLnx6Nxzskkc34iGuecXDLnJ6Nxzikkc34qGuecUjLnp6Nxzo9J5vxMNM45lWTOz0bjnFNL5vxcNM45jWTOz0fjnB+XzPmFaJzzE5I5p43GOT8pmXO6aJzzU5I5p4/GOT8tmXOGaJzzM5I5Z4zGOT8rmfOL0Tjn5yRzzhSNc35eMufM0TjnF6Jxziwq8DZnyJH7Ey5MRagoFaPiVOK+vRSVpjJUlspReapAFakSVaYqVJWqUXWqQTWpFtWmOlSX6lF9akANqRE1pibUlJpRc2pBLakVtaY21JYiqR21pw7UkTpRZ+pCXakbdace1JN6UW/qQ32pH/WnATSQBtFgGkIv0cv0Cg2lV+k1ep3eoDfpLXqb3qF36T16n4bRB/QhfUQf0yf0KX1Gn9MX9CV9RV/TN/QtfUff0w/0I/1Ew+ln+oV+pd/od/qDRtCf9BeNpFE0msbQWBpH42kCTaRJNJmm0FSaRtNpBs2kWTSb5tBcmkfzaQEtpEW0mJbQUlpGy2kFraRVtJrW0FpaR+tpA22kTbSZttBW2kbbaQftpF20m/bQXtpH++kAHaRDdJiO0FE6RsfpBJ2kU3SaztBZOkfn6QJdpEt0ma7QVbpG1+kG3aRbdJvu0F26R4EN4WJRbIpDcSkexacElJASUWJKQkkpGSWnFJSSHqNUlJrS0OP0BD1JT9HT9Aw9S8/R8/QCpaV0lJ4yUEZ6kTJRZspCWSkbZacclJNyUW7KQ6EURnkpnPJRfipABSmCClFhKkJFqRgVpxJUkkpRaSpDZakclacKVJEqUWWqQlWpGlWnGlSTalFtqkN1qR7VpwbUkBpRY2pCTakZNacW1JJaUWtqQ20pktpRe+pAHakTdaYu1JW6UXfqQT2pF/WmPtSX+lF/GkADaRANpiH0Er1Mr9BQepVeo9fpDXqT3qK36R16l96j92kYfUAf0kf0MX1Cn9Jn9Dl9QV/SV/Q1fUPf0nf0Pf1AP9JPNJx+pl/oV/qNfqc/aAT9SX/RSBpFo2kMjaVxNJ4m0ESaRJNpCk2laTSdZtBMmkWzaQ7NpXk0nxbQQlpEi2kJLaVltJxW0EpaRatpDa2ldbSeNtBG2kSbaQttpW20nXbQTtpFu2kP7aV9tJ8O0EE6RIfpCB2lY3ScTtBJOkWn6QydpXN0ni7QRbpEl+kKXaVrdJ1u0E26RbfpDt2lexR4QBCLYlMcikvxKD4loISUiBJTEkpKySg5paCU9BilotSUhh6nJ+hJeoqepmfoWXqOnqcXKC2lo/SUgTLSi5SJMlMWykrZKDvloJyUi3JTHgqlMMpL4ZSP8lMBKkgRVIgKUxEqSsWoOJWgklSKSlMZKkvlqDxVoIpUiSpTFapK1ag61aCaVItqUx2qS/WoPjWghtSIGlMTakrNqDm1oJbUilpTG2pLkdSO2lMH6kidqDN1oa7UjbpTD+pJvag39aG+1I/60wAaSINoMA2hwDHqA8d/DxxbfSgFjgkeON524FjWgeNEB47BHDi+ceDYwYHj8gaOeRs4nmzgWK2B46AGjjEaOH5n4NiYgeNOBo7pGDheYuBYhIHj/AWOoRc4Pl3g2G+B46oFjlkWOB5Y4FhbgeNYBY4RFTj+UuDYRsMpcEyewPFuAseSCRynJXAMlMDxRQLH7ggcFyNwzInA8RwCx0oIHIcgsI//wP7zA/umD+z3PbBP9cD+ygP7Ag/sZzuwD+vA/qED+14O7Nc4sM/gwP54A/u6DexHNrCP1sD+TwP7Fp1PgX1iBvY3GdiXY2A/iYF9EAb27xfYd15gv3SBfb4F9qcW2FdZYD9ggX1sBfZfFdg3VGC/S4F9GgX2FxTYF09gPzeBfcgE9s8S2PdJYL8igX12BPaHEdjXRGA/DoF9JAT2PxD4bP9+CnwmPfB578BnqQOfUw48Zg18vjbw2dXA50IDn7kMfJ4x8FnBwOfwAp9xC3x+LPDZrMDnngKfKQp8XifwWZjA50wCn+EIfD4i8NmDwLb4gW3TA9tqB7aDDmzLG9i2NbCtZ2Dbx8CD5MC2cYFtxQLbTgW2JQpsWxPY1iSw7UVgW4TAe/OB96oD790G3ssMvLcXeK8r8N5P4L2QwHsDgdfKA68dB15LDby2GHitLfDaU+C1mMBrE4Hn6oHnroHncoHnNoHH+rH/8fAjJLCtcuBUOOSfp/t3Tf/jMXzg54FtewPbuga2/QxsCxnYNjCwrVxg27HAtlSBbYsC29oEtj0JbIsR2DYh8F594L3rwHu5gfc2A+/1Bd77CrwXFHhvJPBeQeC188BryYHXVgOvNQZee0tH6SkDZaTAc9nAc7vAc53A9vNZKRtlpxyUk3JRbspDgSdcYZSXwikf5acCVJAi6F828r9/ih10Puv9fx8/XOrpnitHlAsel/MRP4tz/98HT/gSRVlurPtjSj4Y9998vpYoaLnRvfyI1u3aJQr511M0+8MT3V9mrJhZfuiD5cfQ+v8f20EHThWG/nP5wXN5cLmB35dUQeefDPnX8cG3uzhRlhMS9PNEQXOI9us7NF/BB8uPGwPLD23dOiLZgzkO/a/r6MHP4g7918sO/lm8oJ/FDVqfaaOsn5i4voPXT0ys/8D6Sf0I/4O5BU5lhob8z1PUyw1rXTA0slD+dm0jQznXqm2b8NB8hQq0LhTaKjxvwVbtCrTKHxkeER4ZmjcismCrfOF5w3jFqWDrNm0fLLvs0BiYV2ho/gfLLxcjy8/b5sHyy8eMPzzJ/dtZ9vvLSxbyX39HYwVdTzF2n9O6daFYUS4vJORfb48hUS4/cUiM3seG/a/ehyW9bwqcenTvUaZVj959u0QG64KXNj3JP78f8pClBo+JekoSNDbB0H/V/Y9/g7734J7lwT1NwuDxUX6WKOhncYf+qy/x/a/jBl1O8LIeOOJFGZ/t/tcp7v8bP+j/PPj/KR9y+fGjXP6/uB/yveBbZdRlxXnI9x6MDzzyy3D/fGC9PviNizv0n8uLrltVwYjQ0Ae+B+s+XpAv+BQ36OfB4/Pc/zpxlPk++MtR8n/T2a5gq7B24a3atcrfqm3bfG1apYqy/OB1FlhP/e+fVz8SDC0Y+p96JBgjf1l5VyVGH9mEPvyRYPBcHlxunCjjov6f4P9XMWhMxUeMqRQ0ptIjxlQOGlP5EWOqBI2p8ogxVYPGVH3EmGpBY6o9Ykz1oDHVHzGmRtCYGo8YUzNoTM1HjKkVNKbWI8bUDhpT+xFj6gSNqfOIMXWDxtR9xJh6QWPqPWJM/aAx9R8xpkHQmAaPGNMwaEzDR4xpFDSm0SPGNA4a0/gRY5oEjWnyiDFNg8Y0fcSYZkFjmj1iTPOgMc0fMaZF0JgWjxjTMmhMy0eMaRU0ptUjxrQOGtP6EWPaBI1p84gxbYPGtH3EmMigMZGPGNMuaEy7R4xpHzSm/SPGdAga0+ERYzoGjekYZUxMPruP8WeroXnDk0WZa0jIf32UHy9mLjtfrCiXFxLy8Ef5//NxZEhM/v3856P8eFE8UddP1Gfzwc/0Y0X5Wdyh/3Ue/2/P9MsHjXvYbStwitlXAQq0iuHHEgX+z93uQgv+//F29+9eYfrfvd097BWawLhaQefr3z8fs/eDBWP8Vc7UD/FHfR75d39+XfP+13/n59eV7p8Pfn79f1/ti3r6z73a1/PB9RUSo/e5BaI+pooT8s/7uOD7vajvAiSIGU/4A0/8oMuO85B18ODyH9wnxg0aH+sR/z5YVtSfPbisxCEx+rc17N/NLe5D1nXKKOOjroNHLSv+/+Ky/k9ep8HrOkGUuSV4yPjYD5nbw/7uJojys7hBP4sf5WfBf3cfrJPgv7sx/DeuwL97nBHrIfN98P2EDxn/sNtRipD/un4TRplbopiZW95/d90nDLrMB5efNOj7bSNb921ftXv7kCinOFHWw4P1ljFoTPD1FTvkv972EzxiWSFRvo66zDhByws+GV6X7nf/6//Tr0sXuH9e/bp0m7D8/6nXpWPmHfF/PBaLwccWD31dOngu//P2ef/f1MP+uS4fnH9geti7ng+WG8PvvEfE6Hpq3ab1v3sM8+Cy48fMZbeJFeXygq8Pw2Ok/9Xn3P9f//Y/GzQu6m0rbpSfBd8HP7jdBpaROWh5OaJcbpqg23fU6zpGbsdtwvLF7PtcoWH/bguSB3P8uz9Xz3T/67/zc/UX7p//v8/V/93pP/dcPTTouox6P/XvnrcEHuumuX8+smvHPmW6d+vTq1WbPmW6tOrdm8e9UR+PBv/9CYlyGSFRDA/zrEryr+PiPOT/R11GyL/5vw97HfyB0fB4OP/9r/9PPx7+fwDHCq0OaRUKAA==","debug_symbols":"7ZndquowEIXfpde9yCSTn/FVDpuNP92bgqhUPXAQ3/0kYtotdpRGDseLuRHTrmWmX5POop6qVbM4fn+2m6/tvpr9OlXr7XJ+aLebODpVgJdj+918k4b7w7w7VDNwTtdVs1mlr16f6+qrXTfVzPlzfSfW2vmrWOtAvZhgTEwYrmKjNDwWgzMU+joQBrl2elRvB7n3g9rTmNo4k9UI6kb9UVdghQxDxgkZhowXMgyZIGQYMiRkxsloJWQYMiBkGDJayDBkjJBhyKCQYchIBubISAbmyEgG5shIBubISAZmyBjJwBwZycAcGcnAHBnJwBwZFDIMGcnAHBnJwByZ987AaOxABukJGQ3a5UoA7Ytk3jsD/08yr2dgVJTFCDr0Ym/TBKj+9QSjicxqmy/baud+TpA8o1nFEuDV44wxj4sKKt+EgD93OVx+f7TjO4O5pvhoeHLRAQzlCcDSs8UZiPrVSfeM8M3qsS/XQwryfqS4Pm5ucBwsuna9br8/b/52Vulj/L2bcZA3bBhuZ9x/H9z7qIcON9nhJzvCZAdNc8QBJGEYrY1C37mUutsBIRR4aLqHVIEHCjy6wGMKPFjgsQUeV+ApWAdUsA6oYB3EYyUmKDHpEpMpMWGJaXw1ODeY8N7kSky+xBRKTFRgAlVigqmmONJJOt5jDWUnhqFJxSTGt8EHlnMc/p537XyxblJHS2ePm2VucHF4+LPLZ3IL3HXbZbM6dk1qhkMfTAvSQI1wARwHqGv0/UM/nfaqDiqfBjA1QOivNwm0r43v/aG2JpYYy/wL","brillig_names":["pop_capsule","debug_log_oracle_wrapper","emit_contract_class_unencrypted_log_private"],"verification_key":"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"},{"name":"assert_class_id_is_registered","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7ZXLioQwEEX/JWsXVqVMrP6VYWh8xCYgKj4GBul/nyjGdmjtzTDQC3ep1Mm9xaUgo8hNOtyutirqTlw+RlHWWdLbunLVKEDOd12TVFPZ9UnbiwsohYEwVT4dNd4DUdjSiIvS9+AJRlR6gRFjXmGGPZgpXmAZIryGQZGM1jmIHtqocE8cUPlJgKIHrXlPXSrpxQnCX/RnIIDOZA6Sic5kDpJRZzIHyeg/J0Mhe5gA4xXW0WwQ/7cB7xmwI5c3TKRfG0AI2kfqziy3FnurEDOvu8BPE2H4XhO5Im1tWdrbdfvHuOuvpLVJWpqlLIYq23T778Z3/PumrTOTD62ZlOaek/8B","brillig_names":[],"verification_key":"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"},{"name":"broadcast_unconstrained_function","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"artifact_metadata_hash","type":{"kind":"field"},"visibility":"private"},{"name":"private_functions_artifact_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"artifact_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"artifact_function_tree_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"metadata_hash","type":{"kind":"field"}}],"kind":"struct","path":"events::unconstrained_function_broadcasted::InnerUnconstrainedFunction"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7ZjdyuIwEIbvpcc9yEwmP+OtLMuHP/0+CqVK1YVFvPdNxLSKqdLIYg9yIk7zPs34ZuoMPRWbanX8+arb7+2+WPw6Fc12vTzU29ZFpwLocm2/W7Y+3B+W3aFYgNZYFlW78V8Nnsviu26qYqHNuXwQI2pzFSNa7sUMMTGTvYqlQHguBi3Z9nkQDHLUGNWrQW7MoDYcU0stg5pA3Kl/lwWo7MyIMzo7M+KMyc6MOGOzMyPOcHYm7gyK7MyIM5CdGXEGszMjzsjszIgzlJ0ZcWbeMzBJNThD/MIZBNQhEyD1pjPznoE/6cy8Z+BPOjPvGfiTzrw/A5PgICZA24uN8htI8b83iE5kmgmujGZFtxt4JjqrGDKBMVbB86SsCIdg6bYzwOX+0Y5vrO7vz1K8uD9IDhuA4lfFaZn76uRHj2hm+ai382EB4XlkVx93B+yCVVc3Tf3zdffKTfiP+Mwh+62lvTl5HO/FTwk9mTCTCTuZ4GmEC8ALOVrNbPtpR4iHJ4ApgVEJjE5gTAJjExiezrhrKRCkQJgCyRSIUiCVAukUyKRANgVKqQhIqQiIV4TWA0SPEKZAMgWiFEilQHoq5CL0Uoo3Cg4k2aHruNHK70ZqInJ24Z9lVy9XTeVblF89tuvQsVx4+LsLK6Gn7brtutocu8p3t6Gx+XOQUBJcKs0FhCWZ/l/cLxtdWh2WAWwJKPvf6wVoSml63pbKLZ9dmv8A","brillig_names":["pop_capsule","debug_log_oracle_wrapper","emit_contract_class_unencrypted_log_private"],"verification_key":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"packed_note_content","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VZy67aQAwdSEJIuAEKn3Cl7tomXJ47Fn3c30AFPqHrrLppP7qMGCcH46siYVfFEpoknhyfOXZmJqHjztY//TrhOA5tz10b9dmGtrzPKkWs0pJn50F4dh+EZ/QgPGNFnh2Bp2/peUvc+ZlL3fl5bC7iTT7BEdzk/gYAwX6HNgttF/yKCakyYZBa+Otyvs/cpSnzf8kCZmqDvyD8vg1+Sbw/1y0+joXiRqF9rVstX+Eeb0U4xuIlXPJ1wfeF+SLwfWU+rOFvzId1T5xIN1qYlOtqY50XGlsKY+u80TrXaofXSOvcmdZoRTnPGB/On/gU1Kdu+fSYLwZfxnwJ+Eh/3z5DP577FPp9hONP0IfXZ+Su65n8lH/U3aK+YgP8k82lHPD8xPVlbPRhDmLQ85npY7FuoD4W+nt9pm/wp2Nvae0ai5ieqBFp1sf+zJeBL64v4+ThPIY4iEU8Etb/QzgfhbYH99D9YyF+j8W/4C1cQ404ViRco/7++Xwfjgfh52voJ93jructvc31ci7N4Xr4qwY/s+F/JPzcBn9J+AMb/GZv82SCPysJv7Dh38xBQ5v6afaWIxv+B8Ifm+DPD7QOv3OtNXNEOJ7Adb35u6pu2SNh/JxxtdojTRgfrg+uwd43FbiOBR/P4VSIMxXiSFiZItaTItboPx1jXxFroIg1VMTSzGOqiKWpV66IVShiada9pl6UR2mf5m0b2vJOk/ZpiviVtE/TfJcnram+YkFDHF/C+v9gOg9MeFYzWnPoWacYGLswin3rek3xC4EP8c4F3z0fZw+L9XGzXmxOW7JqOds0+SwYV34N34twPsb+0tov7fsUtS6ld/8h6OotBl/BfAn4iKP07j804n+L/hh/LPj4+n9rLifuej0csHHjN6+typjb74HSt3rj+Wtx67NJ8XN3PV//q++NqA/fS+cC17Hg4/uTXIiTC3EeEYt/s0cNfV2TTnHd+rVyuVq3f3TRXJS4y/8BHIufsP6/wjmOjdp75vzjalcdX3bH3WK338+/7yYM31sXdPoDg5oBSR0fAAA=","debug_symbols":"tdfBaoQwFIXhd8k6C29iEuOrlDJEjUMgRIlaKOK7Nw7SDp3lcDbDRK6fG3/w7mzw3Xa/hTROC2s/dhan3q1hSuW0H5x1OcQY7rfny6w6f6x6zC+zS+dxWV1eWasaznwaWKt1uXsM0Ze/5uAvg0Zcg8b8DipxfHJmNQo2KLhBwRYEU1XBZILJAiZLmFzDZAWTNUw2MLmBybAGCdYgwRokWIMEa5BgDRKsQYI1SLAG6b0GrbwGy6vwQlsYLSocTTha4GiJo2scrXC0xtEGR+NqFLgaJa5GCarxKKcvl4Pror+2pnFL/dMStX7P/t8+Neep98OW/blZ/S1VZ3pS8Vo9vjzKgWTNSdrykPKgHw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"artifact_hash","type":{"kind":"field"}},{"name":"private_functions_root","type":{"kind":"field"}},{"name":"public_bytecode_commitment","type":{"kind":"field"}},{"name":"emit","type":{"kind":"boolean"}}],"kind":"struct","path":"ContractClassRegisterer::register_parameters"}}],"kind":"struct","path":"ContractClassRegisterer::register_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"artifact_metadata_hash","type":{"kind":"field"}},{"name":"private_functions_artifact_tree_root","type":{"kind":"field"}},{"name":"artifact_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"artifact_function_tree_leaf_index","type":{"kind":"field"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"metadata_hash","type":{"kind":"field"}}],"kind":"struct","path":"events::unconstrained_function_broadcasted::InnerUnconstrainedFunction"}}],"kind":"struct","path":"ContractClassRegisterer::broadcast_unconstrained_function_parameters"}}],"kind":"struct","path":"ContractClassRegisterer::broadcast_unconstrained_function_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}}],"kind":"struct","path":"ContractClassRegisterer::assert_class_id_is_registered_parameters"}}],"kind":"struct","path":"ContractClassRegisterer::assert_class_id_is_registered_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"artifact_metadata_hash","type":{"kind":"field"}},{"name":"unconstrained_functions_artifact_tree_root","type":{"kind":"field"}},{"name":"private_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"private_function_tree_leaf_index","type":{"kind":"field"}},{"name":"artifact_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"artifact_function_tree_leaf_index","type":{"kind":"field"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"metadata_hash","type":{"kind":"field"}},{"name":"vk_hash","type":{"kind":"field"}}],"kind":"struct","path":"events::private_function_broadcasted::InnerPrivateFunction"}}],"kind":"struct","path":"ContractClassRegisterer::broadcast_private_function_parameters"}}],"kind":"struct","path":"ContractClassRegisterer::broadcast_private_function_abi"}]}},"file_map":{"26":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"52":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"62":{"path":"/build-volume/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/capsule.nr","source":"// We should extract this to a shared lib in aztec-nr once we settle on a design for capsules\\n\\n// docs:start:pop_capsule\\n#[oracle(popCapsule)]\\nunconstrained fn pop_capsule_oracle<let N: u32>() -> [Field; N] {}\\n\\n// A capsule is a \\"blob\\" of data that is passed to the contract through an oracle.\\npub unconstrained fn pop_capsule<let N: u32>() -> [Field; N] {\\n    pop_capsule_oracle()\\n}\\n// docs:end:pop_capsule\\n"},"67":{"path":"/build-volume/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/main.nr","source":"mod events;\\nmod capsule;\\n\\nuse dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract ContractClassRegisterer {\\n    use dep::aztec::protocol_types::{\\n        abis::log_hash::LogHash,\\n        constants::{\\n            ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, FUNCTION_TREE_HEIGHT,\\n            MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,\\n            MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS,\\n            MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\\n        },\\n        contract_class_id::ContractClassId,\\n    };\\n\\n    use dep::aztec::{\\n        context::PrivateContext, macros::functions::private,\\n        oracle::logs::emit_contract_class_unencrypted_log_private,\\n    };\\n\\n    use crate::events::{\\n        class_registered::ContractClassRegistered,\\n        private_function_broadcasted::{\\n            ClassPrivateFunctionBroadcasted, InnerPrivateFunction, PrivateFunction,\\n        },\\n        unconstrained_function_broadcasted::{\\n            ClassUnconstrainedFunctionBroadcasted, InnerUnconstrainedFunction,\\n            UnconstrainedFunction,\\n        },\\n    };\\n\\n    // docs:start:import_pop_capsule\\n    use crate::capsule::pop_capsule;\\n\\n    // docs:end:import_pop_capsule\\n\\n    #[private]\\n    fn register(\\n        artifact_hash: Field,\\n        private_functions_root: Field,\\n        public_bytecode_commitment: Field,\\n        emit: bool,\\n    ) {\\n        // TODO: Validate public_bytecode_commitment is the correct commitment of packed_public_bytecode\\n        // TODO: We should be able to remove public_bytecode_commitment from the input if it\'s calculated in this function\\n        // docs:start:pop_capsule\\n        let packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] =\\n            unsafe { pop_capsule() };\\n        // docs:end:pop_capsule\\n        // First field element contains the length of the bytecode\\n        let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\\n        let bytecode_length_in_fields: u32 =\\n            (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\\n        assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\\n\\n        // The first value in the running hash is the bytecode length in bytes\\n        let mut computed_public_bytecode_commitment = packed_public_bytecode[0];\\n        // We can hash up to MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS - 1, since the first element is the length\\n        for i in 0..(MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS - 1) {\\n            // While we are forced to run the hash MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS times in the circuit,\\n            // we want the bytecode commitment to be based on the actual length\\n            if (i < bytecode_length_in_fields) {\\n                // We skip the first element when hashing since it is the length\\n                computed_public_bytecode_commitment = std::hash::poseidon2::Poseidon2::hash(\\n                    [packed_public_bytecode[i + 1], computed_public_bytecode_commitment],\\n                    2,\\n                );\\n            } else {\\n                // Any bytes after the bytecode length must be 0\\n                assert_eq(packed_public_bytecode[i + 1], 0);\\n            }\\n        }\\n        assert_eq(computed_public_bytecode_commitment, public_bytecode_commitment);\\n\\n        // Compute contract class id from preimage\\n        let contract_class_id = ContractClassId::compute(\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment,\\n        );\\n\\n        // Emit the contract class id as a nullifier to be able to prove that this class has been (not) registered\\n        context.push_nullifier(contract_class_id.to_field());\\n\\n        // Broadcast class info including public bytecode\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ContractClassRegistered: {}\\",\\n            [\\n                contract_class_id.to_field(),\\n                artifact_hash,\\n                private_functions_root,\\n                public_bytecode_commitment,\\n            ],\\n        );\\n\\n        // TODO(#10007): Drop this conditional and always emit the bytecode. We allow skipping the broadcast\\n        // as a stopgap solution to allow txs to fit in Sepolia when we broadcast public bytecode.\\n        if emit {\\n            let event = ContractClassRegistered {\\n                contract_class_id,\\n                version: 1,\\n                artifact_hash,\\n                private_functions_root,\\n                packed_public_bytecode,\\n            };\\n            emit_contract_class_log(&mut context, event.serialize_non_standard());\\n        }\\n    }\\n\\n    #[private]\\n    fn broadcast_private_function(\\n        contract_class_id: ContractClassId,\\n        artifact_metadata_hash: Field,\\n        unconstrained_functions_artifact_tree_root: Field,\\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n        private_function_tree_leaf_index: Field,\\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\\n        artifact_function_tree_leaf_index: Field,\\n        function_data: InnerPrivateFunction,\\n    ) {\\n        let private_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS] =\\n            unsafe { pop_capsule() };\\n\\n        let event = ClassPrivateFunctionBroadcasted {\\n            contract_class_id,\\n            artifact_metadata_hash,\\n            unconstrained_functions_artifact_tree_root,\\n            private_function_tree_sibling_path,\\n            private_function_tree_leaf_index,\\n            artifact_function_tree_sibling_path,\\n            artifact_function_tree_leaf_index,\\n            function: PrivateFunction {\\n                selector: function_data.selector,\\n                metadata_hash: function_data.metadata_hash,\\n                vk_hash: function_data.vk_hash,\\n                bytecode: private_bytecode,\\n            },\\n        };\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ClassPrivateFunctionBroadcasted: {}\\",\\n            [\\n                contract_class_id.to_field(),\\n                artifact_metadata_hash,\\n                unconstrained_functions_artifact_tree_root,\\n                function_data.selector.to_field(),\\n                function_data.vk_hash,\\n                function_data.metadata_hash,\\n            ],\\n        );\\n        emit_contract_class_log(&mut context, event.serialize_non_standard());\\n    }\\n\\n    #[private]\\n    fn broadcast_unconstrained_function(\\n        contract_class_id: ContractClassId,\\n        artifact_metadata_hash: Field,\\n        private_functions_artifact_tree_root: Field,\\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\\n        artifact_function_tree_leaf_index: Field,\\n        function_data: InnerUnconstrainedFunction,\\n    ) {\\n        let unconstrained_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS] =\\n            unsafe { pop_capsule() };\\n        let event = ClassUnconstrainedFunctionBroadcasted {\\n            contract_class_id,\\n            artifact_metadata_hash,\\n            private_functions_artifact_tree_root,\\n            artifact_function_tree_sibling_path,\\n            artifact_function_tree_leaf_index,\\n            function: UnconstrainedFunction {\\n                selector: function_data.selector,\\n                metadata_hash: function_data.metadata_hash,\\n                bytecode: unconstrained_bytecode,\\n            },\\n        };\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ClassUnconstrainedFunctionBroadcasted: {}\\",\\n            [\\n                contract_class_id.to_field(),\\n                artifact_metadata_hash,\\n                private_functions_artifact_tree_root,\\n                function_data.selector.to_field(),\\n                function_data.metadata_hash,\\n            ],\\n        );\\n        emit_contract_class_log(&mut context, event.serialize_non_standard());\\n    }\\n\\n    #[contract_library_method]\\n    fn emit_contract_class_log<let N: u32>(context: &mut PrivateContext, log: [Field; N]) {\\n        let contract_address = context.this_address();\\n        let counter = context.next_counter();\\n\\n        // The log preimage is too large for the hash to compile (16,200 fields, 518,400 bytes), so we do this via a\\n        // specialized oracle.\\n        // A malicious oracle cannot force us to use an incorrect bytecode:\\n        // - Contract class -> we will commit to the packed bytecode (currently a TODO)\\n        // - Private function -> we provide a membership proof\\n        // - Unconstrained function -> we provide a membership proof\\n        // However, the sequencer will be required to know a contract\'s preimage if it is called and the sequencer\\n        // cannot prove non-registration. Therefore, it is possible that a malicious oracle might prevent sequencers\\n        // from including transactions with calls to certain badly-broadcasted contracts.\\n        // TODO(#8978): review correctness\\n        let log_hash =\\n            unsafe { emit_contract_class_unencrypted_log_private(contract_address, log, counter) };\\n\\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\\n        context.contract_class_logs_hashes.push(\\n            LogHash { value: log_hash, counter, length: 40 + (N as Field) * 32 },\\n        );\\n    }\\n\\n    #[private]\\n    fn assert_class_id_is_registered(contract_class_id: ContractClassId) {\\n        context.push_nullifier_read_request(contract_class_id.to_field());\\n    }\\n}\\n"},"75":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::Empty,\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            /// for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\\n        /// to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"91":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\\nuse dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::Hash,\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"141":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n/// Temporary substitute that is used for handling contract class registration. This\\n/// variant returns the log hash, which would be too large to compute inside a circuit.\\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\\n    contract_address: AztecAddress,\\n    message: [Field; N],\\n    counter: u32,\\n) -> Field {\\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\\n}\\n\\n#[oracle(emitContractClassLog)]\\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    message: [Field; N],\\n    counter: u32,\\n) -> Field {}\\n"},"144":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            packed_note_content,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\\npub fn notify_created_nullifier(nullifier: Field) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n        note_hash,\\n        counter,\\n    );\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _packed_note_content: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\\n    let _ = notify_created_nullifier_oracle(nullifier);\\n}\\n\\n#[oracle(notifyCreatedNullifier)]\\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\\n) -> [Option<Note>; S]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    sync_notes_oracle_wrapper();\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let nonce = fields[read_offset];\\n            let note_hash_counter = fields[read_offset + 1] as u32;\\n            let note_content = array::subarray(fields, read_offset + 2);\\n\\n            let mut note = Note::unpack_content(note_content);\\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\\n\\n            placeholder_opt_notes[i] = Option::some(note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\\n/// for later querying via the `get_notes` oracle.\\npub fn sync_notes() {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        sync_notes_oracle_wrapper();\\n    }\\n}\\n\\nunconstrained fn sync_notes_oracle_wrapper() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n"},"254":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr","source":"use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\\nuse crate::traits::{Deserialize, FromField, Packable, Serialize, ToField};\\n\\npub struct ContractClassId {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for ContractClassId {\\n    fn eq(self, other: ContractClassId) -> bool {\\n        other.inner == self.inner\\n    }\\n}\\n\\nimpl ToField for ContractClassId {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for ContractClassId {\\n    fn from_field(value: Field) -> Self {\\n        Self { inner: value }\\n    }\\n}\\n\\nimpl Serialize<1> for ContractClassId {\\n    fn serialize(self: Self) -> [Field; 1] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<1> for ContractClassId {\\n    fn deserialize(fields: [Field; 1]) -> Self {\\n        Self { inner: fields[0] }\\n    }\\n}\\n\\n// Implement the Packable trait so ContractClassId can be stored in contract\'s storage.\\nimpl Packable<1> for ContractClassId {\\n    fn pack(self) -> [Field; 1] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; 1]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl ContractClassId {\\n    pub fn compute(\\n        artifact_hash: Field,\\n        private_functions_root: Field,\\n        public_bytecode_commitment: Field,\\n    ) -> Self {\\n        let hash = crate::hash::poseidon2_hash_with_separator(\\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\\n            GENERATOR_INDEX__CONTRACT_LEAF,\\n        ); // TODO(@spalladino): Update generator index\\n        ContractClassId::from_field(hash)\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"261":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"262":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        function_selector::FunctionSelector,\\n        log_hash::{LogHash, ScopedLogHash},\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, is_empty, ToField},\\n    utils::field::field_from_bytes_32_trunc,\\n};\\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; N * 32];\\n    for offset in 0..N {\\n        // TODO: This is not checking that the decomposition is smaller than P\\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"279":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"}}}');async function dy(e,t){const n=jb[e],s=Qb[e],i=await au(t);return{instance:{...await cu(t,{salt:s}),address:n},contractClass:i,artifact:t,address:n}}i(8891).Buffer,i(8891).Buffer,i(8891).Buffer;const uy=ry(cy);let fy;const hy=ry(JSON.parse('{"transpiled":true,"noir_version":"1.0.0-beta.1+c4e38215cedb5afb","name":"ContractInstanceDeployer","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"packed_note_content","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VZy67aQAwdSEJIuAEKn3Cl7tomXJ47Fn3c30AFPqHrrLppP7qMGCcH46siYVfFEpoknhyfOXZmJqHjztY//TrhOA5tz10b9dmGtrzPKkWs0pJn50F4dh+EZ/QgPGNFnh2Bp2/peUvc+ZlL3fl5bC7iTT7BEdzk/gYAwX6HNgttF/yKCakyYZBa+Otyvs/cpSnzf8kCZmqDvyD8vg1+Sbw/1y0+joXiRqF9rVstX+Eeb0U4xuIlXPJ1wfeF+SLwfWU+rOFvzId1T5xIN1qYlOtqY50XGlsKY+u80TrXaofXSOvcmdZoRTnPGB/On/gU1Kdu+fSYLwZfxnwJ+Eh/3z5DP577FPp9hONP0IfXZ+Su65n8lH/U3aK+YgP8k82lHPD8xPVlbPRhDmLQ85npY7FuoD4W+nt9pm/wp2Nvae0ai5ieqBFp1sf+zJeBL64v4+ThPIY4iEU8Etb/QzgfhbYH99D9YyF+j8W/4C1cQ404ViRco/7++Xwfjgfh52voJ93jructvc31ci7N4Xr4qwY/s+F/JPzcBn9J+AMb/GZv82SCPysJv7Dh38xBQ5v6afaWIxv+B8Ifm+DPD7QOv3OtNXNEOJ7Adb35u6pu2SNh/JxxtdojTRgfrg+uwd43FbiOBR/P4VSIMxXiSFiZItaTItboPx1jXxFroIg1VMTSzGOqiKWpV66IVShiada9pl6UR2mf5m0b2vJOk/ZpiviVtE/TfJcnram+YkFDHF/C+v9gOg9MeFYzWnPoWacYGLswin3rek3xC4EP8c4F3z0fZw+L9XGzXmxOW7JqOds0+SwYV34N34twPsb+0tov7fsUtS6ld/8h6OotBl/BfAn4iKP07j804n+L/hh/LPj4+n9rLifuej0csHHjN6+typjb74HSt3rj+Wtx67NJ8XN3PV//q++NqA/fS+cC17Hg4/uTXIiTC3EeEYt/s0cNfV2TTnHd+rVyuVq3f3TRXJS4y/8BHIufsP6/wjmOjdp75vzjalcdX3bH3WK338+/7yYM31sXdPoDg5oBSR0fAAA=","debug_symbols":"tdfNaoQwFIbhe8k6i5z8mIm3UsoQNQ6BECVqoYj33jhM26GzLN9GiBwfN77g2dkQuu12jXmcFta+7SxNvV/jlOtpPzjrSkwp3q7Pt5k4L87c55fZ5/O4rL6srFWSs5AH1mpRnx5jCqxt5MFfBu33oLU/g0Ye75y5BgVbFHxBwQ4EkxAwmWCyhMkKJmuYbGByA5MtTL7AZFiDBGuQYA0SrEGCNUiwBgnWIMEaJFiD9L8GnXoM1k/hhXYwWgocTTha4miFozWONji6wdEWR+NqlLgaFa5GBarxqKcPX6LvUnhsTeOW+6clav2cw599ai5TH4athHOz+l2qzvSU4drc/zzqgZTmpFx9SX3RFw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"log_plaintext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/92c927bMBDG5URKIieOndG9927leHeme+/W/dsdfosWAtqHSPu09Zfw7DPDAilCovkqQJCto+9+PFHUiTy6EG1s3cFeMJ9jc5w2R5xfjMY3Kbtqjtn2tqpHXVkoxgIB4wQB4yQBY0zAmBAwThEwThMwzhAwpgSMRQLGWQLGOQLGEgHjPAFjmYCxQsC4EIAxBOciCeeSR04d24fiXY52fhvdRcC4m4BxDwHjXgLGfQSM+wkYDxAwHiRgPETAeJiA8QgB41ECxmMEjMcJGE8QMJ4kYDxFwHiagPEMAeNZAsZzBIznCRgvEDBeJGC8RMB4mYDxCgFjRsBYJWBcIWCsETDWCRgbBIxNAsYWAWObgLFDwHiVgPEaAeN1AsYbBIw3CRhvETCuEjDeJmC8Q8B4l4DxHgHjfQLGBwSMDwkYHxEwPiZgfELA+JSA8RkB43MCxhcEjC8JGF8RML4mYHxDwPg2AGMIzncknO9JOLuBOKMPFvTEYMfCLSyMwsIjLOzBwhksTMHCDyyswMIFLAxA4j0S25E4XhnsSHxGUjESdpEEiyRTJHEiSRJJiEjyQxIdktSQBIYkKyQxIUno6GA/NtiRRIIkDSRBIMkAk/iYJMckNCZ5MYmKSUpMAmKSDZNYmCRCrTDJgUkEDNJjEByDzBjExSApBiExyIdBNAxSYRAIgywYxJBBArzk4iUSL2l4CcJLBoJ4BMkIQhHkIYhCkIIgAA9ZPMTwkEAnjE4OnQhuUtwAaFzd6M+bNJIf5pia44SSe1xEV00tuz71t7POx9RRP4/8tdTonAmiv9ES/WkY/kwW2t7LR/p1XcTupDl285Evu/k4k5RZU2XWrDJSnzDXu14P66/qSsnyUaTqIraLYWzXCpY9fV20TOwXo5Btc2NRsrYnPLZ/pO8oSZl8xFOwZHG+uR4iS5RMri/snFfl7LY1Y8mEBZu035LyjWwfjEyuaax0+muvjXbY9lrP/l17rVf/x/YaW7I431yPv22vum3Z7TWJRpv0pSKbUrKflmxayX7lI9sNxdE0n8P2yRvPYH3v+X6GLTn4tS1s0/nIH9IGJ9W5RPlv3T+6vCVLlSzOx+0UzfdY2dG6hCOxytfN97I5TqnfyO8rDvtTlv0xbsc52y+po3zqKI+2dsl8njU72tA3+U20+d7Fvmq+Z9vamh1XP+lPf6vm6gs98n8R/bNB9NeH+ufC8A/jqlIY/w/1z4fh74v+chj9TdFfCaO/IfoXguhfGcYJ+s927DhhSZ33GNduOU4Q+0WLNVScsGTx2P7RcQJkyw7WikNm9wHLDjvLDjsuXfMedS141FXcoXUsedRV8agr9ajL53Wc86jLp7/KHnXNeNTls9379Jdcx7DjVVnmitOiAPqLYfQP+37po/W7ma6T2E+s8l8tP88F8fNoHEr6M+0LVyzl0/ZWn9div+TgEe6iQ7adP0D70mj3O+1GZxDSV5srnaxg6RdW+5x+L9L9iy7veva74j6Pvs5cYxBl5VdssZLNW7JEyYRRj0G44mKf/Fvxv7Zfccjs/nmr13IxGm9r+n6cjUb3c5z7r3urvfHHLuuMRn8SjY8xRpb9xCr/3Xy3+7rt3iP9Vq/ar/X6vUbv8+f6p96ipV/7EH76DXVGL3ipUwAA","debug_symbols":"tZbLCoMwEEX/ZdZZOOOr9VdKKVFjCYQoUQtF/PfG0oe067sJTJg5QxYn3IVaU8/Xi/VdP1J1Wsj1jZ5s72O1rIrqYJ2z18v+mpLt4ESeA+Og/VaPkw4TVakoMr6lKkvieGedoaqQVf01lu/Gsvw05rKeVSSnMHIGI+cwcgEjlzDyAUY+osicwMgMI8McZJiDDHOQYQ4yzEGGOcgwBxnmoMAcFJiDAnNQYA4KxsE1VjcdrK6deQWIbvbNLk9M98H8RIsh9I1p52C2kPHNF9vbM1G5PH/9WLAUilOOS+KiBw==","brillig_names":["process_log"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==","debug_symbols":"bY/dCoMwDIXfJde9aOo2sK8iQ6pGKZRWah0M8d2Xjk26n5tDTvhyyNlgoG6dWuvHsIBuNnChN8kGz27bBXTROmentlyDzILVk19m47NdkokJdKUEkB9AnyRfj9YR6IvaxQ+IEuWb5VnVB45V/Z+v8eAVyg/+urO9mWhN5+j1+rj6vmiS7jN9lZpj6GlYI+V6RTPWBs9CSY7l6Ac=","brillig_names":["sync_notes"]},{"name":"deploy","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"initialization_hash","type":{"kind":"field"},"visibility":"private"},{"name":"public_keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::NpkM"}},{"name":"ivpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::IvpkM"}},{"name":"ovpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::OvpkM"}},{"name":"tpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::TpkM"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::PublicKeys"},"visibility":"private"},{"name":"universal_deploy","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["store_in_execution_cache_oracle_wrapper","call_private_function_internal","decompose_hint","lte_hint","notify_created_nullifier_oracle_wrapper","debug_log_oracle_wrapper","directive_integer_quotient","directive_invert"],"verification_key":"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"}],"outputs":{"globals":{},"structs":{"events":[{"fields":[{"name":"DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE","type":{"kind":"field"}},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"version","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"salt","type":{"kind":"field"}},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"public_keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::NpkM"}},{"name":"ivpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::IvpkM"}},{"name":"ovpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::OvpkM"}},{"name":"tpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::TpkM"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::PublicKeys"}},{"name":"deployer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ContractInstanceDeployer::ContractInstanceDeployed"}],"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"salt","type":{"kind":"field"}},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"public_keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::NpkM"}},{"name":"ivpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::IvpkM"}},{"name":"ovpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::OvpkM"}},{"name":"tpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::TpkM"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::PublicKeys"}},{"name":"universal_deploy","type":{"kind":"boolean"}}],"kind":"struct","path":"ContractInstanceDeployer::deploy_parameters"}}],"kind":"struct","path":"ContractInstanceDeployer::deploy_abi"}]}},"file_map":{"17":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\\nuse crate::ops::arith::{Add, Neg, Sub};\\n\\n/// A point on the embedded elliptic curve\\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\\npub struct EmbeddedCurvePoint {\\n    pub x: Field,\\n    pub y: Field,\\n    pub is_infinite: bool,\\n}\\n\\nimpl EmbeddedCurvePoint {\\n    /// Elliptic curve point doubling operation\\n    /// returns the doubled point of a point P, i.e P+P\\n    pub fn double(self) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, self)\\n    }\\n\\n    /// Returns the null element of the curve; \'the point at infinity\'\\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\\n    }\\n}\\n\\nimpl Add for EmbeddedCurvePoint {\\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, other)\\n    }\\n}\\n\\nimpl Sub for EmbeddedCurvePoint {\\n    /// Points subtraction operation, using addition and negation\\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        self + other.neg()\\n    }\\n}\\n\\nimpl Neg for EmbeddedCurvePoint {\\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\\n    /// If the point is at infinity, then the result is also at infinity.\\n    fn neg(self) -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurvePoint {\\n    /// Checks whether two points are equal\\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\\n        (self.is_infinite & b.is_infinite)\\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\\n    }\\n}\\n\\n/// Scalar for the embedded curve represented as low and high limbs\\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\\npub struct EmbeddedCurveScalar {\\n    pub lo: Field,\\n    pub hi: Field,\\n}\\n\\nimpl EmbeddedCurveScalar {\\n    pub fn new(lo: Field, hi: Field) -> Self {\\n        EmbeddedCurveScalar { lo, hi }\\n    }\\n\\n    #[field(bn254)]\\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\\n        let (a, b) = crate::field::bn254::decompose(scalar);\\n        EmbeddedCurveScalar { lo: a, hi: b }\\n    }\\n\\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\\n    #[field(bn254)]\\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\\n        let mut v = 1;\\n        let mut lo = 0 as Field;\\n        let mut hi = 0 as Field;\\n        for i in 0..16 {\\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\\n        sig_s\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurveScalar {\\n    fn eq(self, other: Self) -> bool {\\n        (other.hi == self.hi) & (other.lo == self.lo)\\n    }\\n}\\n\\n// Computes a multi scalar multiplication over the embedded curve.\\n// For bn254, We have Grumpkin and Baby JubJub.\\n// For bls12-381, we have JubJub and Bandersnatch.\\n//\\n// The embedded curve being used is decided by the\\n// underlying proof system.\\n// docs:start:multi_scalar_mul\\npub fn multi_scalar_mul<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> EmbeddedCurvePoint\\n// docs:end:multi_scalar_mul\\n{\\n    let point_array = multi_scalar_mul_array_return(points, scalars);\\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\\n}\\n\\n#[foreign(multi_scalar_mul)]\\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> [Field; 3] {}\\n\\n// docs:start:fixed_base_scalar_mul\\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\\n// docs:end:fixed_base_scalar_mul\\n{\\n    let g1 = EmbeddedCurvePoint {\\n        x: 1,\\n        y: 17631683881184975370165255887551781615748388533673675138860,\\n        is_infinite: false,\\n    };\\n    multi_scalar_mul([g1], [scalar])\\n}\\n\\n/// This function only assumes that the points are on the curve\\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\\n// docs:start:embedded_curve_add\\npub fn embedded_curve_add(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    // docs:end:embedded_curve_add\\n    let x_coordinates_match = point1.x == point2.x;\\n    let y_coordinates_match = point1.y == point2.y;\\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\\n    let point1_1 = EmbeddedCurvePoint {\\n        x: point1.x + (x_coordinates_match as Field),\\n        y: point1.y,\\n        is_infinite: x_coordinates_match,\\n    };\\n    // point1_1 is guaranteed to have a different abscissa than point2\\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\\n    result.is_infinite = x_coordinates_match;\\n\\n    // dbl if x_match, y_match\\n    let double = embedded_curve_add_unsafe(point1, point1);\\n    result = if double_predicate { double } else { result };\\n\\n    // infinity if x_match, !y_match\\n    if point1.is_infinite {\\n        result = point2;\\n    }\\n    if point2.is_infinite {\\n        result = point1;\\n    }\\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\\n    result\\n}\\n\\n#[foreign(embedded_curve_add)]\\nfn embedded_curve_add_array_return(\\n    _point1: EmbeddedCurvePoint,\\n    _point2: EmbeddedCurvePoint,\\n) -> [Field; 3] {}\\n\\n/// This function assumes that:\\n/// The points are on the curve, and\\n/// The points don\'t share an x-coordinate, and\\n/// Neither point is the infinity point.\\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\\npub fn embedded_curve_add_not_nul(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    assert(point1.x != point2.x);\\n    assert(!point1.is_infinite);\\n    assert(!point2.is_infinite);\\n    embedded_curve_add_unsafe(point1, point2)\\n}\\n\\n/// Unsafe ec addition\\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\\n/// If they have the same value but are different variables, the result will be incorrect because in this case\\n/// it assumes (but does not check) that the points\' x-coordinates are not equal.\\n/// It also assumes neither point is the infinity point.\\npub fn embedded_curve_add_unsafe(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    let point_array = embedded_curve_add_array_return(point1, point2);\\n    let x = point_array[0];\\n    let y = point_array[1];\\n\\n    EmbeddedCurvePoint { x, y, is_infinite: false }\\n}\\n"},"18":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    /// Safety: borrow is enforced to be boolean due to its type.\\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n    unsafe {\\n        /*@safety: borrow is enforced to be boolean due to its type.\\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n        */\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        /// Safety: decomposition is properly checked below\\n        unsafe {\\n            /*@safety: decomposition is properly checked below*/\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            /// Safety: already unconstrained\\n            unsafe { field_less_than(b, a) },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        /// Safety: unsafe in unconstrained\\n        unsafe {\\n            //@safety: unsafe in unconstrained\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        /// Safety: Take a hint of the comparison and verify it\\n        unsafe {\\n            //@safety: Take a hint of the comparison and verify it\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"19":{"path":"std/field/mod.nr","source":"pub mod bn254;\\nuse crate::{runtime::is_unconstrained, static_assert};\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        static_assert(\\n            BIT_SIZE < modulus_num_bits() as u32,\\n            \\"BIT_SIZE must be less than modulus_num_bits\\",\\n        );\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_le_bits\\n        let bits = self._to_le_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(p[N - 1 - i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_be_bits\\n        let bits = self._to_be_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the decomposition does not overflow the modulus\\n            let p = modulus_be_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[i] != p[i]) {\\n                        assert(p[i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            static_assert(1 < radix, \\"radix must be greater than 1\\");\\n            static_assert(radix <= 256, \\"radix must be less than or equal to 256\\");\\n            static_assert(radix & (radix - 1) == 0, \\"radix must be a power of 2\\");\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        /// Safety: unconstrained context\\n        unsafe {\\n            //@safety : unconstrained context\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use crate::{panic::panic, runtime};\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test(should_fail_with = \\"radix must be greater than 1\\")]\\n    fn test_to_le_radix_1() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(1);\\n        } else {\\n            panic(f\\"radix must be greater than 1\\");\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\\n    // #[test]\\n    // fn test_to_le_radix_brillig_1() {\\n    //     // this test should only fail in constrained mode\\n    //     if runtime::is_unconstrained() {\\n    //         let field = 1;\\n    //         let out: [u8; 8] = field.to_le_radix(1);\\n    //         crate::println(out);\\n    //         let expected = [0; 8];\\n    //         assert(out == expected, \\"unexpected result\\");\\n    //     }\\n    // }\\n\\n    #[test(should_fail_with = \\"radix must be a power of 2\\")]\\n    fn test_to_le_radix_3() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(3);\\n        } else {\\n            panic(f\\"radix must be a power of 2\\");\\n        }\\n    }\\n\\n    #[test]\\n    fn test_to_le_radix_brillig_3() {\\n        // this test should only fail in constrained mode\\n        if runtime::is_unconstrained() {\\n            let field = 1;\\n            let out: [u8; 8] = field.to_le_radix(3);\\n            let mut expected = [0; 8];\\n            expected[0] = 1;\\n            assert(out == expected, \\"unexpected result\\");\\n        }\\n    }\\n\\n    #[test(should_fail_with = \\"radix must be less than or equal to 256\\")]\\n    fn test_to_le_radix_512() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(512);\\n        } else {\\n            panic(f\\"radix must be less than or equal to 256\\")\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\\n    // #[test]\\n    // fn test_to_le_radix_brillig_512() {\\n    //     // this test should only fail in constrained mode\\n    //     if runtime::is_unconstrained() {\\n    //         let field = 1;\\n    //         let out: [u8; 8] = field.to_le_radix(512);\\n    //         let mut expected = [0; 8];\\n    //         expected[0] = 1;\\n    //         assert(out == expected, \\"unexpected result\\");\\n    //     }\\n    // }\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n"},"26":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"52":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"62":{"path":"/build-volume/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"use dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract ContractInstanceDeployer {\\n    use dep::aztec::macros::{events::event, functions::private};\\n    use dep::aztec::protocol_types::{\\n        address::{AztecAddress, PartialAddress},\\n        constants::{DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE, REGISTERER_CONTRACT_ADDRESS},\\n        contract_class_id::ContractClassId,\\n        public_keys::PublicKeys,\\n        traits::Serialize,\\n        utils::arrays::array_concat,\\n    };\\n    use dep::contract_class_registerer::ContractClassRegisterer;\\n    use std::meta::derive;\\n\\n    #[derive(Serialize)]\\n    #[event]\\n    struct ContractInstanceDeployed {\\n        DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE: Field,\\n        address: AztecAddress,\\n        version: u8,\\n        salt: Field,\\n        contract_class_id: ContractClassId,\\n        initialization_hash: Field,\\n        public_keys: PublicKeys,\\n        deployer: AztecAddress,\\n    }\\n\\n    // We need to impl this separately because ts deserializes a point as two fields only.\\n    // We had issues that:\\n    // Notice how the \'is_infinite\' field is deserialized as the next point.\\n    // {\\n    //     masterNullifierPublicKey: Point {\\n    //   x: Fr<0x0000000000000000000000000000000000000000000000000000000000000012>,\\n    //   y: Fr<0x0000000000000000000000000000000000000000000000000000000000000034>,\\n    //   isInfinite: false,\\n    //   kind: \'point\'\\n    // },\\n    // masterIncomingViewingPublicKey: Point {\\n    //   x: Fr<0x0000000000000000000000000000000000000000000000000000000000000000>,\\n    //   y: Fr<0x0000000000000000000000000000000000000000000000000000000000000056>,\\n    //   isInfinite: false,\\n    //   kind: \'point\'\\n    // },\\n    // masterOutgoingViewingPublicKey: Point {\\n    //   x: Fr<0x0000000000000000000000000000000000000000000000000000000000000078>,\\n    //   y: Fr<0x0000000000000000000000000000000000000000000000000000000000000000>,\\n    //   isInfinite: false,\\n    //   kind: \'point\'\\n    // },\\n    // masterTaggingPublicKey: Point {\\n    //   x: Fr<0x0000000000000000000000000000000000000000000000000000000000000910>,\\n    //   y: Fr<0x0000000000000000000000000000000000000000000000000000000000001112>,\\n    //   isInfinite: false,\\n    //   kind: \'point\'\\n    // }\\n\\n    impl ContractInstanceDeployed {\\n        fn serialize_non_standard(self) -> [Field; 15] {\\n            [\\n                self.DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n                self.address.to_field(),\\n                self.version.to_field(),\\n                self.salt,\\n                self.contract_class_id.to_field(),\\n                self.initialization_hash,\\n                self.public_keys.npk_m.serialize()[0],\\n                self.public_keys.npk_m.serialize()[1],\\n                self.public_keys.ivpk_m.serialize()[0],\\n                self.public_keys.ivpk_m.serialize()[1],\\n                self.public_keys.ovpk_m.serialize()[0],\\n                self.public_keys.ovpk_m.serialize()[1],\\n                self.public_keys.tpk_m.serialize()[0],\\n                self.public_keys.tpk_m.serialize()[1],\\n                self.deployer.to_field(),\\n            ]\\n        }\\n    }\\n\\n    #[private]\\n    fn deploy(\\n        salt: Field,\\n        contract_class_id: ContractClassId,\\n        initialization_hash: Field,\\n        public_keys: PublicKeys,\\n        universal_deploy: bool,\\n    ) {\\n        // contract class must be registered to deploy an instance\\n        ContractClassRegisterer::at(REGISTERER_CONTRACT_ADDRESS)\\n            .assert_class_id_is_registered(contract_class_id)\\n            .call(&mut context);\\n\\n        let deployer = if universal_deploy {\\n            AztecAddress::zero()\\n        } else {\\n            context.msg_sender()\\n        };\\n\\n        let partial_address =\\n            PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\\n\\n        let address = AztecAddress::compute(public_keys, partial_address);\\n\\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\\n        context.push_nullifier(address.to_field());\\n\\n        // Broadcast the event\\n        let event = ContractInstanceDeployed {\\n            DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n            contract_class_id,\\n            address,\\n            public_keys,\\n            initialization_hash,\\n            salt,\\n            deployer,\\n            version: 1,\\n        };\\n\\n        let payload = event.serialize_non_standard();\\n        dep::aztec::oracle::debug_log::debug_log_format(\\"ContractInstanceDeployed: {}\\", payload);\\n\\n        let padded_log = array_concat(payload, [0; 3]);\\n        context.emit_private_log(padded_log);\\n    }\\n}\\n"},"63":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\\n};\\n\\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\\n\\nuse crate::hash::hash_args;\\nuse crate::oracle::execution_cache;\\n\\npub trait CallInterface<let N: u32> {\\n    fn get_args(self) -> [Field];\\n    fn get_selector(self) -> FunctionSelector;\\n    fn get_name(self) -> str<N>;\\n    fn get_contract_address(self) -> AztecAddress;\\n    fn get_is_static(self) -> bool;\\n}\\n\\npub struct PrivateCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n        );\\n        let returns: T = returns_hash.get_preimage();\\n        returns\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns_hash.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PrivateVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateVoidCallInterface<N> {\\n    pub fn call(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                false,\\n            )\\n            .assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PrivateStaticCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PrivateStaticVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PublicCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub gas_opts: GasOpts,\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PublicCallInterface<N, T> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PublicVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n    pub gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicVoidCallInterface<N> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PublicStaticCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n    pub gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PublicStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (),\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n"},"70":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::Empty,\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            /// for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\\n        /// to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"72":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr","source":"use crate::{hash::hash_args_array, oracle::execution_cache};\\nuse dep::protocol_types::traits::Deserialize;\\n\\npub struct ReturnsHash {\\n    hash: Field,\\n}\\n\\nimpl ReturnsHash {\\n    pub fn new(hash: Field) -> Self {\\n        ReturnsHash { hash }\\n    }\\n\\n    pub fn assert_empty(self) {\\n        assert_eq(self.hash, 0);\\n    }\\n\\n    pub fn raw(self) -> Field {\\n        self.hash\\n    }\\n\\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\\n    /// values.\\n    pub fn get_preimage<T, let N: u32>(self) -> T\\n    where\\n        T: Deserialize<N>,\\n    {\\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\\n        assert_eq(self.hash, hash_args_array(preimage));\\n\\n        Deserialize::deserialize(preimage)\\n    }\\n}\\n"},"86":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\\nuse dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::Hash,\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"125":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> [Field; 2] {}\\n\\npub unconstrained fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> (u32, Field) {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n    );\\n\\n    let mut reader = Reader::new(fields);\\n    let end_side_effect_counter = reader.read_u32();\\n    let returns_hash = reader.read();\\n\\n    (end_side_effect_counter, returns_hash)\\n}\\n"},"128":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr","source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\\npub fn store(values: [Field]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\\n}\\n\\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\\n    let _ = store_in_execution_cache_oracle(values);\\n}\\n\\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\\n    load_from_execution_cache_oracle(hash)\\n}\\n\\n#[oracle(storeInExecutionCache)]\\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\\n\\n#[oracle(loadFromExecutionCache)]\\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\\n"},"139":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            packed_note_content,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\\npub fn notify_created_nullifier(nullifier: Field) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n        note_hash,\\n        counter,\\n    );\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _packed_note_content: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\\n    let _ = notify_created_nullifier_oracle(nullifier);\\n}\\n\\n#[oracle(notifyCreatedNullifier)]\\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\\n) -> [Option<Note>; S]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    sync_notes_oracle_wrapper();\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let nonce = fields[read_offset];\\n            let note_hash_counter = fields[read_offset + 1] as u32;\\n            let note_content = array::subarray(fields, read_offset + 2);\\n\\n            let mut note = Note::unpack_content(note_content);\\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\\n\\n            placeholder_opt_notes[i] = Option::some(note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\\n/// for later querying via the `get_notes` oracle.\\npub fn sync_notes() {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        sync_notes_oracle_wrapper();\\n    }\\n}\\n\\nunconstrained fn sync_notes_oracle_wrapper() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n"},"240":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector,\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        MAX_FIELD_VALUE,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\\n    merkle_tree::membership::MembershipWitness,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::{\\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\\n    ops::Add,\\n};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\n/// We implement the Packable trait for AztecAddress because it can be stored in contract\'s storage (and there\\n/// the implementation of Packable is required).\\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_private_function(\\n        function_selector: FunctionSelector,\\n        function_vk_hash: Field,\\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\\n        contract_class_artifact_hash: Field,\\n        contract_class_public_bytecode_commitment: Field,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let private_functions_root = private_functions_root_from_siblings(\\n            function_selector,\\n            function_vk_hash,\\n            function_leaf_membership_witness.leaf_index,\\n            function_leaf_membership_witness.sibling_path,\\n        );\\n\\n        let contract_class_id = ContractClassId::compute(\\n            contract_class_artifact_hash,\\n            private_functions_root,\\n            contract_class_public_bytecode_commitment,\\n        );\\n\\n        // Compute contract address using the preimage which includes the class_id.\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --\x3e Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"243":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\\n    contract_class_id::ContractClassId,\\n    hash::poseidon2_hash_with_separator,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\\n\\n// Partial address\\npub struct PartialAddress {\\n    pub inner: Field,\\n}\\n\\nimpl ToField for PartialAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\\n        PartialAddress { inner: fields[0] }\\n    }\\n}\\n\\nimpl PartialAddress {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(\\n        contract_class_id: ContractClassId,\\n        salt: Field,\\n        initialization_hash: Field,\\n        deployer: AztecAddress,\\n    ) -> Self {\\n        PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\\n        )\\n    }\\n\\n    pub fn compute_from_salted_initialization_hash(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash,\\n    ) -> Self {\\n        PartialAddress::from_field(poseidon2_hash_with_separator(\\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\\n        ))\\n    }\\n\\n    pub fn to_field(self) -> Field {\\n        self.inner\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.to_field() == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"245":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\\n    hash::poseidon2_hash_with_separator, traits::ToField,\\n};\\n\\n// Salted initialization hash. Used in the computation of a partial address.\\npub struct SaltedInitializationHash {\\n    pub inner: Field,\\n}\\n\\nimpl ToField for SaltedInitializationHash {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl SaltedInitializationHash {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\\n            [salt, initialization_hash, deployer.to_field()],\\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\\n        ))\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"256":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"257":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        function_selector::FunctionSelector,\\n        log_hash::{LogHash, ScopedLogHash},\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, is_empty, ToField},\\n    utils::field::field_from_bytes_32_trunc,\\n};\\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; N * 32];\\n    for offset in 0..N {\\n        // TODO: This is not checking that the decomposition is smaller than P\\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"274":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"283":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\\n    address::public_keys_hash::PublicKeysHash,\\n    constants::{\\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\\n    },\\n    hash::poseidon2_hash_with_separator,\\n    point::POINT_LENGTH,\\n    traits::{Deserialize, Hash, Serialize},\\n};\\n\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\nuse std::default::Default;\\n\\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\\n\\npub struct PublicKeys {\\n    pub npk_m: NpkM,\\n    pub ivpk_m: IvpkM,\\n    pub ovpk_m: OvpkM,\\n    pub tpk_m: TpkM,\\n}\\n\\npub trait ToPoint {\\n    fn to_point(self) -> Point;\\n}\\n\\npub struct NpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for NpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for NpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\\nimpl Hash for NpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\npub struct IvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for IvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for IvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct OvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl Hash for OvpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\nimpl ToPoint for OvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for OvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct TpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for TpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for TpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\nimpl Default for PublicKeys {\\n    fn default() -> Self {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\\n            },\\n        }\\n    }\\n}\\n\\nimpl Eq for PublicKeys {\\n    fn eq(self, other: PublicKeys) -> bool {\\n        (self.npk_m.inner == other.npk_m.inner)\\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\\n            & (self.tpk_m.inner == other.tpk_m.inner)\\n    }\\n}\\n\\nimpl PublicKeys {\\n    pub fn hash(self) -> PublicKeysHash {\\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\\n            self.serialize(),\\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\\n        ))\\n    }\\n}\\n\\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\\n        [\\n            self.npk_m.inner.x,\\n            self.npk_m.inner.y,\\n            self.npk_m.inner.is_infinite as Field,\\n            self.ivpk_m.inner.x,\\n            self.ivpk_m.inner.y,\\n            self.ivpk_m.inner.is_infinite as Field,\\n            self.ovpk_m.inner.x,\\n            self.ovpk_m.inner.y,\\n            self.ovpk_m.inner.is_infinite as Field,\\n            self.tpk_m.inner.x,\\n            self.tpk_m.inner.y,\\n            self.tpk_m.inner.is_infinite as Field,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point {\\n                    x: serialized[0],\\n                    y: serialized[1],\\n                    is_infinite: serialized[2] as bool,\\n                },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point {\\n                    x: serialized[3],\\n                    y: serialized[4],\\n                    is_infinite: serialized[5] as bool,\\n                },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point {\\n                    x: serialized[6],\\n                    y: serialized[7],\\n                    is_infinite: serialized[8] as bool,\\n                },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point {\\n                    x: serialized[9],\\n                    y: serialized[10],\\n                    is_infinite: serialized[11] as bool,\\n                },\\n            },\\n        }\\n    }\\n}\\n\\npub struct AddressPoint {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for AddressPoint {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_public_keys_hash() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let actual = keys.hash();\\n    let expected_public_keys_hash =\\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\\n\\n    assert(actual.to_field() == expected_public_keys_hash);\\n}\\n\\n#[test]\\nunconstrained fn compute_default_hash() {\\n    let keys = PublicKeys::default();\\n\\n    let actual = keys.hash();\\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\\n\\n    assert(actual.to_field() == test_data_default_hash);\\n}\\n\\n#[test]\\nunconstrained fn test_public_keys_serialization() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let serialized = keys.serialize();\\n    let deserialized = PublicKeys::deserialize(serialized);\\n\\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\\n}\\n"},"323":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"340":{"path":"/build-volume/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/main.nr","source":"mod events;\\nmod capsule;\\n\\nuse dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract ContractClassRegisterer {\\n    use dep::aztec::protocol_types::{\\n        abis::log_hash::LogHash,\\n        constants::{\\n            ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, FUNCTION_TREE_HEIGHT,\\n            MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,\\n            MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS,\\n            MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\\n        },\\n        contract_class_id::ContractClassId,\\n    };\\n\\n    use dep::aztec::{\\n        context::PrivateContext, macros::functions::private,\\n        oracle::logs::emit_contract_class_unencrypted_log_private,\\n    };\\n\\n    use crate::events::{\\n        class_registered::ContractClassRegistered,\\n        private_function_broadcasted::{\\n            ClassPrivateFunctionBroadcasted, InnerPrivateFunction, PrivateFunction,\\n        },\\n        unconstrained_function_broadcasted::{\\n            ClassUnconstrainedFunctionBroadcasted, InnerUnconstrainedFunction,\\n            UnconstrainedFunction,\\n        },\\n    };\\n\\n    // docs:start:import_pop_capsule\\n    use crate::capsule::pop_capsule;\\n\\n    // docs:end:import_pop_capsule\\n\\n    #[private]\\n    fn register(\\n        artifact_hash: Field,\\n        private_functions_root: Field,\\n        public_bytecode_commitment: Field,\\n        emit: bool,\\n    ) {\\n        // TODO: Validate public_bytecode_commitment is the correct commitment of packed_public_bytecode\\n        // TODO: We should be able to remove public_bytecode_commitment from the input if it\'s calculated in this function\\n        // docs:start:pop_capsule\\n        let packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] =\\n            unsafe { pop_capsule() };\\n        // docs:end:pop_capsule\\n        // First field element contains the length of the bytecode\\n        let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\\n        let bytecode_length_in_fields: u32 =\\n            (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\\n        assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\\n\\n        // The first value in the running hash is the bytecode length in bytes\\n        let mut computed_public_bytecode_commitment = packed_public_bytecode[0];\\n        // We can hash up to MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS - 1, since the first element is the length\\n        for i in 0..(MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS - 1) {\\n            // While we are forced to run the hash MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS times in the circuit,\\n            // we want the bytecode commitment to be based on the actual length\\n            if (i < bytecode_length_in_fields) {\\n                // We skip the first element when hashing since it is the length\\n                computed_public_bytecode_commitment = std::hash::poseidon2::Poseidon2::hash(\\n                    [packed_public_bytecode[i + 1], computed_public_bytecode_commitment],\\n                    2,\\n                );\\n            } else {\\n                // Any bytes after the bytecode length must be 0\\n                assert_eq(packed_public_bytecode[i + 1], 0);\\n            }\\n        }\\n        assert_eq(computed_public_bytecode_commitment, public_bytecode_commitment);\\n\\n        // Compute contract class id from preimage\\n        let contract_class_id = ContractClassId::compute(\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment,\\n        );\\n\\n        // Emit the contract class id as a nullifier to be able to prove that this class has been (not) registered\\n        context.push_nullifier(contract_class_id.to_field());\\n\\n        // Broadcast class info including public bytecode\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ContractClassRegistered: {}\\",\\n            [\\n                contract_class_id.to_field(),\\n                artifact_hash,\\n                private_functions_root,\\n                public_bytecode_commitment,\\n            ],\\n        );\\n\\n        // TODO(#10007): Drop this conditional and always emit the bytecode. We allow skipping the broadcast\\n        // as a stopgap solution to allow txs to fit in Sepolia when we broadcast public bytecode.\\n        if emit {\\n            let event = ContractClassRegistered {\\n                contract_class_id,\\n                version: 1,\\n                artifact_hash,\\n                private_functions_root,\\n                packed_public_bytecode,\\n            };\\n            emit_contract_class_log(&mut context, event.serialize_non_standard());\\n        }\\n    }\\n\\n    #[private]\\n    fn broadcast_private_function(\\n        contract_class_id: ContractClassId,\\n        artifact_metadata_hash: Field,\\n        unconstrained_functions_artifact_tree_root: Field,\\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n        private_function_tree_leaf_index: Field,\\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\\n        artifact_function_tree_leaf_index: Field,\\n        function_data: InnerPrivateFunction,\\n    ) {\\n        let private_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS] =\\n            unsafe { pop_capsule() };\\n\\n        let event = ClassPrivateFunctionBroadcasted {\\n            contract_class_id,\\n            artifact_metadata_hash,\\n            unconstrained_functions_artifact_tree_root,\\n            private_function_tree_sibling_path,\\n            private_function_tree_leaf_index,\\n            artifact_function_tree_sibling_path,\\n            artifact_function_tree_leaf_index,\\n            function: PrivateFunction {\\n                selector: function_data.selector,\\n                metadata_hash: function_data.metadata_hash,\\n                vk_hash: function_data.vk_hash,\\n                bytecode: private_bytecode,\\n            },\\n        };\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ClassPrivateFunctionBroadcasted: {}\\",\\n            [\\n                contract_class_id.to_field(),\\n                artifact_metadata_hash,\\n                unconstrained_functions_artifact_tree_root,\\n                function_data.selector.to_field(),\\n                function_data.vk_hash,\\n                function_data.metadata_hash,\\n            ],\\n        );\\n        emit_contract_class_log(&mut context, event.serialize_non_standard());\\n    }\\n\\n    #[private]\\n    fn broadcast_unconstrained_function(\\n        contract_class_id: ContractClassId,\\n        artifact_metadata_hash: Field,\\n        private_functions_artifact_tree_root: Field,\\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\\n        artifact_function_tree_leaf_index: Field,\\n        function_data: InnerUnconstrainedFunction,\\n    ) {\\n        let unconstrained_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS] =\\n            unsafe { pop_capsule() };\\n        let event = ClassUnconstrainedFunctionBroadcasted {\\n            contract_class_id,\\n            artifact_metadata_hash,\\n            private_functions_artifact_tree_root,\\n            artifact_function_tree_sibling_path,\\n            artifact_function_tree_leaf_index,\\n            function: UnconstrainedFunction {\\n                selector: function_data.selector,\\n                metadata_hash: function_data.metadata_hash,\\n                bytecode: unconstrained_bytecode,\\n            },\\n        };\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ClassUnconstrainedFunctionBroadcasted: {}\\",\\n            [\\n                contract_class_id.to_field(),\\n                artifact_metadata_hash,\\n                private_functions_artifact_tree_root,\\n                function_data.selector.to_field(),\\n                function_data.metadata_hash,\\n            ],\\n        );\\n        emit_contract_class_log(&mut context, event.serialize_non_standard());\\n    }\\n\\n    #[contract_library_method]\\n    fn emit_contract_class_log<let N: u32>(context: &mut PrivateContext, log: [Field; N]) {\\n        let contract_address = context.this_address();\\n        let counter = context.next_counter();\\n\\n        // The log preimage is too large for the hash to compile (16,200 fields, 518,400 bytes), so we do this via a\\n        // specialized oracle.\\n        // A malicious oracle cannot force us to use an incorrect bytecode:\\n        // - Contract class -> we will commit to the packed bytecode (currently a TODO)\\n        // - Private function -> we provide a membership proof\\n        // - Unconstrained function -> we provide a membership proof\\n        // However, the sequencer will be required to know a contract\'s preimage if it is called and the sequencer\\n        // cannot prove non-registration. Therefore, it is possible that a malicious oracle might prevent sequencers\\n        // from including transactions with calls to certain badly-broadcasted contracts.\\n        // TODO(#8978): review correctness\\n        let log_hash =\\n            unsafe { emit_contract_class_unencrypted_log_private(contract_address, log, counter) };\\n\\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\\n        context.contract_class_logs_hashes.push(\\n            LogHash { value: log_hash, counter, length: 40 + (N as Field) * 32 },\\n        );\\n    }\\n\\n    #[private]\\n    fn assert_class_id_is_registered(contract_class_id: ContractClassId) {\\n        context.push_nullifier_read_request(contract_class_id.to_field());\\n    }\\n}\\n"}}}'));let py;class my extends sy{constructor(e,t,n){super(e,t,n)}}const gy="object"!=typeof process||["1","true","yes",""].includes({NODE_ENV:"production"}.AZTEC_EMIT_PUBLIC_BYTECODE??"");class _y extends Lb{constructor(e,t,n,s){super(e,t),this.postDeployCtor=n,this.instanceGetter=s,this.log=Pe("aztecjs:deploy_sent_tx")}async deployed(e){const t=await this.wait(e),n=await this.instanceGetter();return this.log.info(`Contract ${n.address.toString()} successfully deployed.`),t.contract}async wait(e){return{...await super.wait(e),contract:await this.getContractObject(e?.wallet)}}async getContractObject(e){const t=e??(!!this.pxe.createTxExecutionRequest&&this.pxe);if(!t)throw new Error("A wallet is required for creating a contract instance");const n=await this.instanceGetter();return this.postDeployCtor(n.address,t)}}class by extends Gb{constructor(e,t,n,s){super(e,t),this.postDeployCtor=n,this.instanceGetter=s}send(){const e=(()=>this.wallet.sendTx(this.getPlainDataTx()))();return new _y(this.wallet,e,this.postDeployCtor,this.instanceGetter)}}class yy extends Zb{constructor(e,t,n,s,i=[],r){super(t),this.publicKeys=e,this.artifact=n,this.postDeployCtor=s,this.args=i,this.instance=void 0,this.constructorArtifact=function(e,t){if("string"==typeof t){const n=e.functions.find((e=>e.name===t));if(!n)throw new Error(`Constructor method ${t} not found in contract artifact`);if(!n.isInitializer)throw new Error(`Method ${t} is not an initializer`);return n}if(void 0===t)return wd(e);if(!t.isInitializer)throw new Error(`Method ${t.name} is not an initializer`);return t}(n,r)}async create(e={}){return this.wallet.createTxExecutionRequest(await this.request(e))}async request(e={}){const t=await this.getDeploymentFunctionCalls(e);await this.wallet.registerContract({artifact:this.artifact,instance:await this.getInstance(e)});const n=await this.getInitializeFunctionCalls(e);if(t.calls.length+n.calls.length===0)throw new Error(`No function calls needed to deploy contract ${this.artifact.name}`);const s=[...t.calls,...n.calls],i=[...t.authWitnesses??[],...n.authWitnesses??[]],r=[...t.hashedArguments??[],...n.hashedArguments??[]],{cancellable:a,nonce:o,fee:l}=e,c={calls:s,authWitnesses:i,hashedArguments:r,cancellable:a,fee:l,nonce:o},d=await this.getFeeOptions(c);return{...c,fee:d}}async register(e={}){const t=await this.getInstance(e);return await this.wallet.registerContract({artifact:this.artifact,instance:t}),this.postDeployCtor(t.address,this.wallet)}async getDeploymentFunctionCalls(e={}){const t=[],n=await this.getInstance(e),s=await au(this.artifact);if(!n.contractClassId.equals(s.id))throw new Error(`Contract class mismatch when deploying contract: got ${n.contractClassId.toString()} from instance and ${s.id.toString()} from artifact`);if(!e.skipClassRegistration)if((await this.wallet.getContractClassMetadata(s.id)).isContractClassPubliclyRegistered)this.log.debug(`Skipping registration of already registered contract class ${s.id.toString()} for ${n.address.toString()}`);else{this.log.info(`Creating request for registering contract class ${s.id.toString()} as part of deployment for ${n.address.toString()}`);const e=await async function(e,t,n=gy){const{artifactHash:s,privateFunctionsRoot:i,publicBytecodeCommitment:r,packedBytecode:a}=await au(t),o=Ed(a,Qi),l=await async function(e){const{artifact:t,instance:n}=await async function(){if(!fy){const e=uy;fy=await dy("ContractClassRegisterer",e)}return fy}();return new my(n,t,e)}(e);return await e.addCapsule(o),l.methods.register(s,i,r,n)}(this.wallet,this.artifact);t.push(await e.request())}if(!e.skipPublicDeployment){const e=await async function(e,t){const n=await async function(e){const{artifact:t,instance:n}=await async function(){return py||(py=await dy("ContractInstanceDeployer",hy)),py}();return new my(n,t,e)}(e),{salt:s,contractClassId:i,publicKeys:r,deployer:a}=t,o=a.isZero();if(!o&&!e.getAddress().equals(a))throw new Error(`Expected deployer ${a.toString()} does not match sender wallet ${e.getAddress().toString()}`);return n.methods.deploy(s,i,t.initializationHash,r,o)}(this.wallet,n);t.push(await e.request())}return{calls:t}}async getInitializeFunctionCalls(e){const{address:t}=await this.getInstance(e),n=[];if(this.constructorArtifact&&!e.skipInitialization){const e=new Jb(this.wallet,t,this.constructorArtifact,this.args);n.push(await e.request())}return{calls:n}}send(e={}){const t=super.send(e).getTxHash();return this.log.debug(`Sent deployment tx of ${this.artifact.name} contract`),new _y(this.wallet,t,this.postDeployCtor,(()=>this.getInstance(e)))}async getInstance(e={}){return this.instance||(this.instance=await cu(this.artifact,{constructorArgs:this.args,salt:e.contractAddressSalt,publicKeys:this.publicKeys,constructorArtifact:this.constructorArtifact,deployer:e.universalDeploy?Gc.ZERO:this.wallet.getAddress()})),this.instance}async prove(e){const t=await this.proveInternal(e);return new by(this.wallet,t.toTx(),this.postDeployCtor,(()=>this.getInstance(e)))}estimateGas(e){return super.estimateGas(e)}get address(){return this.instance?.address}get partialAddress(){return this.instance&&qd(this.instance)}}class Ay extends sy{static async at(e,t,n){const s=(await n.getContractMetadata(e)).contractInstance;if(void 0===s)throw new Error(`Contract instance at ${e.toString()} has not been registered in the wallet's PXE`);return new Ay(s,t,n)}static deploy(e,t,n,s){return new yy(Rd.default(),e,t,((e,n)=>Ay.at(e,t,n)),n,s)}static deployWithPublicKeys(e,t,n,s,i){return new yy(e,t,n,((e,t)=>Ay.at(e,n,t)),s,i)}}var wy,xy;class vy extends yy{constructor(e,t,n,s,i=[],r,a){super(t,n,s,((e,t)=>Ay.at(e,s,t)),i,r),wy.set(this,void 0),xy.set(this,void 0),Us(this,wy,e,"f"),Us(this,xy,"string"==typeof a?function(e,t){const n=e.functions.find((e=>e.name===t));if(!n)throw new Error(`Unknown function ${t}`);const s=function(e,t){try{if(t.debugSymbols&&e.fileMap)return{debugSymbols:JSON.parse(el(ad.from(t.debugSymbols,"base64"),{to:"string",raw:!0})).debug_infos[0],files:e.fileMap}}catch(n){if(!(n instanceof RangeError&&n.message.includes("Invalid string length")))throw n;od.warn(`Caught RangeError: Invalid string length. This suggests the debug_symbols field of the contract ${e.name} and function ${t.name} is huge; too big to parse. We'll skip returning this info until this issue is resolved. Here's the error:\n${n.message}`)}}(e,n);return{...n,debug:s}}(s,a):a,"f")}async getInitializeFunctionCalls(e){const t=await super.getInitializeFunctionCalls(e);if(e.fee&&Hs(this,xy,"f")){const{address:n}=await this.getInstance(),s=await Sb.fromAppExecution([]),i=await this.getDefaultFeeOptions(e.fee),r=await Sb.fromFeeOptions(n,i);t.calls.push({name:Hs(this,xy,"f").name,to:n,args:Bd(Hs(this,xy,"f"),[s,r,!1]),selector:await ed.fromNameAndParameters(Hs(this,xy,"f").name,Hs(this,xy,"f").parameters),type:Hs(this,xy,"f").functionType,isStatic:Hs(this,xy,"f").isStatic,returnTypes:Hs(this,xy,"f").returnTypes}),t.authWitnesses??(t.authWitnesses=[]),t.hashedArguments??(t.hashedArguments=[]),t.authWitnesses.push(await Hs(this,wy,"f").createAuthWit(await Ib(s,r))),t.hashedArguments.push(...s.hashedArguments),t.hashedArguments.push(...r.hashedArguments)}return t}}wy=new WeakMap,xy=new WeakMap;class Ey extends Lb{constructor(e,t,n){super(e,t),this.getWalletPromise=n}async getWallet(e){return(await this.wait(e)).wallet}async wait(e=Db){return{...await super.wait(e),wallet:await this.getWalletPromise}}}class My{constructor(e,t,n,s,i){this.pxe=e,this.secretKey=t,this.accountContract=n,this.instance=s,this.salt=i}static async create(e,t,n,s){const{publicKeys:i}=await Wd(t);s=void 0!==s?new si(s):si.random();const r=await cu(n.getContractArtifact(),{constructorArgs:await n.getDeploymentArgs(),salt:s,publicKeys:i});return new My(e,t,n,r,s)}getPublicKeys(){return this.instance.publicKeys}getPublicKeysHash(){return this.getPublicKeys().hash()}async getAccount(){const e=await this.pxe.getNodeInfo(),t=await this.getCompleteAddress();return this.accountContract.getInterface(t,e)}getCompleteAddress(){return Zh.fromSecretKeyAndInstance(this.secretKey,this.instance)}getAddress(){return this.instance.address}getInstance(){return this.instance}async getWallet(){const e=await this.getAccount();return new ty(this.pxe,e,this.secretKey,this.salt)}async register(){return await this.pxe.registerContract({artifact:this.accountContract.getContractArtifact(),instance:this.getInstance()}),await this.pxe.registerAccount(this.secretKey,(await this.getCompleteAddress()).partialAddress),this.getWallet()}async getDeployMethod(){if(!await this.isDeployable())throw new Error(`Account contract ${this.accountContract.getContractArtifact().name} does not require deployment.`);const e=await this.getCompleteAddress();await this.pxe.registerAccount(this.secretKey,e.partialAddress);const{l1ChainId:t,protocolVersion:n}=await this.pxe.getNodeInfo(),s=new ny(this.pxe,new Hb(t,n)),i=await this.accountContract.getDeploymentArgs()??[];return new vy(this.accountContract.getAuthWitnessProvider(e),this.getPublicKeys(),s,this.accountContract.getContractArtifact(),i,"constructor","entrypoint")}deploy(e){const t=this.getDeployMethod().then((t=>t.send({contractAddressSalt:new si(this.salt),skipClassRegistration:e?.skipClassRegistration??!0,skipPublicDeployment:e?.skipPublicDeployment??!0,skipInitialization:e?.skipInitialization??!1,universalDeploy:!0,fee:e?.fee}))).then((e=>e.getTxHash()));return new Ey(this.pxe,t,this.getWallet())}async waitSetup(e=Db){return await(await this.isDeployable()?this.deploy().wait(e):this.register()),this.getWallet()}async isDeployable(){return void 0!==await this.accountContract.getDeploymentArgs()}}class zy{constructor(e,t,n=31337,s=1){this.address=e,this.auth=t,this.chainId=n,this.version=s}async createTxExecutionRequest(e){const{calls:t,fee:n,nonce:s,cancellable:i}=e,r=await Sb.fromAppExecution(t,s),a=await Sb.fromFeeOptions(this.address,n),o=this.getEntrypointAbi(),l=await rb.fromValues(Bd(o,[r,a,!!i])),c=await this.auth.createAuthWit(await Ib(r,a));return ab.from({firstCallArgsHash:l.hash,origin:this.address,functionSelector:await ed.fromNameAndParameters(o.name,o.parameters),txContext:new $h(this.chainId,this.version,n.gasSettings),argsOfCalls:[...r.hashedArguments,...a.hashedArguments,l],authWitnesses:[c]})}getEntrypointAbi(){return{name:"entrypoint",isInitializer:!1,functionType:"private",isInternal:!1,isStatic:!1,parameters:[{name:"app_payload",type:{kind:"struct",path:"authwit::entrypoint::app::AppPayload",fields:[{name:"function_calls",type:{kind:"array",length:4,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}}]},visibility:"public"},{name:"fee_payload",type:{kind:"struct",path:"authwit::entrypoint::fee::FeePayload",fields:[{name:"function_calls",type:{kind:"array",length:2,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}},{name:"is_fee_payer",type:{kind:"boolean"}}]},visibility:"public"},{name:"cancellable",type:{kind:"boolean"}}],returnTypes:[],errorTypes:{}}}}class By{constructor(e,t,n){this.authWitnessProvider=e,this.address=t,this.entrypoint=new zy(t.address,e,n.l1ChainId,n.protocolVersion),this.chainId=new si(n.l1ChainId),this.version=new si(n.protocolVersion)}createTxExecutionRequest(e){return this.entrypoint.createTxExecutionRequest(e)}createAuthWit(e){return this.authWitnessProvider.createAuthWit(e)}getCompleteAddress(){return this.address}getAddress(){return this.address.address}getChainId(){return this.chainId}getVersion(){return this.version}}class Fy{constructor(e){this.artifact=e}getContractArtifact(){return this.artifact}getInterface(e,t){return new By(this.getAuthWitnessProvider(e),e,t)}}function ky(e){const t=new Hd;return t.mul(t.generator(),e)}i(8891).Buffer,i(3686),i(6420),i(643),i(4112),i(663),i(113),Error;var Cy=i(9302);Cy.C,i(3588),i(2610),i(3856),i(9042),i(6027),i(2373),i(3329);var Oy=i(6809);class Dy extends Cy.C{constructor(e,{code:t,docsPath:n,metaMessages:s,name:i,shortMessage:r}){super(r,{cause:e,docsPath:n,metaMessages:s||e?.metaMessages,name:i||"RpcError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=i||e.name,this.code=e instanceof Oy.J8?e.code:t??-1}}class Ly extends Dy{constructor(e,t){super(e,t),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=t.data}}class Ty extends Dy{constructor(e){super(e,{code:Ty.code,name:"ParseRpcError",shortMessage:"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."})}}Object.defineProperty(Ty,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32700});class Sy extends Dy{constructor(e){super(e,{code:Sy.code,name:"InvalidRequestRpcError",shortMessage:"JSON is not a valid request object."})}}Object.defineProperty(Sy,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32600});class Ny extends Dy{constructor(e,{method:t}={}){super(e,{code:Ny.code,name:"MethodNotFoundRpcError",shortMessage:`The method${t?` "${t}"`:""} does not exist / is not available.`})}}Object.defineProperty(Ny,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32601});class Py extends Dy{constructor(e){super(e,{code:Py.code,name:"InvalidParamsRpcError",shortMessage:["Invalid parameters were provided to the RPC method.","Double check you have provided the correct parameters."].join("\n")})}}Object.defineProperty(Py,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32602});class Iy extends Dy{constructor(e){super(e,{code:Iy.code,name:"InternalRpcError",shortMessage:"An internal error was received."})}}Object.defineProperty(Iy,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32603});class Yy extends Dy{constructor(e){super(e,{code:Yy.code,name:"InvalidInputRpcError",shortMessage:["Missing or invalid parameters.","Double check you have provided the correct parameters."].join("\n")})}}Object.defineProperty(Yy,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32e3});class Qy extends Dy{constructor(e){super(e,{code:Qy.code,name:"ResourceNotFoundRpcError",shortMessage:"Requested resource not found."}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ResourceNotFoundRpcError"})}}Object.defineProperty(Qy,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32001});class jy extends Dy{constructor(e){super(e,{code:jy.code,name:"ResourceUnavailableRpcError",shortMessage:"Requested resource not available."})}}Object.defineProperty(jy,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32002});class Hy extends Dy{constructor(e){super(e,{code:Hy.code,name:"TransactionRejectedRpcError",shortMessage:"Transaction creation failed."})}}Object.defineProperty(Hy,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32003});class Uy extends Dy{constructor(e,{method:t}={}){super(e,{code:Uy.code,name:"MethodNotSupportedRpcError",shortMessage:`Method${t?` "${t}"`:""} is not implemented.`})}}Object.defineProperty(Uy,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32004});class Ry extends Dy{constructor(e){super(e,{code:Ry.code,name:"LimitExceededRpcError",shortMessage:"Request exceeds defined limit."})}}Object.defineProperty(Ry,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32005});class Gy extends Dy{constructor(e){super(e,{code:Gy.code,name:"JsonRpcVersionUnsupportedError",shortMessage:"Version of JSON-RPC protocol is not supported."})}}Object.defineProperty(Gy,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32006});class Zy extends Ly{constructor(e){super(e,{code:Zy.code,name:"UserRejectedRequestError",shortMessage:"User rejected the request."})}}Object.defineProperty(Zy,"code",{enumerable:!0,configurable:!0,writable:!0,value:4001});class Jy extends Ly{constructor(e){super(e,{code:Jy.code,name:"UnauthorizedProviderError",shortMessage:"The requested method and/or account has not been authorized by the user."})}}Object.defineProperty(Jy,"code",{enumerable:!0,configurable:!0,writable:!0,value:4100});class Xy extends Ly{constructor(e,{method:t}={}){super(e,{code:Xy.code,name:"UnsupportedProviderMethodError",shortMessage:`The Provider does not support the requested method${t?` " ${t}"`:""}.`})}}Object.defineProperty(Xy,"code",{enumerable:!0,configurable:!0,writable:!0,value:4200});class Wy extends Ly{constructor(e){super(e,{code:Wy.code,name:"ProviderDisconnectedError",shortMessage:"The Provider is disconnected from all chains."})}}Object.defineProperty(Wy,"code",{enumerable:!0,configurable:!0,writable:!0,value:4900});class Vy extends Ly{constructor(e){super(e,{code:Vy.code,name:"ChainDisconnectedError",shortMessage:"The Provider is not connected to the requested chain."})}}Object.defineProperty(Vy,"code",{enumerable:!0,configurable:!0,writable:!0,value:4901});class qy extends Ly{constructor(e){super(e,{code:qy.code,name:"SwitchChainError",shortMessage:"An error occurred when attempting to switch chain."})}}Object.defineProperty(qy,"code",{enumerable:!0,configurable:!0,writable:!0,value:4902}),i(3887),i(2768),i(5261),i(7673),i(9804),i(3538),i(1892),i(7740),Cy.C,i(7426),i(3594),i(5979),i(2545),i(6409),i(7338),Cy.C,Cy.C,Cy.C,Cy.C,i(8113),i(4611).Vw,Cy.C,Cy.C,Cy.C,Cy.C,i(6907),i(8902),i(2894),i(1501),Cy.C,Cy.C,i(1893),new(i(645).A)(128),i(5561),i(8891).Buffer,i(9813),ry(JSON.parse('{"transpiled":true,"noir_version":"1.0.0-beta.1+c4e38215cedb5afb","name":"FeeJuice","functions":[{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"log_plaintext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/92c927bMBDG5URKIieOndG9927leHeme+/W/dsdfosWAtqHSPu09Zfw7DPDAilCovkqQJCto+9+PFHUiTy6EG1s3cFeMJ9jc5w2R5xfjMY3Kbtqjtn2tqpHXVkoxgIB4wQB4yQBY0zAmBAwThEwThMwzhAwpgSMRQLGWQLGOQLGEgHjPAFjmYCxQsC4EIAxBOciCeeSR04d24fiXY52fhvdRcC4m4BxDwHjXgLGfQSM+wkYDxAwHiRgPETAeJiA8QgB41ECxmMEjMcJGE8QMJ4kYDxFwHiagPEMAeNZAsZzBIznCRgvEDBeJGC8RMB4mYDxCgFjRsBYJWBcIWCsETDWCRgbBIxNAsYWAWObgLFDwHiVgPEaAeN1AsYbBIw3CRhvETCuEjDeJmC8Q8B4l4DxHgHjfQLGBwSMDwkYHxEwPiZgfELA+JSA8RkB43MCxhcEjC8JGF8RML4mYHxDwPg2AGMIzncknO9JOLuBOKMPFvTEYMfCLSyMwsIjLOzBwhksTMHCDyyswMIFLAxA4j0S25E4XhnsSHxGUjESdpEEiyRTJHEiSRJJiEjyQxIdktSQBIYkKyQxIUno6GA/NtiRRIIkDSRBIMkAk/iYJMckNCZ5MYmKSUpMAmKSDZNYmCRCrTDJgUkEDNJjEByDzBjExSApBiExyIdBNAxSYRAIgywYxJBBArzk4iUSL2l4CcJLBoJ4BMkIQhHkIYhCkIIgAA9ZPMTwkEAnjE4OnQhuUtwAaFzd6M+bNJIf5pia44SSe1xEV00tuz71t7POx9RRP4/8tdTonAmiv9ES/WkY/kwW2t7LR/p1XcTupDl285Evu/k4k5RZU2XWrDJSnzDXu14P66/qSsnyUaTqIraLYWzXCpY9fV20TOwXo5Btc2NRsrYnPLZ/pO8oSZl8xFOwZHG+uR4iS5RMri/snFfl7LY1Y8mEBZu035LyjWwfjEyuaax0+muvjXbY9lrP/l17rVf/x/YaW7I431yPv22vum3Z7TWJRpv0pSKbUrKflmxayX7lI9sNxdE0n8P2yRvPYH3v+X6GLTn4tS1s0/nIH9IGJ9W5RPlv3T+6vCVLlSzOx+0UzfdY2dG6hCOxytfN97I5TqnfyO8rDvtTlv0xbsc52y+po3zqKI+2dsl8njU72tA3+U20+d7Fvmq+Z9vamh1XP+lPf6vm6gs98n8R/bNB9NeH+ufC8A/jqlIY/w/1z4fh74v+chj9TdFfCaO/IfoXguhfGcYJ+s927DhhSZ33GNduOU4Q+0WLNVScsGTx2P7RcQJkyw7WikNm9wHLDjvLDjsuXfMedS141FXcoXUsedRV8agr9ajL53Wc86jLp7/KHnXNeNTls9379Jdcx7DjVVnmitOiAPqLYfQP+37po/W7ma6T2E+s8l8tP88F8fNoHEr6M+0LVyzl0/ZWn9div+TgEe6iQ7adP0D70mj3O+1GZxDSV5srnaxg6RdW+5x+L9L9iy7veva74j6Pvs5cYxBl5VdssZLNW7JEyYRRj0G44mKf/Fvxv7Zfccjs/nmr13IxGm9r+n6cjUb3c5z7r3urvfHHLuuMRn8SjY8xRpb9xCr/3Xy3+7rt3iP9Vq/ar/X6vUbv8+f6p96ipV/7EH76DXVGL3ipUwAA","debug_symbols":"tZbLCoMwEEX/ZdZZOGPV1l8ppUSNJRCiRC0U8d8bpQ9p13cTmDA5kyxOuDM1pppuV+vbbqDyPJPraj3azsdqXhRVwTpnb9f9NiXrwolsB4Ze+7UeRh1GKg+iyPiGyiyJx1vrDJV5uqi/xuLdWBSfxkyWi4rkFEY+wMgZjJzDyAWMfISRTygyJzAyw8gwBxnmIMMcZJiDDHOQYQ4yzEGGOSgwBwXmoMAcFJiDgnFwidVdB6srZ14Bop18vcsT46M3P9GiD11tmimYNWR888X69nihTLZfPxYsueKU45A46Ak=","brillig_names":["process_log"]},{"name":"initialize","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"initial_mint","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VjtbuIwEHyX/M4P75e921c5nSra0goJQUXpSaeq7342VzulJCAM1xZd/iAcZtjJZLPj5KW5m948P1zPFvfLp+bqx0szX95O1rPlIq5eGqDNsafHySItn9aT1bq5Au+xbaaLu/Q14Gvb3M/m0+bK02u7A0b04Q2MqFbA5vvAxvoGJoewHwyeTIsOhg4eS/bipYOH0KGV+9DkKaMZ3Bb6Z9sAj84MOCOjMwPO+G/tDJN0zrAdcAYBfVYCLCc6E0ZnBpzRk51hZxnMgFrA6jYF7B8XQNdbAIxzAfSyv4BaKWAOOjWBLnoeIHxrZ76w6xFHZwacoZOdMYedMyL7naEyVRm4QIF0I4bPIMZnLw2c7hcDJmT5r03Evx81fZEQm6Bkgu1OJrls+f5z5aMDLY3syOCjnv4Qj2eR9RDQoZtWS2sChv3+qMtqlN/Pbb8R05+bhOXOJT4Qa8beZTHCBy5WDMysBgLJuzvlr5z+lGVX5LDofznQyI3ODDgDozMDzuDJzpwvBInOIObrUoT4suXL58rfH4JxcbOazeezh+ut92gufXCvVIHc6SL4sbfYH08Jx1P0eIodSYkrSMj+/auUMRXEtrMzrjAhQy/RtDyOObezCQhcwZEKjq/ghAqOVnDseI66Cg5UcLCCU9EHWtEHWtEHWtEHWtEHWtEHWtEHVtEH1t8H3e7YOd7hYAWHKjhcwZEKjq/ghGM5cUUJOvBaWbk8B8Ydzs5Q5TGS4vLXZDWb3MynKaXTr8+L2xzacbn+/Zh/ybH+uFreTu+eV9MU8F22p2YkaBmiEEh3jUArvqTe5lDcABOUPEsMsdZbZsRtDjjurmo6Btoilas1VOQ1nssf","brillig_names":["store_in_execution_cache_oracle_wrapper","enqueue_public_function_call_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","store_in_execution_cache_oracle_wrapper"],"verification_key":"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"},{"name":"set_portal","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JgACBAEnAAABBIBFJgAABAMmAgIEASYCAwQAHxgAAwACgEQtCIBEAAEkAAAARSQAAABGJwIAAQSARSYCAgQAOg0AAQACJSQAAADiJgICAAIuDAACAAMcDAMEACsCAAUAAAAAAAAAAAAAAAAA//////////////////////////8OOAQFBiMCAAYAAACSJAAAAQsmAgQAAAo4AwQFIwIABQAAAK0mAgYEADsJAQYoAgADADuaygIuDAADAAUKOAUEBiMCAAYAAADOJAAAAR0nAgAEAN6tLwwABAADLwwAAQACJScAgAQEeAANAAAAgASAAyMAgAMAAAEKKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQVaAuQbtR6pnzsBAQIlKQEAAQUfCi0n3IKHojsBAQIlLQAYyhjK","debug_symbols":"7VfbioMwEP2XPPuQmdwm/ZVlKba1RRAt1i4spf++yVITtysVdLsU9EWMnJkz5zgxzoXtss35sM7LfXViq7cLK6pt2uRV6VaXa8I2dV4U+WHdfcy4vxj1jT8d09IvT01aN2wFxqiEZeXO3RJHl2GfFxlbaXFNfoERBb+BEZUKYNDYgzaCxA1tJJcBTdAHBsIWjAiPwQBctKndvdZd+HvCiM9Hqv53qSZKBfu4ehvL4JwHLKpeX9C2iTUOYAFkdEXTAFqFkpWNFbvinYEWFgMnGQhIi4PTHBRicXCag3LZxVMdHD5IQHYd9EEKxgSNYdJyTJAdEWT6NyNhDFL0uJVAh1YC/cI/Dy7XjLTSH2i1gcJw+qHVU1jxbArk8HwKPZ2CDASwNUNNQUK377mbur8ptIjfR8uHmgIkhqYAEndNgSBmpNVO12pD9WA7p9Nrab261Uda5+mmyG5j8f5cbjtTcvN5zO4G5mNdbbPduc786BynZvCjpFCJ5H6D+80nIZHCcTieLw==","brillig_names":["set_portal"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"10502589790419500451":{"error_kind":"string","string":"Function _increase_public_balance can only be called internally"},"15238796416211288225":{"error_kind":"string","string":"Balance too low"},"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"3219842053230618354":{"error_kind":"string","string":"Function check_balance can only be called statically"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6067862452620309358":{"error_kind":"string","string":"Function balance_of_public can only be called statically"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7V3bjtw4Dv2Xfs6DSIkiNb+yWARJJjNooJEMkswCi0H+fV1VbVd1S22BtlnRWn4JutPi4eERdbEsyf88/P75499/vn/88sfX7w+//eufh6evnz78ePz6Zfjtn5/vHj5+e3x6evzz/e1/P7jTP+D82eD7Xx++nH7//uPDtx8PvwV89/D5y+8Pv5EbzP94fPr88Fv0P//97gEAtQasNECtB9R68FoPPioNAmgNtB5I64FIaRCd1iBoDZLSgLUeWJQGomwPCBpZ32UFwSH557LDzylMxQUu+MkWH4MxvjF/b8zfG/MPys4LtQ0fSdm1oLbho7bho7bhI2ubJWtlFdQaxFWJIZCeS4q/JoX3F/AEluBkCZ7swL1qtqIGF0NwsGSummJpwXFlKjqewDkHj4bg3lmCB0vwZAgeLJkHMQQnXDcWM9M4FIvD+cKI3j0XRiSaCkPEQmn2Mo7yHNyLQb5QGGSkzIgwXxiGR7RpAgEuxlcTCE98iJKJEv1ORIlhLAzssij3UvWzUfJeWv18lF3UpXRRl9JFXa58Rvl/iZLajZKvUUKajzJdaTh35TysJpyiDM51EWXoIkrpIUpoeIa3YZRd1CU2PCvYMMq4XZQQfr5cjgweTNGTJXoIpugr25DgFZ2kUjhO2QWx4QfksHbVYJeirF010ImSJi7s5IUoZy7SDheO7XARuCMXYZgKJ64lrvg45uItdDlxox8X3TkmV0tcmAIcfhb/OnFFDlEyUVK4oyhpChNSxGZFIad8t0uqZ6azgfLdLq2dyTuKU0I6kte9Oq2dQ9fw185eq/hsi++N+Qflu3si5at4SitXLyp7NGhtT1LFt91jEl0wxjfmD8b8tTsOIyq31EQPWgPSGii73ah66DobKPfSRbLa85CXjTA+YUQfX5Q9E5FGiMRWFIncCJGVL/c2JNKKIgKtEImNEEmtKGK2cS4vS0lGIo5zIqkNIrxyZrEhkVYUgVYUgVYUQd8KEW6EiMdWiNyxi6dxyWMY8zMiwbVCxHBDKhNYgpMluOGGVI7BEtySOXtLcDYEX7uMHuO0zHjbjOIzOlmir13uqaAHU3QxRJeV5yNq6GyJDmCKHi3R0ZQ7mrWmvHCIOC7mDj9WNjwMHQtOfYzwbeETb+/uyDuEsbsLgWKNt6OJ98u3xmfelr2XBGeKbtq/rFzRQw7jbBQ5coYulugRTdGjJTo7U/Rgim5aq2Jaq2JaqyvXtWroltyTc6bowRTdMiMToCn6hrXK8TU6gik6maInS3TvTdHZEj2Y1mowzUgy5U6mGUmmGRk3zEipzK4J07jARh6um4qiu1CRO1LxfsL1AV9TYd8OlbuqwmGiIhkVuasq05Z58gleU9ly0lOlEmDCDRgzKvEXUblZo75QAefuKsu0HYZCLHCJ7XCBu+qSxre/RDcHOCYusR0uK69t2pbLynFO3HQiR27O2FzGOXArb9qowospfEBb+GgKT84W3rZqybZqo23VrtyjVYNnW/Zsm5him5him5him5hpw6rFNF8YPE57a324FoZiaZbreUp5eTqhAE1hOjdGdC18fgLJWQ89+cja3ZZ2qfS+IE0xhgT0ekwD5w4JaxJKmpeQ2pXwV52/Gf5v5avCymmLAT8aO0Bn7YCMHXjrCNTX/wJpL9uFtQdEK4ciANbeu1R3wMYOxDoCsY4gGUeA2vOAg0VQW2iveUbwagv9LePqa8a1p34AfSM71wcmjWzmBwzNaBKoFSbkmmHSjiaN7F8HjI1sYB+YSCtMuBlNuBlNpBlNpJGTDoB3PLtVYxIbYeJdI4cdBiahGSaG90bD6tvXK+hsiW55/zqYXsAO3pty92SKnizRg+VO/QGeTeHXXsReg4+m8NHZwpMtfDKFZ9vEZDGFF1v2YtasCgNmmnqQmLCyzp/chJyc0M9Xyzw+2TbYZNrdBGfaogKsfNeTaCyKiSuFNzxfMxBf+YYl+StxgkwXdLbwwRZeTOFXnuGuwkdT+GBbtcG2aoNt1a495VSDt2UfbRMz2iYm2yYm2yYmb1i1LBm8eFt4NoVfu/O3Bk+28MkSnpy3hTdNzLVXeFbhTROTEGzhN0zM5OcLM8fxpQozZ9upybuGuDSkS7irLgITlxRzLtQOF2pIF7qrLpSu+ZIyLtE1xCU0xEXa4cLYEBduh4s0pIvEdrike7ZpwXFxjyVAzoWa4RJdO7pEd1ddpjNSLNFnXMA1xKUhXfC++XLdyR1izoUa4pLa4eJ9Q1y4HS4BG+LSkC4EDXG5a5vmac6Q4MV4lBf2ftr34wPeHIi58E5mGl7goyU8O7CFT6bwq78gUTnxsfa25boD9NYOxNiBt45A+0ULYNKeM2Bee3yrciBjeEgxdiDO2oF1BMk6gmQcge6e1ouF9nyLAKottOdbBJ3agtQW2tND4tXqetFaBKsr3C/obIlOYIpOpujJEn3tTeQVdFPuZicyLuhWe5wL3SeHkcowQl/fpyFdHgDW3vm5LZeGdEmWt1AP8Ka78NbeKFqFD7bwpvtaE3hbeNP9m8n0evQB3nS7ePK27O1uG88Lb7mnOAXbBhtsuxuybVErN/l5mPYU+2FxIYNfeSS1Cs+m8CsfoqvwZAufTOHFtmrFtmqTbdWuXOSch8e1t3BW4ckWPpnCg7eFZ1N43LBqxefw0RR+5b69KnywhRdT+JVrMVV426ol28QkW/bRNjGjbWJG5bofOvZqC7UPUfsQ1lokVFtofQxL32qLqLUAUFuQ1kK7yo2Aeh9Ja6Fd5R4stJkIYe31Y/Ov7AYHbOyAwNpBNHYQrSNgdTNldVcgah/qLg3UXRqouzRUd2no1D5A7QPUPlDtA9U+vNqH13b/qL1oc7BQ+yC1D1L7iE5tEdQW2iEG1ZMdVE92UN0zoLpn0F1CdbHQ1qDXXqQ5WJDaQluDHoLaQluDHr3aQluDXt2XeHVf4tV9iQ/qGiR1lpC6BkmdJVFdg+oHJ6+eZXj1LMOLugZFnSVJXYNJnSUrzxpPl4bw9ZUy4Rk6uGAHbcd65drgHDSiHXQ0g175TnIW2o71yjeGc9ArX+fNQosZdLRjHe1Ys10fInYZInZ5nexaYzJjTQ7soMkMGswyhMorLSQT9s0K8vPGuMGIlhgVh8rZC7GRys2uZrTEU/kJq2JUXn6pGS3wFB0uMSo2pNmbevGNI541I1pghEs84RJPfomn8gvCmlFxCJq9CHhY1vBLjJZ4oiWeyn1EzSguMCrfhFUxKn+3jKe3YByvb8aHvvTZKC0wSks8pQWeuHxYgvH6VSZ8YVRYA4cwnceAKJXSdP1+bbr5klR6ZiMtsSmvQPwqNuXVjV/GpqmaKs8RURw9G6HAzb774eeLWVxiJg6WmS3zVh4mX5ghFMxokRm+4W36AhyKx4IZLTLzy7z5hd5S3SzlZuWTj1Wz8km94S38NetvPvYORKU2IuOABOmmhaT47CKZuyiPRNu6MI/ijfMJ27qwj6K8R3BbF2zuorwmuK2LuIGLaS44vJd+4aJw0ChMlypIuLkAb5hnlvZNTcgB3U3Z0sl7SGFkMby6ni9MEwlCvi161qS8qNm5JnRo8lqT8jJy55oceZJpQkee5JoceZJrkg5NXmsS/aFJpokcmrzWhPHQJNOED01eayJ9zu2nW8fpdmV71KTPsXhWk9TnnG1ek9ClJlPZ+LLooIl30Gfbmdekz3nsrCZ4tJ1ckyNPMk38kSe5JkeeZJqEPp+L5zXp83lnVhPq87l4XpM+33nNahL7fC6e1+SY22eacJ/PxfOahP1rcgm0g4Xnc6DSwezqEmgHU6ZzoKmD8e0SaAeTm1Og4DoYiS6BdjK8gOvgOf8cKHQyvAB0MrwAdvCYfQm0l+HF9zK89LCz8xxoD9s1L4GGXgLt5HkUqJcJA/VSo/vZh4T+GmigLNC0m0k9T18mQvZ+ceGTKuh206A1qkC8xhcFclV20/q3VAV2M+XeUhXcTQe6qSq7mcyrVGEegU8fzcxU2c+z3KaqhEOVgip9jkEVVcJu1rc2VaXPkbmiyn6OO26qyjEyF1SJR66UVDlG5pIqx8hcUGU/Bx83VeUYmQuqyNHbllQ5etuSKkdvW1Al9bluW1NlN9s8VKokGO8LhYSZKt71OTLXVDlypaBK+fOBADJebAy379bKqngav6nu4/Xig/Lt43EsynKVBC7f/RjYxJbYYFPavHFo9Rex2c/xLu8mFh5C1kBoN91GJdDYS43u5yRRLdDdrPxVAt3P42Ut0G5qdDebdzDhFKijymTNTTO7IVTJVNnPQ+CmquxmhFapAv4aH2UbMsJ+HgK3VAV2M1JsqspuhpVNVelzDIJIU3yS9bZhP4cZVKoEN15QN/yY58p+Tj5sqspulvK3VGU/SyebqrKbF6cqVWj6Qs0QkstU2c/tOJuqcuRKQZX93AazqSp9zuIqquxnIWlLVVKfI3NNlT7XV+ZVof0cpNtUlT5n/BVV9nPtyqaqdNqvTF9gB0rZ+Wzaz4Uum6py5EpBlf3coLKlKp2uUNZUCYcqBVU6na/Mq9LpCmVFlU7X4vx1A6n3kKvS51pcRZX97DHbVJU+x6CaKn2OQRVVpM8xqKbK0dsWVNnPHdubqnLkSq5K3M/t3ZuqcozMJVWOkbmgCnQ6MgeeVIkuV6XTXJlXZT/Xwm2pyn6uhdtUlU7nK/OqhE7nthVVjlwpqLKfC9A23FkaKRyqFFQ59mYXVNnPIegtVeEOxqBzoKncgYKfDiBCfHkZQu6DvYyycHDX0qdLk/PCICMhRoT5wgDu5sSSi/G2+IV/3II/X/lDqlAa5rIjdKRrYQ8l6BDDeFlFiPFa+jSUZYVpokHpWnQgdIqUHfQS6RsbgvYYKfcS6Rsbd3YYaXCNR5rGGXXgmwFhiPRCv/WKmqdPjavP0ydchmHe5fQbV5+n4Xign17Tl/K23yABRiuh67TpMgURXxzYQnKTqwT00ii48gSNJ504+FdzneDKhx1SGOcjiSi3iWqbNz6XWrEJC2zeeKCZuzwivPlFzIoVL7F6a2tvxWqRL7/Il1/kKyzyFRb5okX1RYt8xUVxvbUhat7qrQ1DFauwyGpRSyl/mny2j4HyV76TG3v9hLnNgn4Jy9d6zPpBCAtsRG9TbvUVG30/i+WBo2KzwE8IC2yS3oYW+KEFfmIxrxONeZ0YcxvR2/ACP+WP9VVsot4mLfCT9H58dS5QsiF1nXpwC2wW+EG/wEb0Nl7fFnyABTb6/uCNm0ArNqy3iQv8xAXx8ILc4QX1w8o8+Dn89p8P3x4/fHz6/H2wOP3x7y+ffjx+/fL864///jX+5eO3x6enxz/f//Xt66fPv//97fP7p6+fTn97cM///EuGpdAEfuBySmJx8E4Aht/ObYcQ3xHy6ddTGgnQ8FceOAw8/gc=","brillig_names":["public_dispatch"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==","debug_symbols":"bY/dCoMwDIXfJde9aKoO7KvIkKpRCqWVWgdDfPfFsUn3c3PICV8OORsM1K1Ta/0YFtDNBi70Jtng2W27gC5a5+zU5muQh2Dx5JfZ+MMuycQEulQCyA+gK8nXo3UE+lLs4gdEifLN8qzqE8ey/s/XePIK5Qd/3dneTLSmc/R6fVx9nzVJ95m+Ss0x9DSskY56WTPWBiuhJMdy9AM=","brillig_names":["sync_notes"]},{"name":"claim","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17288131482828810359":{"error_kind":"string","string":"Message not in state"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn\'t match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["build_msg_block","attach_len_to_msg_block","get_public_data_witness","field_less_than","decompose_hint","lte_hint","build_msg_block","get_l1_to_l2_membership_witness","notify_created_nullifier_oracle_wrapper","store_in_execution_cache_oracle_wrapper","enqueue_public_function_call_internal","directive_to_radix","directive_invert","directive_integer_quotient"],"verification_key":"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"},{"name":"check_balance","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{"15238796416211288225":{"error_kind":"string","string":"Balance too low"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3219842053230618354":{"error_kind":"string","string":"Function check_balance can only be called statically"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"fee_limit","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["check_balance"]},{"name":"balance_of_public","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6067862452620309358":{"error_kind":"string","string":"Function balance_of_public can only be called statically"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["balance_of_public"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"packed_note_content","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VZy67aQAwdSEJIuAEKn3Cl7tomXJ47Fn3c30AFPqHrrLppP7qMGCcH46siYVfFEpoknhyfOXZmJqHjztY//TrhOA5tz10b9dmGtrzPKkWs0pJn50F4dh+EZ/QgPGNFnh2Bp2/peUvc+ZlL3fl5bC7iTT7BEdzk/gYAwX6HNgttF/yKCakyYZBa+Otyvs/cpSnzf8kCZmqDvyD8vg1+Sbw/1y0+joXiRqF9rVstX+Eeb0U4xuIlXPJ1wfeF+SLwfWU+rOFvzId1T5xIN1qYlOtqY50XGlsKY+u80TrXaofXSOvcmdZoRTnPGB/On/gU1Kdu+fSYLwZfxnwJ+Eh/3z5DP577FPp9hONP0IfXZ+Su65n8lH/U3aK+YgP8k82lHPD8xPVlbPRhDmLQ85npY7FuoD4W+nt9pm/wp2Nvae0ai5ieqBFp1sf+zJeBL64v4+ThPIY4iEU8Etb/QzgfhbYH99D9YyF+j8W/4C1cQ404ViRco/7++Xwfjgfh52voJ93jructvc31ci7N4Xr4qwY/s+F/JPzcBn9J+AMb/GZv82SCPysJv7Dh38xBQ5v6afaWIxv+B8Ifm+DPD7QOv3OtNXNEOJ7Adb35u6pu2SNh/JxxtdojTRgfrg+uwd43FbiOBR/P4VSIMxXiSFiZItaTItboPx1jXxFroIg1VMTSzGOqiKWpV66IVShiada9pl6UR2mf5m0b2vJOk/ZpiviVtE/TfJcnram+YkFDHF/C+v9gOg9MeFYzWnPoWacYGLswin3rek3xC4EP8c4F3z0fZw+L9XGzXmxOW7JqOds0+SwYV34N34twPsb+0tov7fsUtS6ld/8h6OotBl/BfAn4iKP07j804n+L/hh/LPj4+n9rLifuej0csHHjN6+typjb74HSt3rj+Wtx67NJ8XN3PV//q++NqA/fS+cC17Hg4/uTXIiTC3EeEYt/s0cNfV2TTnHd+rVyuVq3f3TRXJS4y/8BHIufsP6/wjmOjdp75vzjalcdX3bH3WK338+/7yYM31sXdPoDg5oBSR0fAAA=","debug_symbols":"tdfNaoQwFIbhe8k6i5z8mIm3UsoQNQ6BECVqoYj33jhM26GzLN9GiBwfN77g2dkQuu12jXmcFta+7SxNvV/jlOtpPzjrSkwp3q7Pt5k4L87c55fZ5/O4rL6srNWSs5AH1hpRnx5jCqxt1MFfBu33oLU/g0Ye75y5BgVbFHxBwQ4EkxAwmWCyhMkKJmuYbGByA5MtTL7AZFiDBGuQYA0SrEGCNUiwBgnWIMEaJFiD9L8GnXoM1k/hhXYwWgocTTha4miFozWONji6wdEWR+NqlLgaFa5GBarxqKcPX6LvUnhsTeOW+6clav2cw599ai5TH4athHOz+l2qzvSU4drc/zzqgZTmpFx9SX3RFw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"_increase_public_balance","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{"10502589790419500451":{"error_kind":"string","string":"Function _increase_public_balance can only be called internally"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["_increase_public_balance"]}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"FeeJuice"}},{"name":"fields","value":{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"fee_limit","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"FeeJuice::check_balance_parameters"}}],"kind":"struct","path":"FeeJuice::check_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"FeeJuice::claim_parameters"}}],"kind":"struct","path":"FeeJuice::claim_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"FeeJuice::_increase_public_balance_parameters"}}],"kind":"struct","path":"FeeJuice::_increase_public_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"FeeJuice::set_portal_parameters"}}],"kind":"struct","path":"FeeJuice::set_portal_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"initial_mint","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"FeeJuice::initialize_parameters"}}],"kind":"struct","path":"FeeJuice::initialize_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"FeeJuice::balance_of_public_parameters"}},{"name":"return_type","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"FeeJuice::balance_of_public_abi"}]}},"file_map":{"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\\n\\n#[derive_via(derive_eq)]\\n// docs:start:eq-trait\\npub trait Eq {\\n    fn eq(self, other: Self) -> bool;\\n}\\n// docs:end:eq-trait\\n\\n// docs:start:derive_eq\\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\\n    let body = |fields| {\\n        if s.fields_as_written().len() == 0 {\\n            quote { true }\\n        } else {\\n            fields\\n        }\\n    };\\n    crate::meta::make_trait_impl(\\n        s,\\n        quote { Eq },\\n        signature,\\n        for_each_field,\\n        quote { & },\\n        body,\\n    )\\n}\\n// docs:end:derive_eq\\n\\nimpl Eq for Field {\\n    fn eq(self, other: Field) -> bool {\\n        self == other\\n    }\\n}\\n\\nimpl Eq for u64 {\\n    fn eq(self, other: u64) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for u32 {\\n    fn eq(self, other: u32) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for u16 {\\n    fn eq(self, other: u16) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for u8 {\\n    fn eq(self, other: u8) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for u1 {\\n    fn eq(self, other: u1) -> bool {\\n        self == other\\n    }\\n}\\n\\nimpl Eq for i8 {\\n    fn eq(self, other: i8) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for i16 {\\n    fn eq(self, other: i16) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for i32 {\\n    fn eq(self, other: i32) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for i64 {\\n    fn eq(self, other: i64) -> bool {\\n        self == other\\n    }\\n}\\n\\nimpl Eq for () {\\n    fn eq(_self: Self, _other: ()) -> bool {\\n        true\\n    }\\n}\\nimpl Eq for bool {\\n    fn eq(self, other: bool) -> bool {\\n        self == other\\n    }\\n}\\n\\nimpl<T, let N: u32> Eq for [T; N]\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: [T; N]) -> bool {\\n        let mut result = true;\\n        for i in 0..self.len() {\\n            result &= self[i].eq(other[i]);\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T> Eq for [T]\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: [T]) -> bool {\\n        let mut result = self.len() == other.len();\\n        for i in 0..self.len() {\\n            result &= self[i].eq(other[i]);\\n        }\\n        result\\n    }\\n}\\n\\nimpl<let N: u32> Eq for str<N> {\\n    fn eq(self, other: str<N>) -> bool {\\n        let self_bytes = self.as_bytes();\\n        let other_bytes = other.as_bytes();\\n        self_bytes == other_bytes\\n    }\\n}\\n\\nimpl<A, B> Eq for (A, B)\\nwhere\\n    A: Eq,\\n    B: Eq,\\n{\\n    fn eq(self, other: (A, B)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1)\\n    }\\n}\\n\\nimpl<A, B, C> Eq for (A, B, C)\\nwhere\\n    A: Eq,\\n    B: Eq,\\n    C: Eq,\\n{\\n    fn eq(self, other: (A, B, C)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\\n    }\\n}\\n\\nimpl<A, B, C, D> Eq for (A, B, C, D)\\nwhere\\n    A: Eq,\\n    B: Eq,\\n    C: Eq,\\n    D: Eq,\\n{\\n    fn eq(self, other: (A, B, C, D)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\\nwhere\\n    A: Eq,\\n    B: Eq,\\n    C: Eq,\\n    D: Eq,\\n    E: Eq,\\n{\\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\\n        self.0.eq(other.0)\\n            & self.1.eq(other.1)\\n            & self.2.eq(other.2)\\n            & self.3.eq(other.3)\\n            & self.4.eq(other.4)\\n    }\\n}\\n\\nimpl Eq for Ordering {\\n    fn eq(self, other: Ordering) -> bool {\\n        self.result == other.result\\n    }\\n}\\n\\n// Noir doesn\'t have enums yet so we emulate (Lt | Eq | Gt) with a struct\\n// that has 3 public functions for constructing the struct.\\npub struct Ordering {\\n    result: Field,\\n}\\n\\nimpl Ordering {\\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\\n    // into the compiler, do not change these without also updating\\n    // the compiler itself!\\n    pub fn less() -> Ordering {\\n        Ordering { result: 0 }\\n    }\\n\\n    pub fn equal() -> Ordering {\\n        Ordering { result: 1 }\\n    }\\n\\n    pub fn greater() -> Ordering {\\n        Ordering { result: 2 }\\n    }\\n}\\n\\n#[derive_via(derive_ord)]\\n// docs:start:ord-trait\\npub trait Ord {\\n    fn cmp(self, other: Self) -> Ordering;\\n}\\n// docs:end:ord-trait\\n\\n// docs:start:derive_ord\\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\\n    let for_each_field = |name| quote {\\n        if result == std::cmp::Ordering::equal() {\\n            result = _self.$name.cmp(_other.$name);\\n        }\\n    };\\n    let body = |fields| quote {\\n        let mut result = std::cmp::Ordering::equal();\\n        $fields\\n        result\\n    };\\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\\n}\\n// docs:end:derive_ord\\n\\n// Note: Field deliberately does not implement Ord\\n\\nimpl Ord for u64 {\\n    fn cmp(self, other: u64) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for u32 {\\n    fn cmp(self, other: u32) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for u16 {\\n    fn cmp(self, other: u16) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for u8 {\\n    fn cmp(self, other: u8) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i8 {\\n    fn cmp(self, other: i8) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i16 {\\n    fn cmp(self, other: i16) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i32 {\\n    fn cmp(self, other: i32) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i64 {\\n    fn cmp(self, other: i64) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for () {\\n    fn cmp(_self: Self, _other: ()) -> Ordering {\\n        Ordering::equal()\\n    }\\n}\\n\\nimpl Ord for bool {\\n    fn cmp(self, other: bool) -> Ordering {\\n        if self {\\n            if other {\\n                Ordering::equal()\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl<T, let N: u32> Ord for [T; N]\\nwhere\\n    T: Ord,\\n{\\n    // The first non-equal element of both arrays determines\\n    // the ordering for the whole array.\\n    fn cmp(self, other: [T; N]) -> Ordering {\\n        let mut result = Ordering::equal();\\n        for i in 0..self.len() {\\n            if result == Ordering::equal() {\\n                let result_i = self[i].cmp(other[i]);\\n\\n                if result_i == Ordering::less() {\\n                    result = result_i;\\n                } else if result_i == Ordering::greater() {\\n                    result = result_i;\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T> Ord for [T]\\nwhere\\n    T: Ord,\\n{\\n    // The first non-equal element of both arrays determines\\n    // the ordering for the whole array.\\n    fn cmp(self, other: [T]) -> Ordering {\\n        let mut result = self.len().cmp(other.len());\\n        for i in 0..self.len() {\\n            if result == Ordering::equal() {\\n                let result_i = self[i].cmp(other[i]);\\n\\n                if result_i == Ordering::less() {\\n                    result = result_i;\\n                } else if result_i == Ordering::greater() {\\n                    result = result_i;\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<A, B> Ord for (A, B)\\nwhere\\n    A: Ord,\\n    B: Ord,\\n{\\n    fn cmp(self, other: (A, B)) -> Ordering {\\n        let result = self.0.cmp(other.0);\\n\\n        if result != Ordering::equal() {\\n            result\\n        } else {\\n            self.1.cmp(other.1)\\n        }\\n    }\\n}\\n\\nimpl<A, B, C> Ord for (A, B, C)\\nwhere\\n    A: Ord,\\n    B: Ord,\\n    C: Ord,\\n{\\n    fn cmp(self, other: (A, B, C)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        result\\n    }\\n}\\n\\nimpl<A, B, C, D> Ord for (A, B, C, D)\\nwhere\\n    A: Ord,\\n    B: Ord,\\n    C: Ord,\\n    D: Ord,\\n{\\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.3.cmp(other.3);\\n        }\\n\\n        result\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\\nwhere\\n    A: Ord,\\n    B: Ord,\\n    C: Ord,\\n    D: Ord,\\n    E: Ord,\\n{\\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.3.cmp(other.3);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.4.cmp(other.4);\\n        }\\n\\n        result\\n    }\\n}\\n\\n// Compares and returns the maximum of two values.\\n//\\n// Returns the second argument if the comparison determines them to be equal.\\n//\\n// # Examples\\n//\\n// ```\\n// use std::cmp;\\n//\\n// assert_eq(cmp::max(1, 2), 2);\\n// assert_eq(cmp::max(2, 2), 2);\\n// ```\\npub fn max<T>(v1: T, v2: T) -> T\\nwhere\\n    T: Ord,\\n{\\n    if v1 > v2 {\\n        v1\\n    } else {\\n        v2\\n    }\\n}\\n\\n// Compares and returns the minimum of two values.\\n//\\n// Returns the first argument if the comparison determines them to be equal.\\n//\\n// # Examples\\n//\\n// ```\\n// use std::cmp;\\n//\\n// assert_eq(cmp::min(1, 2), 1);\\n// assert_eq(cmp::min(2, 2), 2);\\n// ```\\npub fn min<T>(v1: T, v2: T) -> T\\nwhere\\n    T: Ord,\\n{\\n    if v1 > v2 {\\n        v2\\n    } else {\\n        v1\\n    }\\n}\\n\\nmod cmp_tests {\\n    use crate::cmp::{max, min};\\n\\n    #[test]\\n    fn sanity_check_min() {\\n        assert_eq(min(0 as u64, 1 as u64), 0);\\n        assert_eq(min(0 as u64, 0 as u64), 0);\\n        assert_eq(min(1 as u64, 1 as u64), 1);\\n        assert_eq(min(255 as u8, 0 as u8), 0);\\n    }\\n\\n    #[test]\\n    fn sanity_check_max() {\\n        assert_eq(max(0 as u64, 1 as u64), 1);\\n        assert_eq(max(0 as u64, 0 as u64), 0);\\n        assert_eq(max(1 as u64, 1 as u64), 1);\\n        assert_eq(max(255 as u8, 0 as u8), 255);\\n    }\\n}\\n"},"18":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    /// Safety: borrow is enforced to be boolean due to its type.\\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n    unsafe {\\n        /*@safety: borrow is enforced to be boolean due to its type.\\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n        */\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        /// Safety: decomposition is properly checked below\\n        unsafe {\\n            /*@safety: decomposition is properly checked below*/\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            /// Safety: already unconstrained\\n            unsafe { field_less_than(b, a) },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        /// Safety: unsafe in unconstrained\\n        unsafe {\\n            //@safety: unsafe in unconstrained\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        /// Safety: Take a hint of the comparison and verify it\\n        unsafe {\\n            //@safety: Take a hint of the comparison and verify it\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"19":{"path":"std/field/mod.nr","source":"pub mod bn254;\\nuse crate::{runtime::is_unconstrained, static_assert};\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        static_assert(\\n            BIT_SIZE < modulus_num_bits() as u32,\\n            \\"BIT_SIZE must be less than modulus_num_bits\\",\\n        );\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_le_bits\\n        let bits = self._to_le_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(p[N - 1 - i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_be_bits\\n        let bits = self._to_be_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the decomposition does not overflow the modulus\\n            let p = modulus_be_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[i] != p[i]) {\\n                        assert(p[i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            static_assert(1 < radix, \\"radix must be greater than 1\\");\\n            static_assert(radix <= 256, \\"radix must be less than or equal to 256\\");\\n            static_assert(radix & (radix - 1) == 0, \\"radix must be a power of 2\\");\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        /// Safety: unconstrained context\\n        unsafe {\\n            //@safety : unconstrained context\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use crate::{panic::panic, runtime};\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test(should_fail_with = \\"radix must be greater than 1\\")]\\n    fn test_to_le_radix_1() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(1);\\n        } else {\\n            panic(f\\"radix must be greater than 1\\");\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\\n    // #[test]\\n    // fn test_to_le_radix_brillig_1() {\\n    //     // this test should only fail in constrained mode\\n    //     if runtime::is_unconstrained() {\\n    //         let field = 1;\\n    //         let out: [u8; 8] = field.to_le_radix(1);\\n    //         crate::println(out);\\n    //         let expected = [0; 8];\\n    //         assert(out == expected, \\"unexpected result\\");\\n    //     }\\n    // }\\n\\n    #[test(should_fail_with = \\"radix must be a power of 2\\")]\\n    fn test_to_le_radix_3() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(3);\\n        } else {\\n            panic(f\\"radix must be a power of 2\\");\\n        }\\n    }\\n\\n    #[test]\\n    fn test_to_le_radix_brillig_3() {\\n        // this test should only fail in constrained mode\\n        if runtime::is_unconstrained() {\\n            let field = 1;\\n            let out: [u8; 8] = field.to_le_radix(3);\\n            let mut expected = [0; 8];\\n            expected[0] = 1;\\n            assert(out == expected, \\"unexpected result\\");\\n        }\\n    }\\n\\n    #[test(should_fail_with = \\"radix must be less than or equal to 256\\")]\\n    fn test_to_le_radix_512() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(512);\\n        } else {\\n            panic(f\\"radix must be less than or equal to 256\\")\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\\n    // #[test]\\n    // fn test_to_le_radix_brillig_512() {\\n    //     // this test should only fail in constrained mode\\n    //     if runtime::is_unconstrained() {\\n    //         let field = 1;\\n    //         let out: [u8; 8] = field.to_le_radix(512);\\n    //         let mut expected = [0; 8];\\n    //         expected[0] = 1;\\n    //         assert(out == expected, \\"unexpected result\\");\\n    //     }\\n    // }\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n"},"26":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"52":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"60":{"path":"std/uint128.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\\nuse crate::static_assert;\\nuse super::{convert::AsPrimitive, default::Default};\\n\\nglobal pow64: Field = 18446744073709551616; //2^64;\\nglobal pow63: Field = 9223372036854775808; // 2^63;\\npub struct U128 {\\n    pub(crate) lo: Field,\\n    pub(crate) hi: Field,\\n}\\n\\nimpl U128 {\\n\\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\\n        assert(crate::field::modulus_num_bits() as u32 > 128);\\n        U128 { lo: lo as Field, hi: hi as Field }\\n    }\\n\\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\\n        U128::from_u64s_le(lo, hi)\\n    }\\n\\n    pub fn zero() -> U128 {\\n        U128 { lo: 0, hi: 0 }\\n    }\\n\\n    pub fn one() -> U128 {\\n        U128 { lo: 1, hi: 0 }\\n    }\\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\\n        let mut lo = 0;\\n        let mut base = 1;\\n        for i in 0..8 {\\n            lo += (bytes[i] as Field) * base;\\n            base *= 256;\\n        }\\n        let mut hi = 0;\\n        base = 1;\\n        for i in 8..16 {\\n            hi += (bytes[i] as Field) * base;\\n            base *= 256;\\n        }\\n        U128 { lo, hi }\\n    }\\n\\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\\n        let lo: [u8; 8] = self.lo.to_be_bytes();\\n        let hi: [u8; 8] = self.hi.to_be_bytes();\\n        let mut bytes = [0; 16];\\n        for i in 0..8 {\\n            bytes[i] = hi[i];\\n            bytes[i + 8] = lo[i];\\n        }\\n        bytes\\n    }\\n\\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\\n        let lo: [u8; 8] = self.lo.to_le_bytes();\\n        let hi: [u8; 8] = self.hi.to_le_bytes();\\n        let mut bytes = [0; 16];\\n        for i in 0..8 {\\n            bytes[i] = lo[i];\\n            bytes[i + 8] = hi[i];\\n        }\\n        bytes\\n    }\\n\\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\\n        let bytes = hex.as_bytes();\\n        // string must starts with \\"0x\\"\\n        assert((bytes[0] == 48) & (bytes[1] == 120), \\"Invalid hexadecimal string\\");\\n        static_assert(N < 35, \\"Input does not fit into a U128\\");\\n\\n        let mut lo = 0;\\n        let mut hi = 0;\\n        let mut base = 1;\\n        if N <= 18 {\\n            for i in 0..N - 2 {\\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\\n                base = base * 16;\\n            }\\n        } else {\\n            for i in 0..16 {\\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\\n                base = base * 16;\\n            }\\n            base = 1;\\n            for i in 17..N - 1 {\\n                hi += U128::decode_ascii(bytes[N - i]) * base;\\n                base = base * 16;\\n            }\\n        }\\n        U128 { lo: lo as Field, hi: hi as Field }\\n    }\\n\\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\\n        ((ascii >= 65) & (ascii <= 90)) // Between \'A\' and \'Z\'\\n    }\\n\\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\\n        (\\n            if ascii < 58 {\\n                ascii - 48\\n            } else {\\n                /// Safety: optionally adds 32 and then check (below) the result is in \'a..f\' range\\n                let ascii =\\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\\n                assert(ascii >= 97); // enforce >= \'a\'\\n                assert(ascii <= 102); // enforce <= \'f\'\\n                ascii - 87\\n            }\\n        ) as Field\\n    }\\n\\n    // TODO: Replace with a faster version.\\n    // A circuit that uses this function can be slow to compute\\n    // (we\'re doing up to 127 calls to compute the quotient)\\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\\n        if b == U128::zero() {\\n            // Return 0,0 to avoid eternal loop\\n            (U128::zero(), U128::zero())\\n        } else if self < b {\\n            (U128::zero(), self)\\n        } else if self == b {\\n            (U128::one(), U128::zero())\\n        } else {\\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\\n                // The result of multiplication by 2 would overflow\\n                (U128::zero(), self)\\n            } else {\\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\\n            };\\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\\n            if r < b {\\n                (q_mul_2, r)\\n            } else {\\n                (q_mul_2 + U128::one(), r - b)\\n            }\\n        }\\n    }\\n\\n    pub fn from_integer<T>(i: T) -> U128\\n    where\\n        T: AsPrimitive<Field>,\\n    {\\n        let f = i.as_();\\n        // Reject values which would overflow a u128\\n        f.assert_max_bit_size::<128>();\\n        let lo = f as u64 as Field;\\n        let hi = (f - lo) / pow64;\\n        U128 { lo, hi }\\n    }\\n\\n    pub fn to_integer<T>(self) -> T\\n    where\\n        Field: AsPrimitive<T>,\\n    {\\n        AsPrimitive::as_(self.lo + self.hi * pow64)\\n    }\\n\\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\\n        let low = self.lo * b.lo;\\n        let lo = low as u64 as Field;\\n        let carry = (low - lo) / pow64;\\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\\n        let hi = high as u64 as Field;\\n        U128 { lo, hi }\\n    }\\n}\\n\\nimpl Add for U128 {\\n    fn add(self: Self, b: U128) -> U128 {\\n        let low = self.lo + b.lo;\\n        let lo = low as u64 as Field;\\n        let carry = (low - lo) / pow64;\\n        let high = self.hi + b.hi + carry;\\n        let hi = high as u64 as Field;\\n        assert(hi == high, \\"attempt to add with overflow\\");\\n        U128 { lo, hi }\\n    }\\n}\\n\\nimpl Sub for U128 {\\n    fn sub(self: Self, b: U128) -> U128 {\\n        let low = pow64 + self.lo - b.lo;\\n        let lo = low as u64 as Field;\\n        let borrow = (low == lo) as Field;\\n        let high = self.hi - b.hi - borrow;\\n        let hi = high as u64 as Field;\\n        assert(hi == high, \\"attempt to subtract with underflow\\");\\n        U128 { lo, hi }\\n    }\\n}\\n\\nimpl Mul for U128 {\\n    fn mul(self: Self, b: U128) -> U128 {\\n        assert(self.hi * b.hi == 0, \\"attempt to multiply with overflow\\");\\n        let low = self.lo * b.lo;\\n        let lo = low as u64 as Field;\\n        let carry = (low - lo) / pow64;\\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\\n        } else {\\n            self.lo * b.hi + self.hi * b.lo + carry\\n        };\\n        let hi = high as u64 as Field;\\n        assert(hi == high, \\"attempt to multiply with overflow\\");\\n        U128 { lo, hi }\\n    }\\n}\\n\\nimpl Div for U128 {\\n    fn div(self: Self, b: U128) -> U128 {\\n        /// Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\\n        /// Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\\n        unsafe {\\n            /*@safety : euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\\n                Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\\n            */\\n            let (q, r) = self.unconstrained_div(b);\\n            let a = b * q + r;\\n            assert_eq(self, a);\\n            assert(r < b);\\n            q\\n        }\\n    }\\n}\\n\\nimpl Rem for U128 {\\n    fn rem(self: Self, b: U128) -> U128 {\\n        /// Safety: cf div() above\\n        unsafe {\\n            //@safety : cf div() above\\n            let (q, r) = self.unconstrained_div(b);\\n            let a = b * q + r;\\n            assert_eq(self, a);\\n            assert(r < b);\\n\\n            r\\n        }\\n    }\\n}\\n\\nimpl Eq for U128 {\\n    fn eq(self: Self, b: U128) -> bool {\\n        (self.lo == b.lo) & (self.hi == b.hi)\\n    }\\n}\\n\\nimpl Ord for U128 {\\n    fn cmp(self, other: Self) -> Ordering {\\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\\n\\n        if hi_ordering == Ordering::equal() {\\n            lo_ordering\\n        } else {\\n            hi_ordering\\n        }\\n    }\\n}\\n\\nimpl Not for U128 {\\n    fn not(self) -> U128 {\\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\\n    }\\n}\\n\\nimpl BitOr for U128 {\\n    fn bitor(self, other: U128) -> U128 {\\n        U128 {\\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\\n        }\\n    }\\n}\\n\\nimpl BitAnd for U128 {\\n    fn bitand(self, other: U128) -> U128 {\\n        U128 {\\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\\n        }\\n    }\\n}\\n\\nimpl BitXor for U128 {\\n    fn bitxor(self, other: U128) -> U128 {\\n        U128 {\\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\\n        }\\n    }\\n}\\n\\nimpl Shl for U128 {\\n    fn shl(self, other: u8) -> U128 {\\n        assert(other < 128, \\"attempt to shift left with overflow\\");\\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\\n\\n        let mut r: Field = 2;\\n        let mut y: Field = 1;\\n        for i in 1..8 {\\n            let bit = exp_bits[7 - i] as Field;\\n            y = bit * (r * y) + (1 - bit) * y;\\n            r *= r;\\n        }\\n        self.wrapping_mul(U128::from_integer(y))\\n    }\\n}\\n\\nimpl Shr for U128 {\\n    fn shr(self, other: u8) -> U128 {\\n        assert(other < 128, \\"attempt to shift right with overflow\\");\\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\\n\\n        let mut r: Field = 2;\\n        let mut y: Field = 1;\\n        for i in 1..8 {\\n            let bit = exp_bits[7 - i] as Field;\\n            y = bit * (r * y) + (1 - bit) * y;\\n            r *= r;\\n        }\\n        self / U128::from_integer(y)\\n    }\\n}\\n\\nimpl Default for U128 {\\n    fn default() -> Self {\\n        U128::zero()\\n    }\\n}\\n\\nmod tests {\\n    use crate::default::Default;\\n    use crate::ops::Not;\\n    use crate::uint128::{pow63, pow64, U128};\\n\\n    #[test]\\n    fn test_not(lo: u64, hi: u64) {\\n        let num = U128::from_u64s_le(lo, hi);\\n        let not_num = num.not();\\n\\n        assert_eq(not_num.hi, (hi.not() as Field));\\n        assert_eq(not_num.lo, (lo.not() as Field));\\n\\n        let not_not_num = not_num.not();\\n        assert_eq(num, not_not_num);\\n    }\\n    #[test]\\n    fn test_construction() {\\n        // Check little-endian u64 is inversed with big-endian u64 construction\\n        let a = U128::from_u64s_le(2, 1);\\n        let b = U128::from_u64s_be(1, 2);\\n        assert_eq(a, b);\\n        // Check byte construction is equivalent\\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\\n        assert_eq(c, d);\\n    }\\n    #[test]\\n    fn test_byte_decomposition() {\\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\\n        // Get big-endian and little-endian byte decompostions\\n        let le_bytes_a = a.to_le_bytes();\\n        let be_bytes_a = a.to_be_bytes();\\n\\n        // Check equivalence\\n        for i in 0..16 {\\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\\n        }\\n        // Reconstruct U128 from byte decomposition\\n        let b = U128::from_le_bytes(le_bytes_a);\\n        // Check that it\'s the same element\\n        assert_eq(a, b);\\n    }\\n    #[test]\\n    fn test_hex_constuction() {\\n        let a = U128::from_u64s_le(0x1, 0x2);\\n        let b = U128::from_hex(\\"0x20000000000000001\\");\\n        assert_eq(a, b);\\n\\n        let c = U128::from_hex(\\"0xffffffffffffffffffffffffffffffff\\");\\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\\n        assert_eq(c, d);\\n\\n        let e = U128::from_hex(\\"0x00000000000000000000000000000000\\");\\n        let f = U128::from_u64s_le(0, 0);\\n        assert_eq(e, f);\\n    }\\n\\n    // Ascii decode tests\\n\\n    #[test]\\n    fn test_ascii_decode_correct_range() {\\n        // \'0\'..\'9\' range\\n        for i in 0..10 {\\n            let decoded = U128::decode_ascii(48 + i);\\n            assert_eq(decoded, i as Field);\\n        }\\n        // \'A\'..\'F\' range\\n        for i in 0..6 {\\n            let decoded = U128::decode_ascii(65 + i);\\n            assert_eq(decoded, (i + 10) as Field);\\n        }\\n        // \'a\'..\'f\' range\\n        for i in 0..6 {\\n            let decoded = U128::decode_ascii(97 + i);\\n            assert_eq(decoded, (i + 10) as Field);\\n        }\\n    }\\n\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_less_than_48_fails_0() {\\n        crate::println(U128::decode_ascii(0));\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_less_than_48_fails_1() {\\n        crate::println(U128::decode_ascii(47));\\n    }\\n\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_58_64_fails_0() {\\n        let _ = U128::decode_ascii(58);\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_58_64_fails_1() {\\n        let _ = U128::decode_ascii(64);\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_71_96_fails_0() {\\n        let _ = U128::decode_ascii(71);\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_71_96_fails_1() {\\n        let _ = U128::decode_ascii(96);\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_greater_than_102_fails() {\\n        let _ = U128::decode_ascii(103);\\n    }\\n\\n    #[test(should_fail)]\\n    fn test_ascii_decode_regression() {\\n        // This code will actually fail because of ascii_decode,\\n        // but in the past it was possible to create a value > (1<<128)\\n        let a = U128::from_hex(\\"0x~fffffffffffffffffffffffffffffff\\");\\n        let b: Field = a.to_integer();\\n        let c: [u8; 17] = b.to_le_bytes();\\n        assert(c[16] != 0);\\n    }\\n\\n    #[test]\\n    fn test_unconstrained_div() {\\n        // Test the potential overflow case\\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\\n        let c = U128::one();\\n        let d = U128::from_u64s_le(0x0, 0x1);\\n        /// Safety: testing context\\n        unsafe {\\n            //@safety: testing context\\n            let (q, r) = a.unconstrained_div(b);\\n            assert_eq(q, c);\\n            assert_eq(r, d);\\n        }\\n\\n        let a = U128::from_u64s_le(2, 0);\\n        let b = U128::one();\\n        // Check the case where a is a multiple of b\\n        /// Safety: testing context\\n        unsafe {\\n            //@safety: testing context\\n            let (c, d) = a.unconstrained_div(b);\\n            assert_eq((c, d), (a, U128::zero()));\\n        }\\n\\n        // Check where b is a multiple of a\\n        /// Safety: testing context\\n        unsafe {\\n            //@safety: testing context\\n            let (c, d) = b.unconstrained_div(a);\\n            assert_eq((c, d), (U128::zero(), b));\\n        }\\n\\n        // Dividing by zero returns 0,0\\n        let a = U128::from_u64s_le(0x1, 0x0);\\n        let b = U128::zero();\\n        /// Safety: testing context\\n        unsafe {\\n            //@safety: testing context\\n            let (c, d) = a.unconstrained_div(b);\\n            assert_eq((c, d), (U128::zero(), U128::zero()));\\n        }\\n        // Dividing 1<<127 by 1<<127 (special case)\\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\\n        /// Safety: testing context\\n        unsafe {\\n            //@safety: testing context\\n            let (c, d) = a.unconstrained_div(b);\\n            assert_eq((c, d), (U128::one(), U128::zero()));\\n        }\\n    }\\n\\n    #[test]\\n    fn integer_conversions() {\\n        // Maximum\\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n\\n        // Minimum\\n        let start: Field = 0x0;\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n\\n        // Low limb\\n        let start: Field = 0xffffffffffffffff;\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n\\n        // High limb\\n        let start: Field = 0xffffffffffffffff0000000000000000;\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n    }\\n\\n    #[test]\\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n    }\\n\\n    #[test]\\n    fn test_wrapping_mul() {\\n        // 1*0==0\\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\\n\\n        // 0*1==0\\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\\n\\n        // 1*1==1\\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\\n\\n        // 0 * ( 1 << 64 ) ==  0\\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\\n\\n        // ( 1 << 64 ) * 0 == 0\\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\\n\\n        // 1 * ( 1 << 64 ) == 1 << 64\\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\\n\\n        // ( 1 << 64 ) * 1 == 1 << 64\\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\\n\\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\\n        // -1 * -1 == 1\\n        assert_eq(\\n            U128::one(),\\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\\n            ),\\n        );\\n    }\\n\\n    #[test]\\n    fn test_default() {\\n        assert_eq(U128::default(), U128::zero());\\n    }\\n}\\n"},"62":{"path":"/build-volume/noir-projects/noir-contracts/contracts/fee_juice_contract/src/lib.nr","source":"use dep::aztec::context::PublicContext;\\nuse dep::aztec::prelude::AztecAddress;\\nuse dep::aztec::protocol_types::hash::sha256_to_field;\\n\\npub fn calculate_fee<TPublicContext>(context: PublicContext) -> Field {\\n    context.transaction_fee()\\n}\\n\\npub fn get_bridge_gas_msg_hash(owner: AztecAddress, amount: U128) -> Field {\\n    let mut hash_bytes = [0; 68];\\n    let recipient_bytes: [u8; 32] = owner.to_field().to_be_bytes();\\n    let amount_bytes: [u8; 32] = amount.to_field().to_be_bytes();\\n\\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\\n    // it has nothing to do with calling the function.\\n    let selector = comptime { std::hash::keccak256(\\"claim(bytes32,uint256)\\".as_bytes(), 22) };\\n\\n    for i in 0..4 {\\n        hash_bytes[i] = selector[i];\\n    }\\n\\n    for i in 0..32 {\\n        hash_bytes[i + 4] = recipient_bytes[i];\\n        hash_bytes[i + 36] = amount_bytes[i];\\n    }\\n\\n    let content_hash = sha256_to_field(hash_bytes);\\n    content_hash\\n}\\n"},"63":{"path":"/build-volume/noir-projects/noir-contracts/contracts/fee_juice_contract/src/main.nr","source":"mod lib;\\n\\nuse dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract FeeJuice {\\n    use dep::aztec::{\\n        macros::{functions::{internal, private, public, view}, storage::storage},\\n        protocol_types::address::{AztecAddress, EthAddress},\\n        state_vars::{Map, PublicImmutable, PublicMutable},\\n    };\\n\\n    use crate::lib::get_bridge_gas_msg_hash;\\n\\n    #[storage]\\n    struct Storage<Context> {\\n        // This map is accessed directly by protocol circuits to check balances for fee payment.\\n        // Do not change this storage layout unless you also update the base rollup circuits.\\n        balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\\n        portal_address: PublicImmutable<EthAddress, Context>,\\n    }\\n\\n    // Not flagged as initializer to reduce cost of checking init nullifier in all functions.\\n    // This function should be called as entrypoint to initialize the contract by minting itself funds.\\n    #[private]\\n    fn initialize(portal_address: EthAddress, initial_mint: U128) {\\n        // Validate contract class parameters are correct\\n        let self = context.this_address();\\n\\n        // Increase self balance and set as fee payer, and end setup\\n        FeeJuice::at(self)._increase_public_balance(self, initial_mint).enqueue(&mut context);\\n        context.set_as_fee_payer();\\n        context.end_setup();\\n\\n        // Enqueue call to set the portal address\\n        FeeJuice::at(self).set_portal(portal_address).enqueue(&mut context);\\n    }\\n\\n    // We purposefully not set this function as an initializer so we do not bind\\n    // the contract to a specific L1 portal address, since the Fee Juice address\\n    // is a hardcoded constant in the rollup circuits.\\n    #[public]\\n    fn set_portal(portal_address: EthAddress) {\\n        assert(storage.portal_address.read().is_zero());\\n        storage.portal_address.initialize(portal_address);\\n    }\\n\\n    #[private]\\n    fn claim(to: AztecAddress, amount: U128, secret: Field, message_leaf_index: Field) {\\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\\n        let portal_address = storage.portal_address.read();\\n        assert(!portal_address.is_zero());\\n\\n        // Consume message and emit nullifier\\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address, message_leaf_index);\\n\\n        // TODO(palla/gas) Emit an unencrypted log to announce which L1 to L2 message has been claimed\\n        // Otherwise, we cannot trace L1 deposits to their corresponding claims on L2\\n        FeeJuice::at(context.this_address())._increase_public_balance(to, amount).enqueue(\\n            &mut context,\\n        );\\n    }\\n\\n    #[public]\\n    #[internal]\\n    fn _increase_public_balance(to: AztecAddress, amount: U128) {\\n        let new_balance = storage.balances.at(to).read().add(amount);\\n        storage.balances.at(to).write(new_balance);\\n    }\\n\\n    #[public]\\n    #[view]\\n    fn check_balance(fee_limit: U128) {\\n        assert(storage.balances.at(context.msg_sender()).read() >= fee_limit, \\"Balance too low\\");\\n    }\\n\\n    // utility function for testing\\n    #[public]\\n    #[view]\\n    fn balance_of_public(owner: AztecAddress) -> pub U128 {\\n        storage.balances.at(owner).read()\\n    }\\n}\\n"},"73":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\\n};\\n\\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\\n\\nuse crate::hash::hash_args;\\nuse crate::oracle::execution_cache;\\n\\npub trait CallInterface<let N: u32> {\\n    fn get_args(self) -> [Field];\\n    fn get_selector(self) -> FunctionSelector;\\n    fn get_name(self) -> str<N>;\\n    fn get_contract_address(self) -> AztecAddress;\\n    fn get_is_static(self) -> bool;\\n}\\n\\npub struct PrivateCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n        );\\n        let returns: T = returns_hash.get_preimage();\\n        returns\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns_hash.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PrivateVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateVoidCallInterface<N> {\\n    pub fn call(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                false,\\n            )\\n            .assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PrivateStaticCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PrivateStaticVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PublicCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub gas_opts: GasOpts,\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PublicCallInterface<N, T> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PublicVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n    pub gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicVoidCallInterface<N> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PublicStaticCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n    pub gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PublicStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (),\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n"},"80":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::Empty,\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            /// for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\\n        /// to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"81":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\\nuse crate::hash::{\\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\\n};\\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\\n\\npub struct PublicContext {\\n    pub args_hash: Option<Field>,\\n    pub compute_args_hash: fn() -> Field,\\n}\\n\\nimpl PublicContext {\\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\\n        PublicContext { args_hash: Option::none(), compute_args_hash }\\n    }\\n\\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\\n    where\\n        T: Serialize<N>,\\n    {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\\n    }\\n\\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\\n    }\\n\\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\\n    }\\n\\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\\n    }\\n\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        let secret_hash = compute_secret_hash(secret);\\n        let message_hash = compute_l1_to_l2_message_hash(\\n            sender,\\n            self.chain_id(),\\n            /*recipient=*/\\n            self.this_address(),\\n            self.version(),\\n            content,\\n            secret_hash,\\n            leaf_index,\\n        );\\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\\n\\n        assert(\\n            !self.nullifier_exists(nullifier, self.this_address()),\\n            \\"L1-to-L2 message is already nullified\\",\\n        );\\n        assert(\\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\\n            \\"Tried to consume nonexistent L1-to-L2 message\\",\\n        );\\n\\n        self.push_nullifier(nullifier);\\n    }\\n\\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { send_l2_to_l1_msg(recipient, content) };\\n    }\\n\\n    pub unconstrained fn call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n        let success = call(gas_for_call(gas_opts), contract_address, args);\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub unconstrained fn static_call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_note_hash(note_hash) };\\n    }\\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_nullifier(nullifier) };\\n    }\\n\\n    pub fn this_address(_self: Self) -> AztecAddress {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            address()\\n        }\\n    }\\n    pub fn msg_sender(_self: Self) -> AztecAddress {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            sender()\\n        }\\n    }\\n    pub fn selector(_self: Self) -> FunctionSelector {\\n        // The selector is the first element of the calldata when calling a public function through dispatch.\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\\n        FunctionSelector::from_field(raw_selector[0])\\n    }\\n    pub fn get_args_hash(mut self) -> Field {\\n        if !self.args_hash.is_some() {\\n            self.args_hash = Option::some((self.compute_args_hash)());\\n        }\\n\\n        self.args_hash.unwrap_unchecked()\\n    }\\n    pub fn transaction_fee(_self: Self) -> Field {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            transaction_fee()\\n        }\\n    }\\n\\n    pub fn chain_id(_self: Self) -> Field {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            chain_id()\\n        }\\n    }\\n    pub fn version(_self: Self) -> Field {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            version()\\n        }\\n    }\\n    pub fn block_number(_self: Self) -> Field {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            block_number()\\n        }\\n    }\\n    pub fn timestamp(_self: Self) -> u64 {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            timestamp()\\n        }\\n    }\\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_l2_gas()\\n        }\\n    }\\n    pub fn fee_per_da_gas(_self: Self) -> Field {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_da_gas()\\n        }\\n    }\\n\\n    pub fn l2_gas_left(_self: Self) -> Field {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            l2_gas_left()\\n        }\\n    }\\n    pub fn da_gas_left(_self: Self) -> Field {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            da_gas_left()\\n        }\\n    }\\n    pub fn is_static_call(_self: Self) -> bool {\\n        /// Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { is_static_call() } == 1\\n    }\\n\\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\\n        let mut out = [0; N];\\n        for i in 0..N {\\n            /// Safety: AVM opcodes are constrained by the AVM itself\\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\\n        }\\n        out\\n    }\\n\\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n\\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\\n        for i in 0..N {\\n            /// Safety: AVM opcodes are constrained by the AVM itself\\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\\n        }\\n    }\\n\\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\\n    where\\n        T: Packable<N>,\\n    {\\n        self.raw_storage_write(storage_slot, value.pack());\\n    }\\n}\\n\\n// Helper functions\\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\\n    // It\'s ok to use the max possible gas here, because the gas will be\\n    // capped by the gas left in the (STATIC)CALL instruction.\\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\\n}\\n\\n// Unconstrained opcode wrappers (do not use directly).\\nunconstrained fn address() -> AztecAddress {\\n    address_opcode()\\n}\\nunconstrained fn sender() -> AztecAddress {\\n    sender_opcode()\\n}\\nunconstrained fn transaction_fee() -> Field {\\n    transaction_fee_opcode()\\n}\\nunconstrained fn chain_id() -> Field {\\n    chain_id_opcode()\\n}\\nunconstrained fn version() -> Field {\\n    version_opcode()\\n}\\nunconstrained fn block_number() -> Field {\\n    block_number_opcode()\\n}\\nunconstrained fn timestamp() -> u64 {\\n    timestamp_opcode()\\n}\\nunconstrained fn fee_per_l2_gas() -> Field {\\n    fee_per_l2_gas_opcode()\\n}\\nunconstrained fn fee_per_da_gas() -> Field {\\n    fee_per_da_gas_opcode()\\n}\\nunconstrained fn l2_gas_left() -> Field {\\n    l2_gas_left_opcode()\\n}\\nunconstrained fn da_gas_left() -> Field {\\n    da_gas_left_opcode()\\n}\\nunconstrained fn is_static_call() -> Field {\\n    is_static_call_opcode()\\n}\\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\\n    note_hash_exists_opcode(note_hash, leaf_index)\\n}\\nunconstrained fn emit_note_hash(note_hash: Field) {\\n    emit_note_hash_opcode(note_hash)\\n}\\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\\n    nullifier_exists_opcode(nullifier, address)\\n}\\nunconstrained fn emit_nullifier(nullifier: Field) {\\n    emit_nullifier_opcode(nullifier)\\n}\\nunconstrained fn emit_public_log(message: [Field]) {\\n    emit_public_log_opcode(message)\\n}\\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\\n}\\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\\n    send_l2_to_l1_msg_opcode(recipient, content)\\n}\\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\\n    call_opcode(gas, address, args)\\n}\\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\\n    call_static_opcode(gas, address, args)\\n}\\n\\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\\n    calldata_copy_opcode(cdoffset, copy_size)\\n}\\n\\nunconstrained fn returndata_size() -> u32 {\\n    returndata_size_opcode()\\n}\\n\\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\\n    returndata_copy_opcode(rdoffset, copy_size)\\n}\\n\\npub unconstrained fn avm_return(returndata: [Field]) {\\n    return_opcode(returndata)\\n}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\nunconstrained fn avm_revert(revertdata: [Field]) {\\n    revert_opcode(revertdata)\\n}\\n\\nunconstrained fn storage_read(storage_slot: Field) -> Field {\\n    storage_read_opcode(storage_slot)\\n}\\n\\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\\n    storage_write_opcode(storage_slot, value);\\n}\\n\\nimpl Empty for PublicContext {\\n    fn empty() -> Self {\\n        PublicContext::new(|| 0)\\n    }\\n}\\n\\n// AVM oracles (opcodes) follow, do not use directly.\\n#[oracle(avmOpcodeAddress)]\\nunconstrained fn address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeSender)]\\nunconstrained fn sender_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeTransactionFee)]\\nunconstrained fn transaction_fee_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeChainId)]\\nunconstrained fn chain_id_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeVersion)]\\nunconstrained fn version_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeBlockNumber)]\\nunconstrained fn block_number_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeTimestamp)]\\nunconstrained fn timestamp_opcode() -> u64 {}\\n\\n#[oracle(avmOpcodeFeePerL2Gas)]\\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeFeePerDaGas)]\\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeL2GasLeft)]\\nunconstrained fn l2_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeDaGasLeft)]\\nunconstrained fn da_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeIsStaticCall)]\\nunconstrained fn is_static_call_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeNoteHashExists)]\\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNoteHash)]\\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\\n\\n#[oracle(avmOpcodeNullifierExists)]\\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNullifier)]\\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\\n\\n// TODO(#11124): rename unencrypted to public in avm\\n#[oracle(avmOpcodeEmitUnencryptedLog)]\\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\\n\\n#[oracle(avmOpcodeL1ToL2MsgExists)]\\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeSendL2ToL1Msg)]\\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\\n\\n#[oracle(avmOpcodeCalldataCopy)]\\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\\n\\n#[oracle(avmOpcodeReturndataSize)]\\nunconstrained fn returndata_size_opcode() -> u32 {}\\n\\n#[oracle(avmOpcodeReturndataCopy)]\\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\\n\\n#[oracle(avmOpcodeReturn)]\\nunconstrained fn return_opcode(returndata: [Field]) {}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\n#[oracle(avmOpcodeRevert)]\\nunconstrained fn revert_opcode(revertdata: [Field]) {}\\n\\n#[oracle(avmOpcodeCall)]\\nunconstrained fn call_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) -> bool {}\\n\\n#[oracle(avmOpcodeStaticCall)]\\nunconstrained fn call_static_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) -> bool {}\\n\\n#[oracle(avmOpcodeStorageRead)]\\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\\n\\n#[oracle(avmOpcodeStorageWrite)]\\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\\n"},"96":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\\nuse dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::Hash,\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"103":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\\n};\\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\\n\\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\\n\\ntrait PublicStorageHistoricalRead {\\n    fn public_storage_historical_read(\\n        header: BlockHeader,\\n        storage_slot: Field,\\n        contract_address: AztecAddress,\\n    ) -> Field;\\n}\\n\\nimpl PublicStorageHistoricalRead for BlockHeader {\\n    fn public_storage_historical_read(\\n        self,\\n        storage_slot: Field,\\n        contract_address: AztecAddress,\\n    ) -> Field {\\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\\n        let public_data_tree_index = poseidon2_hash_with_separator(\\n            [contract_address.to_field(), storage_slot],\\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\\n        );\\n\\n        // 2) Get the membership witness for the tree index.\\n        /// Safety: The witness is only used as a \\"magical value\\" that makes the proof below pass. Hence it\'s safe.\\n        let witness = unsafe {\\n            get_public_data_witness(\\n                self.global_variables.block_number as u32,\\n                public_data_tree_index,\\n            )\\n        };\\n\\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\\n        // (slot, next index and next slot).\\n        assert_eq(\\n            self.state.partial.public_data_tree.root,\\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\\n            \\"Proving public value inclusion failed\\",\\n        );\\n\\n        // 4) Now that we know the preimage is valid, we determine the value that\'s represented by this tree entry. Here\\n        // we have two scenarios:\\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\\n        // 2. The entry was never initialized, and the value is default zero (the default)\\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\\n        let preimage = witness.leaf_preimage;\\n\\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\\n\\n        let value = if is_in_range {\\n            0\\n        } else {\\n            assert_eq(\\n                preimage.slot,\\n                public_data_tree_index,\\n                \\"Public data tree index doesn\'t match witness\\",\\n            );\\n            preimage.value\\n        };\\n\\n        value\\n    }\\n}\\n"},"120":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\\n};\\n\\nuse dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    merkle_tree::root::root_from_sibling_path,\\n};\\n\\npub fn process_l1_to_l2_message(\\n    l1_to_l2_root: Field,\\n    contract_address: AztecAddress,\\n    portal_contract_address: EthAddress,\\n    chain_id: Field,\\n    version: Field,\\n    content: Field,\\n    secret: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let secret_hash = compute_secret_hash(secret);\\n    let message_hash = compute_l1_to_l2_message_hash(\\n        portal_contract_address,\\n        chain_id,\\n        contract_address,\\n        version,\\n        content,\\n        secret_hash,\\n        leaf_index,\\n    );\\n\\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\\n    // get from an oracle.\\n    /// Safety: The witness is only used as a \\"magical value\\" that makes the merkle proof below pass. Hence it\'s safe.\\n    let (_leaf_index, sibling_path) =\\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\\n\\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\\n    assert_eq(root, l1_to_l2_root, \\"Message not in state\\");\\n\\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\\n}\\n"},"136":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\\n}\\n\\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\\n}\\n\\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\\n"},"138":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr","source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\\npub fn store(values: [Field]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\\n}\\n\\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\\n    let _ = store_in_execution_cache_oracle(values);\\n}\\n\\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\\n    load_from_execution_cache_oracle(hash)\\n}\\n\\n#[oracle(storeInExecutionCache)]\\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\\n\\n#[oracle(loadFromExecutionCache)]\\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\\n"},"140":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use crate::utils::array;\\nuse dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\\n\\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\\n/// its existence.\\npub unconstrained fn get_l1_to_l2_membership_witness(\\n    contract_address: AztecAddress,\\n    message_hash: Field,\\n    secret: Field,\\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\\n    let returned_message =\\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\\n    let leaf_index = returned_message[0];\\n    let sibling_path = array::subarray(returned_message, 1);\\n\\n    (leaf_index, sibling_path)\\n}\\n\\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\\n#[oracle(getL1ToL2MembershipWitness)]\\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\\n    _contract_address: AztecAddress,\\n    _message_hash: Field,\\n    _secret: Field,\\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\\n"},"143":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use crate::utils::array;\\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\\n\\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\\n\\npub struct PublicDataWitness {\\n    pub index: Field,\\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\\n}\\n\\n#[oracle(getPublicDataTreeWitness)]\\nunconstrained fn get_public_data_witness_oracle(\\n    _block_number: u32,\\n    _public_data_tree_index: Field,\\n) -> [Field; PUBLIC_DATA_WITNESS] {}\\n\\npub unconstrained fn get_public_data_witness(\\n    block_number: u32,\\n    public_data_tree_index: Field,\\n) -> PublicDataWitness {\\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\\n    PublicDataWitness {\\n        index: fields[0],\\n        leaf_preimage: PublicDataTreeLeafPreimage {\\n            slot: fields[1],\\n            value: fields[2],\\n            next_index: fields[3] as u32,\\n            next_slot: fields[4],\\n        },\\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\\n    }\\n}\\n"},"149":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            packed_note_content,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\\npub fn notify_created_nullifier(nullifier: Field) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n        note_hash,\\n        counter,\\n    );\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _packed_note_content: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\\n    let _ = notify_created_nullifier_oracle(nullifier);\\n}\\n\\n#[oracle(notifyCreatedNullifier)]\\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\\n) -> [Option<Note>; S]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    sync_notes_oracle_wrapper();\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let nonce = fields[read_offset];\\n            let note_hash_counter = fields[read_offset + 1] as u32;\\n            let note_content = array::subarray(fields, read_offset + 2);\\n\\n            let mut note = Note::unpack_content(note_content);\\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\\n\\n            placeholder_opt_notes[i] = Option::some(note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\\n/// for later querying via the `get_notes` oracle.\\npub fn sync_notes() {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        sync_notes_oracle_wrapper();\\n    }\\n}\\n\\nunconstrained fn sync_notes_oracle_wrapper() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n"},"155":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::Storage;\\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\\n\\n// docs:start:map\\npub struct Map<K, V, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n    state_var_constructor: fn(Context, Field) -> V,\\n}\\n// docs:end:map\\n\\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<K, V, Context> Map<K, V, Context> {\\n    // docs:start:new\\n    pub fn new(\\n        context: Context,\\n        storage_slot: Field,\\n        state_var_constructor: fn(Context, Field) -> V,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Map { context, storage_slot, state_var_constructor }\\n    }\\n    // docs:end:new\\n\\n    // docs:start:at\\n    pub fn at(self, key: K) -> V\\n    where\\n        K: ToField,\\n    {\\n        // TODO(#1204): use a generator index for the storage slot\\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\\n\\n        let state_var_constructor = self.state_var_constructor;\\n        state_var_constructor(self.context, derived_storage_slot)\\n    }\\n    // docs:end:at\\n}\\n"},"162":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{\\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\\n    history::public_storage::PublicStorageHistoricalRead,\\n    state_vars::storage::Storage,\\n};\\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\\n\\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\\n/// contexts.\\n// docs:start:public_immutable_struct\\npub struct PublicImmutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_immutable_struct\\n\\nimpl<T, Context, let N: u32> Storage<N> for PublicImmutable<T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<T, Context> PublicImmutable<T, Context> {\\n    // docs:start:public_immutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicImmutable { context, storage_slot }\\n    }\\n    // docs:end:public_immutable_struct_new\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    // docs:start:public_immutable_struct_write\\n    pub fn initialize(self, value: T) {\\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\\n        let init_field: Field = self.context.storage_read(initialization_slot);\\n        assert(init_field == 0, \\"PublicImmutable already initialized\\");\\n\\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\\n        self.context.storage_write(initialization_slot, 0xdead);\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n    // docs:end:public_immutable_struct_write\\n\\n    // Note that we don\'t access the context, but we do call oracles that are only available in public\\n    // docs:start:public_immutable_struct_read\\n    pub fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n    // docs:end:public_immutable_struct_read\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    pub unconstrained fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    pub fn read(self) -> T {\\n        let header = self.context.get_block_header();\\n        let mut fields = [0; T_PACKED_LEN];\\n\\n        for i in 0..fields.len() {\\n            fields[i] = header.public_storage_historical_read(\\n                self.storage_slot + i as Field,\\n                (*self.context).this_address(),\\n            );\\n        }\\n        T::unpack(fields)\\n    }\\n}\\n"},"163":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\\nuse crate::state_vars::storage::Storage;\\nuse dep::protocol_types::traits::Packable;\\n\\n// docs:start:public_mutable_struct\\npub struct PublicMutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_mutable_struct\\n\\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<T, Context> PublicMutable<T, Context> {\\n    // docs:start:public_mutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicMutable { context, storage_slot }\\n    }\\n    // docs:end:public_mutable_struct_new\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    // docs:start:public_mutable_struct_read\\n    pub fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n    // docs:end:public_mutable_struct_read\\n\\n    // docs:start:public_mutable_struct_write\\n    pub fn write(self, value: T) {\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n    // docs:end:public_mutable_struct_write\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    pub unconstrained fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n"},"183":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\\n/// of elements past `offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\\n/// assert_eq(foo, [3, 4]);\\n///\\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\\n/// ```\\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [T; SRC_LEN],\\n    offset: u32,\\n) -> [T; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"DST_LEN too large for offset\\");\\n\\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::subarray;\\n\\n    #[test]\\n    unconstrained fn subarray_into_empty() {\\n        // In all of these cases we\'re setting DST_LEN to be 0, so we always get back an emtpy array.\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_complete() {\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_different_end_sizes() {\\n        // We implicitly select how many values to read in the size of the return array\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subarray_offset_too_large() {\\n        // With an offset of 1 we can only request up to 4 elements\\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subarray_bad_return_value() {\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\\n    }\\n}\\n"},"250":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector,\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        MAX_FIELD_VALUE,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\\n    merkle_tree::membership::MembershipWitness,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::{\\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\\n    ops::Add,\\n};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\n/// We implement the Packable trait for AztecAddress because it can be stored in contract\'s storage (and there\\n/// the implementation of Packable is required).\\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_private_function(\\n        function_selector: FunctionSelector,\\n        function_vk_hash: Field,\\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\\n        contract_class_artifact_hash: Field,\\n        contract_class_public_bytecode_commitment: Field,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let private_functions_root = private_functions_root_from_siblings(\\n            function_selector,\\n            function_vk_hash,\\n            function_leaf_membership_witness.leaf_index,\\n            function_leaf_membership_witness.sibling_path,\\n        );\\n\\n        let contract_class_id = ContractClassId::compute(\\n            contract_class_artifact_hash,\\n            private_functions_root,\\n            contract_class_public_bytecode_commitment,\\n        );\\n\\n        // Compute contract address using the preimage which includes the class_id.\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --\x3e Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"251":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\\n    constants::ETH_ADDRESS_LENGTH,\\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\\n};\\n\\npub struct EthAddress {\\n    inner: Field,\\n}\\n\\nimpl Eq for EthAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for EthAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for EthAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\\n        EthAddress::from_field(fields[0])\\n    }\\n}\\n\\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl EthAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn from_field(field: Field) -> Self {\\n        field.assert_max_bit_size::<160>();\\n        Self { inner: field }\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"265":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{\\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\\n    traits::{Empty, Hash},\\n};\\n\\npub struct PublicDataTreeLeafPreimage {\\n    pub slot: Field,\\n    pub value: Field,\\n    pub next_slot: Field,\\n    pub next_index: u32,\\n}\\n\\nimpl Empty for PublicDataTreeLeafPreimage {\\n    fn empty() -> Self {\\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\\n    }\\n}\\n\\nimpl Eq for PublicDataTreeLeafPreimage {\\n    fn eq(self, other: Self) -> bool {\\n        (self.slot == other.slot)\\n            & (self.value == other.value)\\n            & (self.next_slot == other.next_slot)\\n            & (self.next_index == other.next_index)\\n    }\\n}\\n\\nimpl Hash for PublicDataTreeLeafPreimage {\\n    fn hash(self) -> Field {\\n        if self.is_empty() {\\n            0\\n        } else {\\n            crate::hash::poseidon2_hash([\\n                self.slot,\\n                self.value,\\n                (self.next_index as Field),\\n                self.next_slot,\\n            ])\\n        }\\n    }\\n}\\n\\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\\n    fn get_key(self) -> Field {\\n        self.slot\\n    }\\n\\n    fn as_leaf(self) -> Field {\\n        self.hash()\\n    }\\n}\\n\\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\\n    fn get_next_key(self) -> Field {\\n        self.next_slot\\n    }\\n\\n    fn points_to_infinity(self) -> bool {\\n        (self.next_slot == 0) & (self.next_index == 0)\\n    }\\n\\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\\n    }\\n\\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\\n        Self {\\n            slot: self.slot,\\n            value: write.value,\\n            next_slot: self.next_slot,\\n            next_index: self.next_index,\\n        }\\n    }\\n\\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\\n        Self {\\n            slot: write.slot,\\n            value: write.value,\\n            next_slot: low_leaf.next_slot,\\n            next_index: low_leaf.next_index,\\n        }\\n    }\\n}\\n\\nimpl PublicDataTreeLeafPreimage {\\n    pub fn is_empty(self) -> bool {\\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\\n    }\\n}\\n"},"266":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"267":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        function_selector::FunctionSelector,\\n        log_hash::{LogHash, ScopedLogHash},\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, is_empty, ToField},\\n    utils::field::field_from_bytes_32_trunc,\\n};\\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; N * 32];\\n    for offset in 0..N {\\n        // TODO: This is not checking that the decomposition is smaller than P\\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"277":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\\n\\n// Calculate the Merkle tree root from the sibling path and leaf.\\n//\\n// The leaf is hashed with its sibling, and then the result is hashed\\n// with the next sibling etc in the path. The last hash is the root.\\n//\\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\\n// TODO a bit simpler in Noir to just have a bit array.\\n// TODO: I\'d generally like to avoid u256 for algorithms like\\n// this because it means we never even need to consider cases where\\n// the index is greater than p.\\npub fn root_from_sibling_path<let N: u32>(\\n    leaf: Field,\\n    leaf_index: Field,\\n    sibling_path: [Field; N],\\n) -> Field {\\n    let mut node = leaf;\\n    let indices: [u1; N] = leaf_index.to_le_bits();\\n\\n    for i in 0..N {\\n        let (hash_left, hash_right) = if indices[i] == 1 {\\n            (sibling_path[i], node)\\n        } else {\\n            (node, sibling_path[i])\\n        };\\n        node = merkle_hash(hash_left, hash_right);\\n    }\\n    node\\n}\\n\\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\\n    MerkleTree::new(leaves).get_root()\\n}\\n\\n// These values are precomputed and we run tests to ensure that they\\n// are correct. The values themselves were computed from the cpp code.\\n//\\n// Would be good if we could use width since the compute_subtree\\n// algorithm uses depth.\\npub fn calculate_empty_tree_root(depth: u32) -> Field {\\n    if depth == 0 {\\n        0\\n    } else if depth == 1 {\\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\\n    } else if depth == 2 {\\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\\n    } else if depth == 3 {\\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\\n    } else if depth == 4 {\\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\\n    } else if depth == 5 {\\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\\n    } else if depth == 6 {\\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\\n    } else if depth == 7 {\\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\\n    } else if depth == 8 {\\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\\n    } else if depth == 9 {\\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\\n    } else if depth == 10 {\\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\\n    } else {\\n        panic(f\\"depth should be between 0 and 10\\")\\n    }\\n}\\n\\n#[test]\\nfn test_merkle_root_interop_test() {\\n    // This is a test to ensure that we match the cpp implementation.\\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\\n    // to find the test that matches this.\\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\\n\\n    let empty_root = calculate_subtree_root([0; 16]);\\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\\n}\\n\\n#[test]\\nfn test_empty_subroot() {\\n    assert(calculate_empty_tree_root(0) == 0);\\n\\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\\n\\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\\n\\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\\n\\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\\n\\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\\n\\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\\n\\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\\n\\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\\n\\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\\n\\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\\n}\\n"},"284":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"296":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\\n\\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\\nwhere\\n    K: ToField,\\n{\\n    poseidon2_hash([storage_slot, key.to_field()])\\n}\\n\\nmod test {\\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\\n\\n    #[test]\\n    fn test_derive_storage_slot_in_map_matches_typescript() {\\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\\n        let key = AztecAddress::from_field(\\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\\n        );\\n\\n        let slot = derive_storage_slot_in_map(map_slot, key);\\n\\n        // The following value was generated by `map_slot.test.ts`\\n        let slot_from_typescript =\\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\\n\\n        assert_eq(slot, slot_from_typescript);\\n    }\\n}\\n"},"309":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\\nuse crate::utils::field::field_from_bytes;\\n\\n// Trait: is_empty\\n//\\n// The general is_empty trait checks if a data type is is empty,\\n// and it defines empty for the basic data types as 0.\\n//\\n// If a Field is equal to zero, then it is regarded as zero.\\n// We will go with this definition for now, however it can be problematic\\n// if a value can actually be zero. In a future refactor, we can\\n// use the optional type for safety. Doing it now would lead to a worse devex\\n// and would make it harder to sync up with the cpp code.\\n// Preferred over Default trait to convey intent, as default doesn\'t necessarily mean empty.\\npub trait Empty {\\n    fn empty() -> Self;\\n}\\n\\nimpl Empty for Field {\\n    fn empty() -> Self {\\n        0\\n    }\\n}\\n\\nimpl Empty for u1 {\\n    fn empty() -> Self {\\n        0\\n    }\\n}\\nimpl Empty for u8 {\\n    fn empty() -> Self {\\n        0\\n    }\\n}\\nimpl Empty for u32 {\\n    fn empty() -> Self {\\n        0\\n    }\\n}\\nimpl Empty for u64 {\\n    fn empty() -> Self {\\n        0\\n    }\\n}\\nimpl Empty for U128 {\\n    fn empty() -> Self {\\n        U128::from_integer(0)\\n    }\\n}\\n\\npub fn is_empty<T>(item: T) -> bool\\nwhere\\n    T: Empty + Eq,\\n{\\n    item.eq(T::empty())\\n}\\n\\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\\nwhere\\n    T: Empty + Eq,\\n{\\n    array.all(|elem| is_empty(elem))\\n}\\n\\npub trait Hash {\\n    fn hash(self) -> Field;\\n}\\n\\npub trait ToField {\\n    fn to_field(self) -> Field;\\n}\\n\\nimpl ToField for Field {\\n    fn to_field(self) -> Field {\\n        self\\n    }\\n}\\n\\nimpl ToField for bool {\\n    fn to_field(self) -> Field {\\n        self as Field\\n    }\\n}\\nimpl ToField for u1 {\\n    fn to_field(self) -> Field {\\n        self as Field\\n    }\\n}\\nimpl ToField for u8 {\\n    fn to_field(self) -> Field {\\n        self as Field\\n    }\\n}\\nimpl ToField for u32 {\\n    fn to_field(self) -> Field {\\n        self as Field\\n    }\\n}\\nimpl ToField for u64 {\\n    fn to_field(self) -> Field {\\n        self as Field\\n    }\\n}\\nimpl ToField for U128 {\\n    fn to_field(self) -> Field {\\n        self.to_integer()\\n    }\\n}\\nimpl<let N: u32> ToField for str<N> {\\n    fn to_field(self) -> Field {\\n        assert(N < 32, \\"String doesn\'t fit in a field, consider using Serialize instead\\");\\n        field_from_bytes(self.as_bytes(), true)\\n    }\\n}\\n\\npub trait FromField {\\n    fn from_field(value: Field) -> Self;\\n}\\n\\nimpl FromField for Field {\\n    fn from_field(value: Field) -> Self {\\n        value\\n    }\\n}\\n\\nimpl FromField for bool {\\n    fn from_field(value: Field) -> Self {\\n        value as bool\\n    }\\n}\\nimpl FromField for u1 {\\n    fn from_field(value: Field) -> Self {\\n        value as u1\\n    }\\n}\\nimpl FromField for u8 {\\n    fn from_field(value: Field) -> Self {\\n        value as u8\\n    }\\n}\\nimpl FromField for u32 {\\n    fn from_field(value: Field) -> Self {\\n        value as u32\\n    }\\n}\\nimpl FromField for u64 {\\n    fn from_field(value: Field) -> Self {\\n        value as u64\\n    }\\n}\\nimpl FromField for U128 {\\n    fn from_field(value: Field) -> Self {\\n        U128::from_integer(value)\\n    }\\n}\\n\\n// docs:start:serialize\\n/// Trait for serializing Noir types into arrays of Fields.\\n///\\n/// An implementation of the Serialize trait has to follow Noir\'s intrinsic serialization (each member of a struct\\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\\n///\\n/// # On Following Noir\'s Intrinsic Serialization\\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\\n/// of fields. This array is then included in the initial witness. Noir\'s intrinsic serialization is then used\\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\\n/// Noir\'s intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\\n/// fail with an arguments hash mismatch error message.\\n///\\n/// # Type Parameters\\n/// * `N` - The length of the output Field array, known at compile time\\n///\\n/// # Example\\n/// ```\\n/// impl<let N: u32> Serialize<N> for str<N> {\\n///     fn serialize(self) -> [Field; N] {\\n///         let bytes = self.as_bytes();\\n///         let mut fields = [0; N];\\n///         for i in 0..bytes.len() {\\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\\n///         }\\n///         fields\\n///     }\\n/// }\\n/// ```\\n#[derive_via(derive_serialize)]\\npub trait Serialize<let N: u32> {\\n    fn serialize(self) -> [Field; N];\\n}\\n// docs:end:serialize\\n\\nimpl<let N: u32> Serialize<N> for str<N> {\\n    fn serialize(self) -> [Field; N] {\\n        let bytes = self.as_bytes();\\n        let mut fields = [0; N];\\n        for i in 0..bytes.len() {\\n            fields[i] = bytes[i] as Field;\\n        }\\n        fields\\n    }\\n}\\n\\n// docs:start:deserialize\\n/// Trait for deserializing Noir types from arrays of Fields.\\n///\\n/// An implementation of the Deserialize trait has to follow Noir\'s intrinsic serialization (each member of a struct\\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\\n///\\n/// # Type Parameters\\n/// * `N` - The length of the input Field array, known at compile time\\n///\\n/// # Example\\n/// ```\\n/// impl<let N: u32> Deserialize<N> for str<N> {\\n///     fn deserialize(fields: [Field; N]) -> Self {\\n///         str<N>::from(fields.map(|value| value as u8))\\n///     }\\n/// }\\n/// ```\\n#[derive_via(derive_deserialize)]\\npub trait Deserialize<let N: u32> {\\n    fn deserialize(fields: [Field; N]) -> Self;\\n}\\n// docs:end:deserialize\\n\\nimpl<let N: u32> Deserialize<N> for str<N> {\\n    fn deserialize(fields: [Field; N]) -> Self {\\n        str<N>::from(fields.map(|value| value as u8))\\n    }\\n}\\n\\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\\n///\\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\\n/// in the contract\'s public storage).\\n///\\n/// # Type Parameters\\n/// * `N` - The length of the Field array, known at compile time.\\n#[derive_via(derive_packable)]\\npub trait Packable<let N: u32> {\\n    /// Packs the current value into a compact array of `Field` elements.\\n    fn pack(self) -> [Field; N];\\n\\n    /// Unpacks a compact array of `Field` elements into the original value.\\n    fn unpack(fields: [Field; N]) -> Self;\\n}\\n"},"313":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::{Packable, ToField};\\n\\nglobal BOOL_PACKED_LEN: u32 = 1;\\nglobal U8_PACKED_LEN: u32 = 1;\\nglobal U16_PACKED_LEN: u32 = 1;\\nglobal U32_PACKED_LEN: u32 = 1;\\nglobal U64_PACKED_LEN: u32 = 1;\\nglobal U128_PACKED_LEN: u32 = 1;\\nglobal FIELD_PACKED_LEN: u32 = 1;\\nglobal I8_PACKED_LEN: u32 = 1;\\nglobal I16_PACKED_LEN: u32 = 1;\\nglobal I32_PACKED_LEN: u32 = 1;\\nglobal I64_PACKED_LEN: u32 = 1;\\n\\nimpl Packable<BOOL_PACKED_LEN> for bool {\\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Packable<U8_PACKED_LEN> for u8 {\\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Packable<U16_PACKED_LEN> for u16 {\\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Packable<U32_PACKED_LEN> for u32 {\\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Packable<U64_PACKED_LEN> for u64 {\\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Packable<U128_PACKED_LEN> for U128 {\\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\\n        [self.to_field()]\\n    }\\n\\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\\n        U128::from_integer(fields[0])\\n    }\\n}\\n\\nimpl Packable<FIELD_PACKED_LEN> for Field {\\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\\n        [self]\\n    }\\n\\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Packable<I8_PACKED_LEN> for i8 {\\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Packable<I16_PACKED_LEN> for i16 {\\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Packable<I32_PACKED_LEN> for i32 {\\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Packable<I64_PACKED_LEN> for i64 {\\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\\nwhere\\n    T: Packable<M>,\\n{\\n    fn pack(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].pack();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n\\n    fn unpack(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_packing() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i8_packing() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i16_packing() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i32_packing() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i64_packing() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::unpack(a.pack()));\\n}\\n"},"314":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\\n\\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\\nglobal U8_SERIALIZED_LEN: u32 = 1;\\nglobal U16_SERIALIZED_LEN: u32 = 1;\\nglobal U32_SERIALIZED_LEN: u32 = 1;\\nglobal U64_SERIALIZED_LEN: u32 = 1;\\nglobal U128_SERIALIZED_LEN: u32 = 2;\\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\\nglobal I8_SERIALIZED_LEN: u32 = 1;\\nglobal I16_SERIALIZED_LEN: u32 = 1;\\nglobal I32_SERIALIZED_LEN: u32 = 1;\\nglobal I64_SERIALIZED_LEN: u32 = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\\n        // This is necessary because of how Noir handles serialization:\\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\\n        //   first.\\n        // For this reason if we didn\'t use the ordering of U128 limbs here and in encoder.ts we would get an arguments\\n        // hash mismatch.\\n        [self.lo, self.hi]\\n    }\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\\nwhere\\n    T: Serialize<M>,\\n{\\n    fn serialize(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].serialize();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\\nwhere\\n    T: Deserialize<M>,\\n{\\n    fn deserialize(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_serialization() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i8_serialization() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i16_serialization() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i32_serialization() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i64_serialization() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::deserialize(a.serialize()));\\n}\\n"},"331":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\\n    assert(bytes.len() < 32, \\"field_from_bytes: N must be less than 32\\");\\n    let mut as_field = 0;\\n    let mut offset = 1;\\n    for i in 0..N {\\n        let mut index = i;\\n        if big_endian {\\n            index = N - i - 1;\\n        }\\n        as_field += (bytes[index] as Field) * offset;\\n        offset *= 256;\\n    }\\n\\n    as_field\\n}\\n\\n// Convert a 32 byte array to a field element by truncating the final byte\\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..15 {\\n        // covers bytes 16..30 (31 is truncated and ignored)\\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\\n        v = v * 256;\\n        // covers bytes 0..14\\n        high = high + (bytes32[14 - i] as Field) * v;\\n    }\\n    // covers byte 15\\n    low = low + (bytes32[15] as Field) * v;\\n\\n    low + high * v\\n}\\n\\n// TODO to radix returns u8, so we cannot use bigger radixes. It\'d be ideal to use a radix of the maximum range-constrained integer noir supports\\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\\n    lhs.lt(rhs)\\n}\\n\\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\\n    rhs.lt(lhs)\\n}\\n\\npub fn min(f1: Field, f2: Field) -> Field {\\n    if f1.lt(f2) {\\n        f1\\n    } else {\\n        f2\\n    }\\n}\\n\\n#[test]\\nunconstrained fn bytes_field_test() {\\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\\n    let inputs = [\\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\\n    ];\\n    let field = field_from_bytes(inputs, true);\\n    let return_bytes: [u8; 31] = field.to_be_bytes();\\n    assert_eq(inputs, return_bytes);\\n    // 32 bytes - we remove the final byte, and check it matches the field\\n    let inputs2 = [\\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\\n    ];\\n    let field2 = field_from_bytes_32_trunc(inputs2);\\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\\n\\n    assert_eq(return_bytes2, return_bytes);\\n    assert_eq(field2, field);\\n}\\n\\n#[test]\\nunconstrained fn max_field_test() {\\n    // Tests the hardcoded value in constants.nr vs underlying modulus\\n    // NB: We can\'t use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\\n    let max_value = crate::constants::MAX_FIELD_VALUE;\\n    assert_eq(max_value, 0 - 1);\\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\\n    let mod_bytes = std::field::modulus_be_bytes();\\n    for i in 0..31 {\\n        assert_eq(max_bytes[i], mod_bytes[i]);\\n    }\\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\\n}\\n"},"333":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"344":{"path":"/root/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr","source":"use std::hash::sha256_compression;\\nuse std::runtime::is_unconstrained;\\n\\nmod tests;\\n\\n// Implementation of SHA-256 mapping a byte array of variable length to\\n// 32 bytes.\\n\\n// A message block is up to 64 bytes taken from the input.\\nglobal BLOCK_SIZE: u32 = 64;\\n\\n// The first index in the block where the 8 byte message size will be written.\\nglobal MSG_SIZE_PTR: u32 = 56;\\n\\n// Size of the message block when packed as 4-byte integer array.\\nglobal INT_BLOCK_SIZE: u32 = 16;\\n\\n// A `u32` integer consists of 4 bytes.\\nglobal INT_SIZE: u32 = 4;\\n\\n// Index of the integer in the `INT_BLOCK` where the length is written.\\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\\n\\n// Magic numbers for bit shifting.\\n// Works with actual bit shifting as well as the compiler turns them into * and /\\n// but circuit execution appears to be 10% faster this way.\\nglobal TWO_POW_8: u32 = 256;\\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\\n\\n// Index of a byte in a 64 byte block; ie. 0..=63\\ntype BLOCK_BYTE_PTR = u32;\\n\\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\\n\\n// A message block is a slice of the original message of a fixed size,\\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\\ntype MSG_BLOCK = INT_BLOCK;\\n\\n// The hash is 32 bytes.\\ntype HASH = [u8; 32];\\n\\n// The state accumulates the blocks.\\n// Its overall size is the same as the `HASH`.\\ntype STATE = [u32; 8];\\n\\n// Deprecated in favour of `sha256_var`\\n// docs:start:sha256\\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\\n// docs:end:sha256\\n{\\n    digest(input)\\n}\\n\\n// SHA-256 hash function\\n#[no_predicates]\\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\\n    sha256_var(msg, N as u64)\\n}\\n\\n// Variable size SHA-256 hash\\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\\n    let message_size = message_size as u32;\\n    let num_blocks = N / BLOCK_SIZE;\\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\\n    // Intermediate hash, starting with the canonical initial value\\n    let mut h: STATE = [\\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\\n        1541459225,\\n    ];\\n    // Pointer into msg_block on a 64 byte scale\\n    let mut msg_byte_ptr = 0;\\n    for i in 0..num_blocks {\\n        let msg_start = BLOCK_SIZE * i;\\n        let (new_msg_block, new_msg_byte_ptr) =\\n            unsafe { build_msg_block(msg, message_size, msg_start) };\\n\\n        if msg_start < message_size {\\n            msg_block = new_msg_block;\\n        }\\n\\n        if !is_unconstrained() {\\n            // Verify the block we are compressing was appropriately constructed\\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\\n            if msg_start < message_size {\\n                msg_byte_ptr = new_msg_byte_ptr;\\n            }\\n        } else if msg_start < message_size {\\n            msg_byte_ptr = new_msg_byte_ptr;\\n        }\\n\\n        // If the block is filled, compress it.\\n        // An un-filled block is handled after this loop.\\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\\n            h = sha256_compression(msg_block, h);\\n        }\\n    }\\n\\n    let modulo = N % BLOCK_SIZE;\\n    // Handle setup of the final msg block.\\n    // This case is only hit if the msg is less than the block size,\\n    // or our message cannot be evenly split into blocks.\\n    if modulo != 0 {\\n        let msg_start = BLOCK_SIZE * num_blocks;\\n        let (new_msg_block, new_msg_byte_ptr) =\\n            unsafe { build_msg_block(msg, message_size, msg_start) };\\n\\n        if msg_start < message_size {\\n            msg_block = new_msg_block;\\n        }\\n\\n        if !is_unconstrained() {\\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\\n            if msg_start < message_size {\\n                msg_byte_ptr = new_msg_byte_ptr;\\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\\n            }\\n        } else if msg_start < message_size {\\n            msg_byte_ptr = new_msg_byte_ptr;\\n        }\\n    }\\n\\n    // If we had modulo == 0 then it means the last block was full,\\n    // and we can reset the pointer to zero to overwrite it.\\n    if msg_byte_ptr == BLOCK_SIZE {\\n        msg_byte_ptr = 0;\\n    }\\n\\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\\n    // Here we rely on the fact that everything beyond the available input is set to 0.\\n    msg_block = update_block_item(\\n        msg_block,\\n        msg_byte_ptr,\\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\\n    );\\n    msg_byte_ptr = msg_byte_ptr + 1;\\n    let last_block = msg_block;\\n\\n    // If we don\'t have room to write the size, compress the block and reset it.\\n    if msg_byte_ptr > MSG_SIZE_PTR {\\n        h = sha256_compression(msg_block, h);\\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\\n        msg_byte_ptr = 0;\\n    }\\n\\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\\n\\n    if !is_unconstrained() {\\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\\n    }\\n\\n    hash_final_block(msg_block, h)\\n}\\n\\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\\n// Returns the block and the length that has been copied rather than padded with zeros.\\nunconstrained fn build_msg_block<let N: u32>(\\n    msg: [u8; N],\\n    message_size: u32,\\n    msg_start: u32,\\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\\n\\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\\n        if message_size < msg_start {\\n            // This function is sometimes called with `msg_start` past the end of the message.\\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\\n            0\\n        } else {\\n            message_size - msg_start\\n        }\\n    } else {\\n        BLOCK_SIZE\\n    };\\n\\n    // Figure out the number of items in the int array that we have to pack.\\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\\n    let mut int_input = block_input / INT_SIZE;\\n    if block_input % INT_SIZE != 0 {\\n        int_input = int_input + 1;\\n    };\\n\\n    for i in 0..int_input {\\n        let mut msg_item: u32 = 0;\\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\\n        for j in 0..INT_SIZE {\\n            let k = i * INT_SIZE + j;\\n            let msg_byte = if k < block_input {\\n                msg[msg_start + k]\\n            } else {\\n                0\\n            };\\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\\n        }\\n        msg_block[i] = msg_item;\\n    }\\n\\n    // Returning the index as if it was a 64 byte array.\\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\\n    (msg_block, block_input)\\n}\\n\\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\\n// and matches the input data. Returns the index of the first unset item.\\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\\n// in that case we can skip verification, ie. no need to check that everything is zero.\\nfn verify_msg_block<let N: u32>(\\n    msg: [u8; N],\\n    message_size: u32,\\n    msg_block: MSG_BLOCK,\\n    msg_start: u32,\\n) -> BLOCK_BYTE_PTR {\\n    let mut msg_byte_ptr = 0;\\n    let mut msg_end = msg_start + BLOCK_SIZE;\\n    if msg_end > N {\\n        msg_end = N;\\n    }\\n    // We might have to go beyond the input to pad the fields.\\n    if msg_end % INT_SIZE != 0 {\\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\\n    }\\n\\n    // Reconstructed packed item.\\n    let mut msg_item: u32 = 0;\\n\\n    // Inclusive at the end so that we can compare the last item.\\n    let mut i: u32 = 0;\\n    for k in msg_start..=msg_end {\\n        if k % INT_SIZE == 0 {\\n            // If we consumed some input we can compare against the block.\\n            if (msg_start < message_size) & (k > msg_start) {\\n                assert_eq(msg_block[i], msg_item as u32);\\n                i = i + 1;\\n                msg_item = 0;\\n            }\\n        }\\n        // Shift the accumulator\\n        msg_item = lshift8(msg_item, 1);\\n        // If we have input to consume, add it at the rightmost position.\\n        if k < message_size & k < msg_end {\\n            msg_item = msg_item + msg[k] as u32;\\n            msg_byte_ptr = msg_byte_ptr + 1;\\n        }\\n    }\\n\\n    msg_byte_ptr\\n}\\n\\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\\n// This is only relevant for the last, potentially partially filled block.\\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\\n    // Check all the way to the end of the block.\\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\\n}\\n\\n// Verify that a region of ints in the message block are (partially) zeroed,\\n// up to an (exclusive) maximum which can either be the end of the block\\n// or just where the size is to be written.\\nfn verify_msg_block_zeros(\\n    msg_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n    max_int_byte_ptr: u32,\\n) {\\n    // This variable is used to get around the compiler under-constrained check giving a warning.\\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\\n    // or return values the compiler check will issue a warning.\\n    let zero = msg_block[0] - msg_block[0];\\n\\n    // First integer which is supposed to be (partially) zero.\\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\\n\\n    // Check partial zeros.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        let zeros = INT_SIZE - modulo;\\n        let mask = if zeros == 3 {\\n            TWO_POW_24\\n        } else if zeros == 2 {\\n            TWO_POW_16\\n        } else {\\n            TWO_POW_8\\n        };\\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\\n        int_byte_ptr = int_byte_ptr + 1;\\n    }\\n\\n    // Check the rest of the items.\\n    for i in 0..max_int_byte_ptr {\\n        if i >= int_byte_ptr {\\n            assert_eq(msg_block[i], zero);\\n        }\\n    }\\n}\\n\\n// Verify that up to the byte pointer the two blocks are equal.\\n// At the byte pointer the new block can be partially zeroed.\\nfn verify_msg_block_equals_last(\\n    msg_block: MSG_BLOCK,\\n    last_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n) {\\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\\n    // First integer which is supposed to be (partially) zero contains that pointer.\\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\\n\\n    // Check partial zeros.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        // Reconstruct the partially zero item from the last block.\\n        let last_field = last_block[int_byte_ptr];\\n        let mut msg_item: u32 = 0;\\n        // Reset to where they are still equal.\\n        msg_byte_ptr = msg_byte_ptr - modulo;\\n        for i in 0..INT_SIZE {\\n            msg_item = lshift8(msg_item, 1);\\n            if i < modulo {\\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\\n                msg_byte_ptr = msg_byte_ptr + 1;\\n            }\\n        }\\n        assert_eq(msg_block[int_byte_ptr], msg_item);\\n    }\\n\\n    for i in 0..INT_SIZE_PTR {\\n        if i < int_byte_ptr {\\n            assert_eq(msg_block[i], last_block[i]);\\n        }\\n    }\\n}\\n\\n// Apply a function on the block item which the pointer indicates.\\nfn update_block_item<Env>(\\n    mut msg_block: MSG_BLOCK,\\n    msg_byte_ptr: BLOCK_BYTE_PTR,\\n    f: fn[Env](u32) -> u32,\\n) -> MSG_BLOCK {\\n    let i = msg_byte_ptr / INT_SIZE;\\n    msg_block[i] = f(msg_block[i]);\\n    msg_block\\n}\\n\\n// Set the rightmost `zeros` number of bytes to 0.\\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\\n    lshift8(rshift8(item, zeros), zeros)\\n}\\n\\n// Replace one byte in the item with a value, and set everything after it to zero.\\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\\n    zeroed_item + new_item\\n}\\n\\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\\n    // How many times do we have to shift to the right to get to the position we want?\\n    let max_shifts = INT_SIZE - 1;\\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\\n    msg_item = rshift8(msg_item, shifts as u8);\\n    // At this point the byte we want is in the rightmost position.\\n    msg_item as u8\\n}\\n\\n// Project a byte into a position in a field based on the overall block pointer.\\n// For example putting 1 into pointer 5 would be 100, because overall we would\\n// have [____, 0100] with indexes [0123,4567].\\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\\n    let mut msg_item = msg_byte as u32;\\n    // How many times do we have to shift to the left to get to the position we want?\\n    let max_shifts = INT_SIZE - 1;\\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\\n    lshift8(msg_item, shifts as u8)\\n}\\n\\n// Construct a field out of 4 bytes.\\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\\n    let mut item = b0 as u32;\\n    item = lshift8(item, 1) + b1 as u32;\\n    item = lshift8(item, 1) + b2 as u32;\\n    item = lshift8(item, 1) + b3 as u32;\\n    item\\n}\\n\\n// Shift by 8 bits to the left between 0 and 4 times.\\n// Checks `is_unconstrained()` to just use a bitshift if we\'re running in an unconstrained context,\\n// otherwise multiplies by 256.\\nfn lshift8(item: u32, shifts: u8) -> u32 {\\n    if is_unconstrained() {\\n        if item == 0 {\\n            0\\n        } else {\\n            // Brillig wouldn\'t shift 0<<4 without overflow.\\n            item << (8 * shifts)\\n        }\\n    } else {\\n        // We can do a for loop up to INT_SIZE or an if-else.\\n        if shifts == 0 {\\n            item\\n        } else if shifts == 1 {\\n            item * TWO_POW_8\\n        } else if shifts == 2 {\\n            item * TWO_POW_16\\n        } else if shifts == 3 {\\n            item * TWO_POW_24\\n        } else {\\n            // Doesn\'t make sense, but it\'s most likely called on 0 anyway.\\n            0\\n        }\\n    }\\n}\\n\\n// Shift by 8 bits to the right between 0 and 4 times.\\n// Checks `is_unconstrained()` to just use a bitshift if we\'re running in an unconstrained context,\\n// otherwise divides by 256.\\nfn rshift8(item: u32, shifts: u8) -> u32 {\\n    if is_unconstrained() {\\n        item >> (8 * shifts)\\n    } else {\\n        // Division wouldn\'t work on `Field`.\\n        if shifts == 0 {\\n            item\\n        } else if shifts == 1 {\\n            item / TWO_POW_8\\n        } else if shifts == 2 {\\n            item / TWO_POW_16\\n        } else if shifts == 3 {\\n            item / TWO_POW_24\\n        } else {\\n            0\\n        }\\n    }\\n}\\n\\n// Zero out all bytes between the end of the message and where the length is appended,\\n// then write the length into the last 8 bytes of the block.\\nunconstrained fn attach_len_to_msg_block(\\n    mut msg_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n    message_size: u32,\\n) -> MSG_BLOCK {\\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\\n    // There can be one item which has to be partially zeroed.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        // Index of the block in which we find the item we need to partially zero.\\n        let i = msg_byte_ptr / INT_SIZE;\\n        let zeros = INT_SIZE - modulo;\\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\\n        msg_byte_ptr = msg_byte_ptr + zeros;\\n    }\\n\\n    // The rest can be zeroed without bit shifting anything.\\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\\n        msg_block[i] = 0;\\n    }\\n\\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\\n    let len = 8 * message_size;\\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\\n    for i in 0..=1 {\\n        let shift = i * 4;\\n        msg_block[INT_SIZE_PTR + i] = make_item(\\n            len_bytes[shift],\\n            len_bytes[shift + 1],\\n            len_bytes[shift + 2],\\n            len_bytes[shift + 3],\\n        );\\n    }\\n    msg_block\\n}\\n\\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\\n// and that everything between the byte pointer and the size pointer was zeroed,\\n// and that everything before the byte pointer was untouched.\\nfn verify_msg_len(\\n    msg_block: MSG_BLOCK,\\n    last_block: MSG_BLOCK,\\n    msg_byte_ptr: BLOCK_BYTE_PTR,\\n    message_size: u32,\\n) {\\n    // Check zeros up to the size pointer.\\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\\n\\n    // Check that up to the pointer we match the last block.\\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\\n\\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\\n    let mut reconstructed_len: u64 = 0;\\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\\n        reconstructed_len = reconstructed_len * TWO_POW_32;\\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\\n    }\\n    let len = 8 * message_size as u64;\\n    assert_eq(reconstructed_len, len);\\n}\\n\\n// Perform the final compression, then transform the `STATE` into `HASH`.\\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\\n    // Hash final padded block\\n    state = sha256_compression(msg_block, state);\\n\\n    // Return final hash as byte array\\n    for j in 0..8 {\\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\\n        for k in 0..4 {\\n            out_h[4 * j + k] = h_bytes[k];\\n        }\\n    }\\n\\n    out_h\\n}\\n\\n"}}}')),function(e){const t={};for(const n in e)e[n]&&void 0!==e[n].defaultValue&&(t[n]=e[n].defaultValue)}({gasLimitBufferPercentage:{description:"How much to increase calculated gas limit by (percentage)",env:"L1_GAS_LIMIT_BUFFER_PERCENTAGE",...ze(20)},minGwei:{description:"Minimum gas price in gwei",env:"L1_GAS_PRICE_MIN",...Be(1n)},maxGwei:{description:"Maximum gas price in gwei",env:"L1_GAS_PRICE_MAX",...Be(100n)},maxBlobGwei:{description:"Maximum blob fee per gas in gwei",env:"L1_BLOB_FEE_PER_GAS_MAX",...Be(1500n)},priorityFeeBumpPercentage:{description:"How much to increase priority fee by each attempt (percentage)",env:"L1_PRIORITY_FEE_BUMP_PERCENTAGE",...ze(20)},priorityFeeRetryBumpPercentage:{description:"How much to increase priority fee by each retry attempt (percentage)",env:"L1_PRIORITY_FEE_RETRY_BUMP_PERCENTAGE",...ze(50)},fixedPriorityFeePerGas:{description:"Fixed priority fee per gas in Gwei. Overrides any priority fee bump percentage",env:"L1_FIXED_PRIORITY_FEE_PER_GAS",...ze(0)},maxAttempts:{description:"Maximum number of speed-up attempts",env:"L1_TX_MONITOR_MAX_ATTEMPTS",...ze(3)},checkIntervalMs:{description:"How often to check tx status",env:"L1_TX_MONITOR_CHECK_INTERVAL_MS",...ze(1e4)},stallTimeMs:{description:"How long before considering tx stalled",env:"L1_TX_MONITOR_STALL_TIME_MS",...ze(45e3)},txTimeoutMs:{description:"How long to wait for a tx to be mined before giving up. Set to 0 to disable.",env:"L1_TX_MONITOR_TX_TIMEOUT_MS",...ze(3e5)},txPropagationMaxQueryAttempts:{description:"How many attempts will be done to get a tx after it was sent",env:"L1_TX_PROPAGATION_MAX_QUERY_ATTEMPTS",...ze(3)}});const Ky=ry(JSON.parse('{"transpiled":true,"noir_version":"1.0.0-beta.1+c4e38215cedb5afb","name":"SchnorrAccount","functions":[{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"field"},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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eG863quN90Hjvbx4byve64n3PuK9gHhvHN4rhvdO4b1EeG8N3muC917gvQh4bR6vVeO1W7yWidf28FoXXvvBayF4bQDXynHtGNdScW0R19pw7QnXYnBtArU6alfUcqhtsNYfOLZ8yOG9yrjNnRu3VVILNv/v63hvL97rivd+4r2QeG8g3iuH947hvVR4bxHea4P3nuC9GHhvAl6rx2vXeC0Xr23itT689oXXgvDaCF4rwLVzXEvGtVVca8S1t+FgI8BmBkPtjloWtR1qHbx/fk6wuXLjb+dq+5NU/k7x4RLT7PD4Jcvo561R+XvOZTPeNN2HAzfUX1uzzmvr1Xltgzqv7Vb5u+QcL2xw8YAxP+qvjan8/XrmWRefdPV/6f+3HVCHw1F1XjutDpYz6rx2Tp3Xzqvz2mV1XruizmvX1nnt+jqv3VzntVvrvHZvndfur/Pag3Vee7jOa0/Uee2pOq/NMKj2azPVeW3OOq/NXee1eeu8Nn+d15w6r+XrvObVeS2o89oidV5brM5ry9V5bYU6r61a57XV67x2VefYvwfP8v2k11526mz6a7t3137fnnVe27fOa/vVee2wOq8dUee1Y+u8dnyd106u89qpdV47t85r59d57cI6r11c57Ur6rx2VZ3Xrqm8lpZ3Zxxc+7XhldeeOPGZhy89tBjpr81c532z1nnf7HXeN1ed1+ap0+Z8dd63QJ33qTrvc+u8VqjTpl/nfQvWed/Cdd63WJ3XlqjT5lJ13rdMnfctV+d9K9Z5beU6ba5a532r13nfmnXet06d19ar0+YGdd63UZ33bVLnfZvXeS2s02ZU531xnfdtUed9W9d5bds6bY6q874d6rxvpzrvO6PO+96ovJaWs96q89p7dV77oM5rX9R57as6r31f57Uf67z2a53Xfq/z2sCe2q8NqvNaW53XOuq81lPntaF1Xpuk8lpavy9Z57WlK6+lxcSydd63fJ33rVjnfavUeW21Om2uUed9a9V53zp13rd+ndc2rNPmxnXet2md921e532lOq+V67Q5ss77tqzzvq3rvG+7Oq9tX6fNHeu8b3Sd9+1S532713ltzzpt7l3nffvWed9+dd53YJ3XDq7T5qF13nd4nfcdWed9x9R57bg6bZ5Q530n1XnfKXXed0+d9005pPb7pqnx2rDK3xUqfyty6L9r37i2hOtKi1f+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","debug_symbols":"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","brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","notify_created_nullifier_oracle_wrapper","notify_created_note_oracle_wrapper","debug_log_oracle_wrapper","random","field_less_than","build_msg_block","attach_len_to_msg_block","get_random_bytes","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","directive_integer_quotient","directive_invert","directive_to_radix"],"verification_key":"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"},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==","debug_symbols":"bY/dCoMwDIXfJde9aLof0FeRIVWjFEortQ6G9N2XDtm6zZuQE75zyNlgoG6dWuNGv0DdbGB9r6PxjtWWBHTBWGumtjyDzANPL36ZtctyiTpEqNUZBZAb8laxfzSWoL6qJP5QlCjVDvOuPjhm6xFf4ZtXKL/4W2J518HoztL+/Li6vugSHzP91JqD72lYA+WCRTeeDV6EkhzL0U8=","brillig_names":["sync_notes"]},{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8861757336002045335":{"error_kind":"fmtstring","item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}],"length":99},"9862881900111276825":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":35}},"parameters":[{"name":"log_plaintext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["process_log"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private","noinitcheck"],"abi":{"error_types":{"11091894166229312484":{"error_kind":"fmtstring","item_types":[],"length":20},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"1705275289401561847":{"error_kind":"string","string":"Mismatch note header storage slot."},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6869395374906889440":{"error_kind":"string","string":"Mismatch note header contract address."}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7Z3djuU4cq3fpa/7QkEG//wqBwfGeDw2GhjMGDPjAxwYfnerKmvvzOrNZDiVSu0VXLwxusbSVqwQxfjEVCz+1y//+qd/+c9//+ff/vJvf/37L//0f/7rlz//9Y9/+Mdvf/3L/q//+iXG7//b3//jD3/59s+//+MPf/vHL/8kOYdff/nTX/7123+W8N+//vJvv/35T7/8U97/8+HgEHL5cXAItd0Pbrl3cNP64+C4BRkfLDm2eo9D5fXw/ZLd49Pr4aW8Hl21d3TM8Xa0yvbT0f/311+irsy8k5m0MvNOZvLKzDuZKSsz72Smrsy8k5m2MtPPjG4rM+9kRlZm3slMWJl5JzOLgd/LjK7MvJOZxcDvZWYx8HuZWQz8XmYWA7+XmcXA72QmLQZ+LzOLgd/LzGLg9zKzGPi9zOjKzDuZWQz8XmYWA7+XmcXA72VmMfB7mVkM/E5m8mLg9zKzGPi9zCwGfi8zi4Hfy4yuzLyTmcXA72VmMfB7mVkM/F5mFgO/l5nFwO9kpiwGfi8zi4Hfy8xi4Pcysxj4vczoysw7mVkM/F5msBlYY3rNjDYjM0FCvkUimj6ZGWwGfmZmsBn4mZn5PAPr1m4Hq4R6P7hu3y5Qt6++QJ/IWmm3C7RWxheQlO45Svk1/7mX0HLPZ9X8emjtHFpzu92pWmI07mvV+32tWtQ4OqbbwRre3NXuaAz3/IW4pfHBEuV+Z2IU4+BN7lnecn178Lc7E9adAb0zcd0Z0Duj686A3pm07gzoncnrzoDembLuDOidqevOgN6Ztu4M5p1p27ozoHdmrQGg3pm1BoB6Z9YaAOqd0XVnQO/MWgNAvTNrDQD1zqw1ANQ7s9YAUO/MWgMAvTOyrUUA2FuzVgFgb81aBoC9NWsdAPbW6Lo1qLdmrQTA3pq1FAB7a9ZaAOytWYsB1q0p9wSGn8Po5aKU2w9Laelzt2atBqDeGjljNaC83ppq3Jrc9Mexpbw+799u6JrQfn9rZN0a1FsT1q1BvTVx3RrUW6Pr1qDemrRuDeqtyevWoN6asm4N6q2p69ag3pq2bg3orQlrNQD21qzVANhbs1YDYG/NWg2AvTW6bg3qrVmrAah/rwlrNQD21pyxGrDdD85pG98a+nzXle9L891Wvq/MdzzhZTzfPf+kSBjnOyTdbkJTSeNfjpvcLP92NHmtDHtx6R2t8QYnUfNrDvc580Wq8EgNE0ktcjs6Sf1Jai/q9Br1Jo+JiayJKW8S08JjYnSexKS7j25MzUzMJvfJdItvjv42Cz8c/Rp10jfp6B0aQ7sHHd/8cJCXhKeV8JMTrlu8T4opPSQ8r4RfO8LLSvi1I7yuhF87wttK+KUjXCd6WwFJeLmnI1Z58ybxgoU60TvTxxK+L4bfog4afkr498RM9IZ1bmImesM6NzHKmhjV+9yVtmzMXSHeZ7qwr3IYS2zsy3dK+xa5BtXXDSraN+VY7xKTFGtQyf1ehhDqGlTjQUW7GrAG1dcNqolWPPJ2+wgi5tiMQdXafTl/V/h6K+vWizrUdr8/oT3sDSU60TrGE9OYrl6dKPf9BUMN+e0vfw/n6nf3Fu7paZoewglY4USscBQrnIQVTsYKp2CFU7HCaVDh5A0rHKxZOWPNyhlrVs5Ys3LGmpUz1qycsWbljDUrZ6xZuWDNygVrVi5Ys3LBmpUL1qxcsGblgjUrF6xZuWDNygVrVq5Ys3LFmpUr1qxcsWblijUrV6xZuWLNyhVrVq5Ys3LFmpUb1qzcsGblhjUrN6xZuWHNyg1rVm5Ys3LDmpUb1qzcoGblsEHNymGDmpXDBjUrhw1qVg4b1KwcNqhZOWxQs3LYoGblsEHNymHDmpUFa1YWrFlZsGZlwZqVBWtWFqxZWbBmZcGalQVrVhasWTlgzcoBa1YOWLNywJqVA9asHLBm5YA1KwesWTlgzcoBa1aOWLNyxJqVI9asHLFm5Yg1K0esWTlizcoRa1aOWLNyxJqVFWtWVqxZWbFmZcWalRVrVlasWVmxZmXFmpUVa1ZWrFk5Yc3KWL19Aau3L2D19gWs3r6A1dsXsHr7AlZvX8Dq7QtYvX0Bq7cvYPX2BazevoDV2xewevsCVm9fwOrtC1i9fQGrty9g9fYFrN6+gNXbF7B6+wJWb1/A6u0LWL19Aau3L2D19gWs3r6A1dsXsHr7AlZvX8Dq7QtYvX0Bq7cvYPX2BazevoDV2xewevsCVm9fwOrtC1i9fQGrty9g9fYFrN6+gNXbF7B6+wJWb1/A6u0LWL19Eau3L2L19kWs3r6I1dsXN6hZOWL19kWs3r6I1dsXsXr7IlZvX8Tq7YtYvX0Rq7cvYvX2RazevojV2xexevsiVm9fxOrti1i9fRGrty9i9fZFrN6+iNXbF7F6+yJWb1/E6u2LWL19Eau3L2L19kWs3r6I1dsXsXr7IlZvX8Tq7YtYvX0Rq7cvYvX2RazevojV2xexevsiVm9fxOrti1i9fRGrty9i9fZFrN6+iNXbF7F6+yJWb1/E6u2LWL19Eau3L2L19kWs3r6I1dsXsXr7IlZvX8Tq7YtYvX0Rq7cvYvX2RazevojV2xexevsiVm9fxOrti1i9fRGrty9i9fZFrN6+iNXbF7F6+yJWb1/E6u2LWL19Eau3L2L19kWs3r6I1dsXsXr7IlZvX8Tq7YtYvX0Rq7cvYvX2RazevojV2xexevsiVm9fxOrti1i9fRGrty9i9fZFrN6+iNXbF7F6+yJWb1/E6u2LWL19itXbp1i9fYrV26dYvX26Qc3KitXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1dunWL19itXbp1i9fYrV26dYvX2K1duXsHr7ElZvX8Lq7UtYvX1pg5qVE1ZvX8Lq7UtYvX0Jq7cvYfX2JazevoTV25ewevsSVm9fwurtS1i9fQmrty9h9fYlrN6+hNXbl7B6+xJWb1/C6u1LWL19Cau3L2H19iWs3r6E1duXsHr7ElZvX8Lq7UtYvX0Jq7cvYfX2JazevoTV25ewevsSVm9fwurtS1i9fQmrty9h9fYlrN6+hNXbl7B6+xJWb1/C6u1LWL19Cau3L2H19iWs3r6E1duXsHr7ElZvX8Lq7UtYvX0Jq7cvYfX2JazevoTV25ewevsSVm9fwurtS1i9fQmrty9h9fYlrN6+hNXbl7B6+xJWb1/C6u1LWL19Cau3L2H19iWs3r6E1duXsHr7ElZvX8Lq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tCzK7aZlUW43LbrS0kvLWsvtpmWt5XbTstZyu2lZa7ndtKwvFnoLC7R7n43hn3bvMyMt64uFblrWFwvdtOhKSy8ti3J7BXrtfdZPy6LcbloW5XbTsr5Y6KWFdu8zIy1rLbeblrWW203LWsvtpkXXwkJnYYF277Mx/NPufWakZX2x0E3L+mKhm5b1xUIvLWvvs26BXnuf9dOyKLeblkW53bToSksvLWstt5uWtZbbTctay+2mZa3ldtOyvljoLSzQ7n02hn/avc+MtKwvFrppWV8sdNOiKy29tCzK7RXotfdZPy2LcrtpWZTbTcv6YqGTlky795mRlrWW203LWsvtpmWt5XbTomth4XFhIdPufTaE/0y795mRlvXFQjct64uFblrWFwu9tKy9z7oFeu191k/LotxuWhbldtOiKy29tKy13G5a1lpuNy1rLbeblrWW203L+mKht7BAu/fZGP5p9z4z0rK+WOimZX2x0E2LrrT00rIot1eg195n/bQsyu2mZVFuNy3ri4VeWmj3PjPSstZyu2lZa7ndtKy13G5adC0sdBYWaPc+G8M/7d5nRlrWFwvdtKwvFrppWV8s9NKy9j7rFui191k/LYtyu2lZlNtNi6609NKy1nK7aVlrud20rLXcblrWWm43LeuLhd7CAu3eZ2P4p937zEjL+mKhm5b1xUI3LbrS0kvLotxegV57n/XTsii3m5ZFud20rC8Wemmh3fvMSMtay+2mZa3ldtOy1nK7adG1sNBZWKDd+2wM/7R7nxlpWV8sdNOyvljopmV9sdBLy9r7rFug195n/bQsyu2mZVFuNy260tJLy1rL7aZlreV207LWcrtpWWu53bSsLxZ6Cwu0e5+N4Z927zMjLeuLhW5a1hcL3bToSksvLYtyewV67X3WT8ui3G5aFuV207K+WOilhXbvMyMtay23m5a1lttNy1rL7aZF18JCZ2GBdu+zMfzT7n1mpGV9sdBNy/pioZuW9cVCJy1l7X3WK9CFde+zcYEutHufGQ/RWsvtpkVXWnppWZTbTcui3G5a1lput0CTUq5VoBfl9h4i2r3PjLSsLxa6aVmU203LotxuWnQV6E6BXnuf9dOyvljopmVRbjctpJSr4U65GspjWkgp10jLPHufpe0WRUgh/3T0i1JkcK16++FaSid2ZLq0YkdGQCt2dRw7MkzVWIexIxOP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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","notify_created_nullifier_oracle_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"],"verification_key":"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"},{"name":"lookup_validity","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}},"parameters":[{"name":"consumer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["lookup_validity"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"11091894166229312484":{"error_kind":"fmtstring","item_types":[],"length":20},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"packed_note_content","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3djuQ2koXfpa/7QiSDf/Mqg4VhezxGAw3b8M8CC8PvvlnZJWVWi5VsRVBKMnT2wliPFVLwO6FknFCW8u8P//nph79+/u7TL//99Y8P//r33x8+//rj939++vWXy7/9/c/HDz/8/unz508/f3f/P3+YXv7h4/X4P377/peXf/3jz+9///PDvyyZjx9++uU/L/9fvsT/99Pnnz78K9h//ufjh2A2R9jNEW5zBG2O8JsjwuaI7XTT5oi8NSJOmyM2ax43ax43ax43ax43ax43ax43ax43ax43a542a542a542a542a542a542a542a542a542a542a543a543a543a543a543a543a543a543a543a543a26maXuI2R5it4e47SG0PcRvDwnbQ+L2kLQ9ZLv6Zrv6Zrv6Zrv6Zrv6Zrv6Zrv6Zrv6Zrv6Zpv6H1eHRvt6ZIzLgf713Hm/c9tpx3ObHc9tdzy32/HctOO5/Y7nDjueO+547h3vS7vjfel2vC/djvel2/G+dDvel27H+9LteF+6He9Lt+N96Xa8L530vszu9chLV/P1yWna8+Rmz5PbPU/u9jw57Xlyv+fJw54nj3uePO158j3vUL/nHer3vEO9tM7DRPPpw5TscvBl6ywdHecThxRuxyb3JRnfUzKhp2RiT8mknpLJHSUTpp6SMT0lY3tKxvWUTE+fwEH8CXzpVufzm/A2mesFwt4XiHtfIO19gbzzBeK09wXM3hewe1/A7X0B2vsCe9/Jce87Oe59J0f5nby01sH6VPnktc6H+cwu3I62IX5JJ3eVTpr6Ssf0lY7tKx3XVzrUVzq+r3RCX+nEg9MxSzrk7Jt01kenEObP8BRiIfk0cvJ54OTzNHLyZuTk7cjJu5GTp5GT910nT2FJPk/r5MPIyfe9w1aS73uHrSTf9w77MHk79b3DVpLve4etJN/3DltJvu8dtpJ83ztsJfmBd1g79b3D5iX56FztaLLL0RSpcvTNHpO9x1JK+tIBzklbc5/0F4R97/NDIOy72xgCYd89zwgITd+d1xAI++7/hkDYdxc6BMK+e+EhEBIQShH27QuGQAh3IkYIdyJGCHciRgh3IkVo4U7ECOFOxAjhTsQI4U7ECAkIpQjhTsQI4U7ECOFOxAjhTsQI4U6kCB3ciRgh3IkYIdyJGCHciRghAaEUIfrCOsJLoS0I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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","noinitcheck","view"],"abi":{"error_types":{"11091894166229312484":{"error_kind":"fmtstring","item_types":[],"length":20},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"1705275289401561847":{"error_kind":"string","string":"Mismatch note header storage slot."},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"19458536156181958":{"error_kind":"string","string":"Function verify_private_authwit can only be called statically"},"4939791462094160055":{"error_kind":"string","string":"Message not authorized by account"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6869395374906889440":{"error_kind":"string","string":"Mismatch note header contract address."}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","store_in_execution_cache_oracle_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"],"verification_key":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"PublicKeyNote"},{"fields":[{"name":"x","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"y","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"owner","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"SchnorrAccount"}},{"name":"fields","value":{"fields":[{"name":"signing_public_key","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_parameters"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"signing_pub_key_x","type":{"kind":"field"}},{"name":"signing_pub_key_y","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::constructor_parameters"}}],"kind":"struct","path":"SchnorrAccount::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_abi"}]}},"file_map":{"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\\n\\n#[derive_via(derive_eq)]\\n// docs:start:eq-trait\\npub trait Eq {\\n    fn eq(self, other: Self) -> bool;\\n}\\n// docs:end:eq-trait\\n\\n// docs:start:derive_eq\\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\\n    let body = |fields| {\\n        if s.fields_as_written().len() == 0 {\\n            quote { true }\\n        } else {\\n            fields\\n        }\\n    };\\n    crate::meta::make_trait_impl(\\n        s,\\n        quote { Eq },\\n        signature,\\n        for_each_field,\\n        quote { & },\\n        body,\\n    )\\n}\\n// docs:end:derive_eq\\n\\nimpl Eq for Field {\\n    fn eq(self, other: Field) -> bool {\\n        self == other\\n    }\\n}\\n\\nimpl Eq for u64 {\\n    fn eq(self, other: u64) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for u32 {\\n    fn eq(self, other: u32) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for u16 {\\n    fn eq(self, other: u16) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for u8 {\\n    fn eq(self, other: u8) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for u1 {\\n    fn eq(self, other: u1) -> bool {\\n        self == other\\n    }\\n}\\n\\nimpl Eq for i8 {\\n    fn eq(self, other: i8) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for i16 {\\n    fn eq(self, other: i16) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for i32 {\\n    fn eq(self, other: i32) -> bool {\\n        self == other\\n    }\\n}\\nimpl Eq for i64 {\\n    fn eq(self, other: i64) -> bool {\\n        self == other\\n    }\\n}\\n\\nimpl Eq for () {\\n    fn eq(_self: Self, _other: ()) -> bool {\\n        true\\n    }\\n}\\nimpl Eq for bool {\\n    fn eq(self, other: bool) -> bool {\\n        self == other\\n    }\\n}\\n\\nimpl<T, let N: u32> Eq for [T; N]\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: [T; N]) -> bool {\\n        let mut result = true;\\n        for i in 0..self.len() {\\n            result &= self[i].eq(other[i]);\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T> Eq for [T]\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: [T]) -> bool {\\n        let mut result = self.len() == other.len();\\n        for i in 0..self.len() {\\n            result &= self[i].eq(other[i]);\\n        }\\n        result\\n    }\\n}\\n\\nimpl<let N: u32> Eq for str<N> {\\n    fn eq(self, other: str<N>) -> bool {\\n        let self_bytes = self.as_bytes();\\n        let other_bytes = other.as_bytes();\\n        self_bytes == other_bytes\\n    }\\n}\\n\\nimpl<A, B> Eq for (A, B)\\nwhere\\n    A: Eq,\\n    B: Eq,\\n{\\n    fn eq(self, other: (A, B)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1)\\n    }\\n}\\n\\nimpl<A, B, C> Eq for (A, B, C)\\nwhere\\n    A: Eq,\\n    B: Eq,\\n    C: Eq,\\n{\\n    fn eq(self, other: (A, B, C)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\\n    }\\n}\\n\\nimpl<A, B, C, D> Eq for (A, B, C, D)\\nwhere\\n    A: Eq,\\n    B: Eq,\\n    C: Eq,\\n    D: Eq,\\n{\\n    fn eq(self, other: (A, B, C, D)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\\nwhere\\n    A: Eq,\\n    B: Eq,\\n    C: Eq,\\n    D: Eq,\\n    E: Eq,\\n{\\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\\n        self.0.eq(other.0)\\n            & self.1.eq(other.1)\\n            & self.2.eq(other.2)\\n            & self.3.eq(other.3)\\n            & self.4.eq(other.4)\\n    }\\n}\\n\\nimpl Eq for Ordering {\\n    fn eq(self, other: Ordering) -> bool {\\n        self.result == other.result\\n    }\\n}\\n\\n// Noir doesn\'t have enums yet so we emulate (Lt | Eq | Gt) with a struct\\n// that has 3 public functions for constructing the struct.\\npub struct Ordering {\\n    result: Field,\\n}\\n\\nimpl Ordering {\\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\\n    // into the compiler, do not change these without also updating\\n    // the compiler itself!\\n    pub fn less() -> Ordering {\\n        Ordering { result: 0 }\\n    }\\n\\n    pub fn equal() -> Ordering {\\n        Ordering { result: 1 }\\n    }\\n\\n    pub fn greater() -> Ordering {\\n        Ordering { result: 2 }\\n    }\\n}\\n\\n#[derive_via(derive_ord)]\\n// docs:start:ord-trait\\npub trait Ord {\\n    fn cmp(self, other: Self) -> Ordering;\\n}\\n// docs:end:ord-trait\\n\\n// docs:start:derive_ord\\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\\n    let for_each_field = |name| quote {\\n        if result == std::cmp::Ordering::equal() {\\n            result = _self.$name.cmp(_other.$name);\\n        }\\n    };\\n    let body = |fields| quote {\\n        let mut result = std::cmp::Ordering::equal();\\n        $fields\\n        result\\n    };\\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\\n}\\n// docs:end:derive_ord\\n\\n// Note: Field deliberately does not implement Ord\\n\\nimpl Ord for u64 {\\n    fn cmp(self, other: u64) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for u32 {\\n    fn cmp(self, other: u32) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for u16 {\\n    fn cmp(self, other: u16) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for u8 {\\n    fn cmp(self, other: u8) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i8 {\\n    fn cmp(self, other: i8) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i16 {\\n    fn cmp(self, other: i16) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i32 {\\n    fn cmp(self, other: i32) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i64 {\\n    fn cmp(self, other: i64) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for () {\\n    fn cmp(_self: Self, _other: ()) -> Ordering {\\n        Ordering::equal()\\n    }\\n}\\n\\nimpl Ord for bool {\\n    fn cmp(self, other: bool) -> Ordering {\\n        if self {\\n            if other {\\n                Ordering::equal()\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl<T, let N: u32> Ord for [T; N]\\nwhere\\n    T: Ord,\\n{\\n    // The first non-equal element of both arrays determines\\n    // the ordering for the whole array.\\n    fn cmp(self, other: [T; N]) -> Ordering {\\n        let mut result = Ordering::equal();\\n        for i in 0..self.len() {\\n            if result == Ordering::equal() {\\n                let result_i = self[i].cmp(other[i]);\\n\\n                if result_i == Ordering::less() {\\n                    result = result_i;\\n                } else if result_i == Ordering::greater() {\\n                    result = result_i;\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T> Ord for [T]\\nwhere\\n    T: Ord,\\n{\\n    // The first non-equal element of both arrays determines\\n    // the ordering for the whole array.\\n    fn cmp(self, other: [T]) -> Ordering {\\n        let mut result = self.len().cmp(other.len());\\n        for i in 0..self.len() {\\n            if result == Ordering::equal() {\\n                let result_i = self[i].cmp(other[i]);\\n\\n                if result_i == Ordering::less() {\\n                    result = result_i;\\n                } else if result_i == Ordering::greater() {\\n                    result = result_i;\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<A, B> Ord for (A, B)\\nwhere\\n    A: Ord,\\n    B: Ord,\\n{\\n    fn cmp(self, other: (A, B)) -> Ordering {\\n        let result = self.0.cmp(other.0);\\n\\n        if result != Ordering::equal() {\\n            result\\n        } else {\\n            self.1.cmp(other.1)\\n        }\\n    }\\n}\\n\\nimpl<A, B, C> Ord for (A, B, C)\\nwhere\\n    A: Ord,\\n    B: Ord,\\n    C: Ord,\\n{\\n    fn cmp(self, other: (A, B, C)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        result\\n    }\\n}\\n\\nimpl<A, B, C, D> Ord for (A, B, C, D)\\nwhere\\n    A: Ord,\\n    B: Ord,\\n    C: Ord,\\n    D: Ord,\\n{\\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.3.cmp(other.3);\\n        }\\n\\n        result\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\\nwhere\\n    A: Ord,\\n    B: Ord,\\n    C: Ord,\\n    D: Ord,\\n    E: Ord,\\n{\\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.3.cmp(other.3);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.4.cmp(other.4);\\n        }\\n\\n        result\\n    }\\n}\\n\\n// Compares and returns the maximum of two values.\\n//\\n// Returns the second argument if the comparison determines them to be equal.\\n//\\n// # Examples\\n//\\n// ```\\n// use std::cmp;\\n//\\n// assert_eq(cmp::max(1, 2), 2);\\n// assert_eq(cmp::max(2, 2), 2);\\n// ```\\npub fn max<T>(v1: T, v2: T) -> T\\nwhere\\n    T: Ord,\\n{\\n    if v1 > v2 {\\n        v1\\n    } else {\\n        v2\\n    }\\n}\\n\\n// Compares and returns the minimum of two values.\\n//\\n// Returns the first argument if the comparison determines them to be equal.\\n//\\n// # Examples\\n//\\n// ```\\n// use std::cmp;\\n//\\n// assert_eq(cmp::min(1, 2), 1);\\n// assert_eq(cmp::min(2, 2), 2);\\n// ```\\npub fn min<T>(v1: T, v2: T) -> T\\nwhere\\n    T: Ord,\\n{\\n    if v1 > v2 {\\n        v2\\n    } else {\\n        v1\\n    }\\n}\\n\\nmod cmp_tests {\\n    use crate::cmp::{max, min};\\n\\n    #[test]\\n    fn sanity_check_min() {\\n        assert_eq(min(0 as u64, 1 as u64), 0);\\n        assert_eq(min(0 as u64, 0 as u64), 0);\\n        assert_eq(min(1 as u64, 1 as u64), 1);\\n        assert_eq(min(255 as u8, 0 as u8), 0);\\n    }\\n\\n    #[test]\\n    fn sanity_check_max() {\\n        assert_eq(max(0 as u64, 1 as u64), 1);\\n        assert_eq(max(0 as u64, 0 as u64), 0);\\n        assert_eq(max(1 as u64, 1 as u64), 1);\\n        assert_eq(max(255 as u8, 0 as u8), 255);\\n    }\\n}\\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\\n\\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\\n/// slices - and thus nested vectors as well - are disallowed).\\n///\\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\\n/// pushing an additional element is also more efficient - the length only needs to be increased\\n/// by one.\\n///\\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\\n/// is a reasonable maximum bound that can be placed on the vector.\\n///\\n/// Example:\\n///\\n/// ```noir\\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\\n/// for i in 0..5 {\\n///     vector.push(i);\\n/// }\\n/// assert(vector.len() == 5);\\n/// assert(vector.max_len() == 10);\\n/// ```\\npub struct BoundedVec<T, let MaxLen: u32> {\\n    storage: [T; MaxLen],\\n    len: u32,\\n}\\n\\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\\n    /// Creates a new, empty vector of length zero.\\n    ///\\n    /// Since this container is backed by an array internally, it still needs an initial value\\n    /// to give each element. To resolve this, each element is zeroed internally. This value\\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\\n    /// assert(empty_vector.len() == 0);\\n    /// ```\\n    ///\\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\\n    /// via a type signature:\\n    ///\\n    /// ```noir\\n    /// fn good() -> BoundedVec<Field, 10> {\\n    ///     // Ok! MaxLen is specified with a type annotation\\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\\n    ///     let v2 = BoundedVec::new();\\n    ///\\n    ///     // Ok! MaxLen is known from the type of `good`\'s return value\\n    ///     v2\\n    /// }\\n    ///\\n    /// fn bad() {\\n    ///     // Error: Type annotation needed\\n    ///     // The compiler can\'t infer `MaxLen` from the following code:\\n    ///     let mut v3 = BoundedVec::new();\\n    ///     v3.push(5);\\n    /// }\\n    /// ```\\n    ///\\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\\n    /// constraint failure at runtime when the vec is pushed to.\\n    pub fn new() -> Self {\\n        let zeroed = crate::mem::zeroed();\\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this\\n    /// will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     let last = v.get(v.len() - 1);\\n    ///     assert(first != last);\\n    /// }\\n    /// ```\\n    pub fn get(self, index: u32) -> T {\\n        assert(index < self.len, \\"Attempted to read past end of BoundedVec\\");\\n        self.get_unchecked(index)\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero, without\\n    /// performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element,\\n    /// it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\\n    ///     // Always ensure the length is larger than the largest\\n    ///     // index passed to get_unchecked\\n    ///     assert(v.len() > 2);\\n    ///     let first = v.get_unchecked(0);\\n    ///     let second = v.get_unchecked(1);\\n    ///     let third = v.get_unchecked(2);\\n    ///     first + second + third\\n    /// }\\n    /// ```\\n    pub fn get_unchecked(self, index: u32) -> T {\\n        self.storage[index]\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     assert(first != 42);\\n    ///     v.set(0, 42);\\n    ///     let new_first = v.get(0);\\n    ///     assert(new_first == 42);\\n    /// }\\n    /// ```\\n    pub fn set(&mut self, index: u32, value: T) {\\n        assert(index < self.len, \\"Attempted to write past end of BoundedVec\\");\\n        self.set_unchecked(index, value)\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn set_unchecked_example() {\\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\\n    ///     vec.extend_from_array([1, 2]);\\n    ///\\n    ///     // Here we\'re safely writing within the valid range of `vec`\\n    ///     // `vec` now has the value [42, 2]\\n    ///     vec.set_unchecked(0, 42);\\n    ///\\n    ///     // We can then safely read this value back out of `vec`.\\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\\n    ///     assert_eq(vec.get(0), 42);\\n    ///\\n    ///     // We\'ve now written past the end of `vec`.\\n    ///     // As this index is still within the maximum potential length of `v`,\\n    ///     // it won\'t cause a constraint failure.\\n    ///     vec.set_unchecked(2, 42);\\n    ///     println(vec);\\n    ///\\n    ///     // This will write past the end of the maximum potential length of `vec`,\\n    ///     // it will then trigger a constraint failure.\\n    ///     vec.set_unchecked(5, 42);\\n    ///     println(vec);\\n    /// }\\n    /// ```\\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\\n        self.storage[index] = value;\\n    }\\n\\n    /// Pushes an element to the end of the vector. This increases the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the new length of the vector will be greater than the max length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    ///\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// // Panics with failed assertion \\"push out of bounds\\"\\n    /// v.push(3);\\n    /// ```\\n    pub fn push(&mut self, elem: T) {\\n        assert(self.len < MaxLen, \\"push out of bounds\\");\\n\\n        self.storage[self.len] = elem;\\n        self.len += 1;\\n    }\\n\\n    /// Returns the current length of this vector\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\\n    /// assert(v.len() == 0);\\n    ///\\n    /// v.push(100);\\n    /// assert(v.len() == 1);\\n    ///\\n    /// v.push(200);\\n    /// v.push(300);\\n    /// v.push(400);\\n    /// assert(v.len() == 4);\\n    ///\\n    /// let _ = v.pop();\\n    /// let _ = v.pop();\\n    /// assert(v.len() == 2);\\n    /// ```\\n    pub fn len(self) -> u32 {\\n        self.len\\n    }\\n\\n    /// Returns the maximum length of this vector. This is always\\n    /// equal to the `MaxLen` parameter this vector was initialized with.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.max_len() == 5);\\n    /// v.push(10);\\n    /// assert(v.max_len() == 5);\\n    /// ```\\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\\n        MaxLen\\n    }\\n\\n    /// Returns the internal array within this vector.\\n    ///\\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\\n    /// the storage held internally by this vector.\\n    ///\\n    /// Note that uninitialized elements may be zeroed out!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\\n    ///\\n    /// v.push(57);\\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn storage(self) -> [T; MaxLen] {\\n        self.storage\\n    }\\n\\n    /// Pushes each element from the given array to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_array([2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\\n        let new_len = self.len + array.len();\\n        assert(new_len <= MaxLen, \\"extend_from_array out of bounds\\");\\n        for i in 0..array.len() {\\n            self.storage[self.len + i] = array[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the given slice to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_slice(&[2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_slice(&mut self, slice: [T]) {\\n        let new_len = self.len + slice.len();\\n        assert(new_len <= MaxLen, \\"extend_from_slice out of bounds\\");\\n        for i in 0..slice.len() {\\n            self.storage[self.len + i] = slice[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the other vector to this vector. The length of\\n    /// the other vector is left unchanged.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// ```noir\\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\\n    ///\\n    /// v2.extend_from_array([1, 2, 3]);\\n    /// v1.extend_from_bounded_vec(v2);\\n    ///\\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\\n        let append_len = vec.len();\\n        let new_len = self.len + append_len;\\n        assert(new_len <= MaxLen, \\"extend_from_bounded_vec out of bounds\\");\\n\\n        if is_unconstrained() {\\n            for i in 0..append_len {\\n                self.storage[self.len + i] = vec.get_unchecked(i);\\n            }\\n        } else {\\n            let mut exceeded_len = false;\\n            for i in 0..Len {\\n                exceeded_len |= i == append_len;\\n                if !exceeded_len {\\n                    self.storage[self.len + i] = vec.get_unchecked(i);\\n                }\\n            }\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Creates a new vector, populating it with values derived from an array input.\\n    /// The maximum length of the vector is determined based on the type signature.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\\n    /// ```\\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\\n        static_assert(Len <= MaxLen, \\"from array out of bounds\\");\\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\\n        vec.extend_from_array(array);\\n        vec\\n    }\\n\\n    /// Pops the element at the end of the vector. This will decrease the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the vector is empty.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// let two = v.pop();\\n    /// let one = v.pop();\\n    ///\\n    /// assert(two == 2);\\n    /// assert(one == 1);\\n    ///\\n    /// // error: cannot pop from an empty vector\\n    /// let _ = v.pop();\\n    /// ```\\n    pub fn pop(&mut self) -> T {\\n        assert(self.len > 0);\\n        self.len -= 1;\\n\\n        let elem = self.storage[self.len];\\n        self.storage[self.len] = crate::mem::zeroed();\\n        elem\\n    }\\n\\n    /// Returns true if the given predicate returns true for any element\\n    /// in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\\n    /// v.extend_from_array([2, 4, 6]);\\n    ///\\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\\n    /// assert(all_even);\\n    /// ```\\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\\n        let mut ret = false;\\n        if is_unconstrained() {\\n            for i in 0..self.len {\\n                ret |= predicate(self.storage[i]);\\n            }\\n        } else {\\n            let mut ret = false;\\n            let mut exceeded_len = false;\\n            for i in 0..MaxLen {\\n                exceeded_len |= i == self.len;\\n                if !exceeded_len {\\n                    ret |= predicate(self.storage[i]);\\n                }\\n            }\\n        }\\n        ret\\n    }\\n\\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n    /// let result = vec.map(|value| value * 2);\\n    ///\\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n    /// assert_eq(result, expected);\\n    /// ```\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\\n        let mut ret = BoundedVec::new();\\n        ret.len = self.len();\\n\\n        if is_unconstrained() {\\n            for i in 0..self.len() {\\n                ret.storage[i] = f(self.get_unchecked(i));\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i < self.len() {\\n                    ret.storage[i] = f(self.get_unchecked(i));\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function will zero out any elements at or past index `len` of `array`.\\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    /// ```\\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        let zeroed = crate::mem::zeroed();\\n\\n        if is_unconstrained() {\\n            for i in len..MaxLen {\\n                array[i] = zeroed;\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i >= len {\\n                    array[i] = zeroed;\\n                }\\n            }\\n        }\\n\\n        BoundedVec { storage: array, len }\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function is unsafe because it expects all elements past the `len` index\\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\\n    /// for a safe version of this function which does zero out any indices past the\\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\\n    /// to give incorrect results since it will check even elements past `len`.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    ///\\n    /// // invalid use!\\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n    ///\\n    /// // both vecs have length 3 so we\'d expect them to be equal, but this\\n    /// // fails because elements past the length are still checked in eq\\n    /// assert_eq(vec1, vec2); // fails\\n    /// ```\\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        BoundedVec { storage: array, len }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\\n        // TODO: https://github.com/noir-lang/noir/issues/4837\\n        //\\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\\n        if self.len == other.len {\\n            self.storage == other.storage\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\\n        BoundedVec::from_array(array)\\n    }\\n}\\n\\nmod bounded_vec_tests {\\n\\n    mod get {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test(should_fail_with = \\"Attempted to read past end of BoundedVec\\")]\\n        fn panics_when_reading_elements_past_end_of_vec() {\\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\\n\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod set {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn set_updates_values_properly() {\\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\\n\\n            vec.set(0, 42);\\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\\n\\n            vec.set(1, 43);\\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\\n\\n            vec.set(2, 44);\\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\\n\\n            vec.set(1, 10);\\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\\n\\n            vec.set(0, 0);\\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\\n        }\\n\\n        #[test(should_fail_with = \\"Attempted to write past end of BoundedVec\\")]\\n        fn panics_when_writing_elements_past_end_of_vec() {\\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\\n            vec.set(0, 42);\\n\\n            // Need to use println to avoid DIE removing the write operation.\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod map {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn applies_function_correctly() {\\n            // docs:start:bounded-vec-map-example\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| value * 2);\\n            // docs:end:bounded-vec-map-example\\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn applies_function_that_changes_return_type() {\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| (value * 2) as Field);\\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn does_not_apply_function_past_len() {\\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\\n            let expected = BoundedVec::from_array([5, 1]);\\n\\n            assert_eq(result, expected);\\n            assert_eq(result.get_unchecked(2), 0);\\n        }\\n    }\\n\\n    mod from_array {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty() {\\n            let empty_array: [Field; 0] = [];\\n            let bounded_vec = BoundedVec::from_array([]);\\n\\n            assert_eq(bounded_vec.max_len(), 0);\\n            assert_eq(bounded_vec.len(), 0);\\n            assert_eq(bounded_vec.storage(), empty_array);\\n        }\\n\\n        #[test]\\n        fn equal_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 3);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage(), array);\\n        }\\n\\n        #[test]\\n        fn max_len_greater_then_array_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n            assert_eq(bounded_vec.get(2), 3);\\n        }\\n\\n        #[test(should_fail_with = \\"from array out of bounds\\")]\\n        fn max_len_lower_then_array_len() {\\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\\n        }\\n    }\\n\\n    mod trait_from {\\n        use crate::collections::bounded_vec::BoundedVec;\\n        use crate::convert::From;\\n\\n        #[test]\\n        fn simple() {\\n            let array = [1, 2];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 2);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n        }\\n    }\\n\\n    mod trait_eq {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty_equality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n\\n            assert_eq(bounded_vec1, bounded_vec2);\\n        }\\n\\n        #[test]\\n        fn inequality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n            bounded_vec1.push(1);\\n            bounded_vec2.push(2);\\n\\n            assert(bounded_vec1 != bounded_vec2);\\n        }\\n    }\\n\\n    mod from_parts {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn from_parts() {\\n            // docs:start:from-parts\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // Any elements past the given length are zeroed out, so these\\n            // two BoundedVecs will be completely equal\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\\n            assert_eq(vec1, vec2);\\n            // docs:end:from-parts\\n        }\\n\\n        #[test]\\n        fn from_parts_unchecked() {\\n            // docs:start:from-parts-unchecked\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // invalid use!\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n\\n            // both vecs have length 3 so we\'d expect them to be equal, but this\\n            // fails because elements past the length are still checked in eq\\n            assert(vec1 != vec2);\\n            // docs:end:from-parts-unchecked\\n        }\\n    }\\n}\\n"},"17":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\\nuse crate::ops::arith::{Add, Neg, Sub};\\n\\n/// A point on the embedded elliptic curve\\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\\npub struct EmbeddedCurvePoint {\\n    pub x: Field,\\n    pub y: Field,\\n    pub is_infinite: bool,\\n}\\n\\nimpl EmbeddedCurvePoint {\\n    /// Elliptic curve point doubling operation\\n    /// returns the doubled point of a point P, i.e P+P\\n    pub fn double(self) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, self)\\n    }\\n\\n    /// Returns the null element of the curve; \'the point at infinity\'\\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\\n    }\\n}\\n\\nimpl Add for EmbeddedCurvePoint {\\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, other)\\n    }\\n}\\n\\nimpl Sub for EmbeddedCurvePoint {\\n    /// Points subtraction operation, using addition and negation\\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        self + other.neg()\\n    }\\n}\\n\\nimpl Neg for EmbeddedCurvePoint {\\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\\n    /// If the point is at infinity, then the result is also at infinity.\\n    fn neg(self) -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurvePoint {\\n    /// Checks whether two points are equal\\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\\n        (self.is_infinite & b.is_infinite)\\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\\n    }\\n}\\n\\n/// Scalar for the embedded curve represented as low and high limbs\\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\\npub struct EmbeddedCurveScalar {\\n    pub lo: Field,\\n    pub hi: Field,\\n}\\n\\nimpl EmbeddedCurveScalar {\\n    pub fn new(lo: Field, hi: Field) -> Self {\\n        EmbeddedCurveScalar { lo, hi }\\n    }\\n\\n    #[field(bn254)]\\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\\n        let (a, b) = crate::field::bn254::decompose(scalar);\\n        EmbeddedCurveScalar { lo: a, hi: b }\\n    }\\n\\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\\n    #[field(bn254)]\\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\\n        let mut v = 1;\\n        let mut lo = 0 as Field;\\n        let mut hi = 0 as Field;\\n        for i in 0..16 {\\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\\n        sig_s\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurveScalar {\\n    fn eq(self, other: Self) -> bool {\\n        (other.hi == self.hi) & (other.lo == self.lo)\\n    }\\n}\\n\\n// Computes a multi scalar multiplication over the embedded curve.\\n// For bn254, We have Grumpkin and Baby JubJub.\\n// For bls12-381, we have JubJub and Bandersnatch.\\n//\\n// The embedded curve being used is decided by the\\n// underlying proof system.\\n// docs:start:multi_scalar_mul\\npub fn multi_scalar_mul<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> EmbeddedCurvePoint\\n// docs:end:multi_scalar_mul\\n{\\n    let point_array = multi_scalar_mul_array_return(points, scalars);\\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\\n}\\n\\n#[foreign(multi_scalar_mul)]\\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> [Field; 3] {}\\n\\n// docs:start:fixed_base_scalar_mul\\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\\n// docs:end:fixed_base_scalar_mul\\n{\\n    let g1 = EmbeddedCurvePoint {\\n        x: 1,\\n        y: 17631683881184975370165255887551781615748388533673675138860,\\n        is_infinite: false,\\n    };\\n    multi_scalar_mul([g1], [scalar])\\n}\\n\\n/// This function only assumes that the points are on the curve\\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\\n// docs:start:embedded_curve_add\\npub fn embedded_curve_add(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    // docs:end:embedded_curve_add\\n    let x_coordinates_match = point1.x == point2.x;\\n    let y_coordinates_match = point1.y == point2.y;\\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\\n    let point1_1 = EmbeddedCurvePoint {\\n        x: point1.x + (x_coordinates_match as Field),\\n        y: point1.y,\\n        is_infinite: x_coordinates_match,\\n    };\\n    // point1_1 is guaranteed to have a different abscissa than point2\\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\\n    result.is_infinite = x_coordinates_match;\\n\\n    // dbl if x_match, y_match\\n    let double = embedded_curve_add_unsafe(point1, point1);\\n    result = if double_predicate { double } else { result };\\n\\n    // infinity if x_match, !y_match\\n    if point1.is_infinite {\\n        result = point2;\\n    }\\n    if point2.is_infinite {\\n        result = point1;\\n    }\\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\\n    result\\n}\\n\\n#[foreign(embedded_curve_add)]\\nfn embedded_curve_add_array_return(\\n    _point1: EmbeddedCurvePoint,\\n    _point2: EmbeddedCurvePoint,\\n) -> [Field; 3] {}\\n\\n/// This function assumes that:\\n/// The points are on the curve, and\\n/// The points don\'t share an x-coordinate, and\\n/// Neither point is the infinity point.\\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\\npub fn embedded_curve_add_not_nul(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    assert(point1.x != point2.x);\\n    assert(!point1.is_infinite);\\n    assert(!point2.is_infinite);\\n    embedded_curve_add_unsafe(point1, point2)\\n}\\n\\n/// Unsafe ec addition\\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\\n/// If they have the same value but are different variables, the result will be incorrect because in this case\\n/// it assumes (but does not check) that the points\' x-coordinates are not equal.\\n/// It also assumes neither point is the infinity point.\\npub fn embedded_curve_add_unsafe(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    let point_array = embedded_curve_add_array_return(point1, point2);\\n    let x = point_array[0];\\n    let y = point_array[1];\\n\\n    EmbeddedCurvePoint { x, y, is_infinite: false }\\n}\\n"},"18":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    /// Safety: borrow is enforced to be boolean due to its type.\\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n    unsafe {\\n        /*@safety: borrow is enforced to be boolean due to its type.\\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n        */\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        /// Safety: decomposition is properly checked below\\n        unsafe {\\n            /*@safety: decomposition is properly checked below*/\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            /// Safety: already unconstrained\\n            unsafe { field_less_than(b, a) },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        /// Safety: unsafe in unconstrained\\n        unsafe {\\n            //@safety: unsafe in unconstrained\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        /// Safety: Take a hint of the comparison and verify it\\n        unsafe {\\n            //@safety: Take a hint of the comparison and verify it\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"19":{"path":"std/field/mod.nr","source":"pub mod bn254;\\nuse crate::{runtime::is_unconstrained, static_assert};\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        static_assert(\\n            BIT_SIZE < modulus_num_bits() as u32,\\n            \\"BIT_SIZE must be less than modulus_num_bits\\",\\n        );\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_le_bits\\n        let bits = self._to_le_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(p[N - 1 - i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_be_bits\\n        let bits = self._to_be_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the decomposition does not overflow the modulus\\n            let p = modulus_be_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[i] != p[i]) {\\n                        assert(p[i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            static_assert(1 < radix, \\"radix must be greater than 1\\");\\n            static_assert(radix <= 256, \\"radix must be less than or equal to 256\\");\\n            static_assert(radix & (radix - 1) == 0, \\"radix must be a power of 2\\");\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        /// Safety: unconstrained context\\n        unsafe {\\n            //@safety : unconstrained context\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use crate::{panic::panic, runtime};\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test(should_fail_with = \\"radix must be greater than 1\\")]\\n    fn test_to_le_radix_1() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(1);\\n        } else {\\n            panic(f\\"radix must be greater than 1\\");\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\\n    // #[test]\\n    // fn test_to_le_radix_brillig_1() {\\n    //     // this test should only fail in constrained mode\\n    //     if runtime::is_unconstrained() {\\n    //         let field = 1;\\n    //         let out: [u8; 8] = field.to_le_radix(1);\\n    //         crate::println(out);\\n    //         let expected = [0; 8];\\n    //         assert(out == expected, \\"unexpected result\\");\\n    //     }\\n    // }\\n\\n    #[test(should_fail_with = \\"radix must be a power of 2\\")]\\n    fn test_to_le_radix_3() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(3);\\n        } else {\\n            panic(f\\"radix must be a power of 2\\");\\n        }\\n    }\\n\\n    #[test]\\n    fn test_to_le_radix_brillig_3() {\\n        // this test should only fail in constrained mode\\n        if runtime::is_unconstrained() {\\n            let field = 1;\\n            let out: [u8; 8] = field.to_le_radix(3);\\n            let mut expected = [0; 8];\\n            expected[0] = 1;\\n            assert(out == expected, \\"unexpected result\\");\\n        }\\n    }\\n\\n    #[test(should_fail_with = \\"radix must be less than or equal to 256\\")]\\n    fn test_to_le_radix_512() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(512);\\n        } else {\\n            panic(f\\"radix must be less than or equal to 256\\")\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\\n    // #[test]\\n    // fn test_to_le_radix_brillig_512() {\\n    //     // this test should only fail in constrained mode\\n    //     if runtime::is_unconstrained() {\\n    //         let field = 1;\\n    //         let out: [u8; 8] = field.to_le_radix(512);\\n    //         let mut expected = [0; 8];\\n    //         expected[0] = 1;\\n    //         assert(out == expected, \\"unexpected result\\");\\n    //     }\\n    // }\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n"},"21":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\\npub mod poseidon2;\\npub mod keccak;\\npub mod sha256;\\npub mod sha512;\\n\\nuse crate::default::Default;\\nuse crate::embedded_curve_ops::{\\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\\n};\\nuse crate::meta::derive_via;\\nuse crate::uint128::U128;\\n\\n// Kept for backwards compatibility\\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\\n\\n#[foreign(blake2s)]\\n// docs:start:blake2s\\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:blake2s\\n{}\\n\\n#[foreign(blake3)]\\n// docs:start:blake3\\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:blake3\\n{}\\n\\n// docs:start:pedersen_commitment\\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\\n    // docs:end:pedersen_commitment\\n    pedersen_commitment_with_separator(input, 0)\\n}\\n\\n#[inline_always]\\npub fn pedersen_commitment_with_separator<let N: u32>(\\n    input: [Field; N],\\n    separator: u32,\\n) -> EmbeddedCurvePoint {\\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\\n    for i in 0..N {\\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\\n        points[i] = from_field_unsafe(input[i]);\\n    }\\n    let generators = derive_generators(\\"DEFAULT_DOMAIN_SEPARATOR\\".as_bytes(), separator);\\n    multi_scalar_mul(generators, points)\\n}\\n\\n// docs:start:pedersen_hash\\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\\n// docs:end:pedersen_hash\\n{\\n    pedersen_hash_with_separator(input, 0)\\n}\\n\\n#[no_predicates]\\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\\n    let domain_generators: [EmbeddedCurvePoint; N] =\\n        derive_generators(\\"DEFAULT_DOMAIN_SEPARATOR\\".as_bytes(), separator);\\n\\n    for i in 0..N {\\n        scalars[i] = from_field_unsafe(input[i]);\\n        generators[i] = domain_generators[i];\\n    }\\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\\n\\n    let length_generator: [EmbeddedCurvePoint; 1] =\\n        derive_generators(\\"pedersen_hash_length\\".as_bytes(), 0);\\n    generators[N] = length_generator[0];\\n    multi_scalar_mul_array_return(generators, scalars)[0]\\n}\\n\\n#[field(bn254)]\\n#[inline_always]\\npub fn derive_generators<let N: u32, let M: u32>(\\n    domain_separator_bytes: [u8; M],\\n    starting_index: u32,\\n) -> [EmbeddedCurvePoint; N] {\\n    crate::assert_constant(domain_separator_bytes);\\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\\n    __derive_generators(domain_separator_bytes, starting_index)\\n}\\n\\n#[builtin(derive_pedersen_generators)]\\n#[field(bn254)]\\nfn __derive_generators<let N: u32, let M: u32>(\\n    domain_separator_bytes: [u8; M],\\n    starting_index: u32,\\n) -> [EmbeddedCurvePoint; N] {}\\n\\n#[field(bn254)]\\n// Same as from_field but:\\n// does not assert the limbs are 128 bits\\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\\n    /// Safety: xlo and xhi decomposition is checked below\\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\\n    // Check that the decomposition is correct\\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\\n}\\n\\npub fn hash_to_field(inputs: [Field]) -> Field {\\n    let mut sum = 0;\\n\\n    for input in inputs {\\n        let input_bytes: [u8; 32] = input.to_le_bytes();\\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\\n    }\\n\\n    sum\\n}\\n\\n// docs:start:keccak256\\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\\n// docs:end:keccak256\\n{\\n    crate::hash::keccak::keccak256(input, message_size)\\n}\\n\\n#[foreign(poseidon2_permutation)]\\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\\n\\n// Generic hashing support.\\n// Partially ported and impacted by rust.\\n\\n// Hash trait shall be implemented per type.\\n#[derive_via(derive_hash)]\\npub trait Hash {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher;\\n}\\n\\n// docs:start:derive_hash\\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\\n    let name = quote { Hash };\\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\\n    crate::meta::make_trait_impl(\\n        s,\\n        name,\\n        signature,\\n        for_each_field,\\n        quote {},\\n        |fields| fields,\\n    )\\n}\\n// docs:end:derive_hash\\n\\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\\n// TODO: consider making the types generic here ([u8], [Field], etc.)\\npub trait Hasher {\\n    fn finish(self) -> Field;\\n\\n    fn write(&mut self, input: Field);\\n}\\n\\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\\npub trait BuildHasher<H>\\nwhere\\n    H: Hasher,\\n{\\n    fn build_hasher(self) -> H;\\n}\\n\\npub struct BuildHasherDefault<H>;\\n\\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\\nwhere\\n    H: Hasher + Default,\\n{\\n    fn build_hasher(_self: Self) -> H {\\n        H::default()\\n    }\\n}\\n\\nimpl<H> Default for BuildHasherDefault<H>\\nwhere\\n    H: Hasher + Default,\\n{\\n    fn default() -> Self {\\n        BuildHasherDefault {}\\n    }\\n}\\n\\nimpl Hash for Field {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self);\\n    }\\n}\\n\\nimpl Hash for u1 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u8 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u16 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u32 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u64 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i8 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i16 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i32 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i64 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for bool {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for () {\\n    fn hash<H>(_self: Self, _state: &mut H)\\n    where\\n        H: Hasher,\\n    {}\\n}\\n\\nimpl Hash for U128 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self.lo as Field);\\n        H::write(state, self.hi as Field);\\n    }\\n}\\n\\nimpl<T, let N: u32> Hash for [T; N]\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        for elem in self {\\n            elem.hash(state);\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for [T]\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.len().hash(state);\\n        for elem in self {\\n            elem.hash(state);\\n        }\\n    }\\n}\\n\\nimpl<A, B> Hash for (A, B)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C> Hash for (A, B, C)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C, D> Hash for (A, B, C, D)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n    D: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n        self.3.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n    D: Hash,\\n    E: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n        self.3.hash(state);\\n        self.4.hash(state);\\n    }\\n}\\n\\n// Some test vectors for Pedersen hash and Pedersen Commitment.\\n// They have been generated using the same functions so the tests are for now useless\\n// but they will be useful when we switch to Noir implementation.\\n#[test]\\nfn assert_pedersen() {\\n    assert_eq(\\n        pedersen_hash_with_separator([1], 1),\\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1], 1),\\n        EmbeddedCurvePoint {\\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\\n            is_infinite: false,\\n        },\\n    );\\n\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2], 2),\\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2], 2),\\n        EmbeddedCurvePoint {\\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3], 3),\\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3], 3),\\n        EmbeddedCurvePoint {\\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\\n        EmbeddedCurvePoint {\\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\\n        EmbeddedCurvePoint {\\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\\n        EmbeddedCurvePoint {\\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\\n        EmbeddedCurvePoint {\\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\\n        EmbeddedCurvePoint {\\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\\n        EmbeddedCurvePoint {\\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\\n        EmbeddedCurvePoint {\\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\\n            is_infinite: false,\\n        },\\n    );\\n}\\n"},"26":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"27":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\\n\\n// Implementation of SHA-256 mapping a byte array of variable length to\\n// 32 bytes.\\n\\n// A message block is up to 64 bytes taken from the input.\\nglobal BLOCK_SIZE: u32 = 64;\\n\\n// The first index in the block where the 8 byte message size will be written.\\nglobal MSG_SIZE_PTR: u32 = 56;\\n\\n// Size of the message block when packed as 4-byte integer array.\\nglobal INT_BLOCK_SIZE: u32 = 16;\\n\\n// A `u32` integer consists of 4 bytes.\\nglobal INT_SIZE: u32 = 4;\\n\\n// Index of the integer in the `INT_BLOCK` where the length is written.\\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\\n\\n// Magic numbers for bit shifting.\\n// Works with actual bit shifting as well as the compiler turns them into * and /\\n// but circuit execution appears to be 10% faster this way.\\nglobal TWO_POW_8: u32 = 256;\\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\\n\\n// Index of a byte in a 64 byte block; ie. 0..=63\\ntype BLOCK_BYTE_PTR = u32;\\n\\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\\n\\n// A message block is a slice of the original message of a fixed size,\\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\\ntype MSG_BLOCK = INT_BLOCK;\\n\\n// The hash is 32 bytes.\\ntype HASH = [u8; 32];\\n\\n// The state accumulates the blocks.\\n// Its overall size is the same as the `HASH`.\\ntype STATE = [u32; 8];\\n\\n// Deprecated in favour of `sha256_var`\\n// docs:start:sha256\\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\\n// docs:end:sha256\\n{\\n    digest(input)\\n}\\n\\n#[foreign(sha256_compression)]\\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\\n\\n// SHA-256 hash function\\n#[no_predicates]\\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\\n    sha256_var(msg, N as u64)\\n}\\n\\n// Variable size SHA-256 hash\\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\\n    let message_size = message_size as u32;\\n    let num_blocks = N / BLOCK_SIZE;\\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\\n    // Intermediate hash, starting with the canonical initial value\\n    let mut h: STATE = [\\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\\n        1541459225,\\n    ];\\n    // Pointer into msg_block on a 64 byte scale\\n    let mut msg_byte_ptr = 0;\\n    for i in 0..num_blocks {\\n        let msg_start = BLOCK_SIZE * i;\\n        /// Safety: the msg_block is checked below in verify_msg_block\\n        let (new_msg_block, new_msg_byte_ptr) =\\n            unsafe { build_msg_block(msg, message_size, msg_start) };\\n\\n        if msg_start < message_size {\\n            msg_block = new_msg_block;\\n        }\\n\\n        if !is_unconstrained() {\\n            // Verify the block we are compressing was appropriately constructed\\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\\n            if msg_start < message_size {\\n                msg_byte_ptr = new_msg_byte_ptr;\\n            }\\n        } else if msg_start < message_size {\\n            msg_byte_ptr = new_msg_byte_ptr;\\n        }\\n\\n        // If the block is filled, compress it.\\n        // An un-filled block is handled after this loop.\\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\\n            h = sha256_compression(msg_block, h);\\n        }\\n    }\\n\\n    let modulo = N % BLOCK_SIZE;\\n    // Handle setup of the final msg block.\\n    // This case is only hit if the msg is less than the block size,\\n    // or our message cannot be evenly split into blocks.\\n    if modulo != 0 {\\n        let msg_start = BLOCK_SIZE * num_blocks;\\n        /// Safety: the msg_block is checked below in verify_msg_block\\n        let (new_msg_block, new_msg_byte_ptr) =\\n            unsafe { build_msg_block(msg, message_size, msg_start) };\\n\\n        if msg_start < message_size {\\n            msg_block = new_msg_block;\\n        }\\n\\n        if !is_unconstrained() {\\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\\n            if msg_start < message_size {\\n                msg_byte_ptr = new_msg_byte_ptr;\\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\\n            }\\n        } else if msg_start < message_size {\\n            msg_byte_ptr = new_msg_byte_ptr;\\n        }\\n    }\\n\\n    // If we had modulo == 0 then it means the last block was full,\\n    // and we can reset the pointer to zero to overwrite it.\\n    if msg_byte_ptr == BLOCK_SIZE {\\n        msg_byte_ptr = 0;\\n    }\\n\\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\\n    // Here we rely on the fact that everything beyond the available input is set to 0.\\n    msg_block = update_block_item(\\n        msg_block,\\n        msg_byte_ptr,\\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\\n    );\\n    msg_byte_ptr = msg_byte_ptr + 1;\\n    let last_block = msg_block;\\n\\n    // If we don\'t have room to write the size, compress the block and reset it.\\n    if msg_byte_ptr > MSG_SIZE_PTR {\\n        h = sha256_compression(msg_block, h);\\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\\n        msg_byte_ptr = 0;\\n    }\\n\\n    /// Safety: the msg_len is checked below in verify_msg_len\\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\\n\\n    if !is_unconstrained() {\\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\\n    }\\n\\n    hash_final_block(msg_block, h)\\n}\\n\\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\\n// Returns the block and the length that has been copied rather than padded with zeros.\\nunconstrained fn build_msg_block<let N: u32>(\\n    msg: [u8; N],\\n    message_size: u32,\\n    msg_start: u32,\\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\\n\\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\\n        if message_size < msg_start {\\n            // This function is sometimes called with `msg_start` past the end of the message.\\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\\n            0\\n        } else {\\n            message_size - msg_start\\n        }\\n    } else {\\n        BLOCK_SIZE\\n    };\\n\\n    // Figure out the number of items in the int array that we have to pack.\\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\\n    let mut int_input = block_input / INT_SIZE;\\n    if block_input % INT_SIZE != 0 {\\n        int_input = int_input + 1;\\n    };\\n\\n    for i in 0..int_input {\\n        let mut msg_item: u32 = 0;\\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\\n        for j in 0..INT_SIZE {\\n            let k = i * INT_SIZE + j;\\n            let msg_byte = if k < block_input {\\n                msg[msg_start + k]\\n            } else {\\n                0\\n            };\\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\\n        }\\n        msg_block[i] = msg_item;\\n    }\\n\\n    // Returning the index as if it was a 64 byte array.\\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\\n    (msg_block, block_input)\\n}\\n\\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\\n// and matches the input data. Returns the index of the first unset item.\\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\\n// in that case we can skip verification, ie. no need to check that everything is zero.\\nfn verify_msg_block<let N: u32>(\\n    msg: [u8; N],\\n    message_size: u32,\\n    msg_block: MSG_BLOCK,\\n    msg_start: u32,\\n) -> BLOCK_BYTE_PTR {\\n    let mut msg_byte_ptr = 0;\\n    let mut msg_end = msg_start + BLOCK_SIZE;\\n    if msg_end > N {\\n        msg_end = N;\\n    }\\n    // We might have to go beyond the input to pad the fields.\\n    if msg_end % INT_SIZE != 0 {\\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\\n    }\\n\\n    // Reconstructed packed item.\\n    let mut msg_item: u32 = 0;\\n\\n    // Inclusive at the end so that we can compare the last item.\\n    let mut i: u32 = 0;\\n    for k in msg_start..=msg_end {\\n        if k % INT_SIZE == 0 {\\n            // If we consumed some input we can compare against the block.\\n            if (msg_start < message_size) & (k > msg_start) {\\n                assert_eq(msg_block[i], msg_item as u32);\\n                i = i + 1;\\n                msg_item = 0;\\n            }\\n        }\\n        // Shift the accumulator\\n        msg_item = lshift8(msg_item, 1);\\n        // If we have input to consume, add it at the rightmost position.\\n        if k < message_size & k < msg_end {\\n            msg_item = msg_item + msg[k] as u32;\\n            msg_byte_ptr = msg_byte_ptr + 1;\\n        }\\n    }\\n\\n    msg_byte_ptr\\n}\\n\\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\\n// This is only relevant for the last, potentially partially filled block.\\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\\n    // Check all the way to the end of the block.\\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\\n}\\n\\n// Verify that a region of ints in the message block are (partially) zeroed,\\n// up to an (exclusive) maximum which can either be the end of the block\\n// or just where the size is to be written.\\nfn verify_msg_block_zeros(\\n    msg_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n    max_int_byte_ptr: u32,\\n) {\\n    // This variable is used to get around the compiler under-constrained check giving a warning.\\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\\n    // or return values the compiler check will issue a warning.\\n    let zero = msg_block[0] - msg_block[0];\\n\\n    // First integer which is supposed to be (partially) zero.\\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\\n\\n    // Check partial zeros.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        let zeros = INT_SIZE - modulo;\\n        let mask = if zeros == 3 {\\n            TWO_POW_24\\n        } else if zeros == 2 {\\n            TWO_POW_16\\n        } else {\\n            TWO_POW_8\\n        };\\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\\n        int_byte_ptr = int_byte_ptr + 1;\\n    }\\n\\n    // Check the rest of the items.\\n    for i in 0..max_int_byte_ptr {\\n        if i >= int_byte_ptr {\\n            assert_eq(msg_block[i], zero);\\n        }\\n    }\\n}\\n\\n// Verify that up to the byte pointer the two blocks are equal.\\n// At the byte pointer the new block can be partially zeroed.\\nfn verify_msg_block_equals_last(\\n    msg_block: MSG_BLOCK,\\n    last_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n) {\\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\\n    // First integer which is supposed to be (partially) zero contains that pointer.\\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\\n\\n    // Check partial zeros.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        // Reconstruct the partially zero item from the last block.\\n        let last_field = last_block[int_byte_ptr];\\n        let mut msg_item: u32 = 0;\\n        // Reset to where they are still equal.\\n        msg_byte_ptr = msg_byte_ptr - modulo;\\n        for i in 0..INT_SIZE {\\n            msg_item = lshift8(msg_item, 1);\\n            if i < modulo {\\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\\n                msg_byte_ptr = msg_byte_ptr + 1;\\n            }\\n        }\\n        assert_eq(msg_block[int_byte_ptr], msg_item);\\n    }\\n\\n    for i in 0..INT_SIZE_PTR {\\n        if i < int_byte_ptr {\\n            assert_eq(msg_block[i], last_block[i]);\\n        }\\n    }\\n}\\n\\n// Apply a function on the block item which the pointer indicates.\\nfn update_block_item<Env>(\\n    mut msg_block: MSG_BLOCK,\\n    msg_byte_ptr: BLOCK_BYTE_PTR,\\n    f: fn[Env](u32) -> u32,\\n) -> MSG_BLOCK {\\n    let i = msg_byte_ptr / INT_SIZE;\\n    msg_block[i] = f(msg_block[i]);\\n    msg_block\\n}\\n\\n// Set the rightmost `zeros` number of bytes to 0.\\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\\n    lshift8(rshift8(item, zeros), zeros)\\n}\\n\\n// Replace one byte in the item with a value, and set everything after it to zero.\\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\\n    zeroed_item + new_item\\n}\\n\\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\\n    // How many times do we have to shift to the right to get to the position we want?\\n    let max_shifts = INT_SIZE - 1;\\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\\n    msg_item = rshift8(msg_item, shifts as u8);\\n    // At this point the byte we want is in the rightmost position.\\n    msg_item as u8\\n}\\n\\n// Project a byte into a position in a field based on the overall block pointer.\\n// For example putting 1 into pointer 5 would be 100, because overall we would\\n// have [____, 0100] with indexes [0123,4567].\\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\\n    let mut msg_item = msg_byte as u32;\\n    // How many times do we have to shift to the left to get to the position we want?\\n    let max_shifts = INT_SIZE - 1;\\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\\n    lshift8(msg_item, shifts as u8)\\n}\\n\\n// Construct a field out of 4 bytes.\\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\\n    let mut item = b0 as u32;\\n    item = lshift8(item, 1) + b1 as u32;\\n    item = lshift8(item, 1) + b2 as u32;\\n    item = lshift8(item, 1) + b3 as u32;\\n    item\\n}\\n\\n// Shift by 8 bits to the left between 0 and 4 times.\\n// Checks `is_unconstrained()` to just use a bitshift if we\'re running in an unconstrained context,\\n// otherwise multiplies by 256.\\nfn lshift8(item: u32, shifts: u8) -> u32 {\\n    if is_unconstrained() {\\n        if item == 0 {\\n            0\\n        } else {\\n            // Brillig wouldn\'t shift 0<<4 without overflow.\\n            item << (8 * shifts)\\n        }\\n    } else {\\n        // We can do a for loop up to INT_SIZE or an if-else.\\n        if shifts == 0 {\\n            item\\n        } else if shifts == 1 {\\n            item * TWO_POW_8\\n        } else if shifts == 2 {\\n            item * TWO_POW_16\\n        } else if shifts == 3 {\\n            item * TWO_POW_24\\n        } else {\\n            // Doesn\'t make sense, but it\'s most likely called on 0 anyway.\\n            0\\n        }\\n    }\\n}\\n\\n// Shift by 8 bits to the right between 0 and 4 times.\\n// Checks `is_unconstrained()` to just use a bitshift if we\'re running in an unconstrained context,\\n// otherwise divides by 256.\\nfn rshift8(item: u32, shifts: u8) -> u32 {\\n    if is_unconstrained() {\\n        item >> (8 * shifts)\\n    } else {\\n        // Division wouldn\'t work on `Field`.\\n        if shifts == 0 {\\n            item\\n        } else if shifts == 1 {\\n            item / TWO_POW_8\\n        } else if shifts == 2 {\\n            item / TWO_POW_16\\n        } else if shifts == 3 {\\n            item / TWO_POW_24\\n        } else {\\n            0\\n        }\\n    }\\n}\\n\\n// Zero out all bytes between the end of the message and where the length is appended,\\n// then write the length into the last 8 bytes of the block.\\nunconstrained fn attach_len_to_msg_block(\\n    mut msg_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n    message_size: u32,\\n) -> MSG_BLOCK {\\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\\n    // There can be one item which has to be partially zeroed.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        // Index of the block in which we find the item we need to partially zero.\\n        let i = msg_byte_ptr / INT_SIZE;\\n        let zeros = INT_SIZE - modulo;\\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\\n        msg_byte_ptr = msg_byte_ptr + zeros;\\n    }\\n\\n    // The rest can be zeroed without bit shifting anything.\\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\\n        msg_block[i] = 0;\\n    }\\n\\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\\n    let len = 8 * message_size;\\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\\n    for i in 0..=1 {\\n        let shift = i * 4;\\n        msg_block[INT_SIZE_PTR + i] = make_item(\\n            len_bytes[shift],\\n            len_bytes[shift + 1],\\n            len_bytes[shift + 2],\\n            len_bytes[shift + 3],\\n        );\\n    }\\n    msg_block\\n}\\n\\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\\n// and that everything between the byte pointer and the size pointer was zeroed,\\n// and that everything before the byte pointer was untouched.\\nfn verify_msg_len(\\n    msg_block: MSG_BLOCK,\\n    last_block: MSG_BLOCK,\\n    msg_byte_ptr: BLOCK_BYTE_PTR,\\n    message_size: u32,\\n) {\\n    // Check zeros up to the size pointer.\\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\\n\\n    // Check that up to the pointer we match the last block.\\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\\n\\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\\n    let mut reconstructed_len: u64 = 0;\\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\\n        reconstructed_len = reconstructed_len * TWO_POW_32;\\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\\n    }\\n    let len = 8 * message_size as u64;\\n    assert_eq(reconstructed_len, len);\\n}\\n\\n// Perform the final compression, then transform the `STATE` into `HASH`.\\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\\n    // Hash final padded block\\n    state = sha256_compression(msg_block, state);\\n\\n    // Return final hash as byte array\\n    for j in 0..8 {\\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\\n        for k in 0..4 {\\n            out_h[4 * j + k] = h_bytes[k];\\n        }\\n    }\\n\\n    out_h\\n}\\n\\nmod tests {\\n    use super::{\\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\\n        set_item_byte_then_zeros, set_item_zeros,\\n    };\\n    use super::INT_BLOCK;\\n    use super::sha256_var;\\n\\n    #[test]\\n    fn smoke_test() {\\n        let input = [0xbd];\\n        let result = [\\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\\n            0x8f, 0xfe, 0x73, 0x2b,\\n        ];\\n        assert_eq(sha256_var(input, input.len() as u64), result);\\n    }\\n\\n    #[test]\\n    fn msg_just_over_block() {\\n        let input = [\\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\\n        ];\\n        let result = [\\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\\n        ];\\n        assert_eq(sha256_var(input, input.len() as u64), result);\\n    }\\n\\n    #[test]\\n    fn msg_multiple_over_block() {\\n        let input = [\\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\\n        ];\\n        let result = [\\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\\n        ];\\n        assert_eq(sha256_var(input, input.len() as u64), result);\\n    }\\n\\n    #[test]\\n    fn msg_just_under_block() {\\n        let input = [\\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\\n            108, 97, 105, 110, 59,\\n        ];\\n        let result = [\\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\\n        ];\\n        assert_eq(sha256_var(input, input.len() as u64), result);\\n    }\\n\\n    #[test]\\n    fn msg_big_not_block_multiple() {\\n        let input = [\\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\\n        ];\\n        let result = [\\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\\n        ];\\n        assert_eq(sha256_var(input, input.len() as u64), result);\\n    }\\n\\n    #[test]\\n    fn msg_big_with_padding() {\\n        let input = [\\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n        ];\\n        let result = [\\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\\n        ];\\n        let message_size = 297;\\n        assert_eq(sha256_var(input, message_size), result);\\n    }\\n\\n    #[test]\\n    fn msg_big_no_padding() {\\n        let input = [\\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\\n        ];\\n        let result = [\\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\\n        ];\\n        assert_eq(sha256_var(input, input.len() as u64), result);\\n    }\\n\\n    #[test]\\n    fn same_msg_len_variable_padding() {\\n        let input = [\\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\\n            119, 30, 63, 129, 143, 32, 96,\\n        ];\\n\\n        // Prepare inputs of different lengths\\n        let mut input_511 = [0; 511];\\n        let mut input_512 = [0; 512]; // Next block\\n        let mut input_575 = [0; 575];\\n        let mut input_576 = [0; 576]; // Next block\\n        for i in 0..input.len() {\\n            input_511[i] = input[i];\\n            input_512[i] = input[i];\\n            input_575[i] = input[i];\\n            input_576[i] = input[i];\\n        }\\n\\n        // Compute hashes of all inputs (with same message length)\\n        let fixed_length_hash = super::sha256(input);\\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\\n\\n        // All of the above should have produced the same hash\\n        assert_eq(var_full_length_hash, fixed_length_hash);\\n        assert_eq(var_length_hash_511, fixed_length_hash);\\n        assert_eq(var_length_hash_512, fixed_length_hash);\\n        assert_eq(var_length_hash_575, fixed_length_hash);\\n        assert_eq(var_length_hash_576, fixed_length_hash);\\n    }\\n\\n    #[test]\\n    fn test_get_item_byte() {\\n        let fld = make_item(10, 20, 30, 40);\\n        assert_eq(fld, 0x0a141e28);\\n        assert_eq(get_item_byte(fld, 0), 10);\\n        assert_eq(get_item_byte(fld, 4), 10);\\n        assert_eq(get_item_byte(fld, 6), 30);\\n    }\\n\\n    #[test]\\n    fn test_byte_into_item() {\\n        let fld = make_item(0, 20, 0, 0);\\n        assert_eq(byte_into_item(20, 1), fld);\\n        assert_eq(byte_into_item(20, 5), fld);\\n    }\\n\\n    #[test]\\n    fn test_set_item_zeros() {\\n        let fld0 = make_item(10, 20, 30, 40);\\n        let fld1 = make_item(10, 0, 0, 0);\\n        assert_eq(set_item_zeros(fld0, 3), fld1);\\n        assert_eq(set_item_zeros(fld0, 4), 0);\\n        assert_eq(set_item_zeros(0, 4), 0);\\n    }\\n\\n    #[test]\\n    fn test_set_item_byte_then_zeros() {\\n        let fld0 = make_item(10, 20, 30, 40);\\n        let fld1 = make_item(10, 50, 0, 0);\\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\\n    }\\n\\n    #[test]\\n    fn test_build_msg_block_start_0() {\\n        let input = [\\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\\n            101, 115, 46, 48,\\n        ];\\n        assert_eq(input.len(), 22);\\n\\n        /// Safety: testing context\\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\\n        assert_eq(msg_byte_ptr, input.len());\\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\\n        assert_eq(msg_block[6], 0);\\n    }\\n\\n    #[test]\\n    fn test_build_msg_block_start_1() {\\n        let input = [\\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\\n        ];\\n        assert_eq(input.len(), 68);\\n        /// Safety: test context\\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\\n        assert_eq(msg_byte_ptr, 4);\\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\\n        assert_eq(msg_block[1], 0);\\n    }\\n\\n    #[test]\\n    fn test_attach_len_to_msg_block() {\\n        let input: INT_BLOCK = [\\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\\n            1849316213, 1651139939,\\n        ];\\n        /// Safety: testing context\\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\\n        assert_eq(msg_block[1], 0);\\n        assert_eq(msg_block[15], 3584);\\n    }\\n}\\n"},"51":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\\nuse crate::default::Default;\\nuse crate::hash::{Hash, Hasher};\\n\\npub struct Option<T> {\\n    _is_some: bool,\\n    _value: T,\\n}\\n\\nimpl<T> Option<T> {\\n    /// Constructs a None value\\n    pub fn none() -> Self {\\n        Self { _is_some: false, _value: crate::mem::zeroed() }\\n    }\\n\\n    /// Constructs a Some wrapper around the given value\\n    pub fn some(_value: T) -> Self {\\n        Self { _is_some: true, _value }\\n    }\\n\\n    /// True if this Option is None\\n    pub fn is_none(self) -> bool {\\n        !self._is_some\\n    }\\n\\n    /// True if this Option is Some\\n    pub fn is_some(self) -> bool {\\n        self._is_some\\n    }\\n\\n    /// Asserts `self.is_some()` and returns the wrapped value.\\n    pub fn unwrap(self) -> T {\\n        assert(self._is_some);\\n        self._value\\n    }\\n\\n    /// Returns the inner value without asserting `self.is_some()`\\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\\n    /// only that it will be of type `T`.\\n    pub fn unwrap_unchecked(self) -> T {\\n        self._value\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\\n    pub fn unwrap_or(self, default: T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\\n    /// a default value.\\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\\n        assert(self.is_some(), message);\\n        self._value\\n    }\\n\\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\\n        if self._is_some {\\n            Option::some(f(self._value))\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Returns None if self is None. Otherwise, this returns `other`.\\n    pub fn and(self, other: Self) -> Self {\\n        if self.is_none() {\\n            Option::none()\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is None, this returns None. Otherwise, this calls the given function\\n    /// with the Some value contained within self, and returns the result of that call.\\n    ///\\n    /// In some languages this function is called `flat_map` or `bind`.\\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `other`.\\n    pub fn or(self, other: Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `default()`.\\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    // If only one of the two Options is Some, return that option.\\n    // Otherwise, if both options are Some or both are None, None is returned.\\n    pub fn xor(self, other: Self) -> Self {\\n        if self._is_some {\\n            if other._is_some {\\n                Option::none()\\n            } else {\\n                self\\n            }\\n        } else if other._is_some {\\n            other\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\\n    /// Otherwise, this returns `None`\\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\\n        if self._is_some {\\n            if predicate(self._value) {\\n                self\\n            } else {\\n                Option::none()\\n            }\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Flattens an Option<Option<T>> into a Option<T>.\\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\\n        if option._is_some {\\n            option._value\\n        } else {\\n            Option::none()\\n        }\\n    }\\n}\\n\\nimpl<T> Default for Option<T> {\\n    fn default() -> Self {\\n        Option::none()\\n    }\\n}\\n\\nimpl<T> Eq for Option<T>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: Self) -> bool {\\n        if self._is_some == other._is_some {\\n            if self._is_some {\\n                self._value == other._value\\n            } else {\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for Option<T>\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self._is_some.hash(state);\\n        if self._is_some {\\n            self._value.hash(state);\\n        }\\n    }\\n}\\n\\n// For this impl we\'re declaring Option::none < Option::some\\nimpl<T> Ord for Option<T>\\nwhere\\n    T: Ord,\\n{\\n    fn cmp(self, other: Self) -> Ordering {\\n        if self._is_some {\\n            if other._is_some {\\n                self._value.cmp(other._value)\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other._is_some {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n"},"52":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"62":{"path":"/build-volume/noir-projects/noir-contracts/contracts/schnorr_account_contract/src/main.nr","source":"mod public_key_note;\\n\\n// Account contract that uses Schnorr signatures for authentication.\\n// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.\\nuse dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract SchnorrAccount {\\n    use dep::authwit::{\\n        account::AccountActions,\\n        auth::{compute_authwit_message_hash, compute_authwit_nullifier},\\n        auth_witness::get_auth_witness,\\n        entrypoint::{app::AppPayload, fee::FeePayload},\\n    };\\n    use dep::aztec::encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note;\\n    use dep::aztec::hash::compute_siloed_nullifier;\\n    use dep::aztec::macros::{\\n        functions::{initializer, noinitcheck, private, view},\\n        storage::storage,\\n    };\\n    use dep::aztec::oracle::get_nullifier_membership_witness::get_low_nullifier_membership_witness;\\n    use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateImmutable};\\n\\n    use crate::public_key_note::PublicKeyNote;\\n\\n    #[storage]\\n    struct Storage<Context> {\\n        // docs:start:public_key\\n        signing_public_key: PrivateImmutable<PublicKeyNote, Context>,\\n        // docs:end:public_key\\n    }\\n\\n    // Constructs the contract\\n    #[private]\\n    #[initializer]\\n    fn constructor(signing_pub_key_x: Field, signing_pub_key_y: Field) {\\n        let this = context.this_address();\\n        let mut pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\\n        storage.signing_public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note(\\n            &mut context,\\n            this,\\n            this,\\n        ));\\n    }\\n\\n    // Note: If you globally change the entrypoint signature don\'t forget to update account_entrypoint.ts file\\n    #[private]\\n    #[noinitcheck]\\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\\n        let actions = AccountActions::init(&mut context, is_valid_impl);\\n        actions.entrypoint(app_payload, fee_payload, cancellable);\\n    }\\n\\n    #[private]\\n    #[noinitcheck]\\n    #[view]\\n    fn verify_private_authwit(inner_hash: Field) -> Field {\\n        let actions = AccountActions::init(&mut context, is_valid_impl);\\n        actions.verify_private_authwit(inner_hash)\\n    }\\n\\n    #[contract_library_method]\\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\\n        // docs:start:is_valid_impl\\n        // Load public key from storage\\n        let storage = Storage::init(context);\\n        let public_key = storage.signing_public_key.get_note();\\n\\n        // Load auth witness\\n        /// Safety: The witness is only used as a \\"magical value\\" that makes the signature verification below pass.\\n        /// Hence it\'s safe.\\n        let witness: [Field; 64] = unsafe { get_auth_witness(outer_hash) };\\n        let mut signature: [u8; 64] = [0; 64];\\n        for i in 0..64 {\\n            signature[i] = witness[i] as u8;\\n        }\\n\\n        let pub_key = std::embedded_curve_ops::EmbeddedCurvePoint {\\n            x: public_key.x,\\n            y: public_key.y,\\n            is_infinite: false,\\n        };\\n        // Verify signature of the payload bytes\\n        schnorr::verify_signature(pub_key, signature, outer_hash.to_be_bytes::<32>())\\n        // docs:end:is_valid_impl\\n    }\\n\\n    /**\\n    * @notice Helper function to check validity of private authwitnesses\\n    * @param consumer The address of the consumer of the message\\n    * @param message_hash The message hash of the message to check the validity\\n    * @return True if the message_hash can be consumed, false otherwise\\n    */\\n    unconstrained fn lookup_validity(consumer: AztecAddress, inner_hash: Field) -> pub bool {\\n        let public_key = storage.signing_public_key.view_note();\\n\\n        let message_hash = compute_authwit_message_hash(\\n            consumer,\\n            context.chain_id(),\\n            context.version(),\\n            inner_hash,\\n        );\\n\\n        let witness: [Field; 64] = get_auth_witness(message_hash);\\n        let mut signature: [u8; 64] = [0; 64];\\n        for i in 0..64 {\\n            signature[i] = witness[i] as u8;\\n        }\\n        let pub_key = std::embedded_curve_ops::EmbeddedCurvePoint {\\n            x: public_key.x,\\n            y: public_key.y,\\n            is_infinite: false,\\n        };\\n        let valid_in_private =\\n            schnorr::verify_signature(pub_key, signature, message_hash.to_be_bytes::<32>());\\n\\n        // Compute the nullifier and check if it is spent\\n        // This will BLINDLY TRUST the oracle, but the oracle is us, and\\n        // it is not as part of execution of the contract, so we are good.\\n        let nullifier = compute_authwit_nullifier(context.this_address(), inner_hash);\\n        let siloed_nullifier = compute_siloed_nullifier(consumer, nullifier);\\n        let lower_wit =\\n            get_low_nullifier_membership_witness(context.block_number(), siloed_nullifier);\\n        let is_spent = lower_wit.leaf_preimage.nullifier == siloed_nullifier;\\n\\n        !is_spent & valid_in_private\\n    }\\n}\\n"},"63":{"path":"/build-volume/noir-projects/noir-contracts/contracts/schnorr_account_contract/src/public_key_note.nr","source":"use dep::aztec::{\\n    keys::getters::{get_nsk_app, get_public_keys},\\n    macros::notes::note,\\n    note::utils::compute_note_hash_for_nullify,\\n    protocol_types::{\\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\\n        hash::poseidon2_hash_with_separator, traits::Packable,\\n    },\\n};\\nuse dep::aztec::prelude::{NoteHeader, NullifiableNote, PrivateContext};\\n\\n// Stores a public key composed of two fields\\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\\n#[note]\\npub struct PublicKeyNote {\\n    x: Field,\\n    y: Field,\\n    owner: AztecAddress,\\n}\\n\\nimpl NullifiableNote for PublicKeyNote {\\n    fn compute_nullifier(\\n        self,\\n        context: &mut PrivateContext,\\n        note_hash_for_nullify: Field,\\n    ) -> Field {\\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\\n        let secret = context.request_nsk_app(owner_npk_m_hash);\\n        poseidon2_hash_with_separator(\\n            [note_hash_for_nullify, secret],\\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\\n        )\\n    }\\n\\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\\n        let secret = get_nsk_app(owner_npk_m_hash);\\n        poseidon2_hash_with_separator(\\n            [note_hash_for_nullify, secret],\\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\\n        )\\n    }\\n}\\n\\nimpl PublicKeyNote {\\n    pub fn new(x: Field, y: Field, owner: AztecAddress) -> Self {\\n        PublicKeyNote { x, y, owner, header: NoteHeader::empty() }\\n    }\\n}\\n"},"64":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\\n    context::PrivateContext,\\n    hash::poseidon2_hash_with_separator,\\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\\n};\\n\\nuse crate::auth::{compute_authwit_message_hash, IS_VALID_SELECTOR};\\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\\n\\npub struct AccountActions<Context> {\\n    context: Context,\\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\\n}\\n\\nimpl<Context> AccountActions<Context> {\\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\\n        AccountActions { context, is_valid_impl }\\n    }\\n}\\n\\n/**\\n * An implementation of the Account Action struct for the private context.\\n *\\n * Implements logic to verify authorization and execute payloads.\\n */\\nimpl AccountActions<&mut PrivateContext> {\\n\\n    /**\\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\\n     *\\n     * Executes the `fee_payload` and `app_payload` in sequence.\\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\\n     *\\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\\n     */\\n    // docs:start:entrypoint\\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\\n        let valid_fn = self.is_valid_impl;\\n\\n        let combined_payload_hash = poseidon2_hash_with_separator(\\n            [app_payload.hash(), fee_payload.hash()],\\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\\n        );\\n        assert(valid_fn(self.context, combined_payload_hash));\\n\\n        fee_payload.execute_calls(self.context);\\n        self.context.end_setup();\\n        app_payload.execute_calls(self.context);\\n        if cancellable {\\n            let tx_nullifier =\\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\\n            self.context.push_nullifier(tx_nullifier);\\n        }\\n    }\\n    // docs:end:entrypoint\\n\\n    /**\\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\\n     *\\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\\n     *\\n     * Will revert if the message is not authorized.\\n     *\\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\\n     */\\n    // docs:start:verify_private_authwit\\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\\n        // The `inner_hash` is \\"siloed\\" with the `msg_sender` to ensure that only it can\\n        // consume the message.\\n        // This ensures that contracts cannot consume messages that are not intended for them.\\n        let message_hash = compute_authwit_message_hash(\\n            self.context.msg_sender(),\\n            self.context.chain_id(),\\n            self.context.version(),\\n            inner_hash,\\n        );\\n        let valid_fn = self.is_valid_impl;\\n        assert(valid_fn(self.context, message_hash) == true, \\"Message not authorized by account\\");\\n        IS_VALID_SELECTOR\\n    }\\n    // docs:end:verify_private_authwit\\n}\\n"},"65":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\\nuse dep::aztec::protocol_types::{\\n    abis::function_selector::FunctionSelector,\\n    address::AztecAddress,\\n    constants::{\\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\\n    },\\n    hash::poseidon2_hash_with_separator,\\n};\\n\\n/**\\n * Authenticaion witness helper library\\n *\\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\\n * (e.g. protocols or other users) to execute an action on their behalf.\\n *\\n * This library provides helper functions to manage such witnesses.\\n * The authentication witness, is some \\"witness\\" (data) that authenticates a `message_hash`.\\n * The simplest example of an authentication witness, is a signature. The signature is the \\"evidence\\",\\n * that the signer has seen the message, agrees with it, and has allowed it.\\n * It does not need to be a signature. It could be any kind of \\"proof\\" that the message is allowed.\\n * Another proof could be knowing some kind of secret, or having some kind of \\"token\\" that allows the message.\\n *\\n * The `message_hash` is a hash of the following structure:\\n * hash(consumer, chain_id, version, inner_hash)\\n * - consumer: the address of the contract that is \\"consuming\\" the message,\\n * - chain_id: the chain id of the chain that the message is being consumed on,\\n * - version: the version of the chain that the message is being consumed on,\\n * - inner_hash: the hash of the \\"inner\\" message that is being consumed, this is the \\"actual\\" message or action.\\n *\\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\\n * a hash of the \\"action\\" to approve, along with who made the call. As part of this library, we provide a few\\n * helper functions to deal with such messages.\\n *\\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\\n * This can be used to let some contract \\"allow\\" another contract to act on its behalf, as long as it can\\n * show that it is acting on behalf of the contract.\\n *\\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\\n * derived as:\\n * inner_hash = hash(caller, \\"transfer\\", hash(to, amount))\\n *\\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\\n * the arguments for the transfer.\\n *\\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\\n * allowed to transfer the tokens.\\n *\\n *\\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\\n * is executed on the user\'s device, so we can use `oracles` to \\"ask\\" the user (not contract) for information. In public\\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \\"registry\\"\\n * to store the messages that we have approved.\\n *\\n * A simple example would be a \\"token\\" that is being \\"pulled\\" from one account into another. We will first outline\\n * how this would look in private, and then in public later.\\n *\\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\\n * convince the `Token` contract that it is allowed to do so.\\n *\\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\\n * execute that call.\\n *\\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\\n * funds from `Alice`.\\n *\\n * To ensure that the same \\"approval\\" cannot be used multiple times, we also compute a `nullifier` for the\\n * authentication witness, and emit it from the `Token` contract (consumer).\\n *\\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\\n *\\n *\\n *  Person          Contract              Contract               Contract\\n *  Alice          Alice Account          Token                   DeFi\\n *   |                  |                  |                      |\\n *   | Defi.deposit(Token, 1000)           |                      |\\n *   |-----------------\x3e|                  |                      |\\n *   |                  | deposit(Token, 1000)                    |\\n *   |                  |----------------------------------------\x3e|\\n *   |                  |                  |                      |\\n *   |                  |                  | transfer(Alice, Defi, 1000)\\n *   |                  |                  |<---------------------|\\n *   |                  |                  |                      |\\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\\n *   |                  |<-----------------|                      |\\n *   |                  |                  |                      |\\n *   | Please give me AuthWit for DeFi     |                      |\\n *   | calling transfer(Alice, Defi, 1000) |                      |\\n *   |<-----------------|                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\\n *   |-----------------\x3e|                  |                      |\\n *   |                  | AuthWit validity |                      |\\n *   |                  |-----------------\x3e|                      |\\n *   |                  |                  |                      |\\n *   |                  |       throw if invalid AuthWit          |\\n *   |                  |                  |                      |\\n *   |                  |       emit AuthWit nullifier            |\\n *   |                  |                  |                      |\\n *   |                  |       transfer(Alice, Defi, 1000)       |\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  | success              |\\n *   |                  |                  |---------------------\x3e|\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  |           deposit(Token, 1000)\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *\\n *\\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\\n * the messages that we have approved.\\n *\\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\\n *\\n * The `Token` contract can then try to \\"spend\\" the approval by calling `consume` on the registry. If the message\\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\\n * registry, see `main.nr` in `auth_registry_contract`.\\n *\\n * Person          Contract              Contract            Contract               Contract\\n * Alice          Alice Account          Registry             Token                   DeFi\\n *   |                  |                    |                   |                      |\\n *   | Registry.set_authorized(..., true)    |                   |                      |\\n *   |-----------------\x3e|                    |                   |                      |\\n *   |                  | set_authorized(..., true)              |                      |\\n *   |                  |-------------------\x3e|                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |         set authorized to true         |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   | Defi.deposit(Token, 1000)             |                   |                      |\\n *   |-----------------\x3e|                    |                   |                      |\\n *   |                  | deposit(Token, 1000)                   |                      |\\n *   |                  |--------------------------------------------------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\\n *   |                  |                    |                   |<---------------------|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\\n *   |                  |                    |<------------------|                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |          throw if invalid AuthWit      |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |           set authorized to false      |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    | AuthWit validity  |                      |\\n *   |                  |                    |------------------\x3e|                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\\n *   |                  |                    |                   |<--------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   | success              |\\n *   |                  |                    |                   |---------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |     deposit(Token, 1000)\\n *   |                  |                    |                   |                      |\\n *\\n *\\n * --- FAQ ---\\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\\"IS_VALID()\\")` instead of just returning a boolean?\\n * A:   We want to make sure that we don\'t accidentally return `true` if there is a collision in the function selector.\\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\\n *      a success flag.\\n *\\n * Q:   Why are we using static calls?\\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\\n *\\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\\n *\\n * Q:   Why is the chain id and the version part of the message hash?\\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\\n *      chain to avoid a case where the same message could be used across multiple chains.\\n */\\n\\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\\"IS_VALID()\\")\\n\\n/**\\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n */\\n// docs:start:assert_current_call_valid_authwit\\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\\n    let inner_hash = compute_inner_authwit_hash([\\n        context.msg_sender().to_field(),\\n        context.selector().to_field(),\\n        context.args_hash,\\n    ]);\\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\\n}\\n// docs:end:assert_current_call_valid_authwit\\n\\n/**\\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\\n *\\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n * @param inner_hash The hash of the message to authorize\\n */\\npub fn assert_inner_hash_valid_authwit(\\n    context: &mut PrivateContext,\\n    on_behalf_of: AztecAddress,\\n    inner_hash: Field,\\n) {\\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\\n    let result: Field = context\\n        .static_call_private_function(\\n            on_behalf_of,\\n            comptime { FunctionSelector::from_signature(\\"verify_private_authwit(Field)\\") },\\n            [inner_hash],\\n        )\\n        .get_preimage();\\n    assert(result == IS_VALID_SELECTOR, \\"Message not authorized by account\\");\\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\\n    context.push_nullifier(nullifier);\\n}\\n\\n/**\\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n */\\n// docs:start:assert_current_call_valid_authwit_public\\npub unconstrained fn assert_current_call_valid_authwit_public(\\n    context: &mut PublicContext,\\n    on_behalf_of: AztecAddress,\\n) {\\n    let inner_hash = compute_inner_authwit_hash([\\n        (*context).msg_sender().to_field(),\\n        (*context).selector().to_field(),\\n        (*context).get_args_hash(),\\n    ]);\\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\\n}\\n// docs:end:assert_current_call_valid_authwit_public\\n\\n/**\\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\\n */\\npub unconstrained fn assert_inner_hash_valid_authwit_public(\\n    context: &mut PublicContext,\\n    on_behalf_of: AztecAddress,\\n    inner_hash: Field,\\n) {\\n    let results: [Field] = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"consume((Field),Field)\\") },\\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(results.len() == 1, \\"Invalid response from registry\\");\\n    assert(results[0] == IS_VALID_SELECTOR, \\"Message not authorized by account\\");\\n}\\n\\n/**\\n * Compute the `message_hash` from a function call to be used by an authentication witness\\n *\\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\\n * B to transfer T on its behalf.\\n *\\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\\n * @param chain_id The chain id of the chain that the message is being consumed on\\n * @param version The version of the chain that the message is being consumed on\\n * @param selector The function selector of the function that is being called\\n * @param args The arguments of the function that is being called\\n */\\n// docs:start:compute_authwit_message_hash_from_call\\npub fn compute_authwit_message_hash_from_call<let N: u32>(\\n    caller: AztecAddress,\\n    consumer: AztecAddress,\\n    chain_id: Field,\\n    version: Field,\\n    selector: FunctionSelector,\\n    args: [Field; N],\\n) -> Field {\\n    let args_hash = hash_args_array(args);\\n    let inner_hash =\\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\\n}\\n// docs:end:compute_authwit_message_hash_from_call\\n\\n/**\\n * Computes the `inner_hash` of the authentication witness\\n *\\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\\n * that is not necessarily a call, but just some \\"bytes\\" or text.\\n *\\n * @param args The arguments to hash\\n */\\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\\n}\\n\\n/**\\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\\n *\\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\\n *\\n * @param on_behalf_of The address that has authorized the `inner_hash`\\n * @param inner_hash The hash of the message to authorize\\n */\\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [on_behalf_of.to_field(), inner_hash],\\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\\n    )\\n}\\n\\n/**\\n * Computes the `message_hash` for the authentication witness\\n *\\n * @param consumer The address of the contract that is consuming the message\\n * @param chain_id The chain id of the chain that the message is being consumed on\\n * @param version The version of the chain that the message is being consumed on\\n * @param inner_hash The hash of the \\"inner\\" message that is being consumed\\n */\\npub fn compute_authwit_message_hash(\\n    consumer: AztecAddress,\\n    chain_id: Field,\\n    version: Field,\\n    inner_hash: Field,\\n) -> Field {\\n    poseidon2_hash_with_separator(\\n        [consumer.to_field(), chain_id, version, inner_hash],\\n        GENERATOR_INDEX__AUTHWIT_OUTER,\\n    )\\n}\\n\\n/**\\n * Helper function to set the authorization status of a message hash\\n *\\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\\n *\\n * @param message_hash The hash of the message to authorize\\n * @param authorize True if the message should be authorized, false if it should be revoked\\n */\\npub unconstrained fn set_authorized(\\n    context: &mut PublicContext,\\n    message_hash: Field,\\n    authorize: bool,\\n) {\\n    let res = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"set_authorized(Field,bool)\\") },\\n        [message_hash, authorize as Field].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(res.len() == 0);\\n}\\n\\n/**\\n * Helper function to reject all authwits\\n *\\n * Wraps a public call to the authentication registry to set the `reject_all` flag\\n *\\n * @param reject True if all authwits should be rejected, false otherwise\\n */\\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\\n    let res = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"set_reject_all(bool)\\") },\\n        [context.this_address().to_field(), reject as Field].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(res.len() == 0);\\n}\\n"},"66":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\\n\\n/**\\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\\n *\\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\\n * @return The `auth_witness` for the given `message_hash` as Field array.\\n */\\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\\n    get_auth_witness_oracle(message_hash)\\n}\\n"},"68":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::{\\n    prelude::PrivateContext,\\n    protocol_types::{\\n        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,\\n        hash::poseidon2_hash_with_separator,\\n        traits::{Hash, Serialize},\\n    },\\n};\\nuse std::meta::derive;\\n\\nuse crate::entrypoint::function_call::FunctionCall;\\n\\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\\n\\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\\n\\n// Note: If you change the following struct you have to update default_entrypoint.ts\\n// docs:start:app-payload-struct\\n#[derive(Serialize)]\\npub struct AppPayload {\\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\\n    nonce: Field,\\n}\\n// docs:end:app-payload-struct\\n\\nimpl Hash for AppPayload {\\n    fn hash(self) -> Field {\\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\\n    }\\n}\\n\\nimpl AppPayload {\\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\\n\\n        for i in 0..ACCOUNT_MAX_CALLS {\\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\\n        }\\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\\n\\n        bytes.storage()\\n    }\\n\\n    // Executes all private and public calls\\n    // docs:start:entrypoint-execute-calls\\n    fn execute_calls(self, context: &mut PrivateContext) {\\n        for call in self.function_calls {\\n            if !call.target_address.is_zero() {\\n                if call.is_public {\\n                    context.call_public_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                } else {\\n                    let _result = context.call_private_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                }\\n            }\\n        }\\n    }\\n    // docs:end:entrypoint-execute-calls\\n}\\n"},"69":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use crate::entrypoint::function_call::FunctionCall;\\nuse dep::aztec::{\\n    prelude::PrivateContext,\\n    protocol_types::{\\n        constants::GENERATOR_INDEX__FEE_PAYLOAD,\\n        hash::poseidon2_hash_with_separator,\\n        traits::{Hash, Serialize},\\n    },\\n};\\nuse std::meta::derive;\\n\\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\\n\\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\\n\\n// docs:start:fee-payload-struct\\n#[derive(Serialize)]\\npub struct FeePayload {\\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\\n    nonce: Field,\\n    is_fee_payer: bool,\\n}\\n// docs:end:fee-payload-struct\\n\\nimpl Hash for FeePayload {\\n    fn hash(self) -> Field {\\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\\n    }\\n}\\n\\nimpl FeePayload {\\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\\n\\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\\n        }\\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\\n        bytes.push(self.is_fee_payer as u8);\\n\\n        bytes.storage()\\n    }\\n\\n    fn execute_calls(self, context: &mut PrivateContext) {\\n        for call in self.function_calls {\\n            if !call.target_address.is_zero() {\\n                if call.is_public {\\n                    context.call_public_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                } else {\\n                    let _result = context.call_private_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                }\\n            }\\n        }\\n        if self.is_fee_payer {\\n            context.set_as_fee_payer();\\n        }\\n    }\\n}\\n"},"80":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::Empty,\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            /// for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\\n        /// to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"83":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use crate::oracle::{\\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\\n    storage::storage_read,\\n};\\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\\n\\npub struct UnconstrainedContext {\\n    block_number: u32,\\n    contract_address: AztecAddress,\\n    version: Field,\\n    chain_id: Field,\\n}\\n\\nimpl UnconstrainedContext {\\n    pub unconstrained fn new() -> Self {\\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\\n        // not even be accessed. However any performance gains are minimal, and we\'d rather fail early if a user\\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\\n        // available.\\n        let block_number = get_block_number();\\n        let contract_address = get_contract_address();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\\n        let block_number = get_block_number();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub fn block_number(self) -> u32 {\\n        self.block_number\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.version\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.chain_id\\n    }\\n\\n    pub unconstrained fn raw_storage_read<let N: u32>(\\n        self: Self,\\n        storage_slot: Field,\\n    ) -> [Field; N] {\\n        storage_read(self.this_address(), storage_slot, self.block_number())\\n    }\\n\\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n}\\n"},"85":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr","source":"use std::hash::{from_field_unsafe as fr_to_fq_unsafe, sha256};\\n\\nuse dep::protocol_types::{\\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\\n    hash::poseidon2_hash_with_separator,\\n    point::Point,\\n};\\n\\nuse crate::utils::point::point_to_bytes;\\n\\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\\n    shared_secret: Point,\\n) -> [u8; 32] {\\n    let rand1: Field = poseidon2_hash_with_separator(\\n        [shared_secret.x, shared_secret.y],\\n        GENERATOR_INDEX__SYMMETRIC_KEY,\\n    );\\n    let rand2: Field = poseidon2_hash_with_separator(\\n        [shared_secret.x, shared_secret.y],\\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\\n    );\\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\\n    let mut bytes: [u8; 32] = [0; 32];\\n    for i in 0..16 {\\n        bytes[i] = rand1_bytes[i];\\n        bytes[i + 1] = rand2_bytes[i];\\n    }\\n    bytes\\n}\\n\\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\\n    shared_secret: Point,\\n) -> [u8; 32] {\\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\\n\\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\\n    for i in 0..shared_secret_bytes.len() {\\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\\n    }\\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\\n\\n    sha256(shared_secret_bytes_with_separator)\\n}\\n\\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\\n    shared_secret: Point,\\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\\n) -> ([u8; 16], [u8; 16]) {\\n    let random_256_bits = randomness_extraction_fn(shared_secret);\\n    let mut sym_key = [0; 16];\\n    let mut iv = [0; 16];\\n    for i in 0..16 {\\n        sym_key[i] = random_256_bits[i];\\n        iv[i] = random_256_bits[i + 16];\\n    }\\n    (sym_key, iv)\\n}\\n\\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\\n    shared_secret: Point,\\n) -> ([u8; 16], [u8; 16]) {\\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\\n        shared_secret,\\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\\n    )\\n}\\n\\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\\n    shared_secret: Point,\\n) -> ([u8; 16], [u8; 16]) {\\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\\n        shared_secret,\\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\\n    )\\n}\\n"},"89":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note.nr","source":"use crate::{\\n    context::PrivateContext,\\n    encrypted_logs::encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\\n    keys::{\\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\\n        ephemeral::generate_ephemeral_key_pair,\\n    },\\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\\n    oracle::{\\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\\n        random::random,\\n    },\\n    utils::{bytes::{be_bytes_31_to_fields, get_random_bytes}, point::get_sign_of_point},\\n};\\nuse dep::protocol_types::{\\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\\n};\\nuse std::aes128::aes128_encrypt;\\n\\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48; // contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\\n\\n/*\\n * WHY IS THERE LOTS OF CODE DUPLICATION BETWEEN event.nr and note.nr?\\n * It\'s because there are a few more optimisations that can be done for notes,\\n * and so the stuff that looks like duplicated code currently, won\'t be\\n * the same for long.\\n * To modularise now feels premature, because we might get that modularisation wrong.\\n * Much better (imo) to have a flattened templates for log assembly, because it\\n * makes it much easier for us all to follow, it serves as a nice example for the\\n * community to follow (if they wish to roll their own log layouts), and it gives\\n * us more time to spot common patterns across all kinds of log layouts.\\n */\\n\\n/*\\n * LOG CONFIGURATION CHOICES:\\n *\\n * deliver_to: INPUT as recipient: AztecAddress\\n * encrypt_with: aes128 CBC (Cipher Block Chaining)\\n * shared_secret: ephemeral\\n * shared_secret_randomness_extraction_hash: sha256\\n * tag: true\\n * tag_from: INPUT as sender: AztecAddress\\n *\\n * Note-specific:\\n * derive_note_randomness_from_shared_secret: false\\n *\\n */\\n\\n/*\\n * LOG LAYOUT CHOICE:\\n *\\n * Short explanation:\\n * log = [tag, epk, header_ct=[[contract_address, ct_len], pkcs7_pad], ct=[[pt], pkcs7_pad], some bytes padding, some fields padding]\\n *\\n * Long explanation:\\n * tag: Field\\n * epk: [Field, u8]\\n * header_ct: [[u8; 32], [u8; 2], [u8; 16]]\\n * ct: [[u8; 2], [u8; x], [u8; y]]\\n *\\n * More precisely (in pseudocode):\\n *\\n * log = [\\n *     tag: Field,\\n *     Epk: Field,\\n *\\n *     le_bytes_31_to_fields(\\n *\\n *         log_bytes: [\\n *             eph_pk_sign: [u8; 1],\\n *\\n *             header_ciphertext: aes_encrypt(\\n *                 contract_address: [u8; 32],\\n *                 ct_length: [u8; 2],\\n *\\n *                 // the aes128_encrypt fn automatically inserts padding:\\n *                 header_pt_aes_padding: [u8; 14], // `16 - (input.len() % 16)`\\n\\n *             ): [u8; 48],\\n *\\n *             ciphertext: aes_encrypt(\\n *                 final_pt: [\\n *                     pt: {\\n *                         note_bytes: {\\n *                             storage_slot: [u8; 32],\\n *                             note_type_id: [u8; 32],\\n *                             ...note: [u8; N * 32],\\n *                         }: [u8; N * 32 + 64],\\n *                     }: [u8; N * 32 + 64],\\n\\n *                 ]: [u8; N * 32 + 64],\\n *\\n *                 // the aes128_encrypt fn automatically inserts padding:\\n *                 pt_aes_padding: [u8; 16 - ( (|pt_length| + |pt|) % 16 )]\\n *\\n *             ): [u8; |pt| + |pt_aes_padding|]\\n *                [u8; |ct|]\\n *\\n *             log_bytes_padding_to_mult_31: [u8; 31 * ceil((1 + 48 + |ct|)/31) - (1 + 48 + |ct|)],\\n *                                           [u8; p]\\n *\\n *         ]: [u8; 1 + 48 + |ct| + p]\\n *\\n *     ): [Field; (1 + 48 + |ct| + p) / 31]\\n *\\n *     log_fields_padding: [Field; PRIVATE_LOG_SIZE_IN_FIELDS - 2 - (1 + 48 + |ct| + p) / 31],\\n *\\n * ]: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\\n *\\n *\\n */\\n\\n/********************************************************/\\n// Disgusting arithmetic on generics\\n/********************************************************/\\n\\n// In this section, instead of initialising arrays with very complicated generic\\n// arithmetic, such as:\\n// let my_arr: [u8; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))] = [0; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))];\\n//... we instead do the arithmetic a little bit at a time, so that the computation\\n// can be audited and understood. Now, we can\'t do arithmetic on generics in the body\\n// of a function, so we abusing functions in the following way:\\n\\n// |full_pt| = |pt| = (N * 32) + 64\\nfn get_arr_of_size__full_plaintext<let PT: u32>() -> [u8; PT] {\\n    [0; PT]\\n}\\n\\n// |pt_aes_padding| = 16 - (|full_pt| % 16)\\nfn get_arr_of_size__plaintext_aes_padding<let FULL_PT: u32>(\\n    _full_pt: [u8; FULL_PT],\\n) -> [u8; 16 - (FULL_PT % 16)] {\\n    [0; 16 - (FULL_PT % 16)]\\n}\\n\\n// |ct| = |full_pt| + |pt_aes_padding|\\nfn get_arr_of_size__ciphertext<let FULL_PT: u32, let PT_AES_PADDING: u32>(\\n    _full_pt: [u8; FULL_PT],\\n    _pt_aes_padding: [u8; PT_AES_PADDING],\\n) -> [u8; FULL_PT + PT_AES_PADDING] {\\n    [0; FULL_PT + PT_AES_PADDING]\\n}\\n\\n// Ok, so we have the following bytes:\\n// eph_pk_sign, header_ciphertext, ciphertext:\\n// Let lbwop = 1 + 48 + |ct| // aka log bytes without padding\\nfn get_arr_of_size__log_bytes_without_padding<let CT: u32>(_ct: [u8; CT]) -> [u8; 1 + 48 + CT] {\\n    [0; 1 + 48 + CT]\\n}\\n\\n// Recall:\\n//   lbwop := 1 + 48 + |ct| // aka log bytes without padding\\n// We now want to pad b to the next multiple of 31, so as to \\"fill\\" fields.\\n// Let p be that padding.\\n// p = 31 * ceil(lbwop / 31) - lbwop\\n//   = 31 * ((lbwop + 30) // 31) - lbwop\\n//     (because ceil(x / y) = (x + y - 1) // y ).\\nfn get_arr_of_size__log_bytes_padding<let LBWOP: u32>(\\n    _lbwop: [u8; LBWOP],\\n) -> [u8; (31 * ((LBWOP + 30) / 31)) - LBWOP] {\\n    [0; (31 * ((LBWOP + 30) / 31)) - LBWOP]\\n}\\n\\n// |log_bytes| = 1 + 48 + |ct| + p // aka log bytes (with padding)\\n// Recall:\\n//   lbwop := 1 + 48 + |ct|\\n//   p is the padding\\nfn get_arr_of_size__log_bytes<let LBWOP: u32, let P: u32>(\\n    _lbwop: [u8; LBWOP],\\n    _p: [u8; P],\\n) -> [u8; LBWOP + P] {\\n    [0; LBWOP + P]\\n}\\n\\n// The return type is pasted from the LSP\'s expectation, because it was too difficult\\n// to match its weird way of doing algebra. It doesn\'t know all rules of arithmetic.\\n// PT is the plaintext length.\\npub(crate) fn get_arr_of_size__log_bytes_padding__from_PT<let PT: u32>() -> [u8; ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49))] {\\n    let full_pt = get_arr_of_size__full_plaintext::<PT>();\\n    let pt_aes_padding = get_arr_of_size__plaintext_aes_padding(full_pt);\\n    let ct = get_arr_of_size__ciphertext(full_pt, pt_aes_padding);\\n    let lbwop = get_arr_of_size__log_bytes_without_padding(ct);\\n    let p = get_arr_of_size__log_bytes_padding(lbwop);\\n    p\\n}\\n\\n// The return type is pasted from the LSP\'s expectation, because it was too difficult\\n// to match its weird way of doing algebra. It doesn\'t know all rules of arithmetic.\\npub(crate) fn get_arr_of_size__log_bytes__from_PT<let PT: u32>() -> [u8; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))] {\\n    let full_pt = get_arr_of_size__full_plaintext::<PT>();\\n    let pt_aes_padding = get_arr_of_size__plaintext_aes_padding(full_pt);\\n    let ct = get_arr_of_size__ciphertext(full_pt, pt_aes_padding);\\n    let lbwop = get_arr_of_size__log_bytes_without_padding(ct);\\n    let p = get_arr_of_size__log_bytes_padding(lbwop);\\n    let log_bytes = get_arr_of_size__log_bytes(lbwop, p);\\n    log_bytes\\n}\\n\\n/********************************************************/\\n// End of disgusting arithmetic on generics\\n/********************************************************/\\n\\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\\nfn assert_note_exists<Note, let N: u32>(context: PrivateContext, note: Note)\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    let note_header = note.get_header();\\n    let note_hash_counter = note_header.note_hash_counter;\\n    // TODO(#8589): use typesystem to skip this check when not needed\\n    let note_exists =\\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\\n    assert(note_exists, \\"Can only emit a note log for an existing note.\\");\\n}\\n\\n/// This particular log assembly strategy (AES 128) requires the note (and the\\n/// note_id and the storage_slot) to be converted into bytes, because the aes function\\n/// operates on bytes; not fields.\\n/// NB: The extra `+ 64` bytes is for the note_id and the storage_slot of the note:\\nfn compute_note_plaintext_for_this_strategy<Note, let N: u32>(note: Note) -> [u8; N * 32 + 64]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    let packed_note = note.pack_content();\\n\\n    let note_header = note.get_header();\\n    let storage_slot = note_header.storage_slot;\\n    let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\\n\\n    // TODO(#10952): The following can be reduced to 7 bits\\n    let note_type_id_bytes: [u8; 32] = Note::get_note_type_id().to_be_bytes();\\n\\n    // We combine all the bytes into plaintext_bytes:\\n    let mut plaintext_bytes: [u8; N * 32 + 64] = [0; N * 32 + 64];\\n    for i in 0..32 {\\n        plaintext_bytes[i] = storage_slot_bytes[i];\\n        plaintext_bytes[32 + i] = note_type_id_bytes[i];\\n    }\\n\\n    for i in 0..packed_note.len() {\\n        let bytes: [u8; 32] = packed_note[i].to_be_bytes();\\n        for j in 0..32 {\\n            plaintext_bytes[64 + i * 32 + j] = bytes[j];\\n        }\\n    }\\n\\n    plaintext_bytes\\n}\\n\\nfn compute_log<Note, let N: u32>(\\n    context: PrivateContext,\\n    note: Note,\\n    recipient: AztecAddress,\\n    sender: AztecAddress,\\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    // *****************************************************************************\\n    // Compute the shared secret\\n    // *****************************************************************************\\n\\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\\n\\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\\n\\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient); // not to be confused with the tagging shared secret\\n\\n    // TODO: also use this shared secret for deriving note randomness.\\n\\n    // *****************************************************************************\\n    // Compute the plaintext\\n    // *****************************************************************************\\n\\n    let final_plaintext_bytes = compute_note_plaintext_for_this_strategy(note);\\n\\n    // *****************************************************************************\\n    // Convert the plaintext into whatever format the encryption function expects\\n    // *****************************************************************************\\n\\n    // Already done for this strategy: AES expects bytes.\\n\\n    // *****************************************************************************\\n    // Encrypt the plaintext\\n    // *****************************************************************************\\n\\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\\n        ciphertext_shared_secret,\\n    );\\n\\n    let ciphertext_bytes = aes128_encrypt(final_plaintext_bytes, iv, sym_key);\\n\\n    // |full_pt| = |pt_length| + |pt|\\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\\n    // |ct| = |full_pt| + |pt_aes_padding|\\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\\n    //      = 16 + 16 * (|full_pt| // 16)\\n    //      = 16 * (1 + |full_pt| // 16)\\n    assert(ciphertext_bytes.len() == 16 * (1 + ((N * 32) + 64) / 16));\\n\\n    // *****************************************************************************\\n    // Compute the header ciphertext\\n    // *****************************************************************************\\n\\n    let contract_address = context.this_address();\\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\\n\\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\\n    for i in 0..32 {\\n        header_plaintext[i] = contract_address_bytes[i];\\n    }\\n    let offset = 32;\\n    let ciphertext_bytes_length = ciphertext_bytes.len();\\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\\n\\n    // TODO: this is insecure and wasteful:\\n    // \\"Insecure\\", because the esk shouldn\'t be used twice (once for the header,\\n    // and again for the proper ciphertext) (at least, I never got the\\n    // \\"go ahead\\" that this would be safe, unfortunately).\\n    // \\"Wasteful\\", because the exact same computation is happening further down.\\n    // I\'m leaving that 2nd computation where it is, because this 1st computation\\n    // will be imminently deleted, when the header logic is deleted.\\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\\n        ciphertext_shared_secret,\\n    );\\n\\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\\n    // bytes larger than the input in this case.\\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\\n    // I recall that converting a slice to an array incurs constraints, so I\'ll check the length this way instead:\\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\\n\\n    // *****************************************************************************\\n    // Prepend / append more bytes of data to the ciphertext, before converting back\\n    // to fields.\\n    // *****************************************************************************\\n\\n    let mut log_bytes_padding_to_mult_31 =\\n        get_arr_of_size__log_bytes_padding__from_PT::<(N * 32) + 64>();\\n    /// Safety: this randomness won\'t be constrained to be random. It\'s in the\\n    /// interest of the executor of this fn to encrypt with random bytes.\\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\\n\\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<(N * 32) + 64>();\\n\\n    assert(\\n        log_bytes.len() % 31 == 0,\\n        \\"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\\",\\n    );\\n\\n    log_bytes[0] = eph_pk_sign_byte;\\n    let mut offset = 1;\\n    for i in 0..header_ciphertext_bytes.len() {\\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\\n    }\\n    offset += header_ciphertext_bytes.len();\\n\\n    for i in 0..ciphertext_bytes.len() {\\n        log_bytes[offset + i] = ciphertext_bytes[i];\\n    }\\n    offset += ciphertext_bytes.len();\\n\\n    for i in 0..log_bytes_padding_to_mult_31.len() {\\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\\n    }\\n\\n    assert(\\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\\n        \\"Something has gone wrong\\",\\n    );\\n\\n    // *****************************************************************************\\n    // Convert bytes back to fields\\n    // *****************************************************************************\\n\\n    let log_bytes_as_fields = be_bytes_31_to_fields(log_bytes);\\n\\n    // *****************************************************************************\\n    // Prepend / append fields, to create the final log\\n    // *****************************************************************************\\n\\n    // In this strategy, we prepend [tag, eph_pk.x]\\n\\n    // We assume that the sender wants for the recipient to find the tagged note,\\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\\n    // tag will result in the recipient not being able to find the note automatically.\\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\\n\\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\\n\\n    final_log[0] = tag;\\n    final_log[1] = eph_pk.x;\\n\\n    let mut offset = 2;\\n    for i in 0..log_bytes_as_fields.len() {\\n        final_log[offset + i] = log_bytes_as_fields[i];\\n    }\\n    offset += log_bytes_as_fields.len();\\n\\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\\n        /// Safety: randomness cannot be constrained.\\n        final_log[i] = unsafe { random() };\\n    }\\n\\n    final_log\\n}\\n\\nunconstrained fn compute_log_unconstrained<Note, let N: u32>(\\n    context: PrivateContext,\\n    note: Note,\\n    recipient: AztecAddress,\\n    sender: AztecAddress,\\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    compute_log(context, note, recipient, sender)\\n}\\n\\n// This function seems to be affected by the following Noir bug:\\n// https://github.com/noir-lang/noir/issues/5771\\n// If you get weird behavior it might be because of it.\\npub fn encode_and_encrypt_note<Note, let N: u32>(\\n    context: &mut PrivateContext,\\n    recipient: AztecAddress,\\n    // We need this because to compute a tagging secret, we require a sender:\\n    sender: AztecAddress,\\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    |e: NoteEmission<Note>| {\\n        let note = e.note;\\n        assert_note_exists(*context, note);\\n\\n        let note_hash_counter = note.get_header().note_hash_counter;\\n\\n        let encrypted_log = compute_log(*context, note, recipient, sender);\\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\\n    }\\n}\\n\\n// Important note: this function -- although called \\"unconstrained\\" -- the\\n// function is not labelled as `unconstrained`, because we pass a reference to the\\n// context.\\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\\n    context: &mut PrivateContext,\\n    recipient: AztecAddress,\\n    // We need this because to compute a tagging secret, we require a sender:\\n    sender: AztecAddress,\\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    |e: NoteEmission<Note>| {\\n        let note = e.note;\\n        assert_note_exists(*context, note);\\n\\n        let note_hash_counter = note.get_header().note_hash_counter;\\n\\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\\n        // recipient is unable to decrypt the payload.\\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\\n        // for the log to be deleted when it shouldn\'t have (which is fine - they can already make the content be\\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it\'ll be a log\\n        // for a note that doesn\'t exist).\\n        //   It\'s important here that we do not\\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\\n        // be wrong.\\n        let encrypted_log = unsafe { compute_log_unconstrained(*context, note, recipient, sender) };\\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\\n    }\\n}\\n\\nmod test {\\n    use crate::test::{helpers::test_environment::TestEnvironment, mocks::mock_note::MockNote};\\n    use dep::protocol_types::address::AztecAddress;\\n    use std::test::OracleMock;\\n\\n    #[test]\\n    unconstrained fn test_encrypted_log_matches_typescript() {\\n        let mut env = TestEnvironment::new();\\n        // Advance 1 block so we can read historic state from private\\n        env.advance_block_by(1);\\n        let mut context = env.private();\\n\\n        // I\'m not sure how to initialise an `env` or `context` with a consistent contract address for every run of this test; the value kept changing each time. So I\'m going to overwrite it now:\\n        context.inputs.call_context.contract_address = AztecAddress::from_field(\\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\\n        ); // This is an address copied to match the typescript one.\\n\\n        let storage_slot = 42;\\n        let note = MockNote::new(1234)\\n            .contract_address(context.this_address())\\n            .storage_slot(storage_slot)\\n            .build();\\n        let contract_address = context.this_address();\\n\\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\\n        let contract_address = AztecAddress::from_field(\\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\\n        );\\n\\n        let plaintext = super::compute_note_plaintext_for_this_strategy(note);\\n\\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\\n        let _ = OracleMock::mock(\\"getRandomField\\").returns(eph_sk).times(1);\\n\\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\\n        let _ = OracleMock::mock(\\"getRandomField\\").returns(randomness).times(1000000);\\n\\n        let recipient = AztecAddress::from_field(\\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\\n        );\\n\\n        let sender = AztecAddress::from_field(\\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\\n        );\\n\\n        let _ = OracleMock::mock(\\"getIndexedTaggingSecretAsSender\\").returns([69420, 1337]);\\n\\n        let _ = OracleMock::mock(\\"incrementAppTaggingSecretIndexAsSender\\").returns(());\\n\\n        let payload = super::compute_log(context, note, recipient, sender);\\n\\n        // The following value was generated by `encrypted_log_payload.test.ts`\\n        // --\x3e Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n        let private_log_payload_from_typescript = [\\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\\n            0x0d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701fa7,\\n            0x00010577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\\n            0x003de81cde78411f27a921e16ebbfba71a5570d3f62f1134c90daced33663ba0,\\n            0x00856cb19c7d563da183a40a6f8bd4988d1696ad6bf0c717c8fb8f6294bd0366,\\n            0x001ed04e4f77a111c7090fcd34c61cfae744e8589a42defba4d0d927dd4679fe,\\n            0x00ec09b49d8d4cf548ea62d44c8839b2fd14664e9d1439b199a8d5166e362348,\\n            0x004a69de2d410e01010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n            0x0101010101010101010101010101010101010101010101010101010101010101,\\n        ];\\n\\n        assert_eq(payload, private_log_payload_from_typescript);\\n    }\\n}\\n"},"96":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\\nuse dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::Hash,\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"105":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr","source":"use dep::protocol_types::{\\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\\n};\\nuse std::embedded_curve_ops::multi_scalar_mul;\\n\\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\\n/// The input secret is known only to one party. The output shared secret is derivable\\n/// by both parties, through this function.\\n/// E.g.:\\n/// Epk = esk * G // ephemeral keypair\\n/// Pk = sk * G // recipient keypair\\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\\n    shared_secret\\n}\\n\\n/// Computes a standard ecdh shared secret using the address public key of the given address:\\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\\n/// The intention is that the _creator_ of a shared secret would call this function,\\n/// given the address of their intended recipient.\\npub fn derive_ecdh_shared_secret_using_aztec_address(\\n    ephemeral_secret: Scalar,\\n    recipient_address: AztecAddress,\\n) -> Point {\\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\\n}\\n\\n#[test]\\nunconstrained fn test_consistency_with_typescript() {\\n    let secret = Scalar {\\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\\n    };\\n    let point = Point {\\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\\n        is_infinite: false,\\n    };\\n\\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\\n\\n    // This is just pasted from a test run.\\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won\'t be needed, so this will have to do.\\n    let hard_coded_shared_secret = Point {\\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\\n        is_infinite: false,\\n    };\\n    assert_eq(shared_secret, hard_coded_shared_secret);\\n}\\n\\n#[test]\\nunconstrained fn test_shared_secret_computation_in_both_directions() {\\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\\n\\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\\n\\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\\n\\n    assert_eq(shared_secret, shared_secret_alt);\\n}\\n\\n#[test]\\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\\n\\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\\n\\n    let address_b = AztecAddress::from_field(pk_b.x);\\n\\n    // We were lazy in deriving the secret keys, and didn\'t check the resulting y-coordinates\\n    // of the pk_a or pk_b to be less than half the field modulus.\\n    // If needed, we negate the pk\'s so that they yield valid address points.\\n    // (We could also have negated the secrets, but there\'s no negate method for\\n    // EmbeddedCurvesScalar).\\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\\n        pk_a\\n    } else {\\n        pk_a.neg()\\n    };\\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\\n        pk_b\\n    } else {\\n        pk_b.neg()\\n    };\\n\\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\\n\\n    assert_eq(shared_secret, shared_secret_alt);\\n}\\n"},"106":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr","source":"use std::{\\n    embedded_curve_ops::fixed_base_scalar_mul, field::bn254::decompose,\\n    hash::from_field_unsafe as fr_to_fq_unsafe,\\n};\\n\\nuse dep::protocol_types::{point::Point, scalar::Scalar};\\n\\nuse crate::oracle::random::random;\\n\\n/// Converts a base field element to scalar field element.\\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\\nfn fr_to_fq(r: Field) -> Scalar {\\n    let (lo, hi) = decompose(r);\\n\\n    Scalar { lo, hi }\\n}\\n\\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\\n    // cooperate in the random value generation.\\n    let randomness = unsafe { random() };\\n\\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\\n    // the scalars.\\n    let eph_sk = fr_to_fq_unsafe(randomness);\\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\\n\\n    (eph_sk, eph_pk)\\n}\\n"},"107":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use crate::{\\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\\n    oracle::{\\n        key_validation_request::get_key_validation_request,\\n        keys::get_public_keys_and_partial_address,\\n    },\\n};\\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\\n\\nmod test;\\n\\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\\n}\\n\\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\\n// function defined on `PrivateContext`.\\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\\n}\\n\\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\\n// read keys that are not required by the caller can simply be discarded.\\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\\n    /// Safety: Public keys are constrained by showing their inclusion in the address\'s preimage.\\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\\n    assert_eq(\\n        account,\\n        AztecAddress::compute(public_keys, partial_address),\\n        \\"Invalid public keys hint for address\\",\\n    );\\n\\n    public_keys\\n}\\n"},"113":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress,\\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\\n};\\n\\nuse crate::{\\n    context::{PrivateContext, PublicContext},\\n    oracle::get_contract_instance::{\\n        get_contract_instance, get_contract_instance_deployer_avm,\\n        get_contract_instance_initialization_hash_avm,\\n    },\\n};\\n\\npub fn mark_as_initialized_public(context: &mut PublicContext) {\\n    let init_nullifier =\\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\\n    context.push_nullifier(init_nullifier);\\n}\\n\\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\\n    let init_nullifier =\\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\\n    context.push_nullifier(init_nullifier);\\n}\\n\\npub fn assert_is_initialized_public(context: &mut PublicContext) {\\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \\"Not initialized\\");\\n}\\n\\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\\n    context.push_nullifier_read_request(init_nullifier);\\n}\\n\\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\\n    address.to_field()\\n}\\n\\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\\n    let address = context.this_address();\\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\\n    assert(initialization_hash == expected_init, \\"Initialization hash does not match\\");\\n    assert(\\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\\n        \\"Initializer address is not the contract deployer\\",\\n    );\\n}\\n\\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\\n    let address = context.this_address();\\n    let instance = get_contract_instance(address);\\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\\n    assert(instance.initialization_hash == expected_init, \\"Initialization hash does not match\\");\\n    assert(\\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\\n        \\"Initializer address is not the contract deployer\\",\\n    );\\n}\\n\\n/// This function is not only used in macros but it\'s also used by external people to check that an instance has been\\n/// initialized with the correct constructor arguments. Don\'t hide this unless you implement factory functionality.\\npub fn compute_initialization_hash(\\n    init_selector: FunctionSelector,\\n    init_args_hash: Field,\\n) -> Field {\\n    poseidon2_hash_with_separator(\\n        [init_selector.to_field(), init_args_hash],\\n        GENERATOR_INDEX__CONSTRUCTOR,\\n    )\\n}\\n"},"122":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr","source":"use std::static_assert;\\n\\nuse crate::{\\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\\n    oracle::note_discovery::deliver_note, utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\\n    hash::compute_note_hash_nonce,\\n};\\n\\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\\n// the note type id.\\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\\n\\npub struct NoteHashesAndNullifier {\\n    pub note_hash: Field,\\n    pub unique_note_hash: Field,\\n    pub inner_nullifier: Field,\\n}\\n\\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would\'ve been\\n/// created, along with the list of unique note hashes in said transaction.\\n///\\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\\n///\\n/// ```\\n/// |packed_note_content, note_header, note_type_id| {\\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\\n///             MyNoteType::unpack_content,\\n///             note_header,\\n///             true,\\n///             packed_note_content.storage(),\\n///         )\\n///     } else {\\n///         panic(f\\"Unknown note type id {note_type_id}\\")\\n///     };\\n///\\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\\n///         note_hash: hashes[0],\\n///         unique_note_hash: hashes[1],\\n///         inner_nullifier: hashes[3],\\n///     })\\n/// }\\n/// ```\\npub unconstrained fn do_process_log<Env>(\\n    context: UnconstrainedContext,\\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field) -> Option<NoteHashesAndNullifier>,\\n) {\\n    let (storage_slot, note_type_id, packed_note_content) =\\n        destructure_log_plaintext(log_plaintext);\\n\\n    // We need to find the note\'s nonce, which is the one that results in one of the unique note hashes from tx_hash\\n    for_each_in_bounded_vec(\\n        unique_note_hashes_in_tx,\\n        |expected_unique_note_hash, i| {\\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\\n\\n            let header = NoteHeader::new(context.this_address(), candidate_nonce, storage_slot);\\n\\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\\n            let hashes =\\n                compute_note_hash_and_nullifier(packed_note_content, header, note_type_id).unwrap();\\n\\n            if hashes.unique_note_hash == expected_unique_note_hash {\\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\\n\\n                assert(\\n                    deliver_note(\\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\\n                        storage_slot,\\n                        candidate_nonce,\\n                        packed_note_content,\\n                        hashes.note_hash,\\n                        hashes.inner_nullifier,\\n                        tx_hash,\\n                        recipient,\\n                    ),\\n                    \\"Failed to deliver note\\",\\n                );\\n\\n                // We don\'t exit the loop - it is possible (though rare) for the exact same note content to be present\\n                // multiple times in the same transaction with different nonces. This typically doesn\'t happen due to\\n                // notes containing random values in order to hide their contents.\\n            }\\n        },\\n    );\\n}\\n\\nunconstrained fn destructure_log_plaintext(\\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\\n\\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\\n    // `storage_slot` and `note_type_id` must be updated as well.\\n    static_assert(\\n        NOTE_LOG_RESERVED_FIELDS == 2,\\n        \\"unepxected value for NOTE_LOG_RESERVED_FIELDS\\",\\n    );\\n    let storage_slot = log_plaintext.get(0);\\n    let note_type_id = log_plaintext.get(1);\\n\\n    let packed_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\\n\\n    (storage_slot, note_type_id, packed_note_content)\\n}\\n\\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\\n    vec: BoundedVec<T, MaxLen>,\\n    f: fn[Env](T, u32) -> (),\\n) {\\n    for i in 0..MaxLen {\\n        if i < vec.len() {\\n            f(vec.get_unchecked(i), i);\\n        }\\n    }\\n}\\n"},"123":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\\nuse crate::note::{\\n    note_emission::NoteEmission,\\n    note_header::NoteHeader,\\n    note_interface::{NoteInterface, NullifiableNote},\\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\\n};\\nuse crate::oracle::notes::notify_created_note;\\n\\npub fn create_note<Note, let N: u32>(\\n    context: &mut PrivateContext,\\n    storage_slot: Field,\\n    note: &mut Note,\\n) -> NoteEmission<Note>\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    let contract_address = (*context).this_address();\\n    let note_hash_counter = context.side_effect_counter;\\n\\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\\n    note.set_header(header);\\n    let note_hash = note.compute_note_hash();\\n\\n    let packed_note_content = Note::pack_content(*note);\\n    notify_created_note(\\n        storage_slot,\\n        Note::get_note_type_id(),\\n        packed_note_content,\\n        note_hash,\\n        note_hash_counter,\\n    );\\n\\n    context.push_note_hash(note_hash);\\n\\n    NoteEmission::new(*note)\\n}\\n\\npub fn create_note_hash_from_public<Note, let N: u32>(\\n    context: &mut PublicContext,\\n    storage_slot: Field,\\n    note: &mut Note,\\n)\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    let contract_address = (*context).this_address();\\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\\n    note.set_header(header);\\n    let note_hash = note.compute_note_hash();\\n\\n    context.push_note_hash(note_hash);\\n}\\n\\n// Note: This function is currently totally unused.\\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\\n\\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\\n}\\n\\npub fn destroy_note_unsafe<Note, let N: u32>(\\n    context: &mut PrivateContext,\\n    note: Note,\\n    note_hash_for_read_request: Field,\\n)\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    let note_hash_for_nullify =\\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\\n\\n    let note_hash_counter = note.get_header().note_hash_counter;\\n    let notification_note_hash = if (note_hash_counter == 0) {\\n        // Counter is zero, so we\'re nullifying a settled note and we don\'t populate the note_hash with real value.\\n        0\\n    } else {\\n        // A non-zero note hash counter implies that we\'re nullifying a pending note (i.e. one that has not yet been\\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\\n        // hash with real value to inform the kernel which note we\'re nullifyng so that it can either squash both\\n        // the note and the nullifier if it\'s an inner note hash, or check that the it matches a pending note if it\'s\\n        // a siloed note hash.\\n        note_hash_for_nullify\\n    };\\n\\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\\n}\\n"},"125":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\\n * A note emission struct containing the information required for emitting a note.\\n * The exact `emit` logic is passed in by the application code\\n */\\npub struct NoteEmission<Note> {\\n    pub note: Note,\\n}\\n\\nimpl<Note> NoteEmission<Note> {\\n    pub fn new(note: Note) -> Self {\\n        Self { note }\\n    }\\n\\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\\n        _emit(self);\\n    }\\n\\n    pub fn discard(_self: Self) {}\\n}\\n\\n/**\\n * A struct wrapping note emission in `Option<T>`.\\n * This is the struct provided to application codes, which can be used to emit\\n * only when a note was actually inserted.\\n * It is fairly common to have cases where a function conditionally inserts,\\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\\n * a change note in a token\'s transfer function only when there is \\"change\\" left).\\n */\\npub struct OuterNoteEmission<Note> {\\n    emission: Option<NoteEmission<Note>>,\\n}\\n\\nimpl<Note> OuterNoteEmission<Note> {\\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\\n        Self { emission }\\n    }\\n\\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\\n        if self.emission.is_some() {\\n            _emit(self.emission.unwrap());\\n        }\\n    }\\n\\n    pub fn discard(_self: Self) {}\\n}\\n"},"127":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use crate::context::PrivateContext;\\nuse crate::note::{\\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\\n    note_interface::{NoteInterface, NullifiableNote},\\n    note_viewer_options::NoteViewerOptions,\\n    utils::compute_note_hash_for_read_request,\\n};\\nuse crate::oracle;\\nuse crate::utils::comparison::compare;\\nuse dep::protocol_types::constants::{\\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\\n};\\n\\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\\n\\nmod test;\\n\\nfn extract_property_value_from_selector<let N: u32>(\\n    packed_note_content: [Field; N],\\n    selector: PropertySelector,\\n) -> Field {\\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\\n    // This allows easier packing and custom (un)packing schemas. A note property is located\\n    // inside the packed note using the index inside the array, a byte offset and a length.\\n    let value: [u8; 32] = packed_note_content[selector.index].to_be_bytes();\\n    let offset = selector.offset;\\n    let length = selector.length;\\n    let mut value_field = 0 as Field;\\n    let mut acc: Field = 1;\\n    for i in 0..32 {\\n        if i < length {\\n            value_field += value[31 + offset - i] as Field * acc;\\n            acc = acc * 256;\\n        }\\n    }\\n    value_field\\n}\\n\\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    let header = note.get_header();\\n    let contract_address = context.this_address();\\n    assert(header.contract_address.eq(contract_address), \\"Mismatch note header contract address.\\");\\n    assert(header.storage_slot == storage_slot, \\"Mismatch note header storage slot.\\");\\n}\\n\\nfn check_note_content<let N: u32>(\\n    packed_note_content: [Field; N],\\n    selects: BoundedVec<Option<Select>, N>,\\n) {\\n    for i in 0..selects.len() {\\n        let select = selects.get_unchecked(i).unwrap_unchecked();\\n        let value_field =\\n            extract_property_value_from_selector(packed_note_content, select.property_selector);\\n\\n        assert(\\n            compare(value_field, select.comparator, select.value.to_field()),\\n            \\"Mismatch return note field.\\",\\n        );\\n    }\\n}\\n\\nfn check_notes_order<let N: u32>(\\n    fields_0: [Field; N],\\n    fields_1: [Field; N],\\n    sorts: BoundedVec<Option<Sort>, N>,\\n) {\\n    for i in 0..sorts.len() {\\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\\n        let eq = field_0 == field_1;\\n        let lt = field_0.lt(field_1);\\n        if sort.order == SortOrder.ASC {\\n            assert(eq | lt, \\"Return notes not sorted in ascending order.\\");\\n        } else if !eq {\\n            assert(!lt, \\"Return notes not sorted in descending order.\\");\\n        }\\n    }\\n}\\n\\npub fn get_note<Note, let N: u32>(\\n    context: &mut PrivateContext,\\n    storage_slot: Field,\\n) -> (Note, Field)\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    /// Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\\n    /// is check that the metadata is correct, and that the note exists.\\n    let note = unsafe { get_note_internal(storage_slot) };\\n    check_note_header(*context, storage_slot, note);\\n\\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\\n    context.push_note_hash_read_request(note_hash_for_read_request);\\n\\n    (note, note_hash_for_read_request)\\n}\\n\\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\\n    context: &mut PrivateContext,\\n    storage_slot: Field,\\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote + Eq,\\n{\\n    /// Safety: The notes are constrained below.\\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\\n\\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\\n    // these checks correctly reject bad notes.\\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\\n}\\n\\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n    preprocessor_args: PREPROCESSOR_ARGS,\\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\\n    preprocessor(notes, preprocessor_args)\\n}\\n\\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\\n    context: &mut PrivateContext,\\n    storage_slot: Field,\\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote + Eq,\\n{\\n    // The filter is applied first to avoid pushing note read requests for notes we\'re not interested in. Note that\\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\\n    // check to fail.\\n    let filter_fn = options.filter;\\n    let filter_args = options.filter_args;\\n    let filtered_notes = filter_fn(opt_notes, filter_args);\\n\\n    let notes = crate::utils::array::collapse(filtered_notes);\\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\\n        BoundedVec::new();\\n\\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\\n    // for the runtime length, and can therefore have fewer loop iterations.\\n    assert(notes.len() <= options.limit, \\"Got more notes than limit.\\");\\n\\n    let mut prev_fields = [0; N];\\n    for i in 0..options.limit {\\n        if i < notes.len() {\\n            let note = notes.get_unchecked(i);\\n            let fields = note.pack_content();\\n            check_note_header(*context, storage_slot, note);\\n            check_note_content(fields, options.selects);\\n            if i != 0 {\\n                check_notes_order(prev_fields, fields, options.sorts);\\n            }\\n            prev_fields = fields;\\n\\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\\n            // failure if malicious oracle injects 0 nonce here for a \\"pre-existing\\" note.\\n            context.push_note_hash_read_request(note_hash_for_read_request);\\n            note_hashes.push(note_hash_for_read_request);\\n        };\\n    }\\n\\n    (notes, note_hashes)\\n}\\n\\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    let placeholder_note = [Option::none()];\\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\\n    let placeholder_note_length = [0; N];\\n    oracle::notes::get_notes(\\n        storage_slot,\\n        0,\\n        [],\\n        [],\\n        [],\\n        [],\\n        [],\\n        [],\\n        [],\\n        [],\\n        [],\\n        1, // limit\\n        0, // offset\\n        NoteStatus.ACTIVE,\\n        placeholder_note,\\n        placeholder_fields,\\n        placeholder_note_length,\\n    )[0]\\n        .expect(f\\"Failed to get a note\\") // Notice: we don\'t allow dummies to be returned from get_note (singular).\\n}\\n\\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\\n    storage_slot: Field,\\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\\n        flatten_options(options.selects, options.sorts);\\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\\n    let placeholder_note_length = [0; N];\\n\\n    let opt_notes = oracle::notes::get_notes(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        options.limit,\\n        options.offset,\\n        options.status,\\n        placeholder_opt_notes,\\n        placeholder_fields,\\n        placeholder_note_length,\\n    );\\n\\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\\n}\\n\\npub unconstrained fn view_notes<Note, let N: u32>(\\n    storage_slot: Field,\\n    options: NoteViewerOptions<Note, N>,\\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\\n        flatten_options(options.selects, options.sorts);\\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\\n    let placeholder_note_length = [0; N];\\n\\n    let notes_array = oracle::notes::get_notes(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        options.limit,\\n        options.offset,\\n        options.status,\\n        placeholder_opt_notes,\\n        placeholder_fields,\\n        placeholder_note_length,\\n    );\\n\\n    let mut notes = BoundedVec::new();\\n    for i in 0..notes_array.len() {\\n        if notes_array[i].is_some() {\\n            notes.push(notes_array[i].unwrap_unchecked());\\n        }\\n    }\\n\\n    notes\\n}\\n\\nunconstrained fn flatten_options<let N: u32>(\\n    selects: BoundedVec<Option<Select>, N>,\\n    sorts: BoundedVec<Option<Sort>, N>,\\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\\n    let mut num_selects = 0;\\n    let mut select_by_indexes = [0; N];\\n    let mut select_by_offsets = [0; N];\\n    let mut select_by_lengths = [0; N];\\n    let mut select_values = [0; N];\\n    let mut select_comparators = [0; N];\\n\\n    for i in 0..selects.len() {\\n        let select = selects.get(i);\\n        if select.is_some() {\\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\\n            select_values[num_selects] = select.unwrap_unchecked().value;\\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\\n            num_selects += 1;\\n        };\\n    }\\n\\n    let mut sort_by_indexes = [0; N];\\n    let mut sort_by_offsets = [0; N];\\n    let mut sort_by_lengths = [0; N];\\n    let mut sort_order = [0; N];\\n    for i in 0..sorts.len() {\\n        let sort = sorts.get(i);\\n        if sort.is_some() {\\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\\n            sort_order[i] = sort.unwrap_unchecked().order;\\n        };\\n    }\\n\\n    (\\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\\n    )\\n}\\n"},"133":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\\n    context::PrivateContext,\\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::hash::{\\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\\n    compute_unique_note_hash,\\n};\\n\\npub fn compute_siloed_nullifier<Note, let N: u32>(\\n    note_with_header: Note,\\n    context: &mut PrivateContext,\\n) -> Field\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    let header = note_with_header.get_header();\\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\\n\\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\\n}\\n\\n// TODO(#7775): make this not impossible to understand\\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    let note_hash = note.compute_note_hash();\\n    let header = note.get_header();\\n    let nonce = header.nonce;\\n    let counter = header.note_hash_counter;\\n\\n    // If same tx note, read request always uses the normal note hash\\n    if counter != 0 {\\n        note_hash\\n    } else {\\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\\n        compute_unique_note_hash(\\n            nonce,\\n            compute_siloed_note_hash(header.contract_address, note_hash),\\n        )\\n    }\\n}\\n\\n// TODO(#7775): make this not impossible to understand\\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\\n    note: Note,\\n    note_hash_for_read_request: Field,\\n) -> Field\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    let header = note.get_header();\\n\\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\\n        let siloed_note_hash =\\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\\n\\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\\n    } else {\\n        note_hash_for_read_request\\n    }\\n}\\n\\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\\n//     let header = note.get_header();\\n//     // There are 3 cases for reading a note intended for consumption:\\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\\n\\n//     let note_hash = note.compute_note_hiding_point().x;\\n\\n//     if header.nonce == 0 {\\n//         // Case 1.\\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\\n//         note_hash\\n//     } else {\\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\\n//         // nullifier.\\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\\n//         // from the siloed note hash.\\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\\n//         // siloed note hash matches the note hash specified in the nullifier.\\n\\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\\n//         // \\"siloed\\" by contract address. When a note hash is computed solely for the purpose of\\n//         // nullification, it is not strictly necessary to silo the note hash before computing\\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\\n//         // nullifiers are computed from a note hash\'s fully-computed note hash tree leaf.\\n//     }\\n// }\\n\\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\\nwhere\\n    Note: NoteInterface<N> + NullifiableNote,\\n{\\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\\n}\\n\\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\\n    unpack_content: fn([Field; N]) -> T,\\n    note_header: NoteHeader,\\n    compute_nullifier: bool,\\n    packed_note_content: [Field; S],\\n) -> [Field; 4]\\nwhere\\n    T: NoteInterface<N> + NullifiableNote,\\n{\\n    let mut note = unpack_content(array::subarray(packed_note_content, 0));\\n    note.set_header(note_header);\\n\\n    let note_hash = note.compute_note_hash();\\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\\n\\n    let inner_nullifier = if compute_nullifier {\\n        note.compute_nullifier_without_context()\\n    } else {\\n        0\\n    };\\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\\n}\\n"},"135":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> [Field; 2] {}\\n\\npub unconstrained fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> (u32, Field) {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n    );\\n\\n    let mut reader = Reader::new(fields);\\n    let end_side_effect_counter = reader.read_u32();\\n    let returns_hash = reader.read();\\n\\n    (end_side_effect_counter, returns_hash)\\n}\\n"},"136":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\\n}\\n\\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\\n}\\n\\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\\n"},"137":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n#[oracle(getContractAddress)]\\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\\n\\n#[oracle(getBlockNumber)]\\nunconstrained fn get_block_number_oracle() -> u32 {}\\n\\n#[oracle(getChainId)]\\nunconstrained fn get_chain_id_oracle() -> Field {}\\n\\n#[oracle(getVersion)]\\nunconstrained fn get_version_oracle() -> Field {}\\n\\npub unconstrained fn get_contract_address() -> AztecAddress {\\n    get_contract_address_oracle()\\n}\\n\\npub unconstrained fn get_block_number() -> u32 {\\n    get_block_number_oracle()\\n}\\n\\npub unconstrained fn get_chain_id() -> Field {\\n    get_chain_id_oracle()\\n}\\n\\npub unconstrained fn get_version() -> Field {\\n    get_version_oracle()\\n}\\n"},"138":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr","source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\\npub fn store(values: [Field]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\\n}\\n\\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\\n    let _ = store_in_execution_cache_oracle(values);\\n}\\n\\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\\n    load_from_execution_cache_oracle(hash)\\n}\\n\\n#[oracle(storeInExecutionCache)]\\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\\n\\n#[oracle(loadFromExecutionCache)]\\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\\n"},"139":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\\n    contract_instance::ContractInstance,\\n};\\n\\n// NOTE: this is for use in private only\\n#[oracle(getContractInstance)]\\nunconstrained fn get_contract_instance_oracle(\\n    _address: AztecAddress,\\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\\n\\n// NOTE: this is for use in private only\\nunconstrained fn get_contract_instance_internal(\\n    address: AztecAddress,\\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\\n    get_contract_instance_oracle(address)\\n}\\n\\n// NOTE: this is for use in private only\\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\\n    /// so by checking that we get the expected address we validate the entire struct.\\n    let instance =\\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\\n    assert_eq(instance.to_address(), address);\\n\\n    instance\\n}\\n\\n// These oracles each return a ContractInstance member\\n// plus a boolean indicating whether the instance was found.\\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\\nunconstrained fn get_contract_instance_deployer_oracle_avm(\\n    _address: AztecAddress,\\n) -> (Field, bool) {}\\n#[oracle(avmOpcodeGetContractInstanceClassId)]\\nunconstrained fn get_contract_instance_class_id_oracle_avm(\\n    _address: AztecAddress,\\n) -> (Field, bool) {}\\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\\n    _address: AztecAddress,\\n) -> (Field, bool) {}\\n\\npub unconstrained fn get_contract_instance_deployer_internal_avm(\\n    address: AztecAddress,\\n) -> (Field, bool) {\\n    get_contract_instance_deployer_oracle_avm(address)\\n}\\npub unconstrained fn get_contract_instance_class_id_internal_avm(\\n    address: AztecAddress,\\n) -> (Field, bool) {\\n    get_contract_instance_class_id_oracle_avm(address)\\n}\\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\\n    address: AztecAddress,\\n) -> (Field, bool) {\\n    get_contract_instance_initialization_hash_oracle_avm(address)\\n}\\n\\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\\n    /// Safety: AVM opcodes are constrained by the AVM itself\\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\\n    if exists {\\n        Option::some(AztecAddress::from_field(member))\\n    } else {\\n        Option::none()\\n    }\\n}\\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\\n    /// Safety: AVM opcodes are constrained by the AVM itself\\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\\n    if exists {\\n        Option::some(ContractClassId::from_field(member))\\n    } else {\\n        Option::none()\\n    }\\n}\\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\\n    /// Safety: AVM opcodes are constrained by the AVM itself\\n    let (member, exists) =\\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\\n    if exists {\\n        Option::some(member)\\n    } else {\\n        Option::none()\\n    }\\n}\\n"},"142":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use crate::utils::array;\\nuse dep::protocol_types::{\\n    abis::nullifier_leaf_preimage::NullifierLeafPreimage, constants::NULLIFIER_TREE_HEIGHT,\\n};\\n\\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 44;\\n\\npub struct NullifierMembershipWitness {\\n    pub index: Field,\\n    pub leaf_preimage: NullifierLeafPreimage,\\n    pub path: [Field; NULLIFIER_TREE_HEIGHT],\\n}\\n\\nimpl NullifierMembershipWitness {\\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\\n        let serialized_leaf_preimage = array::subarray(fields, 1);\\n\\n        Self {\\n            index: fields[0],\\n            leaf_preimage: NullifierLeafPreimage::deserialize(serialized_leaf_preimage),\\n            path: array::subarray(fields, 1 + serialized_leaf_preimage.len()),\\n        }\\n    }\\n}\\n\\n#[oracle(getLowNullifierMembershipWitness)]\\nunconstrained fn get_low_nullifier_membership_witness_oracle(\\n    _block_number: u32,\\n    _nullifier: Field,\\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\\n\\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\\n// nullifier\'s next_value is bigger than the nullifier)\\npub unconstrained fn get_low_nullifier_membership_witness(\\n    block_number: u32,\\n    nullifier: Field,\\n) -> NullifierMembershipWitness {\\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\\n    NullifierMembershipWitness::deserialize(fields)\\n}\\n\\n#[oracle(getNullifierMembershipWitness)]\\nunconstrained fn get_nullifier_membership_witness_oracle(\\n    _block_number: u32,\\n    _nullifier: Field,\\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\\n\\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\\n// nullifier\'s next_value is bigger than the nullifier)\\npub unconstrained fn get_nullifier_membership_witness(\\n    block_number: u32,\\n    nullifier: Field,\\n) -> NullifierMembershipWitness {\\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\\n    NullifierMembershipWitness::deserialize(fields)\\n}\\n"},"144":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\\n};\\n\\n#[oracle(getKeyValidationRequest)]\\nunconstrained fn get_key_validation_request_oracle(\\n    _pk_m_hash: Field,\\n    _key_index: Field,\\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\\n\\nunconstrained fn get_key_validation_request_internal(\\n    npk_m_hash: Field,\\n    key_index: Field,\\n) -> KeyValidationRequest {\\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\\n    KeyValidationRequest::deserialize(result)\\n}\\n\\npub unconstrained fn get_key_validation_request(\\n    pk_m_hash: Field,\\n    key_index: Field,\\n) -> KeyValidationRequest {\\n    get_key_validation_request_internal(pk_m_hash, key_index)\\n}\\n"},"145":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, PartialAddress},\\n    point::Point,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\\n};\\n\\n#[oracle(getPublicKeysAndPartialAddress)]\\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\\n\\npub unconstrained fn get_public_keys_and_partial_address(\\n    address: AztecAddress,\\n) -> (PublicKeys, PartialAddress) {\\n    let result = get_public_keys_and_partial_address_oracle(address);\\n\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\\n        ivpk_m: IvpkM {\\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(result[12]);\\n\\n    (keys, partial_address)\\n}\\n"},"148":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr","source":"use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\\nuse dep::protocol_types::address::AztecAddress;\\n\\n/// Informs PXE of a note\'s existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\\n///\\n/// The note\'s `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\\n/// `tx_hash`, and will store the nullifier to later check for nullification.\\n///\\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\\n/// other accounts will not be able to see one another\'s token balance notes, even in the same PXE) unless authorized.\\n///\\n/// Returns true if the note was sucessfully delivered and added to PXE\'s database.\\npub unconstrained fn deliver_note(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {\\n    deliver_note_oracle(\\n        contract_address,\\n        storage_slot,\\n        nonce,\\n        content,\\n        note_hash,\\n        nullifier,\\n        tx_hash,\\n        recipient,\\n    )\\n}\\n\\n#[oracle(deliverNote)]\\nunconstrained fn deliver_note_oracle(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {}\\n"},"149":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            packed_note_content,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\\npub fn notify_created_nullifier(nullifier: Field) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n        note_hash,\\n        counter,\\n    );\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _packed_note_content: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\\n    let _ = notify_created_nullifier_oracle(nullifier);\\n}\\n\\n#[oracle(notifyCreatedNullifier)]\\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\\n) -> [Option<Note>; S]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    sync_notes_oracle_wrapper();\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let nonce = fields[read_offset];\\n            let note_hash_counter = fields[read_offset + 1] as u32;\\n            let note_content = array::subarray(fields, read_offset + 2);\\n\\n            let mut note = Note::unpack_content(note_content);\\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\\n\\n            placeholder_opt_notes[i] = Option::some(note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\\n/// for later querying via the `get_notes` oracle.\\npub fn sync_notes() {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        sync_notes_oracle_wrapper();\\n    }\\n}\\n\\nunconstrained fn sync_notes_oracle_wrapper() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n"},"151":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\\n/// truly random: we assume that the oracle is cooperating and returning random values.\\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\\npub unconstrained fn random() -> Field {\\n    rand_oracle()\\n}\\n\\n#[oracle(getRandomField)]\\nunconstrained fn rand_oracle() -> Field {}\\n"},"157":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{\\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\\n    traits::Packable,\\n};\\n\\nuse crate::context::{PrivateContext, UnconstrainedContext};\\nuse crate::note::{\\n    lifecycle::create_note,\\n    note_emission::NoteEmission,\\n    note_getter::{get_note, view_notes},\\n    note_interface::{NoteInterface, NullifiableNote},\\n    note_viewer_options::NoteViewerOptions,\\n};\\nuse crate::oracle::notes::check_nullifier_exists;\\nuse crate::state_vars::storage::Storage;\\n\\n// docs:start:struct\\npub struct PrivateImmutable<Note, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:struct\\n\\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<Note, Context> PrivateImmutable<Note, Context> {\\n    // docs:start:new\\n    pub fn new(context: Context, storage_slot: Field) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Self { context, storage_slot }\\n    }\\n    // docs:end:new\\n\\n    // The following computation is leaky, in that it doesn\'t hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\\n    pub fn compute_initialization_nullifier(self) -> Field {\\n        poseidon2_hash_with_separator(\\n            [self.storage_slot],\\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\\n        )\\n    }\\n}\\n\\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\\n    // docs:start:initialize\\n    pub fn initialize<let N: u32>(self, note: &mut Note) -> NoteEmission<Note>\\n    where\\n        Note: NoteInterface<N> + NullifiableNote,\\n    {\\n        // Nullify the storage slot.\\n        let nullifier = self.compute_initialization_nullifier();\\n        self.context.push_nullifier(nullifier);\\n\\n        create_note(self.context, self.storage_slot, note)\\n    }\\n    // docs:end:initialize\\n\\n    // docs:start:get_note\\n    pub fn get_note<let N: u32>(self) -> Note\\n    where\\n        Note: NoteInterface<N> + NullifiableNote,\\n    {\\n        let storage_slot = self.storage_slot;\\n        get_note(self.context, storage_slot).0\\n    }\\n    // docs:end:get_note\\n}\\n\\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\\n    // docs:start:is_initialized\\n    pub unconstrained fn is_initialized(self) -> bool {\\n        let nullifier = self.compute_initialization_nullifier();\\n        check_nullifier_exists(nullifier)\\n    }\\n    // docs:end:is_initialized\\n\\n    // view_note does not actually use the context, but it calls oracles that are only available in private\\n    // docs:start:view_note\\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\\n    where\\n        Note: NoteInterface<N> + NullifiableNote,\\n    {\\n        let mut options = NoteViewerOptions::new();\\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\\n    }\\n    // docs:end:view_note\\n}\\n"},"183":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\\n/// of elements past `offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\\n/// assert_eq(foo, [3, 4]);\\n///\\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\\n/// ```\\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [T; SRC_LEN],\\n    offset: u32,\\n) -> [T; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"DST_LEN too large for offset\\");\\n\\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::subarray;\\n\\n    #[test]\\n    unconstrained fn subarray_into_empty() {\\n        // In all of these cases we\'re setting DST_LEN to be 0, so we always get back an emtpy array.\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_complete() {\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_different_end_sizes() {\\n        // We implicitly select how many values to read in the size of the return array\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subarray_offset_too_large() {\\n        // With an offset of 1 we can only request up to 4 elements\\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subarray_bad_return_value() {\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\\n    }\\n}\\n"},"184":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\\n\\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\\n/// zeroed elements past `len()`).\\n///\\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n///\\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can\'t return just 1 element since 3 remain\\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can\'t return 10 elements since only 7 remain\\n/// ```\\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\\n    vec: BoundedVec<T, SRC_MAX_LEN>,\\n    offset: u32,\\n) -> BoundedVec<T, DST_MAX_LEN> {\\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\\n    // because we\'re constructing the new storage array as a subarray of the original one (which should have zeroed\\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\\n    // their original length.\\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\\n}\\n\\nmod test {\\n    use super::subbvec;\\n\\n    #[test]\\n    unconstrained fn subbvec_empty() {\\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_complete() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n\\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_partial() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_into_empty() {\\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_offset_past_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_insufficient_dst_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // We\'re not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\\n        // for the capacity to reduce, but not the length (other than by len - offset).\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // subbvec does not supprt capacity increases\\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // This effectively requests a capacity increase, since there\'d be just one element plus the 5 empty slots,\\n        // which is less than 7.\\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\\n    }\\n}\\n"},"185":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/utils/bytes.nr","source":"use crate::oracle::random::random;\\n\\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole bytes.\\n///\\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted into a Field. If the last chunk\\n/// is less than 31 bytes long, then only the relevant bytes are considered.\\n/// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\\n/// Note: ceil(N / 31) = (N + 30) / 31\\npub fn be_bytes_31_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; (N + 30) / 31] {\\n    let mut fields = [0; (N + 30) / 31];\\n\\n    // There are N / 31 whole fields that can be populated.\\n    for i in 0..N / 31 {\\n        let mut field = 0;\\n        for j in 0..31 {\\n            // Shift the existing value left by 8 bits and add the new byte\\n            field = field * 256 + bytes[i * 31 + j] as Field;\\n        }\\n        fields[i] = field;\\n    }\\n\\n    // Note: if 31 divides N, then this loop does not execute.\\n    // ceil(N/31) - floor(N/31) = 1, unless 31 divides N, in which case it\'s 0.\\n    for _ in 0..((N + 30) / 31) - (N / 31) {\\n        let mut final_field = 0;\\n        let final_field_idx = fields.len() - 1;\\n        let final_offset = final_field_idx * 31;\\n        // N - ((N / 31) * 31) = N - floor(N/31) * 31 = the number of bytes to go in the final field.\\n        for j in 0..N - ((N / 31) * 31) {\\n            // Shift the existing value left by 8 bits and add the new byte\\n            final_field = final_field * 256 + bytes[final_offset + j] as Field;\\n        }\\n\\n        fields[final_field_idx] = final_field;\\n    }\\n\\n    fields\\n}\\n\\npub fn le_bytes_31_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; (N + 30) / 31] {\\n    let mut fields = [0; (N + 30) / 31];\\n\\n    // There are N / 31 whole fields that can be populated.\\n    for i in 0..N / 31 {\\n        let mut field = 0;\\n        for j in 0..31 {\\n            let k = 31 - j - 1; // iterate in reverse.\\n            // Shift the existing value left by 8 bits and add the new byte\\n            field = field * 256 + bytes[i * 31 + k] as Field;\\n        }\\n        fields[i] = field;\\n    }\\n\\n    // Note: if 31 divides N, then this loop does not execute.\\n    // ceil(N/31) - floor(N/31) = 1, unless 31 divides N, in which case it\'s 0.\\n    for _ in 0..((N + 30) / 31) - (N / 31) {\\n        let mut final_field = 0;\\n        let final_field_idx = fields.len() - 1;\\n        let final_offset = final_field_idx * 31;\\n        // N - ((N / 31) * 31) = N - floor(N/31) * 31 = the number of bytes to go in the final field.\\n        for j in 0..N - ((N / 31) * 31) {\\n            let k = (N - ((N / 31) * 31)) - j - 1; // iterate in reverse.\\n            // Shift the existing value left by 8 bits and add the new byte\\n            final_field = final_field * 256 + bytes[final_offset + k] as Field;\\n        }\\n        fields[final_field_idx] = final_field;\\n    }\\n\\n    fields\\n}\\n\\n/// Converts an input array of fields into a single array of bytes.\\n/// Each input field must contain only 31 bytes (this is constrained to be so).\\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte\\n/// chunks are concatenated back together in the order of the original fields.\\n///\\n/// It appears that the original author of this function wants to give the caller some control\\n/// over the number of bytes that are returned: the final field can be mapped to fewer than 31 bytes,\\n/// based on the caller\'s choice of M.\\n/// Given the input is N fields, and each field (except the last) is mapped to 31 bytes,\\n/// we definitely need M > (N - 1) * 31 to cover those first (N - 1) fields. Hence the static assertion.\\n/// TODO: this is the same as the \\"le\\" version of this function, save for the `field.to_be_bytes()` calls. I tried passing the conversion function in as a parameter, to reduce code duplication, but couldn\'t get it to work.\\npub fn fields_to_be_bytes_31<let N: u32, let M: u32>(fields: [Field; N]) -> [u8; M] {\\n    let mut bytes = [0; M];\\n\\n    std::static_assert(M > (N - 1) * 31, \\"Not enough output bytes specified\\");\\n    // We make this assertion to keep the logic simpler:\\n    std::static_assert(N * 31 >= M, \\"Too many output bytes specified.\\");\\n\\n    for i in 0..N - 1 {\\n        let field = fields[i];\\n\\n        // We expect that the field contains at most 31 bytes of information.\\n        field.assert_max_bit_size::<248>();\\n\\n        // Now we can safely convert the field to 31 bytes.\\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\\n\\n        for j in 0..31 {\\n            bytes[i * 31 + j] = field_as_bytes[j];\\n        }\\n    }\\n\\n    let final_field = fields[N - 1];\\n    final_field.assert_max_bit_size::<8 * (M - ((N - 1) * 31))>();\\n\\n    let final_field_as_bytes: [u8; M - ((N - 1) * 31)] = final_field.to_be_bytes();\\n\\n    let start_index = (N - 1) * 31;\\n    for j in 0..M - ((N - 1) * 31) {\\n        bytes[start_index + j] = final_field_as_bytes[j];\\n    }\\n\\n    bytes\\n}\\n\\n/// Converts an input array of fields into a single array of bytes.\\n/// Each input field must contain only 31 bytes (this is constrained to be so).\\n/// Each field is converted into 31 little-endian bytes, and the resulting 31-byte\\n/// chunks are concatenated back together in the order of the original fields. You\'ll\\n/// end up with quite a strange ordering of bytes if you use this particular function.\\npub fn fields_to_le_bytes_31<let N: u32, let M: u32>(fields: [Field; N]) -> [u8; M] {\\n    let mut bytes = [0; M];\\n\\n    std::static_assert(M > (N - 1) * 31, \\"Not enough output bytes specified\\");\\n    // We make this assertion to keep the logic simpler:\\n    std::static_assert(N * 31 >= M, \\"Too many output bytes specified.\\");\\n\\n    for i in 0..N - 1 {\\n        let field = fields[i];\\n\\n        // We expect that the field contains at most 31 bytes of information.\\n        field.assert_max_bit_size::<248>();\\n\\n        // Now we can safely convert the field to 31 bytes.\\n        let field_as_bytes: [u8; 31] = field.to_le_bytes();\\n\\n        for j in 0..31 {\\n            bytes[i * 31 + j] = field_as_bytes[j];\\n        }\\n    }\\n\\n    let final_field = fields[N - 1];\\n    final_field.assert_max_bit_size::<8 * (M - ((N - 1) * 31))>();\\n\\n    let final_field_as_bytes: [u8; M - ((N - 1) * 31)] = final_field.to_le_bytes();\\n\\n    let start_index = (N - 1) * 31;\\n    for j in 0..M - ((N - 1) * 31) {\\n        bytes[start_index + j] = final_field_as_bytes[j];\\n    }\\n\\n    bytes\\n}\\n\\n/// Converts an input array of fields into a single array of bytes.\\n/// Each field is converted to a 32-byte big-endian array.\\n/// Since a field is ~254 bits, you\'ll end up with a subtle 2-bit \\"gap\\" at the big end,\\n/// every 32 bytes. Be careful that such a gap doesn\'t leak information!\\npub fn fields_to_be_bytes_32<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\\n    let mut bytes = [0; 32 * N];\\n\\n    for i in 0..N {\\n        let field = fields[i];\\n        let field_as_bytes: [u8; 32] = field.to_be_bytes();\\n\\n        for j in 0..32 {\\n            bytes[i * 32 + j] = field_as_bytes[j];\\n        }\\n    }\\n\\n    bytes\\n}\\n\\nunconstrained fn byte_to_bits(byte: u8) -> [u1; 8] {\\n    let mut mut_byte = byte;\\n    let mut bits: [u1; 8] = [0; 8];\\n    for i in 0..8 {\\n        bits[i] = (mut_byte & 1) as u1;\\n        mut_byte >>= 1;\\n    }\\n    bits\\n}\\n\\n/// Returns as many random bytes as specified through N.\\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\\n    let mut bytes = [0; N];\\n    let mut idx = 32;\\n    let mut randomness = [0; 32];\\n    for i in 0..N {\\n        if idx == 32 {\\n            randomness = random().to_be_bytes();\\n            idx = 1; // Skip the first byte as it\'s always 0.\\n        }\\n        bytes[i] = randomness[idx];\\n        idx += 1;\\n    }\\n    bytes\\n}\\n\\n/// Returns as many random bits as specified through N.\\nunconstrained fn get_random_bits<let N: u32>() -> [u1; N] {\\n    // Note: (N + 7) / 8 = ceil(N / 8)\\n    let bytes = get_random_bytes::<(N + 7) / 8>();\\n    let mut bits: [u1; N] = [0; N];\\n    for i in 0..bytes.len() - 1 {\\n        let mut byte = bytes[i];\\n        for j in 0..8 {\\n            let bit_idx = i * 8 + j;\\n            bits[bit_idx] = (byte & 1) as u1;\\n            byte >>= 1;\\n        }\\n    }\\n\\n    // N - ((N / 8) * 8) = N - floor(N/8) * 8 = the number of bits remaining.\\n    let byte_idx = bytes.len() - 1;\\n    let mut byte = bytes[byte_idx];\\n    for j in 0..N - ((N / 8) * 8) {\\n        let bit_idx = (byte_idx) * 8 + j;\\n        bits[bit_idx] = (byte & 1) as u1;\\n        byte >>= 1;\\n    }\\n\\n    bits\\n}\\n\\n/// Returns random bits, in chunks, according to the provided numeric generics.\\nunconstrained fn get_chunks_of_random_bits<let NUM_CHUNKS: u32, let NUM_BITS: u32>() -> [[u1; NUM_BITS]; NUM_CHUNKS] {\\n    let random_bits = get_random_bits::<NUM_CHUNKS * NUM_BITS>();\\n    let mut chunks: [[u1; NUM_BITS]; NUM_CHUNKS] = [[0; NUM_BITS]; NUM_CHUNKS];\\n    for i in 0..NUM_CHUNKS {\\n        let mut chunk: [u1; NUM_BITS] = [0; NUM_BITS];\\n        for j in 0..NUM_BITS {\\n            chunk[j] = random_bits[i * NUM_BITS + j];\\n        }\\n        chunks[i] = chunk;\\n    }\\n    chunks\\n}\\n\\n/**\\n * Helper fn for be/le_bytes_to_padded_fields() fns.\\n */\\nfn pad_31_byte_fields_with_random_bits<let N: u32>(input: [Field; N]) -> [Field; N] {\\n    /// Safety: we can\'t constrain whether or not the returned bits are actually random;\\n    /// we can only rely on it being in the caller\'s best interest.\\n    let chunks_of_random_bits = unsafe { get_chunks_of_random_bits::<((N + 30) / 31), 6>() };\\n    let mut fields = input;\\n    // We push the random bits to the \\"big end\\" of each field\\n    let TWO_POW_248 = 0x100000000000000000000000000000000000000000000000000000000000000;\\n    for i in 0..fields.len() {\\n        let mut shift = TWO_POW_248;\\n        for j in 0..5 {\\n            fields[i] += shift * chunks_of_random_bits[i][j] as Field;\\n            shift *= 2;\\n        }\\n\\n        // This might overflow the field modulus, so we need to be careful.\\n        // By this point, shift = 2 ^ 253, so will populate the 254th bit (counting from 1)\\n        let field_with_254th_bit = fields[i] + shift * chunks_of_random_bits[i][6 - 1] as Field;\\n\\n        // Expensive comparison (one for each field), but it\'s important -- if we want to hide that we were\\n        // working with bytes -- that we include the 254th random bit when it fits.\\n        fields[i] = if (fields[i].lt(field_with_254th_bit)) {\\n            field_with_254th_bit\\n        } else {\\n            fields[i]\\n        };\\n    }\\n    fields\\n}\\n\\n/**\\n * The above functions be_bytes_31_to_fields and le_bytes_31_to_fields have a privacy-leakage problem:\\n * they result in fields which are all 248-bits instead of 254-bits.\\n * That means if the above functions are used to convert a ciphertext from bytes to\\n * fields, it leaks (with very high probability) to all observers of the log that the\\n * ciphertext was created with a \\"bit twiddly\\" encryption scheme like AES.\\n * This reduces privacy sets for all apps.\\n *\\n * This function seeks to \\"pad\\" those remaining 6 bits with randomness, so that all\\n * encrypted logs look even more similar (full fields of 254-bits of random-looking\\n * information). Of course, this adds some extra constraints, unfortunately.\\n */\\npub fn le_bytes_to_padded_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\\n    let mut fields = le_bytes_31_to_fields(input);\\n    pad_31_byte_fields_with_random_bits(fields)\\n}\\n\\npub fn be_bytes_to_padded_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\\n    let mut fields = be_bytes_31_to_fields(input);\\n    pad_31_byte_fields_with_random_bits(fields)\\n}\\n\\nmod test {\\n    use crate::utils::bytes::{\\n        be_bytes_31_to_fields, fields_to_be_bytes_31, fields_to_le_bytes_31, le_bytes_31_to_fields,\\n    };\\n\\n    // BE BYTES\\n\\n    #[test]\\n    fn test_be_bytes_31_to_1_field() {\\n        let input = [\\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n            25, 26, 27, 28, 29, 30, 31,\\n        ];\\n        let output = be_bytes_31_to_fields(input);\\n\\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\\n    }\\n\\n    #[test]\\n    fn test_1_field_to_be_bytes_31() {\\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\\n        let output: [u8; 31] = fields_to_be_bytes_31(input);\\n\\n        assert_eq(\\n            output,\\n            [\\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\\n                24, 25, 26, 27, 28, 29, 30, 31,\\n            ],\\n        );\\n    }\\n\\n    #[test]\\n    fn test_3_small_fields_to_be_bytes_31() {\\n        let input = [1, 2, 3];\\n        let output: [u8; 93] = fields_to_be_bytes_31(input);\\n\\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\\n        assert_eq(\\n            output,\\n            [\\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\\n            ],\\n        );\\n    }\\n\\n    #[test]\\n    fn test_3_small_fields_to_fewer_be_bytes() {\\n        let input = [1, 2, 3];\\n        let output: [u8; 63] = fields_to_be_bytes_31(input);\\n        println(f\\"output: {output}\\");\\n\\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\\n        // 1 byte.\\n        assert_eq(\\n            output,\\n            [\\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 0, 0, 0, 2, 3,\\n            ],\\n        );\\n    }\\n\\n    #[test]\\n    fn test_be_bytes_31_to_2_fields() {\\n        let input = [\\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\\n        ];\\n        let output = be_bytes_31_to_fields(input);\\n\\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\\n    }\\n\\n    #[test]\\n    fn test_2_fields_to_be_bytes_31() {\\n        let input = [\\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\\n        ];\\n        let output: [u8; 62] = fields_to_be_bytes_31(input);\\n\\n        assert_eq(\\n            output,\\n            [\\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\\n            ],\\n        );\\n    }\\n\\n    #[test]\\n    fn test_large_random_be_bytes_31_input_to_fields_and_back(input: [u8; 128]) {\\n        let output = be_bytes_31_to_fields(input);\\n        let input_back: [u8; 128] = fields_to_be_bytes_31(output);\\n\\n        assert_eq(input, input_back);\\n    }\\n\\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\\n    // them to get a value lower than 2^248.\\n    #[test]\\n    fn test_large_random_input_to_be_bytes_31_and_back(\\n        input1: [u64; 5],\\n        input2: [u64; 5],\\n        input3: [u64; 5],\\n        input4: [u32; 5],\\n        input5: [u16; 5],\\n        input6: [u8; 5],\\n    ) {\\n        let mut input = [0; 5];\\n        for i in 0..5 {\\n            input[i] = (input1[i] as Field * 2.pow_32(184))\\n                + (input2[i] as Field * 2.pow_32(120))\\n                + (input3[i] as Field * 2.pow_32(56))\\n                + (input4[i] as Field * 2.pow_32(24))\\n                + (input5[i] as Field * 2.pow_32(8))\\n                + input6[i] as Field;\\n        }\\n\\n        let output: [u8; 155] = fields_to_be_bytes_31(input);\\n        let input_back = be_bytes_31_to_fields(output);\\n\\n        assert_eq(input, input_back);\\n    }\\n\\n    #[test(should_fail_with = \\"call to assert_max_bit_size\\")]\\n    fn test_too_few_destination_be_bytes() {\\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\\n        // at least 2 bytes but we provide it with 1.\\n        let input = [1, 256];\\n        let _ignored_result: [u8; 32] = fields_to_be_bytes_31(input);\\n    }\\n\\n    #[test(should_fail_with = \\"call to assert_max_bit_size\\")]\\n    fn test_fields_to_be_bytes_31_value_too_large() {\\n        let input = [2.pow_32(248)]; // this number is 1 bit larger than 31 bytes.\\n        let _ignored_result: [u8; 31] = fields_to_be_bytes_31(input);\\n    }\\n\\n    #[test]\\n    fn test_fields_to_be_bytes_31_max_value() {\\n        let input = [2.pow_32(248) - 1];\\n        let result: [u8; 31] = fields_to_be_bytes_31(input);\\n\\n        // We check that all the bytes were set to max value (255)\\n        for i in 0..31 {\\n            assert_eq(result[i], 255);\\n        }\\n    }\\n\\n    // LE BYTES\\n\\n    #[test]\\n    fn test_le_bytes_31_to_1_field() {\\n        let input = [\\n            31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10,\\n            9, 8, 7, 6, 5, 4, 3, 2, 1,\\n        ];\\n        let output = le_bytes_31_to_fields(input);\\n\\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\\n    }\\n\\n    #[test]\\n    fn test_1_field_to_le_bytes_31() {\\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\\n        let output: [u8; 31] = fields_to_le_bytes_31(input);\\n\\n        assert_eq(\\n            output,\\n            [\\n                31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,\\n                10, 9, 8, 7, 6, 5, 4, 3, 2, 1,\\n            ],\\n        );\\n    }\\n\\n    #[test]\\n    fn test_3_small_fields_to_le_bytes_31() {\\n        let input = [1, 2, 3];\\n        let output: [u8; 93] = fields_to_le_bytes_31(input);\\n\\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\\n        assert_eq(\\n            output,\\n            [\\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            ],\\n        );\\n    }\\n\\n    #[test]\\n    fn test_3_small_fields_to_fewer_le_bytes() {\\n        let input = [1, 2, 3];\\n        let output: [u8; 63] = fields_to_le_bytes_31(input);\\n\\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\\n        // 1 byte.\\n        assert_eq(\\n            output,\\n            [\\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n                0, 0, 0, 0, 0, 0, 3,\\n            ],\\n        );\\n    }\\n\\n    #[test]\\n    fn test_le_bytes_31_to_2_fields() {\\n        let input = [\\n            59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38,\\n            37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,\\n            15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,\\n        ];\\n        let output = le_bytes_31_to_fields(input);\\n\\n        assert_eq(output[0], 0x1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\\n        assert_eq(output[1], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c);\\n    }\\n\\n    #[test]\\n    fn test_2_fields_to_le_bytes_31() {\\n        let input = [\\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\\n        ];\\n        let output: [u8; 62] = fields_to_le_bytes_31(input);\\n\\n        assert_eq(\\n            output,\\n            [\\n                31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,\\n                10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47,\\n                46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 0, 0, 0,\\n            ],\\n        );\\n    }\\n\\n    #[test]\\n    fn test_large_random_le_bytes_input_to_fields_and_back(input: [u8; 128]) {\\n        let output = le_bytes_31_to_fields(input);\\n        let input_back: [u8; 128] = fields_to_le_bytes_31(output);\\n\\n        assert_eq(input, input_back);\\n    }\\n\\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\\n    // them to get a value lower than 2^248.\\n    #[test]\\n    fn test_large_random_input_to_le_bytes_and_back(\\n        input1: [u64; 5],\\n        input2: [u64; 5],\\n        input3: [u64; 5],\\n        input4: [u32; 5],\\n        input5: [u16; 5],\\n        input6: [u8; 5],\\n    ) {\\n        let mut input = [0; 5];\\n        for i in 0..5 {\\n            input[i] = (input1[i] as Field * 2.pow_32(184))\\n                + (input2[i] as Field * 2.pow_32(120))\\n                + (input3[i] as Field * 2.pow_32(56))\\n                + (input4[i] as Field * 2.pow_32(24))\\n                + (input5[i] as Field * 2.pow_32(8))\\n                + input6[i] as Field;\\n        }\\n\\n        let output: [u8; 155] = fields_to_le_bytes_31(input);\\n        let input_back = le_bytes_31_to_fields(output);\\n\\n        assert_eq(input, input_back);\\n    }\\n\\n    #[test(should_fail_with = \\"call to assert_max_bit_size\\")]\\n    fn test_too_few_destination_le_bytes() {\\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\\n        // at least 2 bytes but we provide it with 1.\\n        let input = [1, 256];\\n        let _ignored_result: [u8; 32] = fields_to_le_bytes_31(input);\\n    }\\n\\n    #[test(should_fail_with = \\"call to assert_max_bit_size\\")]\\n    fn test_fields_to_le_bytes_31_value_too_large() {\\n        let input = [2.pow_32(248)];\\n        let _ignored_result: [u8; 31] = fields_to_le_bytes_31(input);\\n    }\\n\\n    #[test]\\n    fn test_fields_to_le_bytes_31_max_value() {\\n        let input = [2.pow_32(248) - 1];\\n        let result: [u8; 31] = fields_to_le_bytes_31(input);\\n\\n        // We check that all the bytes were set to max value (255)\\n        for i in 0..31 {\\n            assert_eq(result[i], 255);\\n        }\\n    }\\n}\\n"},"189":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use crate::utils::field::sqrt;\\nuse dep::protocol_types::point::Point;\\n\\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \\"String literal too large\\" error\\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\\nglobal BN254_FR_MODULUS_DIV_2: Field =\\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\\n\\n/// Converts a point to a byte array.\\n///\\n/// We don\'t serialize the point at infinity flag because this function is used in situations where we do not want\\n/// to waste the extra byte (encrypted log).\\npub fn point_to_bytes(p: Point) -> [u8; 32] {\\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\\n    // the \\"sign\\") so it\'s possible to use that last bit as an \\"is_infinite\\" flag if desired in the future.\\n    assert(!p.is_infinite, \\"Cannot serialize point at infinity as bytes.\\");\\n\\n    let mut result: [u8; 32] = p.x.to_be_bytes();\\n\\n    if get_sign_of_point(p) {\\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\\n        // the bits as a sign bit.\\n        result[0] += 128;\\n    }\\n\\n    result\\n}\\n\\n/**\\n * Returns: true if p.y <= MOD_DIV_2, else false.\\n */\\npub fn get_sign_of_point(p: Point) -> bool {\\n    // We store only a \\"sign\\" of the y coordinate because the rest can be derived from the x coordinate. To get\\n    // the sign we check if the y coordinate is less or equal than the curve\'s order minus 1 divided by 2.\\n    // Ideally we\'d do `y <= MOD_DIV_2`, but there\'s no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\\n}\\n\\npub fn point_from_x_coord(x: Field) -> Point {\\n    // y ^ 2 = x ^ 3 - 17\\n    let rhs = x * x * x - 17;\\n    let y = sqrt(rhs).unwrap();\\n    Point { x, y, is_infinite: false }\\n}\\n\\nmod test {\\n    use crate::utils::point::point_to_bytes;\\n    use dep::protocol_types::point::Point;\\n\\n    #[test]\\n    unconstrained fn test_point_to_bytes_positive_sign() {\\n        let p = Point {\\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\\n            is_infinite: false,\\n        };\\n\\n        let compressed_point = point_to_bytes(p);\\n\\n        let expected_compressed_point_positive_sign = [\\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\\n        ];\\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\\n    }\\n\\n    #[test]\\n    unconstrained fn test_point_to_bytes_negative_sign() {\\n        let p = Point {\\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\\n            is_infinite: false,\\n        };\\n\\n        let compressed_point = point_to_bytes(p);\\n\\n        let expected_compressed_point_negative_sign = [\\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\\n        ];\\n\\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\\n    }\\n}\\n"},"243":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\\n\\npub struct KeyValidationRequest {\\n    pub pk_m: Point,\\n    pub sk_app: Field, // not a grumpkin scalar because it\'s output of poseidon2\\n}\\n\\nimpl Eq for KeyValidationRequest {\\n    fn eq(self, request: KeyValidationRequest) -> bool {\\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\\n    }\\n}\\n\\nimpl Empty for KeyValidationRequest {\\n    fn empty() -> Self {\\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\\n    }\\n}\\n\\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\\n    }\\n}\\n\\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\\n        Self {\\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\\n            sk_app: fields[3],\\n        }\\n    }\\n}\\n"},"250":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector,\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        MAX_FIELD_VALUE,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\\n    merkle_tree::membership::MembershipWitness,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::{\\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\\n    ops::Add,\\n};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\n/// We implement the Packable trait for AztecAddress because it can be stored in contract\'s storage (and there\\n/// the implementation of Packable is required).\\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_private_function(\\n        function_selector: FunctionSelector,\\n        function_vk_hash: Field,\\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\\n        contract_class_artifact_hash: Field,\\n        contract_class_public_bytecode_commitment: Field,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let private_functions_root = private_functions_root_from_siblings(\\n            function_selector,\\n            function_vk_hash,\\n            function_leaf_membership_witness.leaf_index,\\n            function_leaf_membership_witness.sibling_path,\\n        );\\n\\n        let contract_class_id = ContractClassId::compute(\\n            contract_class_artifact_hash,\\n            private_functions_root,\\n            contract_class_public_bytecode_commitment,\\n        );\\n\\n        // Compute contract address using the preimage which includes the class_id.\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --\x3e Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"253":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\\n    contract_class_id::ContractClassId,\\n    hash::poseidon2_hash_with_separator,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\\n\\n// Partial address\\npub struct PartialAddress {\\n    pub inner: Field,\\n}\\n\\nimpl ToField for PartialAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\\n        PartialAddress { inner: fields[0] }\\n    }\\n}\\n\\nimpl PartialAddress {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(\\n        contract_class_id: ContractClassId,\\n        salt: Field,\\n        initialization_hash: Field,\\n        deployer: AztecAddress,\\n    ) -> Self {\\n        PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\\n        )\\n    }\\n\\n    pub fn compute_from_salted_initialization_hash(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash,\\n    ) -> Self {\\n        PartialAddress::from_field(poseidon2_hash_with_separator(\\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\\n        ))\\n    }\\n\\n    pub fn to_field(self) -> Field {\\n        self.inner\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.to_field() == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"255":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\\n    hash::poseidon2_hash_with_separator, traits::ToField,\\n};\\n\\n// Salted initialization hash. Used in the computation of a partial address.\\npub struct SaltedInitializationHash {\\n    pub inner: Field,\\n}\\n\\nimpl ToField for SaltedInitializationHash {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl SaltedInitializationHash {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\\n            [salt, initialization_hash, deployer.to_field()],\\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\\n        ))\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"260":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\\n    constants::CONTRACT_INSTANCE_LENGTH,\\n    contract_class_id::ContractClassId,\\n    public_keys::PublicKeys,\\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\\n};\\n\\npub struct ContractInstance {\\n    pub salt: Field,\\n    pub deployer: AztecAddress,\\n    pub contract_class_id: ContractClassId,\\n    pub initialization_hash: Field,\\n    pub public_keys: PublicKeys,\\n}\\n\\nimpl Eq for ContractInstance {\\n    fn eq(self, other: Self) -> bool {\\n        self.public_keys.eq(other.public_keys)\\n            & self.initialization_hash.eq(other.initialization_hash)\\n            & self.contract_class_id.eq(other.contract_class_id)\\n            & self.salt.eq(other.salt)\\n    }\\n}\\n\\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\\n        let public_keys_serialized = self.public_keys.serialize();\\n        [\\n            self.salt,\\n            self.deployer.to_field(),\\n            self.contract_class_id.to_field(),\\n            self.initialization_hash,\\n            public_keys_serialized[0],\\n            public_keys_serialized[1],\\n            public_keys_serialized[2],\\n            public_keys_serialized[3],\\n            public_keys_serialized[4],\\n            public_keys_serialized[5],\\n            public_keys_serialized[6],\\n            public_keys_serialized[7],\\n            public_keys_serialized[8],\\n            public_keys_serialized[9],\\n            public_keys_serialized[10],\\n            public_keys_serialized[11],\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\\n        Self {\\n            salt: serialized[0],\\n            deployer: AztecAddress::from_field(serialized[1]),\\n            contract_class_id: ContractClassId::from_field(serialized[2]),\\n            initialization_hash: serialized[3],\\n            public_keys: PublicKeys::deserialize([\\n                serialized[4],\\n                serialized[5],\\n                serialized[6],\\n                serialized[7],\\n                serialized[8],\\n                serialized[9],\\n                serialized[10],\\n                serialized[11],\\n                serialized[12],\\n                serialized[13],\\n                serialized[14],\\n                serialized[15],\\n            ]),\\n        }\\n    }\\n}\\n\\nimpl Hash for ContractInstance {\\n    fn hash(self) -> Field {\\n        self.to_address().to_field()\\n    }\\n}\\n\\nimpl ContractInstance {\\n    pub fn to_address(self) -> AztecAddress {\\n        AztecAddress::compute(\\n            self.public_keys,\\n            PartialAddress::compute(\\n                self.contract_class_id,\\n                self.salt,\\n                self.initialization_hash,\\n                self.deployer,\\n            ),\\n        )\\n    }\\n}\\n"},"266":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"267":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        function_selector::FunctionSelector,\\n        log_hash::{LogHash, ScopedLogHash},\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, is_empty, ToField},\\n    utils::field::field_from_bytes_32_trunc,\\n};\\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; N * 32];\\n    for offset in 0..N {\\n        // TODO: This is not checking that the decomposition is smaller than P\\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"268":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr","source":"use crate::traits::{Deserialize, Serialize, ToField};\\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\\nuse std::meta::derive;\\n\\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\\n\\n#[derive(Serialize, Deserialize)]\\npub struct IndexedTaggingSecret {\\n    app_tagging_secret: Field,\\n    index: u32,\\n}\\n\\nimpl IndexedTaggingSecret {\\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\\n        poseidon2_hash(\\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\\n        )\\n    }\\n}\\n"},"283":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\\n\\npub global POINT_LENGTH: u32 = 3;\\n\\nimpl Serialize<POINT_LENGTH> for Point {\\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\\n        [self.x, self.y, self.is_infinite as Field]\\n    }\\n}\\n\\nimpl Hash for Point {\\n    fn hash(self) -> Field {\\n        poseidon2_hash(self.serialize())\\n    }\\n}\\n\\nimpl Empty for Point {\\n    /// Note: Does not return a valid point on curve - instead represents an empty/\\"unpopulated\\" point struct (e.g.\\n    /// empty/unpopulated value in an array of points).\\n    fn empty() -> Self {\\n        Point { x: 0, y: 0, is_infinite: false }\\n    }\\n}\\n\\nimpl Deserialize<POINT_LENGTH> for Point {\\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\\n    }\\n}\\n// TODO(#11356): use compact representation here.\\nimpl Packable<POINT_LENGTH> for Point {\\n    fn pack(self) -> [Field; POINT_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\\n        Self::deserialize(packed)\\n    }\\n}\\n"},"284":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"293":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\\n    address::public_keys_hash::PublicKeysHash,\\n    constants::{\\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\\n    },\\n    hash::poseidon2_hash_with_separator,\\n    point::POINT_LENGTH,\\n    traits::{Deserialize, Hash, Serialize},\\n};\\n\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\nuse std::default::Default;\\n\\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\\n\\npub struct PublicKeys {\\n    pub npk_m: NpkM,\\n    pub ivpk_m: IvpkM,\\n    pub ovpk_m: OvpkM,\\n    pub tpk_m: TpkM,\\n}\\n\\npub trait ToPoint {\\n    fn to_point(self) -> Point;\\n}\\n\\npub struct NpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for NpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for NpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\\nimpl Hash for NpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\npub struct IvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for IvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for IvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct OvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl Hash for OvpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\nimpl ToPoint for OvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for OvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct TpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for TpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for TpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\nimpl Default for PublicKeys {\\n    fn default() -> Self {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\\n            },\\n        }\\n    }\\n}\\n\\nimpl Eq for PublicKeys {\\n    fn eq(self, other: PublicKeys) -> bool {\\n        (self.npk_m.inner == other.npk_m.inner)\\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\\n            & (self.tpk_m.inner == other.tpk_m.inner)\\n    }\\n}\\n\\nimpl PublicKeys {\\n    pub fn hash(self) -> PublicKeysHash {\\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\\n            self.serialize(),\\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\\n        ))\\n    }\\n}\\n\\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\\n        [\\n            self.npk_m.inner.x,\\n            self.npk_m.inner.y,\\n            self.npk_m.inner.is_infinite as Field,\\n            self.ivpk_m.inner.x,\\n            self.ivpk_m.inner.y,\\n            self.ivpk_m.inner.is_infinite as Field,\\n            self.ovpk_m.inner.x,\\n            self.ovpk_m.inner.y,\\n            self.ovpk_m.inner.is_infinite as Field,\\n            self.tpk_m.inner.x,\\n            self.tpk_m.inner.y,\\n            self.tpk_m.inner.is_infinite as Field,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point {\\n                    x: serialized[0],\\n                    y: serialized[1],\\n                    is_infinite: serialized[2] as bool,\\n                },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point {\\n                    x: serialized[3],\\n                    y: serialized[4],\\n                    is_infinite: serialized[5] as bool,\\n                },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point {\\n                    x: serialized[6],\\n                    y: serialized[7],\\n                    is_infinite: serialized[8] as bool,\\n                },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point {\\n                    x: serialized[9],\\n                    y: serialized[10],\\n                    is_infinite: serialized[11] as bool,\\n                },\\n            },\\n        }\\n    }\\n}\\n\\npub struct AddressPoint {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for AddressPoint {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_public_keys_hash() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let actual = keys.hash();\\n    let expected_public_keys_hash =\\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\\n\\n    assert(actual.to_field() == expected_public_keys_hash);\\n}\\n\\n#[test]\\nunconstrained fn compute_default_hash() {\\n    let keys = PublicKeys::default();\\n\\n    let actual = keys.hash();\\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\\n\\n    assert(actual.to_field() == test_data_default_hash);\\n}\\n\\n#[test]\\nunconstrained fn test_public_keys_serialization() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let serialized = keys.serialize();\\n    let deserialized = PublicKeys::deserialize(serialized);\\n\\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\\n}\\n"},"330":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"pub mod assert_array_appended;\\npub mod assert_array_prepended;\\npub mod assert_combined_array;\\npub mod assert_combined_transformed_array;\\npub mod assert_exposed_sorted_transformed_value_array;\\npub mod assert_sorted_array;\\npub mod assert_sorted_transformed_value_array;\\npub mod assert_split_sorted_transformed_value_arrays;\\npub mod assert_split_transformed_value_arrays;\\npub mod get_sorted_result;\\npub mod get_sorted_tuple;\\npub mod sort_by;\\npub mod sort_by_counter;\\n\\n// Re-exports.\\npub use assert_array_appended::{\\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\\n    assert_array_appended_scoped,\\n};\\npub use assert_array_prepended::assert_array_prepended;\\npub use assert_combined_array::{assert_combined_array, combine_arrays};\\npub use assert_combined_transformed_array::{\\n    assert_combined_transformed_array, combine_and_transform_arrays,\\n};\\npub use assert_exposed_sorted_transformed_value_array::{\\n    assert_exposed_sorted_transformed_value_array,\\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\\n};\\npub use assert_sorted_array::assert_sorted_array;\\npub use assert_sorted_transformed_value_array::{\\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\\n};\\npub use assert_split_sorted_transformed_value_arrays::{\\n    assert_split_sorted_transformed_value_arrays_asc,\\n    assert_split_sorted_transformed_value_arrays_desc,\\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\\n};\\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\\npub use get_sorted_result::{get_sorted_result, SortedResult};\\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\\n\\nuse crate::traits::{Empty, is_empty};\\n\\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [Field; SRC_LEN],\\n    offset: u32,\\n) -> [Field; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"offset too large\\");\\n\\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\n// Helper function to convert a validated array to BoundedVec.\\n// Important: Only use it for validated arrays: validate_array(array) should be true.\\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\\nwhere\\n    T: Empty + Eq,\\n{\\n    let len = array_length(array);\\n    BoundedVec::from_parts_unchecked(array, len)\\n}\\n\\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\\n// is not found, the function returns N as the index.\\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\\n    array: [T; N],\\n    find: fn[Env](T) -> bool,\\n) -> u32 {\\n    let mut index = N;\\n    for i in 0..N {\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & find(array[i]) {\\n            index = i;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\\n// valid.\\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut seen_empty = false;\\n    let mut length = 0;\\n    for i in 0..N {\\n        if is_empty(array[i]) {\\n            seen_empty = true;\\n        } else {\\n            assert(seen_empty == false, \\"invalid array\\");\\n            length += 1;\\n        }\\n    }\\n    length\\n}\\n\\n// Helper function to count the number of non-empty elements in a validated array.\\n// Important: Only use it for validated arrays where validate_array(array) returns true,\\n// which ensures that:\\n// 1. All elements before the first empty element are non-empty\\n// 2. All elements after and including the first empty element are empty\\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // We get the length by checking the index of the first empty element.\\n\\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\\n    /// of the element and non-emptiness of the previous element is checked below.\\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]));\\n    }\\n    if length != N {\\n        assert(is_empty(array[length]));\\n    }\\n    length\\n}\\n\\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\\n    let mut result = [array1[0]; N + M];\\n    for i in 1..N {\\n        result[i] = array1[i];\\n    }\\n    for i in 0..M {\\n        result[i + N] = array2[i];\\n    }\\n    result\\n}\\n\\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut result: [T; N] = [T::empty(); N];\\n    let mut i = 0;\\n    for elem in array1 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    for elem in array2 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    result\\n}\\n\\n// Helper fn to create a subarray from a given array\\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\\nwhere\\n    T: Empty,\\n{\\n    assert(M + offset <= N, \\"Subarray length larger than array length\\");\\n    let mut result: [T; M] = [T::empty(); M];\\n    for i in 0..M {\\n        result[i] = array[offset + i];\\n    }\\n    result\\n}\\n\\npub fn check_permutation<T, let N: u32>(\\n    original_array: [T; N],\\n    permuted_array: [T; N],\\n    original_indexes: [u32; N],\\n)\\nwhere\\n    T: Eq + Empty,\\n{\\n    let mut seen_value = [false; N];\\n    for i in 0..N {\\n        let index = original_indexes[i];\\n        let original_value = original_array[index];\\n        assert(permuted_array[i].eq(original_value), \\"Invalid index\\");\\n        assert(!seen_value[index], \\"Duplicated index\\");\\n        seen_value[index] = true;\\n    }\\n}\\n\\n#[test]\\nfn smoke_validate_array() {\\n    let valid_array: [Field; 0] = [];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(validate_array(valid_array) == 1);\\n\\n    let valid_array = [1, 2, 3];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(validate_array(valid_array) == 3);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case0() {\\n    let invalid_array = [0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case1() {\\n    let invalid_array = [1, 0, 0, 1, 0];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case2() {\\n    let invalid_array = [0, 0, 0, 0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test]\\nfn test_empty_array_length() {\\n    assert_eq(array_length([0]), 0);\\n    assert_eq(array_length([0, 0, 0]), 0);\\n}\\n\\n#[test]\\nfn test_array_length() {\\n    assert_eq(array_length([123]), 1);\\n    assert_eq(array_length([123, 0, 0]), 1);\\n    assert_eq(array_length([123, 456]), 2);\\n    assert_eq(array_length([123, 456, 0]), 2);\\n}\\n\\n#[test]\\nfn test_array_length_invalid_arrays() {\\n    // Result can be misleading (but correct) for invalid arrays.\\n    assert_eq(array_length([0, 0, 123]), 0);\\n    assert_eq(array_length([0, 123, 0]), 0);\\n    assert_eq(array_length([0, 123, 456]), 0);\\n    assert_eq(array_length([123, 0, 456]), 1);\\n}\\n\\n#[test]\\nunconstrained fn find_index_greater_than_min() {\\n    let values = [10, 20, 30, 40];\\n    let min = 22;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 2);\\n}\\n\\n#[test]\\nunconstrained fn find_index_not_found() {\\n    let values = [10, 20, 30, 40];\\n    let min = 100;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 4);\\n}\\n\\n#[test]\\nfn test_array_concat() {\\n    let array0 = [1, 2, 3];\\n    let array1 = [4, 5];\\n    let concatenated = array_concat(array0, array1);\\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\\n}\\n\\n#[test]\\nfn check_permutation_basic_test() {\\n    let original_array = [1, 2, 3];\\n    let permuted_array = [3, 1, 2];\\n    let indexes = [2, 0, 1];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Duplicated index\\")]\\nfn check_permutation_duplicated_index() {\\n    let original_array = [0, 1, 0];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 0];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Invalid index\\")]\\nfn check_permutation_invalid_index() {\\n    let original_array = [0, 1, 2];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 2];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n"},"333":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"338":{"path":"/root/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr","source":"// Elliptic curve implementation\\n// Overview\\n// ========\\n// The following three elliptic curve representations are admissible:\\npub mod tecurve; // Twisted Edwards curves\\npub mod swcurve; // Elliptic curves in Short Weierstrass form\\npub mod montcurve; // Montgomery curves\\npub mod consts; // Commonly used curve presets\\n//\\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\\n// they may be freely converted between one another, whereas Short Weierstrass curves are\\n// more general. Diagramatically:\\n//\\n// tecurve == montcurve `subset` swcurve\\n//\\n// Each module is further divided into two submodules, \'affine\' and \'curvegroup\', depending\\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\\n// \'CurveGroup\' coordinates (terminology borrowed from Arkworks, whose conventions we try\\n// to follow) are special coordinate systems with respect to which the group operations may be\\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\\n//\\n// In each of these submodules, there is a Point struct and a Curve struct, the former\\n// representing a point in the coordinate system and the latter a curve configuration.\\n//\\n// Points\\n// ======\\n// Points may be instantiated using the associated function `new`, which takes coordinates\\n// as its arguments. For instance,\\n//\\n// `let p = swcurve::Point::new(1,1);`\\n//\\n// The additive identity may be constructed by a call to the associated function `zero` of no\\n// arguments:\\n//\\n// `let zero = swcurve::Point::zero();`\\n//\\n// Points may be tested for equality by calling the method `eq`:\\n//\\n// `let pred = p.eq(zero);`\\n//\\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\\n//\\n// `constrain pred == p.is_zero();`\\n//\\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\\n// below, as the underlying mappings are those of curves rather than ambient spaces.\\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\\n// (resp. CurveGroup) coordinates.\\n//\\n// Curves\\n// ======\\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\\n// Edwards curve in affine coordinates as follows:\\n//\\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\\n//\\n// The `contains` method may be used to check whether a Point lies on a given curve:\\n//\\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\\n//\\n// The elliptic curve group\'s addition operation is exposed as the `add` method, e.g.\\n//\\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\\n//\\n// subtraction as the `subtract` method, e.g.\\n//\\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\\n//\\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\\n//\\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\\n//\\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\\n// to be of the same length.\\n//\\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\\n// and `into_affine` methods on them, e.g.\\n//\\n// `let bjj_curvegroup = bjj_affine.into_group();`\\n//\\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\\n//\\n// Curve maps\\n// ==========\\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\\n//\\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\\n//\\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\\n// the curve.\\n//\\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\\n//\\n//\\n// *TODO: Replace Field with Bigint.\\n// **TODO: Support arrays of structs to make this work.\\n// Field-dependent constant ZETA = a non-square element of Field\\n// Required for Elligator 2 map\\n// TODO: Replace with built-in constant.\\nglobal ZETA: Field = 5;\\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\\n// TODO: Possibly make this built-in.\\nglobal C1: u32 = 28;\\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\\n// Higher-order version of scalar multiplication\\n// TODO: Make this work so that the submodules\' bit_mul may be defined in terms of it.\\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\\n//    let mut out = e;\\n//    let n = bits.len();\\n//\\n//    for i in 0..n {\\n//        out = add(\\n//            add(out, out),\\n//            if(bits[n - i - 1] == 0) {e} else {p});\\n//    }\\n//\\n//    out\\n//}\\n// TODO: Make this built-in.\\npub fn safe_inverse(x: Field) -> Field {\\n    if x == 0 {\\n        0\\n    } else {\\n        1 / x\\n    }\\n}\\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\\npub fn is_square(x: Field) -> bool {\\n    let v = pow(x, 0 - 1 / 2);\\n\\n    v * (v - 1) == 0\\n}\\n// Power function of two Field arguments of arbitrary size.\\n// Adapted from std::field::pow_32.\\npub fn pow(x: Field, y: Field) -> Field {\\n    let mut r = 1 as Field;\\n    let b: [u1; 254] = y.to_le_bits();\\n\\n    for i in 0..254 {\\n        r *= r;\\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\\n    }\\n\\n    r\\n}\\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\\n// These are pre-computed above as globals.\\npub fn sqrt(x: Field) -> Field {\\n    let mut z = pow(x, C3);\\n    let mut t = z * z * x;\\n    z *= x;\\n    let mut b = t;\\n    let mut c = C5;\\n\\n    for i in 0..(C1 - 1) {\\n        for _j in 1..(C1 - i - 1) {\\n            b *= b;\\n        }\\n\\n        z *= if b == 1 { 1 } else { c };\\n\\n        c *= c;\\n\\n        t *= if b == 1 { 1 } else { c };\\n\\n        b = t;\\n    }\\n\\n    z\\n}\\n\\nmod tests {\\n    use crate::montcurve::affine::Point as MGaffine;\\n    use crate::montcurve::curvegroup::Point as MG;\\n    use crate::swcurve::affine::Point as SWGaffine;\\n    use crate::swcurve::curvegroup::Point as SWG;\\n    use crate::tecurve::affine::Curve as AffineCurve;\\n    use crate::tecurve::affine::Point as Gaffine;\\n    use crate::tecurve::curvegroup::Point as G;\\n\\n    #[test]\\n    fn smoke_test() {\\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\\n        let bjj_affine = AffineCurve::new(\\n            168700,\\n            168696,\\n            Gaffine::new(\\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\\n            ),\\n        );\\n        // Test addition\\n        let p1_affine = Gaffine::new(\\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\\n        );\\n        let p2_affine = Gaffine::new(\\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\\n        );\\n\\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\\n        assert(p3_affine.eq(Gaffine::new(\\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\\n        )));\\n        // Test scalar multiplication\\n        let p4_affine = bjj_affine.mul(2, p1_affine);\\n        assert(p4_affine.eq(Gaffine::new(\\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\\n        )));\\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\\n        // Test subtraction\\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\\n        assert(p5_affine.eq(Gaffine::zero()));\\n        // Check that these points are on the curve\\n        assert(\\n            bjj_affine.contains(bjj_affine.gen)\\n                & bjj_affine.contains(p1_affine)\\n                & bjj_affine.contains(p2_affine)\\n                & bjj_affine.contains(p3_affine)\\n                & bjj_affine.contains(p4_affine)\\n                & bjj_affine.contains(p5_affine),\\n        );\\n        // Test CurveGroup equivalents\\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\\n        let p1 = p1_affine.into_group();\\n        let p2 = p2_affine.into_group();\\n        let p3 = p3_affine.into_group();\\n        let p4 = p4_affine.into_group();\\n        let p5 = p5_affine.into_group();\\n        // Test addition\\n        assert(p3.eq(bjj.add(p1, p2)));\\n        // Test scalar multiplication\\n        assert(p4.eq(bjj.mul(2, p1)));\\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\\n        // Test subtraction\\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\\n        assert(p5.eq(G::zero()));\\n        // Check that these points are on the curve\\n        assert(\\n            bjj.contains(bjj.gen)\\n                & bjj.contains(p1)\\n                & bjj.contains(p2)\\n                & bjj.contains(p3)\\n                & bjj.contains(p4)\\n                & bjj.contains(p5),\\n        );\\n        // Test SWCurve equivalents of the above\\n        // First the affine representation\\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\\n\\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\\n        // Addition\\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\\n        // Doubling\\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\\n        // Subtraction\\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\\n            p3_swcurve_affine,\\n            p3_swcurve_affine,\\n        )));\\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\\n        // Check that these points are on the curve\\n        assert(\\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\\n        );\\n        // Then the CurveGroup representation\\n        let bjj_swcurve = bjj.into_swcurve();\\n\\n        let p1_swcurve = bjj.map_into_swcurve(p1);\\n        let p2_swcurve = bjj.map_into_swcurve(p2);\\n        let p3_swcurve = bjj.map_into_swcurve(p3);\\n        let p4_swcurve = bjj.map_into_swcurve(p4);\\n        let p5_swcurve = bjj.map_into_swcurve(p5);\\n        // Addition\\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\\n        // Doubling\\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\\n        // Subtraction\\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\\n        assert(p5_swcurve.eq(SWG::zero()));\\n        // Check that these points are on the curve\\n        assert(\\n            bjj_swcurve.contains(bjj_swcurve.gen)\\n                & bjj_swcurve.contains(p1_swcurve)\\n                & bjj_swcurve.contains(p2_swcurve)\\n                & bjj_swcurve.contains(p3_swcurve)\\n                & bjj_swcurve.contains(p4_swcurve)\\n                & bjj_swcurve.contains(p5_swcurve),\\n        );\\n        // Test MontCurve conversions\\n        // First the affine representation\\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\\n\\n        let p1_montcurve_affine = p1_affine.into_montcurve();\\n        let p2_montcurve_affine = p2_affine.into_montcurve();\\n        let p3_montcurve_affine = p3_affine.into_montcurve();\\n        let p4_montcurve_affine = p4_affine.into_montcurve();\\n        let p5_montcurve_affine = p5_affine.into_montcurve();\\n        // Addition\\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\\n            p1_montcurve_affine,\\n            p2_montcurve_affine,\\n        )));\\n        // Doubling\\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\\n        // Subtraction\\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\\n            p3_montcurve_affine,\\n            p3_montcurve_affine,\\n        )));\\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\\n        // Check that these points are on the curve\\n        assert(\\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\\n        );\\n        // Then the CurveGroup representation\\n        let bjj_montcurve = bjj.into_montcurve();\\n\\n        let p1_montcurve = p1_montcurve_affine.into_group();\\n        let p2_montcurve = p2_montcurve_affine.into_group();\\n        let p3_montcurve = p3_montcurve_affine.into_group();\\n        let p4_montcurve = p4_montcurve_affine.into_group();\\n        let p5_montcurve = p5_montcurve_affine.into_group();\\n        // Addition\\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\\n        // Doubling\\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\\n        // Subtraction\\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\\n        assert(p5_montcurve.eq(MG::zero()));\\n        // Check that these points are on the curve\\n        assert(\\n            bjj_montcurve.contains(bjj_montcurve.gen)\\n                & bjj_montcurve.contains(p1_montcurve)\\n                & bjj_montcurve.contains(p2_montcurve)\\n                & bjj_montcurve.contains(p3_montcurve)\\n                & bjj_montcurve.contains(p4_montcurve)\\n                & bjj_montcurve.contains(p5_montcurve),\\n        );\\n        // Elligator 2 map-to-curve\\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\\n\\n        assert(ell2_pt_map.eq(MGaffine::new(\\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\\n        )\\n            .into_tecurve()));\\n        // SWU map-to-curve\\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\\n\\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\\n        ))));\\n    }\\n\\n}\\n"},"345":{"path":"/root/nargo/github.com/noir-lang/schnorr/v0.1.1/src/lib.nr","source":"use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\\nuse std::hash::{blake2s, pedersen_hash};\\n\\npub fn verify_signature<let N: u32>(\\n    public_key: EmbeddedCurvePoint,\\n    signature: [u8; 64],\\n    message: [u8; N],\\n) -> bool {\\n    //scalar lo/hi from bytes\\n    let sig_s = scalar_from_bytes(signature, 0);\\n    let sig_e = scalar_from_bytes(signature, 32);\\n    // pub_key is on Grumpkin curve\\n    let mut is_ok = (public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17)\\n        & (!public_key.is_infinite);\\n\\n    if ((sig_s.lo != 0) | (sig_s.hi != 0)) & ((sig_e.lo != 0) | (sig_e.hi != 0)) {\\n        let (r_is_infinite, result) =\\n            calculate_signature_challenge(public_key, sig_s, sig_e, message);\\n\\n        is_ok &= !r_is_infinite;\\n        for i in 0..32 {\\n            is_ok &= result[i] == signature[32 + i];\\n        }\\n    } else {\\n        is_ok = false;\\n    }\\n    is_ok\\n}\\n\\npub fn assert_valid_signature<let N: u32>(\\n    public_key: EmbeddedCurvePoint,\\n    signature: [u8; 64],\\n    message: [u8; N],\\n) {\\n    //scalar lo/hi from bytes\\n    let sig_s = scalar_from_bytes(signature, 0);\\n    let sig_e = scalar_from_bytes(signature, 32);\\n\\n    // assert pub_key is on Grumpkin curve\\n    assert(public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17);\\n    assert(public_key.is_infinite == false);\\n    // assert signature is not null\\n    assert((sig_s.lo != 0) | (sig_s.hi != 0));\\n    assert((sig_e.lo != 0) | (sig_e.hi != 0));\\n\\n    let (r_is_infinite, result) = calculate_signature_challenge(public_key, sig_s, sig_e, message);\\n\\n    assert(!r_is_infinite);\\n    for i in 0..32 {\\n        assert(result[i] == signature[32 + i]);\\n    }\\n}\\n\\nfn calculate_signature_challenge<let N: u32>(\\n    public_key: EmbeddedCurvePoint,\\n    sig_s: EmbeddedCurveScalar,\\n    sig_e: EmbeddedCurveScalar,\\n    message: [u8; N],\\n) -> (bool, [u8; 32]) {\\n    let g1 = EmbeddedCurvePoint {\\n        x: 1,\\n        y: 17631683881184975370165255887551781615748388533673675138860,\\n        is_infinite: false,\\n    };\\n    let r = multi_scalar_mul([g1, public_key], [sig_s, sig_e]);\\n    // compare the _hashes_ rather than field elements modulo r\\n    let pedersen_hash = pedersen_hash([r.x, public_key.x, public_key.y]);\\n    let pde: [u8; 32] = pedersen_hash.to_be_bytes();\\n\\n    let mut hash_input = [0; N + 32];\\n    for i in 0..32 {\\n        hash_input[i] = pde[i];\\n    }\\n    for i in 0..N {\\n        hash_input[32 + i] = message[i];\\n    }\\n\\n    let result = blake2s(hash_input);\\n    (r.is_infinite, result)\\n}\\n\\n//Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\\nfn scalar_from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\\n    let mut v: Field = 1;\\n    let mut lo: Field = 0;\\n    let mut hi: Field = 0;\\n    for i in 0..16 {\\n        lo = lo + (bytes[offset + 31 - i] as Field) * v;\\n        hi = hi + (bytes[offset + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    let sig_s = EmbeddedCurveScalar::new(lo, hi);\\n    sig_s\\n}\\n\\nmod test {\\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\\n\\n    use super::verify_signature;\\n\\n    #[test]\\n    fn test_zero_signature() {\\n        let public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {\\n            x: 1,\\n            y: 17631683881184975370165255887551781615748388533673675138860,\\n            is_infinite: false,\\n        };\\n        let signature: [u8; 64] = [0; 64];\\n        let message: [u8; _] = [2; 64]; // every message\\n        let verified = verify_signature(public_key, signature, message);\\n        assert(!verified);\\n    }\\n\\n    #[test]\\n    fn smoke_test() {\\n        let message: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\\n        let pub_key_x: Field = 0x04b260954662e97f00cab9adb773a259097f7a274b83b113532bce27fa3fb96a;\\n        let pub_key_y: Field = 0x2fd51571db6c08666b0edfbfbc57d432068bccd0110a39b166ab243da0037197;\\n        let signature: [u8; 64] = [\\n            1, 13, 119, 112, 212, 39, 233, 41, 84, 235, 255, 93, 245, 172, 186, 83, 157, 253, 76,\\n            77, 33, 128, 178, 15, 214, 67, 105, 107, 177, 234, 77, 48, 27, 237, 155, 84, 39, 84,\\n            247, 27, 22, 8, 176, 230, 24, 115, 145, 220, 254, 122, 135, 179, 171, 4, 214, 202, 64,\\n            199, 19, 84, 239, 138, 124, 12,\\n        ];\\n\\n        let pub_key = EmbeddedCurvePoint { x: pub_key_x, y: pub_key_y, is_infinite: false };\\n        let valid_signature = verify_signature(pub_key, signature, message);\\n        assert(valid_signature);\\n        super::assert_valid_signature(pub_key, signature, message);\\n    }\\n\\n}\\n\\nmod bench {\\n    use super::{assert_valid_signature, verify_signature};\\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\\n\\n    #[export]\\n    pub fn bench_verify_signature(\\n        public_key: EmbeddedCurvePoint,\\n        signature: [u8; 64],\\n        message: [u8; 32],\\n    ) -> bool {\\n        verify_signature(public_key, signature, message)\\n    }\\n\\n    #[export]\\n    pub fn bench_assert_valid_signature(\\n        public_key: EmbeddedCurvePoint,\\n        signature: [u8; 64],\\n        message: [u8; 32],\\n    ) {\\n        assert_valid_signature(public_key, signature, message)\\n    }\\n}\\n"}}}'));class $y extends Fy{constructor(e){super(Ky),this.signingPrivateKey=e}async getDeploymentArgs(){const e=await(new pm).computePublicKey(this.signingPrivateKey);return[e.x,e.y]}getAuthWitnessProvider(e){return new eA(this.signingPrivateKey)}}class eA{constructor(e){this.signingPrivateKey=e}async createAuthWit(e){const t=new pm,n=await t.constructSignature(e.toBuffer(),this.signingPrivateKey);return new $_(e,[...n.toBuffer()])}}function tA(e,t,n,s){return My.create(e,t,new $y(n),s)}const nA=ry(JSON.parse('{"transpiled":true,"noir_version":"1.0.0-beta.1+c4e38215cedb5afb","name":"SchnorrSingleKeyAccount","functions":[{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_auth_witness","decompose_hint","lte_hint","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","notify_created_nullifier_oracle_wrapper","directive_to_radix","directive_invert","directive_integer_quotient"],"verification_key":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"packed_note_content","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VZy67aQAwdSEJIuAEKn3Cl7tomXJ47Fn3c30AFPqHrrLppP7qMGCcH46siYVfFEpoknhyfOXZmJqHjztY//TrhOA5tz10b9dmGtrzPKkWs0pJn50F4dh+EZ/QgPGNFnh2Bp2/peUvc+ZlL3fl5bC7iTT7BEdzk/gYAwX6HNgttF/yKCakyYZBa+Otyvs/cpSnzf8kCZmqDvyD8vg1+Sbw/1y0+joXiRqF9rVstX+Eeb0U4xuIlXPJ1wfeF+SLwfWU+rOFvzId1T5xIN1qYlOtqY50XGlsKY+u80TrXaofXSOvcmdZoRTnPGB/On/gU1Kdu+fSYLwZfxnwJ+Eh/3z5DP577FPp9hONP0IfXZ+Su65n8lH/U3aK+YgP8k82lHPD8xPVlbPRhDmLQ85npY7FuoD4W+nt9pm/wp2Nvae0ai5ieqBFp1sf+zJeBL64v4+ThPIY4iEU8Etb/QzgfhbYH99D9YyF+j8W/4C1cQ404ViRco/7++Xwfjgfh52voJ93jructvc31ci7N4Xr4qwY/s+F/JPzcBn9J+AMb/GZv82SCPysJv7Dh38xBQ5v6afaWIxv+B8Ifm+DPD7QOv3OtNXNEOJ7Adb35u6pu2SNh/JxxtdojTRgfrg+uwd43FbiOBR/P4VSIMxXiSFiZItaTItboPx1jXxFroIg1VMTSzGOqiKWpV66IVShiada9pl6UR2mf5m0b2vJOk/ZpiviVtE/TfJcnram+YkFDHF/C+v9gOg9MeFYzWnPoWacYGLswin3rek3xC4EP8c4F3z0fZw+L9XGzXmxOW7JqOds0+SwYV34N34twPsb+0tov7fsUtS6ld/8h6OotBl/BfAn4iKP07j804n+L/hh/LPj4+n9rLifuej0csHHjN6+typjb74HSt3rj+Wtx67NJ8XN3PV//q++NqA/fS+cC17Hg4/uTXIiTC3EeEYt/s0cNfV2TTnHd+rVyuVq3f3TRXJS4y/8BHIufsP6/wjmOjdp75vzjalcdX3bH3WK338+/7yYM31sXdPoDg5oBSR0fAAA=","debug_symbols":"tZfBisMgFEX/xbULn8YY+yvDUExiiiAmmGRgCPn3MSVMS7ssdxN84XrceMC7sd636+0a0jDO7PK1sTh2bgljKtO2c9bmEGO4XZ9/M3F8rL7n58mlY5wXlxd2qQVnPvVl0ZTdQ4i+LNXO34JGnkFj/oNa7t+c2RoFNihwgwJbEJiEgJEJRpYwsoKRKxhZw8g1jGxg5AZGhjlIMAcJ5iDBHCSYgwRzkGAOEsxBgjlInzlo1RksV+ENbWFoKXBowqElDq1w6AqH1jh0jUMbHBpno8TZqHA2KpCNe5l+XA6ujf5sTcOauqcStfxO/qVPTXnsfL9mfzSrR6k61FOaV/r+8igDqYqTsuWQctAf","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"log_plaintext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/92c927bMBDG5URKIieOndG9927leHeme+/W/dsdfosWAtqHSPu09Zfw7DPDAilCovkqQJCto+9+PFHUiTy6EG1s3cFeMJ9jc5w2R5xfjMY3Kbtqjtn2tqpHXVkoxgIB4wQB4yQBY0zAmBAwThEwThMwzhAwpgSMRQLGWQLGOQLGEgHjPAFjmYCxQsC4EIAxBOciCeeSR04d24fiXY52fhvdRcC4m4BxDwHjXgLGfQSM+wkYDxAwHiRgPETAeJiA8QgB41ECxmMEjMcJGE8QMJ4kYDxFwHiagPEMAeNZAsZzBIznCRgvEDBeJGC8RMB4mYDxCgFjRsBYJWBcIWCsETDWCRgbBIxNAsYWAWObgLFDwHiVgPEaAeN1AsYbBIw3CRhvETCuEjDeJmC8Q8B4l4DxHgHjfQLGBwSMDwkYHxEwPiZgfELA+JSA8RkB43MCxhcEjC8JGF8RML4mYHxDwPg2AGMIzncknO9JOLuBOKMPFvTEYMfCLSyMwsIjLOzBwhksTMHCDyyswMIFLAxA4j0S25E4XhnsSHxGUjESdpEEiyRTJHEiSRJJiEjyQxIdktSQBIYkKyQxIUno6GA/NtiRRIIkDSRBIMkAk/iYJMckNCZ5MYmKSUpMAmKSDZNYmCRCrTDJgUkEDNJjEByDzBjExSApBiExyIdBNAxSYRAIgywYxJBBArzk4iUSL2l4CcJLBoJ4BMkIQhHkIYhCkIIgAA9ZPMTwkEAnjE4OnQhuUtwAaFzd6M+bNJIf5pia44SSe1xEV00tuz71t7POx9RRP4/8tdTonAmiv9ES/WkY/kwW2t7LR/p1XcTupDl285Evu/k4k5RZU2XWrDJSnzDXu14P66/qSsnyUaTqIraLYWzXCpY9fV20TOwXo5Btc2NRsrYnPLZ/pO8oSZl8xFOwZHG+uR4iS5RMri/snFfl7LY1Y8mEBZu035LyjWwfjEyuaax0+muvjXbY9lrP/l17rVf/x/YaW7I431yPv22vum3Z7TWJRpv0pSKbUrKflmxayX7lI9sNxdE0n8P2yRvPYH3v+X6GLTn4tS1s0/nIH9IGJ9W5RPlv3T+6vCVLlSzOx+0UzfdY2dG6hCOxytfN97I5TqnfyO8rDvtTlv0xbsc52y+po3zqKI+2dsl8njU72tA3+U20+d7Fvmq+Z9vamh1XP+lPf6vm6gs98n8R/bNB9NeH+ufC8A/jqlIY/w/1z4fh74v+chj9TdFfCaO/IfoXguhfGcYJ+s927DhhSZ33GNduOU4Q+0WLNVScsGTx2P7RcQJkyw7WikNm9wHLDjvLDjsuXfMedS141FXcoXUsedRV8agr9ajL53Wc86jLp7/KHnXNeNTls9379Jdcx7DjVVnmitOiAPqLYfQP+37po/W7ma6T2E+s8l8tP88F8fNoHEr6M+0LVyzl0/ZWn9div+TgEe6iQ7adP0D70mj3O+1GZxDSV5srnaxg6RdW+5x+L9L9iy7veva74j6Pvs5cYxBl5VdssZLNW7JEyYRRj0G44mKf/Fvxv7Zfccjs/nmr13IxGm9r+n6cjUb3c5z7r3urvfHHLuuMRn8SjY8xRpb9xCr/3Xy3+7rt3iP9Vq/ar/X6vUbv8+f6p96ipV/7EH76DXVGL3ipUwAA","debug_symbols":"tZZBCoMwEEXvknUWzli17VVKKVGjBEKUqIUi3r2jSCvt+m9CJkzekMULf1a1Laf24ULTDep6m5XvKjO6Lkg1L1qV0Xnv2sfxWCXrQglvF4behLUeRhNHdc0TrWyoZXOW643zVrbpov8aC94bi+LTmPFy10JOYeQTjJzByDmMXMDIZxj5giJTAiMTjAxzkGAOEsxBgjlIMAcJ5iDBHCSYgwxzkGEOMsxBhjnIGAcXqZ4mOlN6uweIZgrVIU+Mr97+RIs+dpWtp2jXkPHNF+vbT6wz3n59KYhzTSnJEBn0Bg==","brillig_names":["process_log"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==","debug_symbols":"bY/RCoMwDEX/Jc99SCqO6a/IkKpRCqWVWgdD/PfFIeI2X8K94eSSu0DHzTzU1vdhgrJawIXWJBu8uGVV0ETrnB3q8xpwG5R9+Gk0frNTMjFBeUMF7DsRd7nurWOR2ar+QEJCvbOidXHglOM1X9DBa8Iv/rGKfZpoTeN4f72ffXtqkl4j/5QaY2i5myNv9U7NZFaUK40SK9Fv","brillig_names":["sync_notes"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","view"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"19458536156181958":{"error_kind":"string","string":"Function verify_private_authwit can only be called statically"},"4939791462094160055":{"error_kind":"string","string":"Message not authorized by account"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_auth_witness","decompose_hint","lte_hint","store_in_execution_cache_oracle_wrapper","directive_to_radix","directive_invert","directive_integer_quotient"],"verification_key":"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"}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrSingleKeyAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrSingleKeyAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"SchnorrSingleKeyAccount::entrypoint_parameters"}}],"kind":"struct","path":"SchnorrSingleKeyAccount::entrypoint_abi"}]}},"file_map":{"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\\n\\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\\n/// slices - and thus nested vectors as well - are disallowed).\\n///\\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\\n/// pushing an additional element is also more efficient - the length only needs to be increased\\n/// by one.\\n///\\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\\n/// is a reasonable maximum bound that can be placed on the vector.\\n///\\n/// Example:\\n///\\n/// ```noir\\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\\n/// for i in 0..5 {\\n///     vector.push(i);\\n/// }\\n/// assert(vector.len() == 5);\\n/// assert(vector.max_len() == 10);\\n/// ```\\npub struct BoundedVec<T, let MaxLen: u32> {\\n    storage: [T; MaxLen],\\n    len: u32,\\n}\\n\\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\\n    /// Creates a new, empty vector of length zero.\\n    ///\\n    /// Since this container is backed by an array internally, it still needs an initial value\\n    /// to give each element. To resolve this, each element is zeroed internally. This value\\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\\n    /// assert(empty_vector.len() == 0);\\n    /// ```\\n    ///\\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\\n    /// via a type signature:\\n    ///\\n    /// ```noir\\n    /// fn good() -> BoundedVec<Field, 10> {\\n    ///     // Ok! MaxLen is specified with a type annotation\\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\\n    ///     let v2 = BoundedVec::new();\\n    ///\\n    ///     // Ok! MaxLen is known from the type of `good`\'s return value\\n    ///     v2\\n    /// }\\n    ///\\n    /// fn bad() {\\n    ///     // Error: Type annotation needed\\n    ///     // The compiler can\'t infer `MaxLen` from the following code:\\n    ///     let mut v3 = BoundedVec::new();\\n    ///     v3.push(5);\\n    /// }\\n    /// ```\\n    ///\\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\\n    /// constraint failure at runtime when the vec is pushed to.\\n    pub fn new() -> Self {\\n        let zeroed = crate::mem::zeroed();\\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this\\n    /// will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     let last = v.get(v.len() - 1);\\n    ///     assert(first != last);\\n    /// }\\n    /// ```\\n    pub fn get(self, index: u32) -> T {\\n        assert(index < self.len, \\"Attempted to read past end of BoundedVec\\");\\n        self.get_unchecked(index)\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero, without\\n    /// performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element,\\n    /// it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\\n    ///     // Always ensure the length is larger than the largest\\n    ///     // index passed to get_unchecked\\n    ///     assert(v.len() > 2);\\n    ///     let first = v.get_unchecked(0);\\n    ///     let second = v.get_unchecked(1);\\n    ///     let third = v.get_unchecked(2);\\n    ///     first + second + third\\n    /// }\\n    /// ```\\n    pub fn get_unchecked(self, index: u32) -> T {\\n        self.storage[index]\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     assert(first != 42);\\n    ///     v.set(0, 42);\\n    ///     let new_first = v.get(0);\\n    ///     assert(new_first == 42);\\n    /// }\\n    /// ```\\n    pub fn set(&mut self, index: u32, value: T) {\\n        assert(index < self.len, \\"Attempted to write past end of BoundedVec\\");\\n        self.set_unchecked(index, value)\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn set_unchecked_example() {\\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\\n    ///     vec.extend_from_array([1, 2]);\\n    ///\\n    ///     // Here we\'re safely writing within the valid range of `vec`\\n    ///     // `vec` now has the value [42, 2]\\n    ///     vec.set_unchecked(0, 42);\\n    ///\\n    ///     // We can then safely read this value back out of `vec`.\\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\\n    ///     assert_eq(vec.get(0), 42);\\n    ///\\n    ///     // We\'ve now written past the end of `vec`.\\n    ///     // As this index is still within the maximum potential length of `v`,\\n    ///     // it won\'t cause a constraint failure.\\n    ///     vec.set_unchecked(2, 42);\\n    ///     println(vec);\\n    ///\\n    ///     // This will write past the end of the maximum potential length of `vec`,\\n    ///     // it will then trigger a constraint failure.\\n    ///     vec.set_unchecked(5, 42);\\n    ///     println(vec);\\n    /// }\\n    /// ```\\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\\n        self.storage[index] = value;\\n    }\\n\\n    /// Pushes an element to the end of the vector. This increases the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the new length of the vector will be greater than the max length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    ///\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// // Panics with failed assertion \\"push out of bounds\\"\\n    /// v.push(3);\\n    /// ```\\n    pub fn push(&mut self, elem: T) {\\n        assert(self.len < MaxLen, \\"push out of bounds\\");\\n\\n        self.storage[self.len] = elem;\\n        self.len += 1;\\n    }\\n\\n    /// Returns the current length of this vector\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\\n    /// assert(v.len() == 0);\\n    ///\\n    /// v.push(100);\\n    /// assert(v.len() == 1);\\n    ///\\n    /// v.push(200);\\n    /// v.push(300);\\n    /// v.push(400);\\n    /// assert(v.len() == 4);\\n    ///\\n    /// let _ = v.pop();\\n    /// let _ = v.pop();\\n    /// assert(v.len() == 2);\\n    /// ```\\n    pub fn len(self) -> u32 {\\n        self.len\\n    }\\n\\n    /// Returns the maximum length of this vector. This is always\\n    /// equal to the `MaxLen` parameter this vector was initialized with.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.max_len() == 5);\\n    /// v.push(10);\\n    /// assert(v.max_len() == 5);\\n    /// ```\\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\\n        MaxLen\\n    }\\n\\n    /// Returns the internal array within this vector.\\n    ///\\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\\n    /// the storage held internally by this vector.\\n    ///\\n    /// Note that uninitialized elements may be zeroed out!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\\n    ///\\n    /// v.push(57);\\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn storage(self) -> [T; MaxLen] {\\n        self.storage\\n    }\\n\\n    /// Pushes each element from the given array to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_array([2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\\n        let new_len = self.len + array.len();\\n        assert(new_len <= MaxLen, \\"extend_from_array out of bounds\\");\\n        for i in 0..array.len() {\\n            self.storage[self.len + i] = array[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the given slice to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_slice(&[2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_slice(&mut self, slice: [T]) {\\n        let new_len = self.len + slice.len();\\n        assert(new_len <= MaxLen, \\"extend_from_slice out of bounds\\");\\n        for i in 0..slice.len() {\\n            self.storage[self.len + i] = slice[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the other vector to this vector. The length of\\n    /// the other vector is left unchanged.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// ```noir\\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\\n    ///\\n    /// v2.extend_from_array([1, 2, 3]);\\n    /// v1.extend_from_bounded_vec(v2);\\n    ///\\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\\n        let append_len = vec.len();\\n        let new_len = self.len + append_len;\\n        assert(new_len <= MaxLen, \\"extend_from_bounded_vec out of bounds\\");\\n\\n        if is_unconstrained() {\\n            for i in 0..append_len {\\n                self.storage[self.len + i] = vec.get_unchecked(i);\\n            }\\n        } else {\\n            let mut exceeded_len = false;\\n            for i in 0..Len {\\n                exceeded_len |= i == append_len;\\n                if !exceeded_len {\\n                    self.storage[self.len + i] = vec.get_unchecked(i);\\n                }\\n            }\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Creates a new vector, populating it with values derived from an array input.\\n    /// The maximum length of the vector is determined based on the type signature.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\\n    /// ```\\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\\n        static_assert(Len <= MaxLen, \\"from array out of bounds\\");\\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\\n        vec.extend_from_array(array);\\n        vec\\n    }\\n\\n    /// Pops the element at the end of the vector. This will decrease the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the vector is empty.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// let two = v.pop();\\n    /// let one = v.pop();\\n    ///\\n    /// assert(two == 2);\\n    /// assert(one == 1);\\n    ///\\n    /// // error: cannot pop from an empty vector\\n    /// let _ = v.pop();\\n    /// ```\\n    pub fn pop(&mut self) -> T {\\n        assert(self.len > 0);\\n        self.len -= 1;\\n\\n        let elem = self.storage[self.len];\\n        self.storage[self.len] = crate::mem::zeroed();\\n        elem\\n    }\\n\\n    /// Returns true if the given predicate returns true for any element\\n    /// in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\\n    /// v.extend_from_array([2, 4, 6]);\\n    ///\\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\\n    /// assert(all_even);\\n    /// ```\\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\\n        let mut ret = false;\\n        if is_unconstrained() {\\n            for i in 0..self.len {\\n                ret |= predicate(self.storage[i]);\\n            }\\n        } else {\\n            let mut ret = false;\\n            let mut exceeded_len = false;\\n            for i in 0..MaxLen {\\n                exceeded_len |= i == self.len;\\n                if !exceeded_len {\\n                    ret |= predicate(self.storage[i]);\\n                }\\n            }\\n        }\\n        ret\\n    }\\n\\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n    /// let result = vec.map(|value| value * 2);\\n    ///\\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n    /// assert_eq(result, expected);\\n    /// ```\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\\n        let mut ret = BoundedVec::new();\\n        ret.len = self.len();\\n\\n        if is_unconstrained() {\\n            for i in 0..self.len() {\\n                ret.storage[i] = f(self.get_unchecked(i));\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i < self.len() {\\n                    ret.storage[i] = f(self.get_unchecked(i));\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function will zero out any elements at or past index `len` of `array`.\\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    /// ```\\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        let zeroed = crate::mem::zeroed();\\n\\n        if is_unconstrained() {\\n            for i in len..MaxLen {\\n                array[i] = zeroed;\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i >= len {\\n                    array[i] = zeroed;\\n                }\\n            }\\n        }\\n\\n        BoundedVec { storage: array, len }\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function is unsafe because it expects all elements past the `len` index\\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\\n    /// for a safe version of this function which does zero out any indices past the\\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\\n    /// to give incorrect results since it will check even elements past `len`.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    ///\\n    /// // invalid use!\\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n    ///\\n    /// // both vecs have length 3 so we\'d expect them to be equal, but this\\n    /// // fails because elements past the length are still checked in eq\\n    /// assert_eq(vec1, vec2); // fails\\n    /// ```\\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        BoundedVec { storage: array, len }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\\n        // TODO: https://github.com/noir-lang/noir/issues/4837\\n        //\\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\\n        if self.len == other.len {\\n            self.storage == other.storage\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\\n        BoundedVec::from_array(array)\\n    }\\n}\\n\\nmod bounded_vec_tests {\\n\\n    mod get {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test(should_fail_with = \\"Attempted to read past end of BoundedVec\\")]\\n        fn panics_when_reading_elements_past_end_of_vec() {\\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\\n\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod set {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn set_updates_values_properly() {\\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\\n\\n            vec.set(0, 42);\\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\\n\\n            vec.set(1, 43);\\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\\n\\n            vec.set(2, 44);\\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\\n\\n            vec.set(1, 10);\\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\\n\\n            vec.set(0, 0);\\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\\n        }\\n\\n        #[test(should_fail_with = \\"Attempted to write past end of BoundedVec\\")]\\n        fn panics_when_writing_elements_past_end_of_vec() {\\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\\n            vec.set(0, 42);\\n\\n            // Need to use println to avoid DIE removing the write operation.\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod map {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn applies_function_correctly() {\\n            // docs:start:bounded-vec-map-example\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| value * 2);\\n            // docs:end:bounded-vec-map-example\\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn applies_function_that_changes_return_type() {\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| (value * 2) as Field);\\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn does_not_apply_function_past_len() {\\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\\n            let expected = BoundedVec::from_array([5, 1]);\\n\\n            assert_eq(result, expected);\\n            assert_eq(result.get_unchecked(2), 0);\\n        }\\n    }\\n\\n    mod from_array {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty() {\\n            let empty_array: [Field; 0] = [];\\n            let bounded_vec = BoundedVec::from_array([]);\\n\\n            assert_eq(bounded_vec.max_len(), 0);\\n            assert_eq(bounded_vec.len(), 0);\\n            assert_eq(bounded_vec.storage(), empty_array);\\n        }\\n\\n        #[test]\\n        fn equal_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 3);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage(), array);\\n        }\\n\\n        #[test]\\n        fn max_len_greater_then_array_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n            assert_eq(bounded_vec.get(2), 3);\\n        }\\n\\n        #[test(should_fail_with = \\"from array out of bounds\\")]\\n        fn max_len_lower_then_array_len() {\\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\\n        }\\n    }\\n\\n    mod trait_from {\\n        use crate::collections::bounded_vec::BoundedVec;\\n        use crate::convert::From;\\n\\n        #[test]\\n        fn simple() {\\n            let array = [1, 2];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 2);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n        }\\n    }\\n\\n    mod trait_eq {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty_equality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n\\n            assert_eq(bounded_vec1, bounded_vec2);\\n        }\\n\\n        #[test]\\n        fn inequality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n            bounded_vec1.push(1);\\n            bounded_vec2.push(2);\\n\\n            assert(bounded_vec1 != bounded_vec2);\\n        }\\n    }\\n\\n    mod from_parts {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn from_parts() {\\n            // docs:start:from-parts\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // Any elements past the given length are zeroed out, so these\\n            // two BoundedVecs will be completely equal\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\\n            assert_eq(vec1, vec2);\\n            // docs:end:from-parts\\n        }\\n\\n        #[test]\\n        fn from_parts_unchecked() {\\n            // docs:start:from-parts-unchecked\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // invalid use!\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n\\n            // both vecs have length 3 so we\'d expect them to be equal, but this\\n            // fails because elements past the length are still checked in eq\\n            assert(vec1 != vec2);\\n            // docs:end:from-parts-unchecked\\n        }\\n    }\\n}\\n"},"17":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\\nuse crate::ops::arith::{Add, Neg, Sub};\\n\\n/// A point on the embedded elliptic curve\\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\\npub struct EmbeddedCurvePoint {\\n    pub x: Field,\\n    pub y: Field,\\n    pub is_infinite: bool,\\n}\\n\\nimpl EmbeddedCurvePoint {\\n    /// Elliptic curve point doubling operation\\n    /// returns the doubled point of a point P, i.e P+P\\n    pub fn double(self) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, self)\\n    }\\n\\n    /// Returns the null element of the curve; \'the point at infinity\'\\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\\n    }\\n}\\n\\nimpl Add for EmbeddedCurvePoint {\\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, other)\\n    }\\n}\\n\\nimpl Sub for EmbeddedCurvePoint {\\n    /// Points subtraction operation, using addition and negation\\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        self + other.neg()\\n    }\\n}\\n\\nimpl Neg for EmbeddedCurvePoint {\\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\\n    /// If the point is at infinity, then the result is also at infinity.\\n    fn neg(self) -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurvePoint {\\n    /// Checks whether two points are equal\\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\\n        (self.is_infinite & b.is_infinite)\\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\\n    }\\n}\\n\\n/// Scalar for the embedded curve represented as low and high limbs\\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\\npub struct EmbeddedCurveScalar {\\n    pub lo: Field,\\n    pub hi: Field,\\n}\\n\\nimpl EmbeddedCurveScalar {\\n    pub fn new(lo: Field, hi: Field) -> Self {\\n        EmbeddedCurveScalar { lo, hi }\\n    }\\n\\n    #[field(bn254)]\\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\\n        let (a, b) = crate::field::bn254::decompose(scalar);\\n        EmbeddedCurveScalar { lo: a, hi: b }\\n    }\\n\\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\\n    #[field(bn254)]\\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\\n        let mut v = 1;\\n        let mut lo = 0 as Field;\\n        let mut hi = 0 as Field;\\n        for i in 0..16 {\\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\\n        sig_s\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurveScalar {\\n    fn eq(self, other: Self) -> bool {\\n        (other.hi == self.hi) & (other.lo == self.lo)\\n    }\\n}\\n\\n// Computes a multi scalar multiplication over the embedded curve.\\n// For bn254, We have Grumpkin and Baby JubJub.\\n// For bls12-381, we have JubJub and Bandersnatch.\\n//\\n// The embedded curve being used is decided by the\\n// underlying proof system.\\n// docs:start:multi_scalar_mul\\npub fn multi_scalar_mul<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> EmbeddedCurvePoint\\n// docs:end:multi_scalar_mul\\n{\\n    let point_array = multi_scalar_mul_array_return(points, scalars);\\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\\n}\\n\\n#[foreign(multi_scalar_mul)]\\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> [Field; 3] {}\\n\\n// docs:start:fixed_base_scalar_mul\\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\\n// docs:end:fixed_base_scalar_mul\\n{\\n    let g1 = EmbeddedCurvePoint {\\n        x: 1,\\n        y: 17631683881184975370165255887551781615748388533673675138860,\\n        is_infinite: false,\\n    };\\n    multi_scalar_mul([g1], [scalar])\\n}\\n\\n/// This function only assumes that the points are on the curve\\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\\n// docs:start:embedded_curve_add\\npub fn embedded_curve_add(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    // docs:end:embedded_curve_add\\n    let x_coordinates_match = point1.x == point2.x;\\n    let y_coordinates_match = point1.y == point2.y;\\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\\n    let point1_1 = EmbeddedCurvePoint {\\n        x: point1.x + (x_coordinates_match as Field),\\n        y: point1.y,\\n        is_infinite: x_coordinates_match,\\n    };\\n    // point1_1 is guaranteed to have a different abscissa than point2\\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\\n    result.is_infinite = x_coordinates_match;\\n\\n    // dbl if x_match, y_match\\n    let double = embedded_curve_add_unsafe(point1, point1);\\n    result = if double_predicate { double } else { result };\\n\\n    // infinity if x_match, !y_match\\n    if point1.is_infinite {\\n        result = point2;\\n    }\\n    if point2.is_infinite {\\n        result = point1;\\n    }\\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\\n    result\\n}\\n\\n#[foreign(embedded_curve_add)]\\nfn embedded_curve_add_array_return(\\n    _point1: EmbeddedCurvePoint,\\n    _point2: EmbeddedCurvePoint,\\n) -> [Field; 3] {}\\n\\n/// This function assumes that:\\n/// The points are on the curve, and\\n/// The points don\'t share an x-coordinate, and\\n/// Neither point is the infinity point.\\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\\npub fn embedded_curve_add_not_nul(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    assert(point1.x != point2.x);\\n    assert(!point1.is_infinite);\\n    assert(!point2.is_infinite);\\n    embedded_curve_add_unsafe(point1, point2)\\n}\\n\\n/// Unsafe ec addition\\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\\n/// If they have the same value but are different variables, the result will be incorrect because in this case\\n/// it assumes (but does not check) that the points\' x-coordinates are not equal.\\n/// It also assumes neither point is the infinity point.\\npub fn embedded_curve_add_unsafe(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    let point_array = embedded_curve_add_array_return(point1, point2);\\n    let x = point_array[0];\\n    let y = point_array[1];\\n\\n    EmbeddedCurvePoint { x, y, is_infinite: false }\\n}\\n"},"18":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    /// Safety: borrow is enforced to be boolean due to its type.\\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n    unsafe {\\n        /*@safety: borrow is enforced to be boolean due to its type.\\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n        */\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        /// Safety: decomposition is properly checked below\\n        unsafe {\\n            /*@safety: decomposition is properly checked below*/\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            /// Safety: already unconstrained\\n            unsafe { field_less_than(b, a) },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        /// Safety: unsafe in unconstrained\\n        unsafe {\\n            //@safety: unsafe in unconstrained\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        /// Safety: Take a hint of the comparison and verify it\\n        unsafe {\\n            //@safety: Take a hint of the comparison and verify it\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"19":{"path":"std/field/mod.nr","source":"pub mod bn254;\\nuse crate::{runtime::is_unconstrained, static_assert};\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        static_assert(\\n            BIT_SIZE < modulus_num_bits() as u32,\\n            \\"BIT_SIZE must be less than modulus_num_bits\\",\\n        );\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_le_bits\\n        let bits = self._to_le_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(p[N - 1 - i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_be_bits\\n        let bits = self._to_be_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the decomposition does not overflow the modulus\\n            let p = modulus_be_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[i] != p[i]) {\\n                        assert(p[i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            static_assert(1 < radix, \\"radix must be greater than 1\\");\\n            static_assert(radix <= 256, \\"radix must be less than or equal to 256\\");\\n            static_assert(radix & (radix - 1) == 0, \\"radix must be a power of 2\\");\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        /// Safety: unconstrained context\\n        unsafe {\\n            //@safety : unconstrained context\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use crate::{panic::panic, runtime};\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test(should_fail_with = \\"radix must be greater than 1\\")]\\n    fn test_to_le_radix_1() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(1);\\n        } else {\\n            panic(f\\"radix must be greater than 1\\");\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\\n    // #[test]\\n    // fn test_to_le_radix_brillig_1() {\\n    //     // this test should only fail in constrained mode\\n    //     if runtime::is_unconstrained() {\\n    //         let field = 1;\\n    //         let out: [u8; 8] = field.to_le_radix(1);\\n    //         crate::println(out);\\n    //         let expected = [0; 8];\\n    //         assert(out == expected, \\"unexpected result\\");\\n    //     }\\n    // }\\n\\n    #[test(should_fail_with = \\"radix must be a power of 2\\")]\\n    fn test_to_le_radix_3() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(3);\\n        } else {\\n            panic(f\\"radix must be a power of 2\\");\\n        }\\n    }\\n\\n    #[test]\\n    fn test_to_le_radix_brillig_3() {\\n        // this test should only fail in constrained mode\\n        if runtime::is_unconstrained() {\\n            let field = 1;\\n            let out: [u8; 8] = field.to_le_radix(3);\\n            let mut expected = [0; 8];\\n            expected[0] = 1;\\n            assert(out == expected, \\"unexpected result\\");\\n        }\\n    }\\n\\n    #[test(should_fail_with = \\"radix must be less than or equal to 256\\")]\\n    fn test_to_le_radix_512() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(512);\\n        } else {\\n            panic(f\\"radix must be less than or equal to 256\\")\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\\n    // #[test]\\n    // fn test_to_le_radix_brillig_512() {\\n    //     // this test should only fail in constrained mode\\n    //     if runtime::is_unconstrained() {\\n    //         let field = 1;\\n    //         let out: [u8; 8] = field.to_le_radix(512);\\n    //         let mut expected = [0; 8];\\n    //         expected[0] = 1;\\n    //         assert(out == expected, \\"unexpected result\\");\\n    //     }\\n    // }\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n"},"21":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\\npub mod poseidon2;\\npub mod keccak;\\npub mod sha256;\\npub mod sha512;\\n\\nuse crate::default::Default;\\nuse crate::embedded_curve_ops::{\\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\\n};\\nuse crate::meta::derive_via;\\nuse crate::uint128::U128;\\n\\n// Kept for backwards compatibility\\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\\n\\n#[foreign(blake2s)]\\n// docs:start:blake2s\\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:blake2s\\n{}\\n\\n#[foreign(blake3)]\\n// docs:start:blake3\\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:blake3\\n{}\\n\\n// docs:start:pedersen_commitment\\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\\n    // docs:end:pedersen_commitment\\n    pedersen_commitment_with_separator(input, 0)\\n}\\n\\n#[inline_always]\\npub fn pedersen_commitment_with_separator<let N: u32>(\\n    input: [Field; N],\\n    separator: u32,\\n) -> EmbeddedCurvePoint {\\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\\n    for i in 0..N {\\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\\n        points[i] = from_field_unsafe(input[i]);\\n    }\\n    let generators = derive_generators(\\"DEFAULT_DOMAIN_SEPARATOR\\".as_bytes(), separator);\\n    multi_scalar_mul(generators, points)\\n}\\n\\n// docs:start:pedersen_hash\\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\\n// docs:end:pedersen_hash\\n{\\n    pedersen_hash_with_separator(input, 0)\\n}\\n\\n#[no_predicates]\\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\\n    let domain_generators: [EmbeddedCurvePoint; N] =\\n        derive_generators(\\"DEFAULT_DOMAIN_SEPARATOR\\".as_bytes(), separator);\\n\\n    for i in 0..N {\\n        scalars[i] = from_field_unsafe(input[i]);\\n        generators[i] = domain_generators[i];\\n    }\\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\\n\\n    let length_generator: [EmbeddedCurvePoint; 1] =\\n        derive_generators(\\"pedersen_hash_length\\".as_bytes(), 0);\\n    generators[N] = length_generator[0];\\n    multi_scalar_mul_array_return(generators, scalars)[0]\\n}\\n\\n#[field(bn254)]\\n#[inline_always]\\npub fn derive_generators<let N: u32, let M: u32>(\\n    domain_separator_bytes: [u8; M],\\n    starting_index: u32,\\n) -> [EmbeddedCurvePoint; N] {\\n    crate::assert_constant(domain_separator_bytes);\\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\\n    __derive_generators(domain_separator_bytes, starting_index)\\n}\\n\\n#[builtin(derive_pedersen_generators)]\\n#[field(bn254)]\\nfn __derive_generators<let N: u32, let M: u32>(\\n    domain_separator_bytes: [u8; M],\\n    starting_index: u32,\\n) -> [EmbeddedCurvePoint; N] {}\\n\\n#[field(bn254)]\\n// Same as from_field but:\\n// does not assert the limbs are 128 bits\\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\\n    /// Safety: xlo and xhi decomposition is checked below\\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\\n    // Check that the decomposition is correct\\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\\n}\\n\\npub fn hash_to_field(inputs: [Field]) -> Field {\\n    let mut sum = 0;\\n\\n    for input in inputs {\\n        let input_bytes: [u8; 32] = input.to_le_bytes();\\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\\n    }\\n\\n    sum\\n}\\n\\n// docs:start:keccak256\\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\\n// docs:end:keccak256\\n{\\n    crate::hash::keccak::keccak256(input, message_size)\\n}\\n\\n#[foreign(poseidon2_permutation)]\\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\\n\\n// Generic hashing support.\\n// Partially ported and impacted by rust.\\n\\n// Hash trait shall be implemented per type.\\n#[derive_via(derive_hash)]\\npub trait Hash {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher;\\n}\\n\\n// docs:start:derive_hash\\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\\n    let name = quote { Hash };\\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\\n    crate::meta::make_trait_impl(\\n        s,\\n        name,\\n        signature,\\n        for_each_field,\\n        quote {},\\n        |fields| fields,\\n    )\\n}\\n// docs:end:derive_hash\\n\\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\\n// TODO: consider making the types generic here ([u8], [Field], etc.)\\npub trait Hasher {\\n    fn finish(self) -> Field;\\n\\n    fn write(&mut self, input: Field);\\n}\\n\\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\\npub trait BuildHasher<H>\\nwhere\\n    H: Hasher,\\n{\\n    fn build_hasher(self) -> H;\\n}\\n\\npub struct BuildHasherDefault<H>;\\n\\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\\nwhere\\n    H: Hasher + Default,\\n{\\n    fn build_hasher(_self: Self) -> H {\\n        H::default()\\n    }\\n}\\n\\nimpl<H> Default for BuildHasherDefault<H>\\nwhere\\n    H: Hasher + Default,\\n{\\n    fn default() -> Self {\\n        BuildHasherDefault {}\\n    }\\n}\\n\\nimpl Hash for Field {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self);\\n    }\\n}\\n\\nimpl Hash for u1 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u8 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u16 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u32 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u64 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i8 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i16 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i32 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i64 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for bool {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for () {\\n    fn hash<H>(_self: Self, _state: &mut H)\\n    where\\n        H: Hasher,\\n    {}\\n}\\n\\nimpl Hash for U128 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self.lo as Field);\\n        H::write(state, self.hi as Field);\\n    }\\n}\\n\\nimpl<T, let N: u32> Hash for [T; N]\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        for elem in self {\\n            elem.hash(state);\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for [T]\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.len().hash(state);\\n        for elem in self {\\n            elem.hash(state);\\n        }\\n    }\\n}\\n\\nimpl<A, B> Hash for (A, B)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C> Hash for (A, B, C)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C, D> Hash for (A, B, C, D)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n    D: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n        self.3.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n    D: Hash,\\n    E: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n        self.3.hash(state);\\n        self.4.hash(state);\\n    }\\n}\\n\\n// Some test vectors for Pedersen hash and Pedersen Commitment.\\n// They have been generated using the same functions so the tests are for now useless\\n// but they will be useful when we switch to Noir implementation.\\n#[test]\\nfn assert_pedersen() {\\n    assert_eq(\\n        pedersen_hash_with_separator([1], 1),\\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1], 1),\\n        EmbeddedCurvePoint {\\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\\n            is_infinite: false,\\n        },\\n    );\\n\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2], 2),\\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2], 2),\\n        EmbeddedCurvePoint {\\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3], 3),\\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3], 3),\\n        EmbeddedCurvePoint {\\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\\n        EmbeddedCurvePoint {\\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\\n        EmbeddedCurvePoint {\\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\\n        EmbeddedCurvePoint {\\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\\n        EmbeddedCurvePoint {\\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\\n        EmbeddedCurvePoint {\\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\\n        EmbeddedCurvePoint {\\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\\n        EmbeddedCurvePoint {\\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\\n            is_infinite: false,\\n        },\\n    );\\n}\\n"},"26":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"52":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"62":{"path":"/build-volume/noir-projects/noir-contracts/contracts/schnorr_single_key_account_contract/src/auth_oracle.nr","source":"use dep::authwit::auth_witness;\\nuse dep::aztec::{\\n    protocol_types::{address::PartialAddress, public_keys::{PUBLIC_KEYS_LENGTH, PublicKeys}},\\n    utils::array,\\n};\\n\\npub struct AuthWitness {\\n    keys: PublicKeys,\\n    signature: [u8; 64],\\n    partial_address: PartialAddress,\\n}\\n\\nimpl AuthWitness {\\n    fn deserialize(values: [Field; 77]) -> Self {\\n        let mut signature = [0; 64];\\n        for i in 0..64 {\\n            signature[i] = values[i + PUBLIC_KEYS_LENGTH] as u8;\\n        }\\n        Self {\\n            keys: PublicKeys::deserialize(array::subarray(values, 0)),\\n            signature,\\n            partial_address: PartialAddress::from_field(values[76]),\\n        }\\n    }\\n}\\n\\npub unconstrained fn get_auth_witness(message_hash: Field) -> AuthWitness {\\n    let witness: [Field; 77] = auth_witness::get_auth_witness(message_hash);\\n    AuthWitness::deserialize(witness)\\n}\\n"},"63":{"path":"/build-volume/noir-projects/noir-contracts/contracts/schnorr_single_key_account_contract/src/main.nr","source":"mod util;\\nmod auth_oracle;\\n\\nuse dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract SchnorrSingleKeyAccount {\\n    use dep::aztec::prelude::PrivateContext;\\n\\n    use dep::authwit::{account::AccountActions, entrypoint::{app::AppPayload, fee::FeePayload}};\\n\\n    use crate::{auth_oracle::get_auth_witness, util::recover_address};\\n\\n    use dep::aztec::macros::functions::{private, view};\\n\\n    // Note: If you globally change the entrypoint signature don\'t forget to update account_entrypoint.ts\\n    #[private]\\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\\n        let actions = AccountActions::init(&mut context, is_valid_impl);\\n        actions.entrypoint(app_payload, fee_payload, cancellable);\\n    }\\n\\n    #[private]\\n    #[view]\\n    fn verify_private_authwit(inner_hash: Field) -> Field {\\n        let actions = AccountActions::init(&mut context, is_valid_impl);\\n        actions.verify_private_authwit(inner_hash)\\n    }\\n\\n    #[contract_library_method]\\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\\n        /// Safety: The witness is only used as a \\"magical value\\" that makes the signature verification\\n        /// in `recover_address` and the address check below pass. Hence it\'s safe.\\n        let witness = unsafe { get_auth_witness(outer_hash) };\\n        recover_address(outer_hash, witness).eq(context.this_address())\\n    }\\n}\\n"},"64":{"path":"/build-volume/noir-projects/noir-contracts/contracts/schnorr_single_key_account_contract/src/util.nr","source":"use crate::auth_oracle::AuthWitness;\\nuse dep::aztec::prelude::AztecAddress;\\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\\n\\npub fn recover_address(message_hash: Field, witness: AuthWitness) -> AztecAddress {\\n    let message_bytes: [u8; 32] = message_hash.to_be_bytes();\\n    let public_key = EmbeddedCurvePoint {\\n        x: witness.keys.ivpk_m.inner.x,\\n        y: witness.keys.ivpk_m.inner.y,\\n        is_infinite: false,\\n    };\\n\\n    // In a single key account contract we re-used ivpk_m as signing key\\n    schnorr::assert_valid_signature(public_key, witness.signature, message_bytes);\\n\\n    AztecAddress::compute(witness.keys, witness.partial_address)\\n}\\n"},"65":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\\n    context::PrivateContext,\\n    hash::poseidon2_hash_with_separator,\\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\\n};\\n\\nuse crate::auth::{compute_authwit_message_hash, IS_VALID_SELECTOR};\\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\\n\\npub struct AccountActions<Context> {\\n    context: Context,\\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\\n}\\n\\nimpl<Context> AccountActions<Context> {\\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\\n        AccountActions { context, is_valid_impl }\\n    }\\n}\\n\\n/**\\n * An implementation of the Account Action struct for the private context.\\n *\\n * Implements logic to verify authorization and execute payloads.\\n */\\nimpl AccountActions<&mut PrivateContext> {\\n\\n    /**\\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\\n     *\\n     * Executes the `fee_payload` and `app_payload` in sequence.\\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\\n     *\\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\\n     */\\n    // docs:start:entrypoint\\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\\n        let valid_fn = self.is_valid_impl;\\n\\n        let combined_payload_hash = poseidon2_hash_with_separator(\\n            [app_payload.hash(), fee_payload.hash()],\\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\\n        );\\n        assert(valid_fn(self.context, combined_payload_hash));\\n\\n        fee_payload.execute_calls(self.context);\\n        self.context.end_setup();\\n        app_payload.execute_calls(self.context);\\n        if cancellable {\\n            let tx_nullifier =\\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\\n            self.context.push_nullifier(tx_nullifier);\\n        }\\n    }\\n    // docs:end:entrypoint\\n\\n    /**\\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\\n     *\\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\\n     *\\n     * Will revert if the message is not authorized.\\n     *\\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\\n     */\\n    // docs:start:verify_private_authwit\\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\\n        // The `inner_hash` is \\"siloed\\" with the `msg_sender` to ensure that only it can\\n        // consume the message.\\n        // This ensures that contracts cannot consume messages that are not intended for them.\\n        let message_hash = compute_authwit_message_hash(\\n            self.context.msg_sender(),\\n            self.context.chain_id(),\\n            self.context.version(),\\n            inner_hash,\\n        );\\n        let valid_fn = self.is_valid_impl;\\n        assert(valid_fn(self.context, message_hash) == true, \\"Message not authorized by account\\");\\n        IS_VALID_SELECTOR\\n    }\\n    // docs:end:verify_private_authwit\\n}\\n"},"66":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\\nuse dep::aztec::protocol_types::{\\n    abis::function_selector::FunctionSelector,\\n    address::AztecAddress,\\n    constants::{\\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\\n    },\\n    hash::poseidon2_hash_with_separator,\\n};\\n\\n/**\\n * Authenticaion witness helper library\\n *\\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\\n * (e.g. protocols or other users) to execute an action on their behalf.\\n *\\n * This library provides helper functions to manage such witnesses.\\n * The authentication witness, is some \\"witness\\" (data) that authenticates a `message_hash`.\\n * The simplest example of an authentication witness, is a signature. The signature is the \\"evidence\\",\\n * that the signer has seen the message, agrees with it, and has allowed it.\\n * It does not need to be a signature. It could be any kind of \\"proof\\" that the message is allowed.\\n * Another proof could be knowing some kind of secret, or having some kind of \\"token\\" that allows the message.\\n *\\n * The `message_hash` is a hash of the following structure:\\n * hash(consumer, chain_id, version, inner_hash)\\n * - consumer: the address of the contract that is \\"consuming\\" the message,\\n * - chain_id: the chain id of the chain that the message is being consumed on,\\n * - version: the version of the chain that the message is being consumed on,\\n * - inner_hash: the hash of the \\"inner\\" message that is being consumed, this is the \\"actual\\" message or action.\\n *\\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\\n * a hash of the \\"action\\" to approve, along with who made the call. As part of this library, we provide a few\\n * helper functions to deal with such messages.\\n *\\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\\n * This can be used to let some contract \\"allow\\" another contract to act on its behalf, as long as it can\\n * show that it is acting on behalf of the contract.\\n *\\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\\n * derived as:\\n * inner_hash = hash(caller, \\"transfer\\", hash(to, amount))\\n *\\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\\n * the arguments for the transfer.\\n *\\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\\n * allowed to transfer the tokens.\\n *\\n *\\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\\n * is executed on the user\'s device, so we can use `oracles` to \\"ask\\" the user (not contract) for information. In public\\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \\"registry\\"\\n * to store the messages that we have approved.\\n *\\n * A simple example would be a \\"token\\" that is being \\"pulled\\" from one account into another. We will first outline\\n * how this would look in private, and then in public later.\\n *\\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\\n * convince the `Token` contract that it is allowed to do so.\\n *\\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\\n * execute that call.\\n *\\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\\n * funds from `Alice`.\\n *\\n * To ensure that the same \\"approval\\" cannot be used multiple times, we also compute a `nullifier` for the\\n * authentication witness, and emit it from the `Token` contract (consumer).\\n *\\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\\n *\\n *\\n *  Person          Contract              Contract               Contract\\n *  Alice          Alice Account          Token                   DeFi\\n *   |                  |                  |                      |\\n *   | Defi.deposit(Token, 1000)           |                      |\\n *   |-----------------\x3e|                  |                      |\\n *   |                  | deposit(Token, 1000)                    |\\n *   |                  |----------------------------------------\x3e|\\n *   |                  |                  |                      |\\n *   |                  |                  | transfer(Alice, Defi, 1000)\\n *   |                  |                  |<---------------------|\\n *   |                  |                  |                      |\\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\\n *   |                  |<-----------------|                      |\\n *   |                  |                  |                      |\\n *   | Please give me AuthWit for DeFi     |                      |\\n *   | calling transfer(Alice, Defi, 1000) |                      |\\n *   |<-----------------|                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\\n *   |-----------------\x3e|                  |                      |\\n *   |                  | AuthWit validity |                      |\\n *   |                  |-----------------\x3e|                      |\\n *   |                  |                  |                      |\\n *   |                  |       throw if invalid AuthWit          |\\n *   |                  |                  |                      |\\n *   |                  |       emit AuthWit nullifier            |\\n *   |                  |                  |                      |\\n *   |                  |       transfer(Alice, Defi, 1000)       |\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  | success              |\\n *   |                  |                  |---------------------\x3e|\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  |           deposit(Token, 1000)\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *\\n *\\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\\n * the messages that we have approved.\\n *\\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\\n *\\n * The `Token` contract can then try to \\"spend\\" the approval by calling `consume` on the registry. If the message\\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\\n * registry, see `main.nr` in `auth_registry_contract`.\\n *\\n * Person          Contract              Contract            Contract               Contract\\n * Alice          Alice Account          Registry             Token                   DeFi\\n *   |                  |                    |                   |                      |\\n *   | Registry.set_authorized(..., true)    |                   |                      |\\n *   |-----------------\x3e|                    |                   |                      |\\n *   |                  | set_authorized(..., true)              |                      |\\n *   |                  |-------------------\x3e|                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |         set authorized to true         |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   | Defi.deposit(Token, 1000)             |                   |                      |\\n *   |-----------------\x3e|                    |                   |                      |\\n *   |                  | deposit(Token, 1000)                   |                      |\\n *   |                  |--------------------------------------------------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\\n *   |                  |                    |                   |<---------------------|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\\n *   |                  |                    |<------------------|                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |          throw if invalid AuthWit      |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |           set authorized to false      |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    | AuthWit validity  |                      |\\n *   |                  |                    |------------------\x3e|                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\\n *   |                  |                    |                   |<--------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   | success              |\\n *   |                  |                    |                   |---------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |     deposit(Token, 1000)\\n *   |                  |                    |                   |                      |\\n *\\n *\\n * --- FAQ ---\\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\\"IS_VALID()\\")` instead of just returning a boolean?\\n * A:   We want to make sure that we don\'t accidentally return `true` if there is a collision in the function selector.\\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\\n *      a success flag.\\n *\\n * Q:   Why are we using static calls?\\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\\n *\\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\\n *\\n * Q:   Why is the chain id and the version part of the message hash?\\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\\n *      chain to avoid a case where the same message could be used across multiple chains.\\n */\\n\\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\\"IS_VALID()\\")\\n\\n/**\\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n */\\n// docs:start:assert_current_call_valid_authwit\\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\\n    let inner_hash = compute_inner_authwit_hash([\\n        context.msg_sender().to_field(),\\n        context.selector().to_field(),\\n        context.args_hash,\\n    ]);\\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\\n}\\n// docs:end:assert_current_call_valid_authwit\\n\\n/**\\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\\n *\\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n * @param inner_hash The hash of the message to authorize\\n */\\npub fn assert_inner_hash_valid_authwit(\\n    context: &mut PrivateContext,\\n    on_behalf_of: AztecAddress,\\n    inner_hash: Field,\\n) {\\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\\n    let result: Field = context\\n        .static_call_private_function(\\n            on_behalf_of,\\n            comptime { FunctionSelector::from_signature(\\"verify_private_authwit(Field)\\") },\\n            [inner_hash],\\n        )\\n        .get_preimage();\\n    assert(result == IS_VALID_SELECTOR, \\"Message not authorized by account\\");\\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\\n    context.push_nullifier(nullifier);\\n}\\n\\n/**\\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n */\\n// docs:start:assert_current_call_valid_authwit_public\\npub unconstrained fn assert_current_call_valid_authwit_public(\\n    context: &mut PublicContext,\\n    on_behalf_of: AztecAddress,\\n) {\\n    let inner_hash = compute_inner_authwit_hash([\\n        (*context).msg_sender().to_field(),\\n        (*context).selector().to_field(),\\n        (*context).get_args_hash(),\\n    ]);\\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\\n}\\n// docs:end:assert_current_call_valid_authwit_public\\n\\n/**\\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\\n */\\npub unconstrained fn assert_inner_hash_valid_authwit_public(\\n    context: &mut PublicContext,\\n    on_behalf_of: AztecAddress,\\n    inner_hash: Field,\\n) {\\n    let results: [Field] = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"consume((Field),Field)\\") },\\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(results.len() == 1, \\"Invalid response from registry\\");\\n    assert(results[0] == IS_VALID_SELECTOR, \\"Message not authorized by account\\");\\n}\\n\\n/**\\n * Compute the `message_hash` from a function call to be used by an authentication witness\\n *\\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\\n * B to transfer T on its behalf.\\n *\\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\\n * @param chain_id The chain id of the chain that the message is being consumed on\\n * @param version The version of the chain that the message is being consumed on\\n * @param selector The function selector of the function that is being called\\n * @param args The arguments of the function that is being called\\n */\\n// docs:start:compute_authwit_message_hash_from_call\\npub fn compute_authwit_message_hash_from_call<let N: u32>(\\n    caller: AztecAddress,\\n    consumer: AztecAddress,\\n    chain_id: Field,\\n    version: Field,\\n    selector: FunctionSelector,\\n    args: [Field; N],\\n) -> Field {\\n    let args_hash = hash_args_array(args);\\n    let inner_hash =\\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\\n}\\n// docs:end:compute_authwit_message_hash_from_call\\n\\n/**\\n * Computes the `inner_hash` of the authentication witness\\n *\\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\\n * that is not necessarily a call, but just some \\"bytes\\" or text.\\n *\\n * @param args The arguments to hash\\n */\\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\\n}\\n\\n/**\\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\\n *\\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\\n *\\n * @param on_behalf_of The address that has authorized the `inner_hash`\\n * @param inner_hash The hash of the message to authorize\\n */\\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [on_behalf_of.to_field(), inner_hash],\\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\\n    )\\n}\\n\\n/**\\n * Computes the `message_hash` for the authentication witness\\n *\\n * @param consumer The address of the contract that is consuming the message\\n * @param chain_id The chain id of the chain that the message is being consumed on\\n * @param version The version of the chain that the message is being consumed on\\n * @param inner_hash The hash of the \\"inner\\" message that is being consumed\\n */\\npub fn compute_authwit_message_hash(\\n    consumer: AztecAddress,\\n    chain_id: Field,\\n    version: Field,\\n    inner_hash: Field,\\n) -> Field {\\n    poseidon2_hash_with_separator(\\n        [consumer.to_field(), chain_id, version, inner_hash],\\n        GENERATOR_INDEX__AUTHWIT_OUTER,\\n    )\\n}\\n\\n/**\\n * Helper function to set the authorization status of a message hash\\n *\\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\\n *\\n * @param message_hash The hash of the message to authorize\\n * @param authorize True if the message should be authorized, false if it should be revoked\\n */\\npub unconstrained fn set_authorized(\\n    context: &mut PublicContext,\\n    message_hash: Field,\\n    authorize: bool,\\n) {\\n    let res = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"set_authorized(Field,bool)\\") },\\n        [message_hash, authorize as Field].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(res.len() == 0);\\n}\\n\\n/**\\n * Helper function to reject all authwits\\n *\\n * Wraps a public call to the authentication registry to set the `reject_all` flag\\n *\\n * @param reject True if all authwits should be rejected, false otherwise\\n */\\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\\n    let res = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"set_reject_all(bool)\\") },\\n        [context.this_address().to_field(), reject as Field].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(res.len() == 0);\\n}\\n"},"67":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\\n\\n/**\\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\\n *\\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\\n * @return The `auth_witness` for the given `message_hash` as Field array.\\n */\\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\\n    get_auth_witness_oracle(message_hash)\\n}\\n"},"69":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::{\\n    prelude::PrivateContext,\\n    protocol_types::{\\n        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,\\n        hash::poseidon2_hash_with_separator,\\n        traits::{Hash, Serialize},\\n    },\\n};\\nuse std::meta::derive;\\n\\nuse crate::entrypoint::function_call::FunctionCall;\\n\\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\\n\\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\\n\\n// Note: If you change the following struct you have to update default_entrypoint.ts\\n// docs:start:app-payload-struct\\n#[derive(Serialize)]\\npub struct AppPayload {\\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\\n    nonce: Field,\\n}\\n// docs:end:app-payload-struct\\n\\nimpl Hash for AppPayload {\\n    fn hash(self) -> Field {\\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\\n    }\\n}\\n\\nimpl AppPayload {\\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\\n\\n        for i in 0..ACCOUNT_MAX_CALLS {\\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\\n        }\\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\\n\\n        bytes.storage()\\n    }\\n\\n    // Executes all private and public calls\\n    // docs:start:entrypoint-execute-calls\\n    fn execute_calls(self, context: &mut PrivateContext) {\\n        for call in self.function_calls {\\n            if !call.target_address.is_zero() {\\n                if call.is_public {\\n                    context.call_public_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                } else {\\n                    let _result = context.call_private_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                }\\n            }\\n        }\\n    }\\n    // docs:end:entrypoint-execute-calls\\n}\\n"},"70":{"path":"/build-volume/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use crate::entrypoint::function_call::FunctionCall;\\nuse dep::aztec::{\\n    prelude::PrivateContext,\\n    protocol_types::{\\n        constants::GENERATOR_INDEX__FEE_PAYLOAD,\\n        hash::poseidon2_hash_with_separator,\\n        traits::{Hash, Serialize},\\n    },\\n};\\nuse std::meta::derive;\\n\\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\\n\\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\\n\\n// docs:start:fee-payload-struct\\n#[derive(Serialize)]\\npub struct FeePayload {\\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\\n    nonce: Field,\\n    is_fee_payer: bool,\\n}\\n// docs:end:fee-payload-struct\\n\\nimpl Hash for FeePayload {\\n    fn hash(self) -> Field {\\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\\n    }\\n}\\n\\nimpl FeePayload {\\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\\n\\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\\n        }\\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\\n        bytes.push(self.is_fee_payer as u8);\\n\\n        bytes.storage()\\n    }\\n\\n    fn execute_calls(self, context: &mut PrivateContext) {\\n        for call in self.function_calls {\\n            if !call.target_address.is_zero() {\\n                if call.is_public {\\n                    context.call_public_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                } else {\\n                    let _result = context.call_private_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                }\\n            }\\n        }\\n        if self.is_fee_payer {\\n            context.set_as_fee_payer();\\n        }\\n    }\\n}\\n"},"81":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::Empty,\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            /// for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\\n        /// to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        /// WARNING: This is insecure and should be temporary!\\n        /// The oracle hashes the arguments and returns a new args_hash.\\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        /// We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        /// b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"97":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\\nuse dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::Hash,\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"136":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> [Field; 2] {}\\n\\npub unconstrained fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> (u32, Field) {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n    );\\n\\n    let mut reader = Reader::new(fields);\\n    let end_side_effect_counter = reader.read_u32();\\n    let returns_hash = reader.read();\\n\\n    (end_side_effect_counter, returns_hash)\\n}\\n"},"137":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\\n}\\n\\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\\n}\\n\\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\\n"},"139":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr","source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\\npub fn store(values: [Field]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\\n}\\n\\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\\n    let _ = store_in_execution_cache_oracle(values);\\n}\\n\\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\\n    load_from_execution_cache_oracle(hash)\\n}\\n\\n#[oracle(storeInExecutionCache)]\\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\\n\\n#[oracle(loadFromExecutionCache)]\\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\\n"},"150":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            packed_note_content,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\\npub fn notify_created_nullifier(nullifier: Field) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n        note_hash,\\n        counter,\\n    );\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _packed_note_content: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\\n    let _ = notify_created_nullifier_oracle(nullifier);\\n}\\n\\n#[oracle(notifyCreatedNullifier)]\\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\\n) -> [Option<Note>; S]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    sync_notes_oracle_wrapper();\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let nonce = fields[read_offset];\\n            let note_hash_counter = fields[read_offset + 1] as u32;\\n            let note_content = array::subarray(fields, read_offset + 2);\\n\\n            let mut note = Note::unpack_content(note_content);\\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\\n\\n            placeholder_opt_notes[i] = Option::some(note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\\n/// for later querying via the `get_notes` oracle.\\npub fn sync_notes() {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe {\\n        sync_notes_oracle_wrapper();\\n    }\\n}\\n\\nunconstrained fn sync_notes_oracle_wrapper() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n"},"184":{"path":"/build-volume/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\\n/// of elements past `offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\\n/// assert_eq(foo, [3, 4]);\\n///\\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\\n/// ```\\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [T; SRC_LEN],\\n    offset: u32,\\n) -> [T; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"DST_LEN too large for offset\\");\\n\\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::subarray;\\n\\n    #[test]\\n    unconstrained fn subarray_into_empty() {\\n        // In all of these cases we\'re setting DST_LEN to be 0, so we always get back an emtpy array.\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_complete() {\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_different_end_sizes() {\\n        // We implicitly select how many values to read in the size of the return array\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subarray_offset_too_large() {\\n        // With an offset of 1 we can only request up to 4 elements\\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subarray_bad_return_value() {\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\\n    }\\n}\\n"},"251":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector,\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        MAX_FIELD_VALUE,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\\n    merkle_tree::membership::MembershipWitness,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::{\\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\\n    ops::Add,\\n};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\n/// We implement the Packable trait for AztecAddress because it can be stored in contract\'s storage (and there\\n/// the implementation of Packable is required).\\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_private_function(\\n        function_selector: FunctionSelector,\\n        function_vk_hash: Field,\\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\\n        contract_class_artifact_hash: Field,\\n        contract_class_public_bytecode_commitment: Field,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let private_functions_root = private_functions_root_from_siblings(\\n            function_selector,\\n            function_vk_hash,\\n            function_leaf_membership_witness.leaf_index,\\n            function_leaf_membership_witness.sibling_path,\\n        );\\n\\n        let contract_class_id = ContractClassId::compute(\\n            contract_class_artifact_hash,\\n            private_functions_root,\\n            contract_class_public_bytecode_commitment,\\n        );\\n\\n        // Compute contract address using the preimage which includes the class_id.\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --\x3e Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"267":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    /// to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"268":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        function_selector::FunctionSelector,\\n        log_hash::{LogHash, ScopedLogHash},\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, is_empty, ToField},\\n    utils::field::field_from_bytes_32_trunc,\\n};\\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; N * 32];\\n    for offset in 0..N {\\n        // TODO: This is not checking that the decomposition is smaller than P\\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"285":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"294":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\\n    address::public_keys_hash::PublicKeysHash,\\n    constants::{\\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\\n    },\\n    hash::poseidon2_hash_with_separator,\\n    point::POINT_LENGTH,\\n    traits::{Deserialize, Hash, Serialize},\\n};\\n\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\nuse std::default::Default;\\n\\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\\n\\npub struct PublicKeys {\\n    pub npk_m: NpkM,\\n    pub ivpk_m: IvpkM,\\n    pub ovpk_m: OvpkM,\\n    pub tpk_m: TpkM,\\n}\\n\\npub trait ToPoint {\\n    fn to_point(self) -> Point;\\n}\\n\\npub struct NpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for NpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for NpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\\nimpl Hash for NpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\npub struct IvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for IvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for IvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct OvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl Hash for OvpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\nimpl ToPoint for OvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for OvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct TpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for TpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for TpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\nimpl Default for PublicKeys {\\n    fn default() -> Self {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\\n            },\\n        }\\n    }\\n}\\n\\nimpl Eq for PublicKeys {\\n    fn eq(self, other: PublicKeys) -> bool {\\n        (self.npk_m.inner == other.npk_m.inner)\\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\\n            & (self.tpk_m.inner == other.tpk_m.inner)\\n    }\\n}\\n\\nimpl PublicKeys {\\n    pub fn hash(self) -> PublicKeysHash {\\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\\n            self.serialize(),\\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\\n        ))\\n    }\\n}\\n\\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\\n        [\\n            self.npk_m.inner.x,\\n            self.npk_m.inner.y,\\n            self.npk_m.inner.is_infinite as Field,\\n            self.ivpk_m.inner.x,\\n            self.ivpk_m.inner.y,\\n            self.ivpk_m.inner.is_infinite as Field,\\n            self.ovpk_m.inner.x,\\n            self.ovpk_m.inner.y,\\n            self.ovpk_m.inner.is_infinite as Field,\\n            self.tpk_m.inner.x,\\n            self.tpk_m.inner.y,\\n            self.tpk_m.inner.is_infinite as Field,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point {\\n                    x: serialized[0],\\n                    y: serialized[1],\\n                    is_infinite: serialized[2] as bool,\\n                },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point {\\n                    x: serialized[3],\\n                    y: serialized[4],\\n                    is_infinite: serialized[5] as bool,\\n                },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point {\\n                    x: serialized[6],\\n                    y: serialized[7],\\n                    is_infinite: serialized[8] as bool,\\n                },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point {\\n                    x: serialized[9],\\n                    y: serialized[10],\\n                    is_infinite: serialized[11] as bool,\\n                },\\n            },\\n        }\\n    }\\n}\\n\\npub struct AddressPoint {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for AddressPoint {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_public_keys_hash() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let actual = keys.hash();\\n    let expected_public_keys_hash =\\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\\n\\n    assert(actual.to_field() == expected_public_keys_hash);\\n}\\n\\n#[test]\\nunconstrained fn compute_default_hash() {\\n    let keys = PublicKeys::default();\\n\\n    let actual = keys.hash();\\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\\n\\n    assert(actual.to_field() == test_data_default_hash);\\n}\\n\\n#[test]\\nunconstrained fn test_public_keys_serialization() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let serialized = keys.serialize();\\n    let deserialized = PublicKeys::deserialize(serialized);\\n\\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\\n}\\n"},"334":{"path":"/build-volume/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"346":{"path":"/root/nargo/github.com/noir-lang/schnorr/v0.1.1/src/lib.nr","source":"use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\\nuse std::hash::{blake2s, pedersen_hash};\\n\\npub fn verify_signature<let N: u32>(\\n    public_key: EmbeddedCurvePoint,\\n    signature: [u8; 64],\\n    message: [u8; N],\\n) -> bool {\\n    //scalar lo/hi from bytes\\n    let sig_s = scalar_from_bytes(signature, 0);\\n    let sig_e = scalar_from_bytes(signature, 32);\\n    // pub_key is on Grumpkin curve\\n    let mut is_ok = (public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17)\\n        & (!public_key.is_infinite);\\n\\n    if ((sig_s.lo != 0) | (sig_s.hi != 0)) & ((sig_e.lo != 0) | (sig_e.hi != 0)) {\\n        let (r_is_infinite, result) =\\n            calculate_signature_challenge(public_key, sig_s, sig_e, message);\\n\\n        is_ok &= !r_is_infinite;\\n        for i in 0..32 {\\n            is_ok &= result[i] == signature[32 + i];\\n        }\\n    } else {\\n        is_ok = false;\\n    }\\n    is_ok\\n}\\n\\npub fn assert_valid_signature<let N: u32>(\\n    public_key: EmbeddedCurvePoint,\\n    signature: [u8; 64],\\n    message: [u8; N],\\n) {\\n    //scalar lo/hi from bytes\\n    let sig_s = scalar_from_bytes(signature, 0);\\n    let sig_e = scalar_from_bytes(signature, 32);\\n\\n    // assert pub_key is on Grumpkin curve\\n    assert(public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17);\\n    assert(public_key.is_infinite == false);\\n    // assert signature is not null\\n    assert((sig_s.lo != 0) | (sig_s.hi != 0));\\n    assert((sig_e.lo != 0) | (sig_e.hi != 0));\\n\\n    let (r_is_infinite, result) = calculate_signature_challenge(public_key, sig_s, sig_e, message);\\n\\n    assert(!r_is_infinite);\\n    for i in 0..32 {\\n        assert(result[i] == signature[32 + i]);\\n    }\\n}\\n\\nfn calculate_signature_challenge<let N: u32>(\\n    public_key: EmbeddedCurvePoint,\\n    sig_s: EmbeddedCurveScalar,\\n    sig_e: EmbeddedCurveScalar,\\n    message: [u8; N],\\n) -> (bool, [u8; 32]) {\\n    let g1 = EmbeddedCurvePoint {\\n        x: 1,\\n        y: 17631683881184975370165255887551781615748388533673675138860,\\n        is_infinite: false,\\n    };\\n    let r = multi_scalar_mul([g1, public_key], [sig_s, sig_e]);\\n    // compare the _hashes_ rather than field elements modulo r\\n    let pedersen_hash = pedersen_hash([r.x, public_key.x, public_key.y]);\\n    let pde: [u8; 32] = pedersen_hash.to_be_bytes();\\n\\n    let mut hash_input = [0; N + 32];\\n    for i in 0..32 {\\n        hash_input[i] = pde[i];\\n    }\\n    for i in 0..N {\\n        hash_input[32 + i] = message[i];\\n    }\\n\\n    let result = blake2s(hash_input);\\n    (r.is_infinite, result)\\n}\\n\\n//Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\\nfn scalar_from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\\n    let mut v: Field = 1;\\n    let mut lo: Field = 0;\\n    let mut hi: Field = 0;\\n    for i in 0..16 {\\n        lo = lo + (bytes[offset + 31 - i] as Field) * v;\\n        hi = hi + (bytes[offset + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    let sig_s = EmbeddedCurveScalar::new(lo, hi);\\n    sig_s\\n}\\n\\nmod test {\\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\\n\\n    use super::verify_signature;\\n\\n    #[test]\\n    fn test_zero_signature() {\\n        let public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {\\n            x: 1,\\n            y: 17631683881184975370165255887551781615748388533673675138860,\\n            is_infinite: false,\\n        };\\n        let signature: [u8; 64] = [0; 64];\\n        let message: [u8; _] = [2; 64]; // every message\\n        let verified = verify_signature(public_key, signature, message);\\n        assert(!verified);\\n    }\\n\\n    #[test]\\n    fn smoke_test() {\\n        let message: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\\n        let pub_key_x: Field = 0x04b260954662e97f00cab9adb773a259097f7a274b83b113532bce27fa3fb96a;\\n        let pub_key_y: Field = 0x2fd51571db6c08666b0edfbfbc57d432068bccd0110a39b166ab243da0037197;\\n        let signature: [u8; 64] = [\\n            1, 13, 119, 112, 212, 39, 233, 41, 84, 235, 255, 93, 245, 172, 186, 83, 157, 253, 76,\\n            77, 33, 128, 178, 15, 214, 67, 105, 107, 177, 234, 77, 48, 27, 237, 155, 84, 39, 84,\\n            247, 27, 22, 8, 176, 230, 24, 115, 145, 220, 254, 122, 135, 179, 171, 4, 214, 202, 64,\\n            199, 19, 84, 239, 138, 124, 12,\\n        ];\\n\\n        let pub_key = EmbeddedCurvePoint { x: pub_key_x, y: pub_key_y, is_infinite: false };\\n        let valid_signature = verify_signature(pub_key, signature, message);\\n        assert(valid_signature);\\n        super::assert_valid_signature(pub_key, signature, message);\\n    }\\n\\n}\\n\\nmod bench {\\n    use super::{assert_valid_signature, verify_signature};\\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\\n\\n    #[export]\\n    pub fn bench_verify_signature(\\n        public_key: EmbeddedCurvePoint,\\n        signature: [u8; 64],\\n        message: [u8; 32],\\n    ) -> bool {\\n        verify_signature(public_key, signature, message)\\n    }\\n\\n    #[export]\\n    pub fn bench_assert_valid_signature(\\n        public_key: EmbeddedCurvePoint,\\n        signature: [u8; 64],\\n        message: [u8; 32],\\n    ) {\\n        assert_valid_signature(public_key, signature, message)\\n    }\\n}\\n"}}}'));class sA extends Fy{constructor(e){super(nA),this.encryptionPrivateKey=e}getDeploymentArgs(){return Promise.resolve(void 0)}getAuthWitnessProvider(e){return new iA(this.encryptionPrivateKey,e)}}class iA{constructor(e,t){this.privateKey=e,this.account=t}async createAuthWit(e){const t=new pm,n=await t.constructSignature(e.toBuffer(),this.privateKey),s=[...this.account.publicKeys.toFields(),...n.toBuffer(),this.account.partialAddress];return Promise.resolve(new $_(e,s))}}function rA(e,t,n){const s=Gd(t);return My.create(e,t,new sA(s),n)}const aA=[si.fromHexString("2153536ff6628eee01cf4024889ff977a18d9fa61d0e414422f7681cf085c281"),si.fromHexString("aebd1b4be76efa44f5ee655c20bf9ea60f7ae44b9a7fd1fd9f189c7a0b0cdae"),si.fromHexString("0f6addf0da06c33293df974a565b03d1ab096090d907d98055a8b7f4954e120c")],oA=aA.map((e=>Gd(e))),lA=[si.ZERO,si.ZERO,si.ZERO];async function cA(e){const t=await e.getRegisteredAccounts(),n=await Promise.all(aA.map((async e=>{const t=Gd(e);return{sk:e,pk:await ky(t)}})));return Promise.all(n.filter((e=>null!=t.find((t=>t.publicKeys.masterIncomingViewingPublicKey.equals(e.pk))))).map((async t=>{const n=(s=t.sk,fl([s,Ri.IVSK_M]));var s;return(await tA(e,t.sk,n,si.ZERO)).getWallet()})))}})();var a=r.wC,o=r.hp,l=r.QM,c=r.NZ,d=r.pF,u=r.Fr,f=r.cY,h=r._5,p=r.b$,m=r.dP,g=r.dB,_=r.cg,b=r.RQ,y=r.BJ,A=r.ZI;export{a as AztecAddress,o as Buffer,l as CompleteAddress,c as Contract,d as DeployMethod,u as Fr,f as INITIAL_TEST_ACCOUNT_SALTS,h as INITIAL_TEST_SECRET_KEYS,p as INITIAL_TEST_SIGNING_KEYS,m as contractArtifactFromBuffer,g as createPXEClient,_ as generatePublicKey,b as getDeployedTestAccountsWallets,y as getSchnorrAccount,A as getUnsafeSchnorrAccount};