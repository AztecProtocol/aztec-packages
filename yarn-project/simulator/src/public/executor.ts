import { type PublicExecutionRequest } from '@aztec/circuit-types';
import { type AvmSimulationStats } from '@aztec/circuit-types/stats';
import { Fr, Gas, type GlobalVariables, type Header, type Nullifier, type TxContext } from '@aztec/circuits.js';
import { createDebugLogger } from '@aztec/foundation/log';
import { Timer } from '@aztec/foundation/timer';
import { type TelemetryClient } from '@aztec/telemetry-client';

import { AvmContext } from '../avm/avm_context.js';
import { AvmExecutionEnvironment } from '../avm/avm_execution_environment.js';
import { AvmMachineState } from '../avm/avm_machine_state.js';
import { AvmSimulator } from '../avm/avm_simulator.js';
import { HostStorage } from '../avm/journal/host_storage.js';
import { AvmPersistableStateManager } from '../avm/journal/index.js';
import { type CommitmentsDB, type PublicContractsDB, type PublicStateDB } from './db_interfaces.js';
import { type PublicExecutionResult } from './execution.js';
import { ExecutorMetrics } from './executor_metrics.js';
import { PublicSideEffectTrace } from './side_effect_trace.js';

/**
 * Handles execution of public functions.
 */
export class PublicExecutor {
  metrics: ExecutorMetrics;

  constructor(
    private readonly publicStorageDB: PublicStateDB,
    private readonly contractsDb: PublicContractsDB,
    private readonly commitmentsDb: CommitmentsDB,
    private readonly header: Header,
    client: TelemetryClient,
  ) {
    this.metrics = new ExecutorMetrics(client, 'PublicExecutor');
  }

  static readonly log = createDebugLogger('aztec:simulator:public_executor');

  /**
   * Executes a public execution request.
   * @param executionRequest - The execution to run.
   * @param globalVariables - The global variables to use.
   * @param availableGas - The gas available at the start of this enqueued call.
   * @param txContext - Transaction context.
   * @param pendingSiloedNullifiers - The pending nullifier set from earlier parts of this TX.
   * @param transactionFee - Fee offered for this TX.
   * @param startSideEffectCounter - The counter of the first side-effect generated by this simulation.
   * @returns The result of execution, including the results of all nested calls.
   */
  public async simulate(
    executionRequest: PublicExecutionRequest,
    globalVariables: GlobalVariables,
    availableGas: Gas,
    _txContext: TxContext,
    pendingSiloedNullifiers: Nullifier[],
    transactionFee: Fr = Fr.ZERO,
    startSideEffectCounter: number = 0,
  ): Promise<PublicExecutionResult> {
    const address = executionRequest.contractAddress;
    const selector = executionRequest.callContext.functionSelector;
    const fnName = (await this.contractsDb.getDebugFunctionName(address, selector)) ?? `${address}:${selector}`;

    PublicExecutor.log.verbose(`[AVM] Executing public external function ${fnName}.`);
    const timer = new Timer();

    const hostStorage = new HostStorage(this.publicStorageDB, this.contractsDb, this.commitmentsDb);
    const trace = new PublicSideEffectTrace(startSideEffectCounter);
    const avmPersistableState = AvmPersistableStateManager.newWithPendingSiloedNullifiers(
      hostStorage,
      trace,
      pendingSiloedNullifiers.map(n => n.value),
    );

    const avmExecutionEnv = createAvmExecutionEnvironment(
      executionRequest,
      this.header,
      globalVariables,
      transactionFee,
    );

    const avmMachineState = new AvmMachineState(availableGas);
    const avmContext = new AvmContext(avmPersistableState, avmExecutionEnv, avmMachineState);
    const simulator = new AvmSimulator(avmContext);
    const avmResult = await simulator.execute();
    const bytecode = simulator.getBytecode()!;

    // Commit the public storage state to the DBs since this is a top-level execution.
    // Observe that this will write all the state changes to the DBs, not only the latest for each slot.
    // However, the underlying DB keep a cache and will only write the latest state to disk.
    // TODO(dbanks12): this should be unnecessary here or should be exposed by state manager
    await avmContext.persistableState.publicStorage.commitToDB();

    PublicExecutor.log.verbose(
      `[AVM] ${fnName} returned, reverted: ${avmResult.reverted}${
        avmResult.reverted ? ', reason: ' + avmResult.revertReason : ''
      }.`,
      {
        eventName: 'avm-simulation',
        appCircuitName: fnName,
        duration: timer.ms(),
        bytecodeSize: bytecode!.length,
      } satisfies AvmSimulationStats,
    );

    const publicExecutionResult = trace.toPublicExecutionResult(
      avmExecutionEnv,
      /*startGasLeft=*/ availableGas,
      /*endGasLeft=*/ Gas.from(avmContext.machineState.gasLeft),
      bytecode,
      avmResult,
      fnName,
    );

    if (publicExecutionResult.reverted) {
      this.metrics.recordFunctionSimulationFailure();
    } else {
      this.metrics.recordFunctionSimulation(bytecode.length, timer.ms());
    }

    return publicExecutionResult;
  }
}

/**
 * Convert a PublicExecutionRequest object to an AvmExecutionEnvironment
 *
 * @param executionRequest
 * @param globalVariables
 * @returns
 */
function createAvmExecutionEnvironment(
  executionRequest: PublicExecutionRequest,
  header: Header,
  globalVariables: GlobalVariables,
  transactionFee: Fr,
): AvmExecutionEnvironment {
  return new AvmExecutionEnvironment(
    executionRequest.contractAddress,
    executionRequest.callContext.storageContractAddress,
    executionRequest.callContext.msgSender,
    executionRequest.callContext.functionSelector,
    /*contractCallDepth=*/ Fr.zero(),
    transactionFee,
    header,
    globalVariables,
    executionRequest.callContext.isStaticCall,
    executionRequest.callContext.isDelegateCall,
    executionRequest.args,
  );
}
