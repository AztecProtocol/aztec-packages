{"noir_version":"0.23.0+f1b91511124df89bbe9e059b87536901bdf0d6f3","hash":5754904168726933723,"abi":{"parameters":[{"name":"input","type":{"kind":"struct","path":"private_kernel_lib::private_kernel_ordering::PrivateKernelInputsOrdering","fields":[{"name":"previous_kernel","type":{"kind":"struct","path":"private_kernel_lib::types::abis::previous_kernel_data::PreviousKernelData","fields":[{"name":"public_inputs","type":{"kind":"struct","path":"private_kernel_lib::types::abis::kernel_circuit_public_inputs::KernelCircuitPublicInputs","fields":[{"name":"aggregation_object","type":{"kind":"struct","path":"private_kernel_lib::types::mocked::AggregationObject","fields":[]}},{"name":"meta_hwm","type":{"kind":"field"}},{"name":"end","type":{"kind":"struct","path":"private_kernel_lib::types::abis::combined_accumulated_data::CombinedAccumulatedData","fields":[{"name":"read_requests","type":{"kind":"array","length":128,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::nullifier_key_validation_request::NullifierKeyValidationRequestContext","fields":[{"name":"public_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"new_contracts","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::new_contract_data::NewContractData","fields":[{"name":"contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_class_id","type":{"kind":"struct","path":"private_kernel_lib::types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}},{"name":"public_data_update_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::public_data_update_request::PublicDataUpdateRequest","fields":[{"name":"leaf_slot","type":{"kind":"field"}},{"name":"old_value","type":{"kind":"field"}},{"name":"new_value","type":{"kind":"field"}}]}}},{"name":"public_data_reads","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::public_data_read::PublicDataRead","fields":[{"name":"leaf_slot","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}}]}}}]}},{"name":"constants","type":{"kind":"struct","path":"private_kernel_lib::types::abis::combined_constant_data::CombinedConstantData","fields":[{"name":"historical_header","type":{"kind":"struct","path":"private_kernel_lib::types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"private_kernel_lib::types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"private_kernel_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"private_kernel_lib::types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"tx_context","type":{"kind":"struct","path":"private_kernel_lib::types::transaction::context::TxContext","fields":[{"name":"is_fee_payment_tx","type":{"kind":"boolean"}},{"name":"is_rebate_payment_tx","type":{"kind":"boolean"}},{"name":"is_contract_deployment_tx","type":{"kind":"boolean"}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"private_kernel_lib::types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"private_kernel_lib::types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]}},{"name":"is_private","type":{"kind":"boolean"}}]}},{"name":"proof","type":{"kind":"struct","path":"private_kernel_lib::types::mocked::Proof","fields":[]}},{"name":"vk","type":{"kind":"struct","path":"private_kernel_lib::types::mocked::VerificationKey","fields":[]}},{"name":"vk_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"vk_path","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]}},{"name":"sorted_new_commitments","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"sorted_new_commitments_indexes","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":32}}},{"name":"read_commitment_hints","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"sorted_new_nullifiers","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"sorted_new_nullifiers_indexes","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":32}}},{"name":"nullifier_commitment_hints","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"master_nullifier_secret_keys","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}}]},"visibility":"private"}],"param_witnesses":{"input":[{"start":0,"end":1468}]},"return_type":{"abi_type":{"kind":"struct","path":"private_kernel_lib::types::abis::kernel_circuit_public_inputs::KernelCircuitPublicInputsFinal","fields":[{"name":"aggregation_object","type":{"kind":"struct","path":"private_kernel_lib::types::mocked::AggregationObject","fields":[]}},{"name":"meta_hwm","type":{"kind":"field"}},{"name":"end_meta","type":{"kind":"struct","path":"private_kernel_lib::types::abis::combined_accumulated_data::AccumulatedMetaData","fields":[{"name":"new_commitments","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}}]}},{"name":"end","type":{"kind":"struct","path":"private_kernel_lib::types::abis::combined_accumulated_data::FinalAccumulatedData","fields":[{"name":"new_commitments","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"new_contracts","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::new_contract_data::NewContractData","fields":[{"name":"contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_class_id","type":{"kind":"struct","path":"private_kernel_lib::types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}}]}},{"name":"constants","type":{"kind":"struct","path":"private_kernel_lib::types::abis::combined_constant_data::CombinedConstantData","fields":[{"name":"historical_header","type":{"kind":"struct","path":"private_kernel_lib::types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"private_kernel_lib::types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"private_kernel_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"private_kernel_lib::types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"tx_context","type":{"kind":"struct","path":"private_kernel_lib::types::transaction::context::TxContext","fields":[{"name":"is_fee_payment_tx","type":{"kind":"boolean"}},{"name":"is_rebate_payment_tx","type":{"kind":"boolean"}},{"name":"is_contract_deployment_tx","type":{"kind":"boolean"}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"private_kernel_lib::types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"private_kernel_lib::types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]}},{"name":"is_private","type":{"kind":"boolean"}}]},"visibility":"public"},"return_witnesses":[1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049,2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149,2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199,2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249,2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299,2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349,2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399,2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449,2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491]},"bytecode":"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","debug_symbols":"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+sVfdmq5lvm56ePo9Hl0+jo6/T46fZPTv/irWi0XUz81/Ub3/cv06L5/mR7dOS/+JlhvdOe8TM/unFfpQZ3zRyS5TvlGJONFAtXtIxKoQx+RghcJ9HT7iARaH49IoJ3wiAQq+kckXnsPr72H197Da+/htffw2nt47T289h5eew+vvQfX3nPh2nsuXHvPhWvvuXDtPReuvefCtfdcuPaeC9fec+Haey5eexuvvY3X3sZrb+O1t/Ha23jtbbz2Nl57G6+9jdfei9fei9fei9fei9fei9fei9fei9fei9fei9fei9fezmtv57W389rbee3tvPZ2Xns7r72d197Oa2/ntXfw2jt47R289g5eewevvYPX3sFr7+C1d/DaO3jtnbz2Tl57J6+9k9feyWvv5LV38to7ee2dvPZOXnsXr72L194knfIRidfeJPHxEYnX3iRF8RGJ194kmfARidfem9fem9feJDnyEYnX3pvX3pvX3iTZ8xGJ194kLfMRidfePNdyeK7l8FzL4bmWw3Mth+daDs+1HJ5rOTzXcniu5fBcy+G5lsNzLYfnWg7PtRyeazk813J4ruXwXMvBuZZ54VzLOxKtve9ItPa+I9Ha+45Ea+87Eq2970i09r4j0dr7jkRr7zsSr71xruUdidfeONfyjsRrb5xreUfitTfOtbwj8dob51rekXjtjXMt70i89sa5lnckXnvjXMs7Eq+9ca7lHYnX3jjX8o7Ea2+ca3lH4rU3zrW8I/HaG+da3pF47Y1zLe9IvPbGuZZ3JF5741zLOxKvvXGu5R2J19441/KOxGtvnGt5R+K1N861vCPx2hvnWt6ReO2Ncy3vSOr2vh8+HpHuTP8Q6Z9f/dd/2elOH0enz6PT19Hp99Hp++j0Q07/139VKy+5mPq56dF9/zI9uu9fpkd3zl//TbA7PbpzXqZnd86L9BvUOY9Ixou0eJFAdfuIBOrQRyTQg/AjEujp9hEJtD4ekUA74REJVPR/RGpeezevvZvX3s1r7+a1d/Pau3nt3bz2bl57N6+9h9few2vv4bX38Np7eO09vPYeXnsPr72H196Da2+7cO1tF6697cK1t1249rYL19524drbLlx724Vrb7tw7W0Xr72N197Ga2/jtbfx2tt47W289jZeexuvvY3X3sZr78Vr78Vr78Vr78Vr78Vr78Vr78Vr78Vr78Vr78Vrb+e1t/Pa23nt7bz2dl57O6+9ndfezmtv57W389o7eO0dvPYOXnsHr72D197Ba+/gtXfw2jt47R289k5eeyevvZPX3iSd8hGJ194k8fERidfeJEXxEYnX3iSZ8I9IJEPwEYnX3sVrb5Ic+YjEa+/itXfx2pskez4i8dqbpGX+EYnnWhrPtTSea2k819J4rqXxXEvjuZbGcy2N51oaz7U0nmtpPNfSeK6l8VxL47mWxnMtjedaGs+1NJ5raTzX0niupfFcS+O5lsZzLY3nWhrPtTSea2k819J4rqXxXMvFcy0Xz7VcPNdy8VzLdeHae/Fcy8VzLRfPtVw813LxXMvFcy0Xz7VcPNdy8VzLxXMtF8+1XDzXcvFcy8VzLRfPtVw813LxXMvFcy0Xz7VcPNdy8VzLxXMtF8+1XDzXcvFcy8VzLRfPtVw813LxXMvFcy0Xz7VcPNdy8VzLxXMtF8+1XDzXcvFcy8VzLRfPtVx617L3I1Kt+YdI//zqF3/Zaem1zE9NX0en30en76PTz8np9bbpfyb9i7+qtfRi6qemR/f9y/Tovn+ZHt05L/4m2Ep057xKX+zOeZUe1DmPSIsXyXmRQHX7iATq0Eck0IPwIxLo6fYRCbQ+HpFAO+GPSBtU9I9IvPbevPbevPbevPbevPbevPbevPbevPbevPZuXns3r72b197Na+/mtXfz2rt57d289m5eezevvYfX3sNr7+G19/Dae3jtPbz2Hl57D6+9h9feg2tvv3Dt7Reuvf3CtbdfuPb2C9fefuHa2y9ce/uFa2+/cO3tF6+9jdfexmtv47W38drbeO1tvPY2Xnsbr72N197Ga+/Fa+/Fa+/Fa+/Fa+/Fa+/Fa+/Fa+/Fa+/Fa+/Fa2/ntbfz2tt57e289nZeezuvvZ3X3s5rb+e1t/PaO3jtHbz2Dl57B6+9STrlIxKvvUni4yMSr71JiuIjEq+9STLhIxKvvZPX3slrb5Ic+YjEa+/ktXfy2pskez4i8dqbpGU+IvHam+daOs+1dJ5r6TzX0nmupfNcS+e5ls5zLZ3nWjrPtXSea+k819J5rqXzXEvnuZbOcy2d51o6z7V0nmvpPNfSea6l81xL57mWznMtnedaOs+1dJ5r6TzX0nmupfNcS+e5ls5zLZ3nWjrPtXSea+k819J5rqXzXMvguZbBcy2D51oGz7WMC9fewXMtg+daBs+1DJ5rGTzXMniuZfBcy+C5lsFzLYPnWgbPtQyeaxk81zJ4rmXwXMvguZbBcy2D51oGz7UMnmsZPNcyeK5l8FzL4LmWwXMtg+daBs+1DJ5rGTzXMniuZchdy9r5iLSX/UOkf371i7/sFHIt83PT76PT99Hp5+T0coX0c9MbOf2Lv6oVcjH1c9Oj+/5lenTfv0yP7pwXfxMsEt05L9OzO+dVelDnPCI5L1LwIoHq9hEJ1KGPSKAH4Uck0NPtIxJoffwRqUA74REJVPSPSLz2Ll57F6+9i9fexWvv4rV38dq7eO29ee29ee29ee29ee29ee29ee29ee29ee29ee29ee3dvPZuXns3r72b197Na+/mtXfz2rt57d289m5eew+vvYfX3sNr7+G19/Dae3jtPbz2Hl57D6+9B9feeeHaOy9ce+eFa++8cO2dF66988K1d1649s4L19554do7L157G6+9jdfexmtv47W38drbeO1tvPY2Xnsbr72N196L196L196L196L196L196L196L196L196L196L197Oa2/ntbfz2tt57e289ibplI9IvPYmiY+PSLz2JimKf0QieYePSLz2JhmCj0i89g5ee5PkyEckXnsHr72D194k2fOPSCSD8xGJ19481zJ5rmXyXMvkuZbJcy2T51omz7VMnmuZPNcyea5l8lzL5LmWyXMtk+daJs+1TJ5rmTzXMnmuZfJcy+S5lslzLZPnWibPtUyea5k81zJ5rmXyXMvkuZbJcy2T51omz7VMnmuZPNcyea5l8lzL5LmWyXMtk+daJs+1TJ5rmTzXMnmuZfJcy+S5lslzLZPnWibPtUyea1k817J4rmXxXMviuZZ14dq7eK5l8VzL4rmWxXMti+daFs+1LJ5rWTzXsniuZfFcy+K5lsVzLYvnWhbPtSyea1k817J4rmXxXMviuZbFcy2L51qW3LXc9YzUdv1DpH9+9Yu/7FRyLfNz0/fR6efk9HIv9HPT29HpFzn9i7+qVXIx9XPTo/v+ZXp0379KH+jOefE3wSrQnfMyPbtzXqUHdc4jUvAiJS8SqG4fkUAd+ogEehB+RAI93f4RKUHr4xEJtBMekUBF/4jEa+/ktXfy2jt57Z289k5eeyevvYvX3sVr7+K1d/Hau3jtXbz2Ll57F6+9i9fexWvvzWvvzWvvzWvvzWvvzWvvzWvvzWvvzWvvzWvvzWvv5rV389q7ee3dvPZuXns3r72b197Na+/mtXfz2nt47T289h5eew+vvYfX3sNr7+G19/Dae3jtPbj23heuvfeFa+994dp7X7j23heuvfeFa+994dp7X7j23heuvffFa2/jtbfx2tt47W289jZeexuvvY3X3sZrb+O1t/Hae/Hae/Hae/Hae/Hae/Hae/Ham6RTPiLx2pskPj4i8dqbpCg+IvHamyQTPiLx2tt57e289ibJkY9IvPZ2Xns7r71JsucjEq+9SVrmIxKvvXmu5ea5lpvnWm6ea7l5ruXmuZab51punmu5ea7l5rmWm+dabp5ruXmu5ea5lpvnWm6ea7l5ruXmuZab51punmu5ea7l5rmWm+dabp5ruXmu5ea5lpvnWm6ea7l5ruXmuZab51punmu5ea7l5rmWm+dabp5ruXmu5ea5lpvnWm6ea7l5ruXmuZab51punmu5ea7l5rmWm+dabp5ruXmu5ea5lpvnWm6ea7l5ruXmuZab51punmvZPNeyea5l81zL5rmWfeHau3muZfNcy+a5ls1zLZvnWjbPtWyea9k817J5rmXzXMvmuZbNcy1b7lp2xjPSzD9E+udXv/jLTi3XMj83/ZycXi57fm56Ozr9Ojq9k9O/+KtaLRdTPzc9uu9fpkf3/av0ju6cF38TrB3dOS/TszvnVXpQ5zwiJS9S8SKB6vYRCdShj0igB+E/IgXo6fYRCbQ+HpFAO+ERCVT0j0i89g5eewevvYPX3sFr7+C1d/LaO3ntnbz2Tl57J6+9k9feyWvv5LV38to7ee1dvPYuXnsXr72L197Fa+/itXfx2rt47V289i5ee29ee29ee29ee29ee29ee29ee29ee29ee29ee29eezevvZvX3s1r7+a1d/Pau3nt3bz2bl57N6+9m9few2vv4bX38Np7eO09vPYeXnsPr72H197Da+/BtfdcuPaeC9fec+Haey5ce8+Fa++5cO09F66958K191y49p6L197Ga2/jtbfx2tt47W289jZeexuvvUk65SMSr71J4uMfkUg24yMSr71J3uEjEq+9SYbgIxKvvRevvUly5CMSr70Xr72d194k2fMRidfeJC3zEYnX3jzXcniu5fBcy+G5lsNzLYfnWg7PtRyeazk813J4ruXwXMvhuZbDcy2H51oOz7Ucnms5PNdyeK7l8FzL4bmWw3Mth+daDs+1HJ5rOTzXcniu5fBcy+G5lsNzLYfnWg7PtRyeazk813J4ruXwXMvhuZbDcy2H51oOz7Ucnms5PNdyeK7l8FzL4bmWw3Mth+daDs+1HJ5rOTzXcniu5fBcy+G5lsNzLYfnWg7PtRyeazk813J4ruXwXMvhuZbDcy2H51oOz7Ucnms5ONeyLpxreUeitfcdidbedyRae9+RaO19R6K19x2J1t53JFp735HE7V1rP750uf1jpH9+9V//Zac7/ZycXm1wfnJ6Ozr9Ojq9H50+yOn/+q9q3enz6PTovn+ZHt33r9IvdOf89d8Eu9OjO+dlenbnvEoP6pxHpOJF2rxIoLp9RAJ16B+RHPQg/IgEerp9RAKtj0ck0E54RAIV/SMSr72d197Oa2/ntbfz2jt47R289g5eewevvYPX3sFr7+C1d/DaO3jtHbz2Tl57J6+9k9feyWvv5LV38to7ee2dvPZOXnsnr72L197Fa+/itXfx2rt47V289i5eexevvYvX3sVr781r781r781r781r781r781r781r781r781r781r7+a1d/Pau3nt3bz2bl57N6+9m9fezWvv5rV389p7eO09vPYeXnsPr72H197Da+/htffw2nt47T249rYL19524drbLlx724Vrb7tw7W0Xrr3twrW3Xbj2NpJO+YjEa2+S+PiIxGtvkqL4iMRrb5JM+IjEa2/jtbfx2pskRz4i8dp78dp78dqbJHs+IvHam6RlPiLx2pvnWhrPtTSea2k819J4rqXxXEvjuZbGcy2N51oaz7U0nmtpPNfSeK6l8VxL47mWxnMtjedaGs+1NJ5raTzX0niupfFcS+O5lsZzLY3nWhrPtTSea2k819J4rqXxXEvjuZbGcy2N51oaz7U0nmtpPNfSeK6l8VxL47mWxnMtjedaGs+1NJ5raTzX0niupfFcS+O5lsZzLY3nWhrPtTSea2k819J4rqXxXEvjuZbGcy2N51oaz7U0nmtpPNfSeK6l8VxL47mWxnMtjedaGs+1NJ5raTzX0niupfFcS+O5lvZzXcvHIa04ZH7+IevnGo6PQ0xxyFIc4opDQnFIKg4pxSFbcUgrDlFMvCkm3hQTb4qJN8XEm2LiTTHxpph4U0y8KSbeFBO/FBO/FBO/FBO/FBO/FBO/FBO/FBO/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AdAQPyKBxvIRCTRoj0jNizS0SH1dvEigzntEArXYIxLo8e4RKXiRcO3dF669+8K1d1+49u6L197Ga2/jtbfx2tt47W289jZeexuvvY3X3sZrb+O19+K19+K19+K19+K19+K19+K19+K19+K19+K19+K1t/Pa23nt7bz2dl57O6+9ndfezmtv57W389rbee0dvPYOXnsHr72D197Ba+/gtXfw2jt47R289g5eeyevvZPX3slr7+S1d/LaO3ntnbz2Tl57J6+9k9fexWvv4rV38dq7eO1dvPYuXnsXr72L197Fa+/itffmtffmtffmtffmtffmtffmtffmtffmtffmtffmtXfz2rt57d289ibpfI9IvPYmKXePSLz2Jmlxj0i89m5eew+vvUmG4iMSr72H197Da2+ea9k817J5rmXzXMvmuZbDcy2H51oOz7Ucnms5F669h+daDs+1HJ5rOTzXcniu5fBcy+G5lsNzLYfnWg7PtRyeazk813J4ruXwXMvhuZbDcy2H51oOz7Ucnms5PNdyeK7l8FzL4bmWw3Mth+daDs+1HJ5rOTzXcniu5fBcy+G5lsNzLYfnWg7PtRyeazk813J4ruXwXMvhuZbDcy2H51oOz7Ucnms5PNdyeK7l8FzL4bmWw3Mth+daDs+1HJ5rOTzXcniu5fBcy+G5lsNzLYfnWg7PtRyeazk813J4ruXwXMvhuZbDcy2H51oOz7Ucnms5PNdyeK7l8FzL4bmWw3Mth+daDs+1HJ5rOTzXcniu5fBcy+G5lsNzLYfnWg7PtRyeazk813J4ruXwXMvhuZbDcy2H51oOz7Ucnms5PNdyeK7l8FzLwbmW+8K5lnckWnvfkWjtfUeitfcdidbedyRae9+RaO19R6K19x2J1t53JF5741zLOxKvvXGu5R2J19441/KOxGtvnGt5R+K1N861vCPx2hvnWt6ReO2Ncy3vSLz2xrmWdyRee+NcyzsSr71xruUdidfeONfyjsRrb5xreUfitTfOtbwj8dob51rekXjtjXMt70i89sa5lnckXnvjXMs7Eq+9ca7lHYnX3jjX8o7Ea2+ca3lH4rU3zrW8I/HaG+da3pF47Y1zLe9IvPbGuZZ3JF5741zLOxKvvXGu5R2J19441/KOxGtvnGt5R+K1N861vCPx2hvnWt6ReO2Ncy3vSLz2xrmWdyRee+Nc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","file_map":{"2":{"source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u16 { fn eq(self, other: u16) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i16 { fn eq(self, other: i16) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, N> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<N> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, N> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n","path":"std/cmp.nr"},"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}","path":"std/collections/bounded_vec.nr"},"19":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"21":{"source":"use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n","path":"std/grumpkin_scalar_mul.nr"},"44":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint,\n    grumpkin_private_key::GrumpkinPrivateKey,\n};\n\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN = 5;\n\nstruct NullifierKeyValidationRequest {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\nimpl Eq for NullifierKeyValidationRequest {\n    fn eq(self, request: NullifierKeyValidationRequest) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequest {\n    fn empty() -> Self {\n        NullifierKeyValidationRequest {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN> for NullifierKeyValidationRequest {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN> for NullifierKeyValidationRequest {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n        }\n    }\n}\n\nimpl NullifierKeyValidationRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> NullifierKeyValidationRequestContext {\n        NullifierKeyValidationRequestContext {\n            public_key: self.public_key,\n            secret_key: self.secret_key,\n            contract_address,\n        }\n    }\n}\n\nstruct NullifierKeyValidationRequestContext {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n    contract_address: AztecAddress,\n}\n\nimpl Eq for NullifierKeyValidationRequestContext {\n    fn eq(self, request: NullifierKeyValidationRequestContext) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n            & (request.contract_address.eq(self.contract_address))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequestContext {\n    fn empty() -> Self {\n        NullifierKeyValidationRequestContext {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN> for NullifierKeyValidationRequestContext {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n            self.contract_address.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN> for NullifierKeyValidationRequestContext {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n            contract_address: AztecAddress::from_field(fields[4]),\n        }\n    }\n}\n\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/nullifier_key_validation_request.nr"},"50":{"source":"use crate::constants::{GENERATOR_INDEX__SIDE_EFFECT};\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Hash, Serialize, Deserialize};\n\ntrait Ordered {\n    fn counter(self) -> u32;\n}\n\nstruct SideEffect{\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffect {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffect {\n    fn eq(self, side_effect: SideEffect) -> bool {\n        (self.value == side_effect.value)\n        & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffect {\n    fn empty() -> Self {\n        SideEffect {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffect {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize() , GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<2> for SideEffect {\n    fn serialize(self) -> [Field; 2] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<2> for SideEffect {\n    fn deserialize(values: [Field; 2]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nstruct SideEffectLinkedToNoteHash{\n    value: Field,\n    note_hash: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffectLinkedToNoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffectLinkedToNoteHash {\n    fn eq(self, side_effect: SideEffectLinkedToNoteHash) -> bool {\n        (self.value == side_effect.value)\n            & (self.note_hash == side_effect.note_hash) \n            & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffectLinkedToNoteHash {\n    fn empty() -> Self {\n        SideEffectLinkedToNoteHash {\n            value: 0,\n            note_hash: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffectLinkedToNoteHash {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize(),\n        GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<3> for SideEffectLinkedToNoteHash {\n    fn serialize(self) -> [Field; 3] {\n        [self.value, self.note_hash, self.counter as Field]\n    }\n}\n\nimpl Deserialize<3> for SideEffectLinkedToNoteHash {\n    fn deserialize(values: [Field; 3]) -> Self {\n        Self {\n            value: values[0],\n            note_hash: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/side_effect.nr"},"57":{"source":"use crate::{\n    abis::{\n        call_request::CallRequest,\n        new_contract_data::NewContractData,\n        nullifier_key_validation_request::NullifierKeyValidationRequestContext,\n        public_data_read::PublicDataRead,\n        public_data_update_request::PublicDataUpdateRequest,\n        side_effect::{SideEffect, SideEffectLinkedToNoteHash},\n    }\n};\nuse crate::constants::{\n    MAX_READ_REQUESTS_PER_TX,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX,\n    MAX_NEW_COMMITMENTS_PER_TX,\n    MAX_NEW_NULLIFIERS_PER_TX,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX,\n    MAX_NEW_L2_TO_L1_MSGS_PER_TX,\n    MAX_NEW_CONTRACTS_PER_TX,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX,\n    MAX_PUBLIC_DATA_READS_PER_TX,\n    NUM_FIELDS_PER_SHA256,\n\n    MAX_NEW_COMMITMENTS_PER_TX_META,\n    MAX_NEW_NULLIFIERS_PER_TX_META,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX_META,\n};\n\nstruct CombinedAccumulatedData {\n    read_requests: [SideEffect; MAX_READ_REQUESTS_PER_TX],\n    nullifier_key_validation_requests: [NullifierKeyValidationRequestContext; MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX],\n\n    new_commitments: [SideEffect; MAX_NEW_COMMITMENTS_PER_TX],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_TX],\n\n    private_call_stack: [CallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX],\n    public_call_stack: [CallRequest; MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_TX],\n\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n\n    new_contracts: [NewContractData; MAX_NEW_CONTRACTS_PER_TX],\n\n    public_data_update_requests: [PublicDataUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX],\n\n    public_data_reads: [PublicDataRead; MAX_PUBLIC_DATA_READS_PER_TX],\n}\n\nstruct FinalAccumulatedData {\n    new_commitments: [SideEffect; MAX_NEW_COMMITMENTS_PER_TX],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_TX],\n\n    private_call_stack: [CallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX],\n    public_call_stack: [CallRequest; MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_TX],\n\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n\n    new_contracts: [NewContractData; MAX_NEW_CONTRACTS_PER_TX],\n}\n\nstruct AccumulatedMetaData {\n    new_commitments: [SideEffect; MAX_NEW_COMMITMENTS_PER_TX_META],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_TX_META],\n    public_call_stack: [CallRequest; MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX_META],\n}\n\nstruct CombinedAccumulatedDataBuilder {\n    read_requests: BoundedVec<SideEffect,MAX_READ_REQUESTS_PER_TX>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequestContext, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_TX>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_TX>,\n\n    private_call_stack: BoundedVec<CallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX>,\n    public_call_stack: BoundedVec<CallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX>,\n    new_l2_to_l1_msgs: BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_TX>,\n\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n\n    new_contracts: BoundedVec<NewContractData, MAX_NEW_CONTRACTS_PER_TX>,\n\n    public_data_update_requests: BoundedVec<PublicDataUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX>,\n\n    public_data_reads: BoundedVec<PublicDataRead, MAX_PUBLIC_DATA_READS_PER_TX>,\n}\n\nimpl CombinedAccumulatedDataBuilder {\n    pub fn finish(self) -> CombinedAccumulatedData {\n        CombinedAccumulatedData {\n\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n\n            encrypted_logs_hash: self.encrypted_logs_hash,\n            unencrypted_logs_hash: self.unencrypted_logs_hash,\n\n            encrypted_log_preimages_length: self.encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: self.unencrypted_log_preimages_length,\n\n            new_contracts: self.new_contracts.storage,\n\n            public_data_update_requests: self.public_data_update_requests.storage,\n\n            public_data_reads: self.public_data_reads.storage,\n        }\n    }\n\n    pub fn to_final(self) -> FinalAccumulatedData {\n        assert_eq(self.read_requests.len, 0, \"Final accumulated data: read requests not empty\");\n        assert_eq(self.nullifier_key_validation_requests.len, 0, \"Final accumulated data: nullifier key validation requests not empty\");\n        assert_eq(self.public_data_update_requests.len, 0, \"Final accumulated data: public data update requests not empty\");\n        assert_eq(self.public_data_reads.len, 0, \"Final accumulated data: public data reads not empty\");\n\n        FinalAccumulatedData {\n\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n\n            encrypted_logs_hash: self.encrypted_logs_hash,\n            unencrypted_logs_hash: self.unencrypted_logs_hash,\n\n            encrypted_log_preimages_length: self.encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: self.unencrypted_log_preimages_length,\n\n            new_contracts: self.new_contracts.storage,\n        }\n    }\n}\n\nstruct AccumulatedMetaDataBuilder {\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_TX_META>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_TX_META>,\n    public_call_stack: BoundedVec<CallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX_META>,\n}\n\nimpl AccumulatedMetaDataBuilder {\n    pub fn finish(self) -> AccumulatedMetaData {\n        AccumulatedMetaData {\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n        }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/combined_accumulated_data.nr"},"60":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::contract_class::ContractClassId;\nuse crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Hash};\n\nstruct NewContractData {\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_class_id: ContractClassId,\n}\n\nimpl Eq for NewContractData {\n    fn eq(self, data: NewContractData) -> bool {\n        data.contract_address.eq(self.contract_address)\n            & data.portal_contract_address.eq(self.portal_contract_address)\n            & data.contract_class_id.eq(self.contract_class_id)\n    }\n}\n\nimpl Empty for NewContractData {\n    fn empty() -> Self {\n        Self {\n            contract_address : AztecAddress::empty(),\n            portal_contract_address : EthAddress::empty(),\n            contract_class_id: ContractClassId::from_field(0),\n        }\n    }\n}\n\nimpl Hash for NewContractData {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0 // We want to return 0 here since the contract_address is zero\n        } else {\n            dep::std::hash::pedersen_hash_with_separator([\n                self.contract_address.to_field(),\n                self.portal_contract_address.to_field(),\n                self.contract_class_id.to_field(),\n            ], GENERATOR_INDEX__CONTRACT_LEAF)\n        }\n    }\n}\n\nimpl NewContractData {\n    pub fn is_empty(self) -> bool {\n        (self.contract_address.to_field() == 0) & \n        (self.portal_contract_address.to_field() == 0) & \n        (self.contract_class_id.to_field() == 0)\n    }\n\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/new_contract_data.nr"},"62":{"source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::Empty;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, caller_context: CallerContext) -> bool {\n        caller_context.msg_sender.eq(self.msg_sender)\n            & caller_context.storage_contract_address.eq(self.storage_contract_address)\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nstruct CallRequest {\n    hash: Field,\n    caller_contract_address: AztecAddress,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Eq for CallRequest {\n    fn eq(self, call_request: CallRequest) -> bool {\n        (call_request.hash == self.hash)\n            & (call_request.caller_contract_address.eq(self.caller_contract_address))\n            & (call_request.caller_context.eq(self.caller_context))\n            & (call_request.start_side_effect_counter == self.start_side_effect_counter)\n            & (call_request.end_side_effect_counter == self.end_side_effect_counter)\n    }\n}\n\nimpl Empty for CallRequest {\n    fn empty() -> Self {\n        CallRequest {\n            hash: 0,\n            caller_contract_address: AztecAddress::zero(),\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl CallRequest {\n    pub fn is_empty(self) -> bool {\n        self.hash == 0\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/call_request.nr"},"64":{"source":"use crate::abis::{\n    combined_accumulated_data::{\n        CombinedAccumulatedData,\n        FinalAccumulatedData,\n        AccumulatedMetaData,\n        AccumulatedMetaDataBuilder,\n        CombinedAccumulatedDataBuilder,\n    },\n    combined_constant_data::CombinedConstantData\n};\nuse crate::mocked::AggregationObject;\n\nstruct KernelCircuitPublicInputs {\n    aggregation_object: AggregationObject,\n    meta_hwm: Field,\n    end: CombinedAccumulatedData,\n    constants: CombinedConstantData,\n    is_private: bool,\n}\n\nstruct KernelCircuitPublicInputsFinal {\n    aggregation_object: AggregationObject,\n    meta_hwm: Field,\n    end_meta: AccumulatedMetaData,\n    // TODO(fees) change this to end_app_logic\n    end: FinalAccumulatedData,\n    constants: CombinedConstantData,\n    is_private: bool,\n}\n\nstruct KernelCircuitPublicInputsBuilder {\n    aggregation_object: AggregationObject,\n    meta_hwm: Field,\n    end_meta: AccumulatedMetaDataBuilder,\n    end: CombinedAccumulatedDataBuilder,\n    constants: CombinedConstantData,\n    is_private: bool,\n}\n\nimpl KernelCircuitPublicInputsBuilder {\n    pub fn finish(self) -> KernelCircuitPublicInputs {\n        KernelCircuitPublicInputs {\n            aggregation_object: self.aggregation_object,\n            meta_hwm: self.meta_hwm,\n            end: self.end.finish(),\n            constants: self.constants,\n            is_private: self.is_private,\n        }\n    }\n\n    pub fn to_final(self) -> KernelCircuitPublicInputsFinal {\n        let meta = self.end_meta.finish();\n        let app = self.end.to_final();\n        KernelCircuitPublicInputsFinal {\n            aggregation_object: self.aggregation_object,\n            meta_hwm: self.meta_hwm,\n            end_meta: meta,\n            end: app,\n            constants: self.constants,\n            is_private: self.is_private,\n        }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/kernel_circuit_public_inputs.nr"},"74":{"source":"use crate::{\n    constants::{\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONSTRUCTOR\n    },\n    hash::pedersen_hash,\n    contract_class::ContractClassId,\n    utils,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, ToField, Serialize, Deserialize};\nuse crate::type_serialization::{ETH_ADDRESS_SERIALIZED_LEN, AZTEC_ADDRESS_SERIALIZED_LEN};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_SERIALIZED_LEN> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_SERIALIZED_LEN] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_SERIALIZED_LEN> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_SERIALIZED_LEN]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute_from_public_key(pub_key: GrumpkinPoint, contract_class_id: ContractClassId, salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> AztecAddress {\n        AztecAddress::compute(PublicKeysHash::compute(pub_key), PartialAddress::compute(contract_class_id, salt, initialization_hash, portal_contract_address))\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n    \n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n}\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_SERIALIZED_LEN> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_SERIALIZED_LEN] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_SERIALIZED_LEN> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_SERIALIZED_LEN]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\nimpl EthAddress{\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n}\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(contract_class_id: ContractClassId, salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(contract_class_id, SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address))\n    }\n\n    pub fn compute_from_salted_initialization_hash(contract_class_id: ContractClassId, salted_initialization_hash: SaltedInitializationHash) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash([\n                contract_class_id.to_field(),\n                salted_initialization_hash.to_field()\n            ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n        )\n    }\n\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(salt : Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash([\n                salt,\n                initialization_hash,\n                portal_contract_address.to_field(),\n            ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash([\n                public_key.x,\n                public_key.y,\n            ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\npub fn compute_initialization_hash(selector: Field, args_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        selector,\n        args_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/address.nr"},"90":{"source":"use dep::std::array;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, N>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len, empty_value: T::empty() }\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, N>(array: [T; N]) where T: Empty + Eq {\n    let array_length = array.len();\n\n    let mut first_zero_pos = array_length;\n    let mut last_non_zero_pos = 0;\n\n    for i in 0..array_length {\n        let is_empty = is_empty(array[i]);\n        if !is_empty {\n            last_non_zero_pos = i;\n        } else if is_empty & (first_zero_pos == array_length) {\n            first_zero_pos = i;\n        }\n    }\n    assert((last_non_zero_pos as u64) <= (first_zero_pos as u64), \"invalid array\");\n}\n\n// Helper method to determine the number of non-zero/empty elements in a validated array (ie, validate_array(array) \n// should be true).\npub fn array_length<T, N>(array: [T; N]) -> Field where T: Empty + Eq {\n    let mut length = 0;\n    let mut end = false;\n    for elem in array {\n        end |= is_empty(elem);\n        if !end {\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_eq<T, N, S>(array: [T; N], expected: [T; S]) -> bool where T: Empty + Eq {\n    let mut eq = array_length(array) == S;\n\n    for i in 0..S {\n        eq &= array[i].eq(expected[i]);\n    }\n\n    eq\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array = [];\n    validate_array(valid_array);\n\n    let valid_array = [0];\n    validate_array(valid_array);\n\n    let valid_array = [1, 2, 3];\n    validate_array(valid_array);\n\n    let valid_array = [1, 2, 3, 0];\n    validate_array(valid_array);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    validate_array(valid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid() {\n    let invalid_array = [0, 1];\n    validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([]), 0);\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n    assert_eq(array_length([123, 0, 456]), 1);\n    assert_eq(array_length([0, 123, 0, 456]), 0);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/utils/arrays.nr"},"94":{"source":"use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u16 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/traits.nr"},"98":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::{ContractClassFunctionLeafPreimage, FunctionLeafPreimage};\nuse crate::contract_class::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n        ARGS_HASH_CHUNK_COUNT,\n        ARGS_HASH_CHUNK_LENGTH,\n        CONTRACT_TREE_HEIGHT, \n        FUNCTION_TREE_HEIGHT, \n        NOTE_HASH_TREE_HEIGHT,\n        NUM_FIELDS_PER_SHA256,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK,\n        GENERATOR_INDEX__CONSTRUCTOR,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__COMMITMENT_NONCE,\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/hash.nr"},"99":{"source":"use crate::abis::{\n    function_data::FunctionData,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n};\nuse crate::address::AztecAddress;\nuse crate::constants::{\n    GENERATOR_INDEX__CONTRACT_LEAF,\n};\nuse crate::traits::Hash;\n\nstruct ContractClassId {\n  inner: Field\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(artifact_hash: Field, private_functions_root: Field, public_bytecode_commitment: Field) -> Self {\n        let hash = dep::std::hash::pedersen_hash_with_separator([\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment,\n        ], GENERATOR_INDEX__CONTRACT_LEAF); // TODO(@spalladino): Update generator index\n        \n        ContractClassId::from_field(hash)\n    }\n\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_field(value : Field) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n\n    pub fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/contract_class.nr"},"101":{"source":"use crate::traits::{Serialize, Deserialize};\nuse dep::std::cmp::Eq;\n\nglobal GRUMPKIN_POINT_SERIALIZED_LEN: Field = 2;\n\nstruct GrumpkinPoint {\n    x: Field,\n    y: Field,\n}\n\nimpl Serialize<GRUMPKIN_POINT_SERIALIZED_LEN> for GrumpkinPoint {\n    fn serialize(self) -> [Field; GRUMPKIN_POINT_SERIALIZED_LEN] {\n        [self.x, self.y]\n    }\n}\n\nimpl Deserialize<GRUMPKIN_POINT_SERIALIZED_LEN> for GrumpkinPoint {\n    fn deserialize(serialized: [Field; GRUMPKIN_POINT_SERIALIZED_LEN]) -> Self {\n        Self {\n            x: serialized[0],\n            y: serialized[1],\n        }\n    }\n}\n\nimpl Eq for GrumpkinPoint {\n    fn eq(self, point: GrumpkinPoint) -> bool {\n        (point.x == self.x) & (point.y == self.y)\n    }\n}\n\nimpl GrumpkinPoint {\n    pub fn new(x: Field, y: Field) -> Self {\n        Self { x, y }\n    }\n\n    pub fn zero() -> Self {\n        Self {\n            x: 0,\n            y: 0,\n        }\n    }\n\n    pub fn is_zero(self) -> bool {\n        (self.x == 0) & (self.y == 0)\n    }\n\n    // TODO(David): Would be quite careful here as (0,0) is not a point\n    // on the curve. A boolean flag may be the better approach here,\n    // would also cost less constraints. It seems like we don't need to \n    // group arithmetic either. \n    fn assert_is_zero(self) {\n        assert(self.x == 0);\n        assert(self.y == 0);\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/grumpkin_point.nr"},"104":{"source":"use dep::std::{\n    cmp::Eq,\n    grumpkin_scalar::GrumpkinScalar,\n    grumpkin_scalar_mul::grumpkin_fixed_base,\n};\nuse crate::grumpkin_point::GrumpkinPoint;\n\nglobal GRUMPKIN_PRIVATE_KEY_SERIALIZED_LEN: Field = 2;\n\nstruct GrumpkinPrivateKey {\n    high: Field,\n    low: Field,\n}\n\nimpl Eq for GrumpkinPrivateKey {\n    fn eq(self, key: GrumpkinPrivateKey) -> bool {\n        (key.high == self.high) & (key.low == self.low)\n    }\n}\n\nimpl GrumpkinPrivateKey {\n    pub fn new(high: Field, low: Field) -> Self {\n        GrumpkinPrivateKey { high, low }\n    }\n\n    pub fn zero() -> Self {\n        Self {\n            high: 0,\n            low: 0,\n        }\n    }\n\n    pub fn is_zero(self) -> bool {\n        (self.high == 0) & (self.low == 0)\n    }\n\n    pub fn serialize(self) -> [Field; GRUMPKIN_PRIVATE_KEY_SERIALIZED_LEN] {\n        [self.high, self.low]\n    }\n\n    pub fn derive_public_key(self) -> GrumpkinPoint {\n        let public_key = grumpkin_fixed_base(GrumpkinScalar { high: self.high, low: self.low });\n        GrumpkinPoint { x: public_key[0], y: public_key[1] }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/grumpkin_private_key.nr"},"109":{"source":"use crate::common;\nuse dep::std::{\n    cmp::Eq,\n    option::Option,\n    unsafe,\n};\nuse dep::types::{\n    abis::{\n        call_request::CallRequest,\n        nullifier_key_validation_request::NullifierKeyValidationRequestContext,\n        previous_kernel_data::PreviousKernelData,\n        kernel_circuit_public_inputs::{\n            KernelCircuitPublicInputsBuilder,\n            KernelCircuitPublicInputsFinal,\n        },\n        side_effect::{SideEffect, SideEffectLinkedToNoteHash, Ordered},\n    },\n    constants::{\n        MAX_NEW_COMMITMENTS_PER_TX,\n        MAX_NEW_NULLIFIERS_PER_TX,\n        MAX_READ_REQUESTS_PER_TX,\n        MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX,\n        MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX\n    },\n    grumpkin_private_key::GrumpkinPrivateKey,\n    hash::{\n        compute_commitment_nonce,\n        compute_unique_siloed_commitment,\n    },\n    utils::{\n        arrays::{array_length, array_eq},\n    },\n    traits::{Empty, is_empty}\n};\n\nstruct PrivateKernelInputsOrdering {\n    previous_kernel: PreviousKernelData,\n    sorted_new_commitments: [SideEffect; MAX_NEW_COMMITMENTS_PER_TX],\n    sorted_new_commitments_indexes: [u32; MAX_NEW_COMMITMENTS_PER_TX],\n    read_commitment_hints: [Field; MAX_READ_REQUESTS_PER_TX],\n    sorted_new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_TX],\n    sorted_new_nullifiers_indexes: [u32; MAX_NEW_NULLIFIERS_PER_TX],\n    nullifier_commitment_hints: [Field; MAX_NEW_NULLIFIERS_PER_TX],\n    master_nullifier_secret_keys: [GrumpkinPrivateKey; MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX],\n}\n\nimpl PrivateKernelInputsOrdering {\n    fn validate_inputs(self) {\n        assert_eq(array_length(self.previous_kernel.public_inputs.end.private_call_stack), 0,\n            \"Private call stack must be empty when executing the ordering circuit\");\n    }\n\n    fn validate_nullifier_keys(self, public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n        let requests = self.previous_kernel.public_inputs.end.nullifier_key_validation_requests;\n        for i in 0..MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX {\n            let request = requests[i];\n            if !is_empty(request) {\n                let master_secret_key = self.master_nullifier_secret_keys[i];\n                let computed_public_key = master_secret_key.derive_public_key();\n                assert(computed_public_key.eq(request.public_key), \"Cannot derive nullifier public key from the master key.\");\n\n                let computed_secret_key = common::compute_siloed_nullifier_secret_key(master_secret_key, request.contract_address);\n                assert(computed_secret_key.eq(request.secret_key), \"Cannot derive siloed secret key from the master key.\");\n            }\n        }\n\n        // Empty out nullifier key validation requests after verifying them.\n        public_inputs.end.nullifier_key_validation_requests = BoundedVec::new(NullifierKeyValidationRequestContext::empty());\n    }\n\n    fn match_reads_to_commitments(self, public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n        let new_commitments = public_inputs.end.new_commitments;\n        let read_requests = public_inputs.end.read_requests;\n\n        // match reads to commitments from the previous call(s)\n        for rr_idx in 0..MAX_READ_REQUESTS_PER_TX {\n            let read_request = read_requests.get_unchecked(rr_idx);\n            let read_commitment_hint = self.read_commitment_hints[rr_idx] as u64;\n\n            if (read_request.value != 0) {\n                let commitment = new_commitments.get_unchecked(read_commitment_hint as Field);\n                assert_eq(read_request.value, commitment.value, \"Hinted commitment does not match read request\");\n                assert(read_request.counter > commitment.counter, \"Read request counter must be greater than commitment counter\");\n            }\n        }\n\n        // Empty out read requests after matching them to commitments\n        public_inputs.end.read_requests = BoundedVec::new(SideEffect::empty());\n    }\n\n    fn assert_sorted_counters<T, N>(original: [T; N], sorted: [T; N], indexes: [u32; N]) where T: Eq + Ordered + Empty {\n        let mut prev_was_empty = false;\n\n        for i in 0..N {\n            let item = if prev_was_empty {\n                sorted[i]\n            } else {\n                sorted[indexes[i]]\n            };\n            assert(item.eq(original[i]), \"Sorted item is not equal\");\n            let is_empty = is_empty(item);\n\n            if prev_was_empty {\n                assert(is_empty, \"Empty items must be at the end\");\n            } else if (i != 0) & !is_empty {\n                assert(sorted[i].counter() > sorted[i - 1].counter(), \"Not sorted\");\n            }\n\n            prev_was_empty = is_empty;\n        }\n    }\n\n    fn sort_arrays(self, public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n        PrivateKernelInputsOrdering::assert_sorted_counters(public_inputs.end.new_commitments.storage, self.sorted_new_commitments, self.sorted_new_commitments_indexes);\n        PrivateKernelInputsOrdering::assert_sorted_counters(public_inputs.end.new_nullifiers.storage, self.sorted_new_nullifiers, self.sorted_new_nullifiers_indexes);\n        public_inputs.end.new_commitments.storage = self.sorted_new_commitments;\n        public_inputs.end.new_nullifiers.storage = self.sorted_new_nullifiers;\n    }\n\n    fn match_nullifiers_to_commitments_and_squash(self, public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n        // Remark: The commitments in public_inputs.end have already been siloed by contract address!\n        // Match nullifiers/nullified_commitments to commitments from the previous call(s)\n        let mut new_commitments = public_inputs.end.new_commitments.storage;\n        let mut new_nullifiers = public_inputs.end.new_nullifiers.storage;\n\n        for n_idx in 0..MAX_NEW_NULLIFIERS_PER_TX {\n            let nullifier = new_nullifiers[n_idx];\n            // TODO - should not be able to squash the first nullifier.\n            let nullified_commitment = nullifier.note_hash;\n            let hint_pos = self.nullifier_commitment_hints[n_idx] as u64;\n\n            // Nullified_commitment of value `0` implies non-transient (persistable)\n            // nullifier in which case no attempt will be made to match it to a commitment.\n            // Non-empty nullified_commitment implies transient nullifier which MUST be matched to a commitment below!\n            // 0-valued nullified_commitment is empty and will be ignored\n            if nullified_commitment != 0 {\n                assert(hint_pos < MAX_NEW_COMMITMENTS_PER_TX as u64, \"New nullifier is transient but hint is invalid\");\n                let commitment = new_commitments[hint_pos];\n                assert_eq(nullified_commitment, commitment.value, \"Hinted commitment does not match\");\n                assert(nullifier.counter > commitment.counter, \"Nullifier counter must be greater than commitment counter\");\n                // match found!\n                // squash both the nullifier and the commitment\n                // (set to 0 here and then rearrange array after loop)\n                new_commitments[hint_pos] = SideEffect::empty();\n                new_nullifiers[n_idx as u64] = SideEffectLinkedToNoteHash::empty();\n            }\n            // non-transient (persistable) nullifiers are just kept in new_nullifiers array and forwarded\n            // to public inputs (used later by base rollup circuit)\n        }\n\n        // Move all zero-ed (removed) entries of these arrays to the end and preserve ordering of other entries\n\n        let mut new_commitments_vec = BoundedVec::new(SideEffect::empty());\n\n        for c_idx in 0..MAX_NEW_COMMITMENTS_PER_TX {\n            if new_commitments[c_idx].value != 0 {\n                new_commitments_vec.push(new_commitments[c_idx]);\n            }\n        }\n\n        public_inputs.end.new_commitments = new_commitments_vec;\n\n        let mut new_nullifiers_vec = BoundedVec::new(SideEffectLinkedToNoteHash::empty());\n\n        for n_idx in 0..MAX_NEW_NULLIFIERS_PER_TX {\n            if new_nullifiers[n_idx].value != 0 {\n                new_nullifiers_vec.push(new_nullifiers[n_idx]);\n            }\n        }\n\n        public_inputs.end.new_nullifiers = new_nullifiers_vec;\n    }\n\n    fn apply_commitment_nonces(public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n        // Remark: The commitments in public_inputs.end have already been siloed by contract address!\n        // tx hash\n        let first_nullifier = public_inputs.end.new_nullifiers.get(0);\n        let mut unique_commitments = public_inputs.end.new_commitments.storage;\n\n        for c_idx in 0..MAX_NEW_COMMITMENTS_PER_TX {\n            // Apply nonce to all non-zero/non-empty commitments\n            // Nonce is the hash of the first (0th) nullifier and the commitment's index into new_commitments array\n            let nonce = compute_commitment_nonce(first_nullifier.value, c_idx);\n            let commitment = unique_commitments[c_idx];\n            if commitment.value != 0 {\n                let unique_commitment = compute_unique_siloed_commitment(nonce, commitment.value);\n                unique_commitments[c_idx] = SideEffect{\n                    value: unique_commitment,\n                    counter: commitment.counter\n                };\n            }\n        }\n\n        public_inputs.end.new_commitments.storage = unique_commitments;\n    }\n\n    pub fn native_private_kernel_circuit_ordering(self) -> KernelCircuitPublicInputsFinal {\n        let mut public_inputs : KernelCircuitPublicInputsBuilder = unsafe::zeroed();\n        public_inputs.is_private = true;\n\n        self.validate_inputs();\n\n        common::validate_previous_kernel_values(self.previous_kernel.public_inputs.end);\n\n        // Do this before any functions can modify the inputs.\n        common::initialize_end_values(self.previous_kernel, &mut public_inputs);\n\n        self.validate_nullifier_keys(&mut public_inputs);\n\n        self.sort_arrays(&mut public_inputs);\n\n        self.match_reads_to_commitments(&mut public_inputs);\n\n        self.match_nullifiers_to_commitments_and_squash(&mut public_inputs);\n\n        PrivateKernelInputsOrdering::apply_commitment_nonces(&mut public_inputs);\n\n\n        public_inputs.to_final()\n    }\n}\n\nmod tests {\n    use dep::std::cmp::Eq;\n    use crate::private_kernel_ordering::PrivateKernelInputsOrdering;\n    use dep::types::constants::{\n        MAX_READ_REQUESTS_PER_TX,\n        MAX_NEW_COMMITMENTS_PER_TX,\n        MAX_NEW_NULLIFIERS_PER_TX,\n    };\n    use dep::types::{\n        abis::{\n            kernel_circuit_public_inputs::KernelCircuitPublicInputsFinal,\n            side_effect::{SideEffect, SideEffectLinkedToNoteHash, Ordered},\n        },\n        hash::compute_unique_siloed_commitments,\n        tests::previous_kernel_data_builder::PreviousKernelDataBuilder,\n        utils::{\n            arrays::{array_eq, array_length},\n        },\n        traits::{Empty, is_empty, is_empty_array}\n    };\n\n    struct PrivateKernelOrderingInputsBuilder {\n        previous_kernel: PreviousKernelDataBuilder,\n        read_commitment_hints: [Field; MAX_READ_REQUESTS_PER_TX],\n        nullifier_commitment_hints: [Field; MAX_NEW_NULLIFIERS_PER_TX],\n    }\n\n    impl PrivateKernelOrderingInputsBuilder {\n        pub fn new() -> Self {\n            PrivateKernelOrderingInputsBuilder {\n                previous_kernel: PreviousKernelDataBuilder::new(),\n                read_commitment_hints: [0; MAX_READ_REQUESTS_PER_TX],\n                nullifier_commitment_hints: [0; MAX_NEW_NULLIFIERS_PER_TX],\n            }\n        }\n\n        pub fn get_new_commitments(self) -> [SideEffect; MAX_NEW_COMMITMENTS_PER_TX] {\n            self.previous_kernel.end.new_commitments.storage\n        }\n\n        pub fn get_new_nullifiers(self) -> [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_TX] {\n            self.previous_kernel.end.new_nullifiers.storage\n        }\n\n        pub fn get_unique_siloed_commitments(self) -> [SideEffect; MAX_NEW_COMMITMENTS_PER_TX] {\n            self.compute_unique_siloed_commitments(self.previous_kernel.end.new_commitments.storage)\n        }\n\n        // A helper function that uses the first nullifer in the previous kernel to compute the unique siloed\n        // commitments for the given commitments.\n        pub fn compute_unique_siloed_commitments<N>(self, commitments: [SideEffect; N]) -> [SideEffect; N] {\n            let first_nullifier = self.previous_kernel.end.new_nullifiers.get_unchecked(0);\n            compute_unique_siloed_commitments(first_nullifier.value, commitments)\n        }\n\n        pub fn append_transient_commitments(&mut self, num_commitments: Field) {\n            // All new commitments aggregated in the previous kernel are transient commitments.\n            self.previous_kernel.append_new_commitments(num_commitments);\n        }\n\n        pub fn add_transient_read(&mut self, commitment_index: Field) {\n            let read_request_index = self.previous_kernel.add_read_request_for_transient_commitment(commitment_index);\n            self.read_commitment_hints[read_request_index] = commitment_index;\n        }\n\n        pub fn append_nullifiers(&mut self, num_nullifiers: Field) {\n            self.previous_kernel.append_new_nullifiers(num_nullifiers);\n        }\n\n        pub fn nullify_transient_commitment(&mut self, nullifier_index: Field, commitment_index: Field) {\n            self.previous_kernel.end.new_nullifiers.storage[nullifier_index].note_hash = self.previous_kernel.end.new_commitments.get(commitment_index).value;\n            self.nullifier_commitment_hints[nullifier_index] = commitment_index;\n        }\n\n        fn sort_sideffects<T, N>(original: [T; N]) -> ([T; N],[u32; N]) where T: Ordered + Eq + Empty {\n            let mut indexes = [0; N];\n            for i in 0..N {\n                indexes[i] = i as u32;\n            }\n            let sorted_indexes = indexes.sort_via(|a_index: u32, b_index: u32| {\n                let a = original[a_index];\n                let b = original[b_index];\n                if is_empty(b) {\n                    true\n                } else if is_empty(a) {\n                    false\n                } else {\n                    a.counter() < b.counter()\n                }\n            });\n            let sorted_sideffects = sorted_indexes.map(|i: u32| original[i]);\n            let mut reverse_map = [0; N];\n            for i in 0..N {\n                reverse_map[sorted_indexes[i]] = i;\n            }\n\n            (sorted_sideffects, reverse_map)\n        }\n\n        pub fn execute(self) -> KernelCircuitPublicInputsFinal {\n            let (sorted_new_commitments, sorted_new_commitments_indexes) = PrivateKernelOrderingInputsBuilder::sort_sideffects(self.get_new_commitments());\n            let mut sorted_read_commitment_hints = [0; MAX_READ_REQUESTS_PER_TX];\n            for i in 0..sorted_read_commitment_hints.len() {\n                sorted_read_commitment_hints[i] = sorted_new_commitments_indexes[self.read_commitment_hints[i]] as Field;\n            }\n            let (sorted_new_nullifiers, sorted_new_nullifiers_indexes) = PrivateKernelOrderingInputsBuilder::sort_sideffects(self.get_new_nullifiers());\n            let mut sorted_nullifier_commitment_hints = [0; MAX_NEW_NULLIFIERS_PER_TX];\n            for i in 0..sorted_nullifier_commitment_hints.len() {\n                sorted_nullifier_commitment_hints[i] = sorted_new_nullifiers_indexes[self.nullifier_commitment_hints[i]] as Field;\n            }\n            let kernel = PrivateKernelInputsOrdering {\n                previous_kernel: self.previous_kernel.finish(),\n                sorted_new_commitments,\n                sorted_new_commitments_indexes,\n                read_commitment_hints: sorted_read_commitment_hints,\n                sorted_new_nullifiers,\n                sorted_new_nullifiers_indexes,\n                nullifier_commitment_hints: sorted_nullifier_commitment_hints,\n                master_nullifier_secret_keys: dep::std::unsafe::zeroed(),\n            };\n            kernel.native_private_kernel_circuit_ordering()\n        }\n\n        pub fn failed(self) {\n            let _ = self.execute();\n        }\n    }\n\n    #[test]\n    unconstrained fn native_matching_one_read_request_to_commitment_works() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n\n        builder.append_transient_commitments(1);\n        builder.add_transient_read(0);\n\n        let unique_siloed_commitments = builder.get_unique_siloed_commitments();\n\n        let public_inputs = builder.execute();\n        assert(array_length(public_inputs.end.new_commitments) == 1);\n        assert(public_inputs.end.new_commitments[0].eq(unique_siloed_commitments[0]));\n    }\n\n    #[test]\n    unconstrained fn native_matching_some_read_requests_to_commitments_works() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_transient_commitments(MAX_NEW_COMMITMENTS_PER_TX);\n        // Read the commitment at index 1;\n        builder.add_transient_read(1);\n        // Read the commitment at index 3;\n        builder.add_transient_read(3);\n        let unique_siloed_commitments = builder.get_unique_siloed_commitments();\n        let public_inputs = builder.execute();\n        assert_eq(array_length(public_inputs.end.new_commitments), MAX_NEW_COMMITMENTS_PER_TX);\n        for i in 0..MAX_NEW_COMMITMENTS_PER_TX {\n            assert(public_inputs.end.new_commitments[i].eq(unique_siloed_commitments[i]));\n        }\n    }\n\n    #[test(should_fail_with=\"Hinted commitment does not match read request\")]\n    unconstrained fn native_read_request_unknown_fails() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_transient_commitments(1);\n        builder.add_transient_read(0);\n        // Tweak the read request so that it does not match the commitment at index 0;\n        let read_request = builder.previous_kernel.end.read_requests.pop();\n        builder.previous_kernel.end.read_requests.push(SideEffect { value: read_request.value + 1, counter: 0 });\n        builder.failed();\n    }\n\n    #[test]\n    unconstrained fn native_squash_one_of_one_transient_matches_works() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_transient_commitments(1);\n        builder.append_nullifiers(2);\n        // The nullifier at index 1 is nullifying the commitment at index 0;\n        builder.nullify_transient_commitment(1, 0);\n        let new_nullifiers = builder.get_new_nullifiers();\n        let public_inputs = builder.execute();\n        assert(is_empty_array(public_inputs.end.new_commitments));\n\n        // The nullifier at index 1 is chopped.\n        let expected_new_nullifiers = [new_nullifiers[0], new_nullifiers[2]];\n        assert(array_eq(public_inputs.end.new_nullifiers, expected_new_nullifiers));\n    }\n\n    #[test]\n    unconstrained fn native_squash_one_of_two_transient_matches_works() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_transient_commitments(2);\n        builder.append_nullifiers(2);\n        // The nullifier at index 1 is nullifying the commitment at index 0;\n        builder.nullify_transient_commitment(1, 0);\n        let new_commitments = builder.get_new_commitments();\n        // The 0th commitment will be chopped.\n        let unique_siloed_commitments = builder.compute_unique_siloed_commitments([new_commitments[1]]);\n        let new_nullifiers = builder.get_new_nullifiers();\n        let public_inputs = builder.execute();\n        assert(\n            array_eq(\n                public_inputs.end.new_commitments,\n                [unique_siloed_commitments[0]]\n            )\n        );\n        // The nullifier at index 1 is chopped.\n        let expected_new_nullifiers = [new_nullifiers[0], new_nullifiers[2]];\n        assert(array_eq(public_inputs.end.new_nullifiers, expected_new_nullifiers));\n    }\n\n    #[test]\n    unconstrained fn native_squash_two_of_two_transient_matches_works() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_transient_commitments(2);\n        builder.append_nullifiers(2);\n        // The nullifier at index 1 is nullifying the commitment at index 1;\n        builder.nullify_transient_commitment(1, 1);\n        // The nullifier at index 2 is nullifying the commitment at index 0;\n        builder.nullify_transient_commitment(2, 0);\n        let new_nullifiers = builder.get_new_nullifiers();\n        let public_inputs = builder.execute();\n        assert(is_empty_array(public_inputs.end.new_commitments));\n        assert(array_eq(public_inputs.end.new_nullifiers, [new_nullifiers[0]]));\n    }\n\n    #[test]\n    unconstrained fn ordering_of_commitments_and_nullifiers() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n\n        let mut sorted_new_commitments = [SideEffect::empty(); 10];\n        let mut sorted_new_nullifiers = [SideEffectLinkedToNoteHash::empty(); 10];\n\n        for i in 0..10 {\n            sorted_new_commitments[i] = SideEffect { value: (i + 1) as Field, counter: i + 1 };\n            sorted_new_nullifiers[i] = SideEffectLinkedToNoteHash { value: (i + 11) as Field, counter: i + 11, note_hash: 0 };\n        }\n\n        for i in 0..10 {\n            builder.previous_kernel.end.new_commitments.push(sorted_new_commitments[9 - i]);\n            builder.previous_kernel.end.new_nullifiers.push(sorted_new_nullifiers[9 - i]);\n        }\n\n        let public_inputs = builder.execute();\n\n        let sorted_unique_commitments = compute_unique_siloed_commitments(\n            public_inputs.end.new_nullifiers[0].value,\n            sorted_new_commitments\n        );\n\n        for i in 0..10 {\n            assert(public_inputs.end.new_commitments[i].eq(sorted_unique_commitments[i]));\n            // +1 due to the 0th nullifier being the tx hash\n            assert(public_inputs.end.new_nullifiers[i + 1].eq(sorted_new_nullifiers[i]));\n        }\n    }\n\n    #[test]\n    unconstrained fn native_empty_nullified_commitment_means_persistent_nullifier_0() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_transient_commitments(2);\n        builder.append_nullifiers(2);\n        let public_inputs = builder.execute();\n        assert_eq(array_length(public_inputs.end.new_commitments), 2);\n        assert_eq(array_length(public_inputs.end.new_nullifiers), 3);\n    }\n    // same as previous test, but this time there are 0 commitments!\n    // (Do we really need this test?)\n\n    #[test]\n    unconstrained fn native_empty_nullified_commitment_means_persistent_nullifier_1() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_nullifiers(2);\n        let public_inputs = builder.execute();\n        assert(array_length(public_inputs.end.new_commitments) == 0);\n        assert(array_length(public_inputs.end.new_nullifiers) == 3);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn invalid_nullifier_commitment_hint_fails() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_transient_commitments(1);\n        builder.append_nullifiers(1);\n        // The nullifier at index 1 is nullifying the commitment at index 0;\n        builder.nullify_transient_commitment(1, 0);\n        // Change the hint to be out of bounds.\n        builder.nullifier_commitment_hints[1] = MAX_NEW_COMMITMENTS_PER_TX;\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"Hinted commitment does not match\")]\n    unconstrained fn wrong_nullifier_commitment_hint_fails() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.append_transient_commitments(2);\n        builder.append_nullifiers(2);\n        // The nullifier at index 1 is nullifying the commitment at index 1;\n        builder.nullify_transient_commitment(1, 1);\n        // The nullifier at index 2 is nullifying the commitment at index 0;\n        builder.nullify_transient_commitment(2, 0);\n        // Tweak the hint to be for the commitment at index 1.\n        builder.nullifier_commitment_hints[2] = 1;\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"Private call stack must be empty when executing the ordering circuit\")]\n    unconstrained fn non_empty_private_call_stack_should_fail() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.previous_kernel.push_private_call_request(1, false);\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"The 0th nullifier in the accumulated nullifier array is zero\")]\n    unconstrained fn zero_0th_nullifier_fails() {\n        let mut builder = PrivateKernelOrderingInputsBuilder::new();\n        builder.previous_kernel.end.new_nullifiers = BoundedVec::new(SideEffectLinkedToNoteHash::empty());\n        builder.failed();\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/private-kernel-lib/src/private_kernel_ordering.nr"},"112":{"source":"use dep::std;\nuse dep::types::{\n    abis::{\n        call_request::CallRequest,\n        combined_accumulated_data::CombinedAccumulatedData,\n        function_data::FunctionData,\n        kernel_circuit_public_inputs::KernelCircuitPublicInputsBuilder,\n        membership_witness::ReadRequestMembershipWitness,\n        new_contract_data::NewContractData,\n        nullifier_key_validation_request::NullifierKeyValidationRequestContext,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_kernel::private_call_data::PrivateCallData,\n        previous_kernel_data::PreviousKernelData,\n        side_effect::{SideEffect, SideEffectLinkedToNoteHash},\n    },\n    address::{AztecAddress, EthAddress, PartialAddress, compute_initialization_hash},\n    contract_class::ContractClassId,\n    contrakt::deployment_data::ContractDeploymentData,\n    constants::{\n        MAX_NEW_NULLIFIERS_PER_CALL,\n        MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NEW_COMMITMENTS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n        MAX_READ_REQUESTS_PER_CALL,\n        MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL,\n    },\n    grumpkin_private_key::GrumpkinPrivateKey,\n    hash::{\n        compute_constructor_hash,\n        compute_l2_to_l1_hash,\n        compute_logs_hash,\n        compute_new_contract_address_hash,\n        contract_tree_root_from_siblings,\n        function_tree_root_from_siblings,\n        pedersen_hash,\n        private_functions_root_from_siblings,\n        read_request_root_from_siblings,\n        silo_commitment,\n        silo_nullifier,\n        stdlib_recursion_verification_key_compress_native_vk,\n    },\n    utils::{\n        arrays::{\n            array_length,\n            array_to_bounded_vec,\n            validate_array,\n        },\n    },\n    traits::{is_empty, is_empty_array},\n};\n\npub fn validate_arrays(app_public_inputs: PrivateCircuitPublicInputs) {\n    // Each of the following arrays is expected to be zero-padded.\n    // In addition, some of the following arrays (new_commitments, etc...) are passed\n    // to extend_from_array_to_array() routines which rely on the passed arrays to be well-formed.\n\n    validate_array(app_public_inputs.return_values);\n    validate_array(app_public_inputs.read_requests);\n    validate_array(app_public_inputs.nullifier_key_validation_requests);\n    validate_array(app_public_inputs.new_commitments);\n    validate_array(app_public_inputs.new_nullifiers);\n    validate_array(app_public_inputs.private_call_stack_hashes);\n    validate_array(app_public_inputs.public_call_stack_hashes);\n    validate_array(app_public_inputs.new_l2_to_l1_msgs);\n    // encrypted_logs_hash and unencrypted_logs_hash have their own integrity checks.\n}\n\n// Validate all read requests against the historical note hash tree root.\n// Use their membership witnesses to do so. If the historical root is not yet\n// initialized, initialize it using the first read request here (if present).\n//\n// More info here:\n// - https://discourse.aztec.network/t/to-read-or-not-to-read/178\n// - https://discourse.aztec.network/t/spending-notes-which-havent-yet-been-inserted/180\npub fn validate_read_requests(\n    historical_note_hash_tree_root: Field,\n    read_requests: [SideEffect; MAX_READ_REQUESTS_PER_CALL],\n    read_request_membership_witnesses: [ReadRequestMembershipWitness; MAX_READ_REQUESTS_PER_CALL]\n) {\n    // membership witnesses must resolve to the same note hash tree root\n    // for every request in all kernel iterations\n    for rr_idx in 0..MAX_READ_REQUESTS_PER_CALL {\n        let read_request = read_requests[rr_idx].value;\n        let witness = read_request_membership_witnesses[rr_idx];\n\n        // A pending commitment is the one that is not yet added to note hash tree\n        // A \"transient read\" is when we try to \"read\" a pending commitment within a transaction\n        // between function calls, as opposed to reading the outputs of a previous transaction\n        // which is a \"pending read\".\n        // A transient read is when we try to \"read\" a pending commitment\n        // We determine if it is a transient read depending on the leaf index from the membership witness\n        // Note that the Merkle membership proof would be null and void in case of an transient read\n        // but we use the leaf index as a placeholder to detect a 'pending note read'.\n\n        if (read_request != 0) & (witness.is_transient == false) {\n            let root_for_read_request = read_request_root_from_siblings(read_request, witness.leaf_index, witness.sibling_path);\n            assert(root_for_read_request == historical_note_hash_tree_root, \"note hash tree root mismatch\");\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1354): do we need to enforce\n            // that a non-transient read_request was derived from the proper/current contract address?\n        }\n    }\n}\n\npub fn initialize_end_values(\n    previous_kernel: PreviousKernelData,\n    public_inputs: &mut KernelCircuitPublicInputsBuilder\n) {\n    public_inputs.constants = previous_kernel.public_inputs.constants;\n\n    // Ensure the arrays are the same as previously, before we start pushing more data onto them in other\n    // functions within this circuit:\n    let start = previous_kernel.public_inputs.end;\n\n    public_inputs.end.read_requests = array_to_bounded_vec(start.read_requests);\n    public_inputs.end.nullifier_key_validation_requests = array_to_bounded_vec(start.nullifier_key_validation_requests);\n\n    public_inputs.end.new_commitments = array_to_bounded_vec(start.new_commitments);\n    public_inputs.end.new_nullifiers = array_to_bounded_vec(start.new_nullifiers);\n\n    public_inputs.end.private_call_stack = array_to_bounded_vec(start.private_call_stack);\n    public_inputs.end.public_call_stack = array_to_bounded_vec(start.public_call_stack);\n    public_inputs.end.new_l2_to_l1_msgs = array_to_bounded_vec(start.new_l2_to_l1_msgs);\n\n    public_inputs.end.encrypted_logs_hash = start.encrypted_logs_hash;\n    public_inputs.end.unencrypted_logs_hash = start.unencrypted_logs_hash;\n\n    public_inputs.end.encrypted_log_preimages_length = start.encrypted_log_preimages_length;\n    public_inputs.end.unencrypted_log_preimages_length = start.unencrypted_log_preimages_length;\n\n    public_inputs.end.new_contracts = array_to_bounded_vec(start.new_contracts);\n}\n\nfn perform_static_call_checks(private_call: PrivateCallData) {\n    let public_inputs = private_call.call_stack_item.public_inputs;\n    let is_static_call = public_inputs.call_context.is_static_call;\n    if is_static_call {\n        // No state changes are allowed for static calls:\n        assert(\n            is_empty_array(public_inputs.new_commitments), \"new_commitments must be empty for static calls\"\n        );\n        assert(\n            is_empty_array(public_inputs.new_nullifiers), \"new_nullifiers must be empty for static calls\"\n        );\n    }\n}\n\nfn is_valid_caller(request: CallRequest, private_call: PrivateCallData) -> bool {\n    let call_context = private_call.call_stack_item.public_inputs.call_context;\n    let valid_caller_context = request.caller_context.msg_sender.eq(call_context.msg_sender)\n        & request.caller_context.storage_contract_address.eq(call_context.storage_contract_address);\n    request.caller_contract_address.eq(private_call.call_stack_item.contract_address)\n        & (request.caller_context.is_empty() | valid_caller_context)\n}\n\nfn validate_call_requests<N>(\n    call_requests: BoundedVec<CallRequest, N>,\n    hashes: [Field; N],\n    private_call: PrivateCallData\n) {\n    assert_eq(\n        array_length(hashes), call_requests.len(), \"call requests length does not match the expected length\"\n    );\n    for i in 0..N {\n        let hash = hashes[i];\n        if hash != 0 {\n            let request = call_requests.get_unchecked(i);\n            assert_eq(request.hash, hash, \"call stack hash does not match call request hash\");\n            assert(is_valid_caller(request, private_call), \"invalid caller\");\n        }\n    }\n}\n\npub fn update_end_values(private_call: PrivateCallData, public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n    // If this call is a static call, certain operations are disallowed, such as creating new state.\n    perform_static_call_checks(private_call);\n\n    let private_call_public_inputs = private_call.call_stack_item.public_inputs;\n\n    let read_requests = private_call_public_inputs.read_requests;\n    let read_request_membership_witnesses = private_call.read_request_membership_witnesses;\n\n    let nullifier_key_validation_requests = private_call_public_inputs.nullifier_key_validation_requests;\n\n    let new_commitments = private_call_public_inputs.new_commitments;\n    let new_nullifiers = private_call_public_inputs.new_nullifiers;\n\n    let storage_contract_address = private_call_public_inputs.call_context.storage_contract_address;\n\n    // Transient read requests and witnesses are accumulated in public_inputs.end\n    // We silo the read requests (domain separation per contract address)\n    let mut siloed_read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL> = BoundedVec::new(SideEffect::empty());\n    for i in 0..MAX_READ_REQUESTS_PER_CALL {\n        let read_request = read_requests[i].value;\n        let witness = read_request_membership_witnesses[i];\n        if witness.is_transient & (read_request != 0) { // only forward transient to public inputs\n            siloed_read_requests.push(\n                SideEffect { counter: read_requests[i].counter, value: silo_commitment(storage_contract_address, read_request) }\n            )\n        }\n    }\n    public_inputs.end.read_requests.extend_from_bounded_vec(siloed_read_requests);\n\n    // Nullifier key validation requests.\n    for i in 0..MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL {\n        let request = nullifier_key_validation_requests[i];\n        if !is_empty(request) {\n            public_inputs.end.nullifier_key_validation_requests.push(request.to_context(storage_contract_address));\n        }\n    }\n\n    // Enhance commitments and nullifiers with domain separation whereby domain is the contract.\n    //\n    // nullifiers\n    let mut siloed_new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL> = BoundedVec::new(SideEffectLinkedToNoteHash::empty());\n    for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n        let new_nullifier = new_nullifiers[i];\n        if new_nullifier.value != 0 {\n            let siloed_note_hash = if new_nullifier.note_hash == 0 {\n                0\n            } else {\n                silo_commitment(storage_contract_address, new_nullifier.note_hash)\n            };\n            siloed_new_nullifiers.push(\n                SideEffectLinkedToNoteHash {\n                value: silo_nullifier(storage_contract_address, new_nullifier.value),\n                counter: new_nullifier.counter,\n                note_hash: siloed_note_hash\n            }\n            );\n        }\n    }\n    public_inputs.end.new_nullifiers.extend_from_bounded_vec(siloed_new_nullifiers);\n\n    // commitments\n    let mut siloed_new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL> = BoundedVec::new(SideEffect::empty());\n    for i in 0..MAX_NEW_COMMITMENTS_PER_CALL {\n        let new_commitment = new_commitments[i].value;\n        if new_commitment != 0 {\n            siloed_new_commitments.push(\n                SideEffect { value: silo_commitment(storage_contract_address, new_commitment), counter: new_commitments[i].counter }\n            );\n        }\n    }\n    public_inputs.end.new_commitments.extend_from_bounded_vec(siloed_new_commitments);\n\n    // Call stacks\n    // Private call stack.\n    let private_call_stack = array_to_bounded_vec(private_call.private_call_stack);\n    validate_call_requests(\n        private_call_stack,\n        private_call_public_inputs.private_call_stack_hashes,\n        private_call\n    );\n    public_inputs.end.private_call_stack.extend_from_bounded_vec(private_call_stack);\n    // Public call stack.\n    let public_call_stack = array_to_bounded_vec(private_call.public_call_stack);\n    validate_call_requests(\n        public_call_stack,\n        private_call_public_inputs.public_call_stack_hashes,\n        private_call\n    );\n    public_inputs.end.public_call_stack.extend_from_bounded_vec(public_call_stack);\n\n    // new l2 to l1 messages\n    let portal_contract_address = private_call.portal_contract_address;\n    let new_l2_to_l1_msgs = private_call_public_inputs.new_l2_to_l1_msgs;\n    let mut new_l2_to_l1_msgs_to_insert : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL> = BoundedVec::new(0);\n    for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n        let msg_is_zero = new_l2_to_l1_msgs[i] == 0;\n        if msg_is_zero == false {\n            let new_l2_to_l1_msgs = compute_l2_to_l1_hash(\n                storage_contract_address,\n                private_call_public_inputs.version,\n                portal_contract_address,\n                private_call_public_inputs.chain_id,\n                new_l2_to_l1_msgs[i]\n            );\n            new_l2_to_l1_msgs_to_insert.push(new_l2_to_l1_msgs)\n        }\n    }\n    public_inputs.end.new_l2_to_l1_msgs.extend_from_bounded_vec(new_l2_to_l1_msgs_to_insert);\n\n    // logs hashes\n    // See the following thread if not clear:\n    // https://discourse.aztec.network/t/proposal-forcing-the-sequencer-to-actually-submit-data-to-l1/426\n    let previous_encrypted_logs_hash = public_inputs.end.encrypted_logs_hash;\n    let current_encrypted_logs_hash = private_call_public_inputs.encrypted_logs_hash;\n    public_inputs.end.encrypted_logs_hash = compute_logs_hash(previous_encrypted_logs_hash,current_encrypted_logs_hash);\n    let previous_unencrypted_logs_hash = public_inputs.end.unencrypted_logs_hash;\n    let current_unencrypted_logs_hash = private_call_public_inputs.unencrypted_logs_hash;\n    public_inputs.end.unencrypted_logs_hash = compute_logs_hash(previous_unencrypted_logs_hash,current_unencrypted_logs_hash);\n\n    // Add log preimages lengths from current iteration to accumulated lengths\n    public_inputs.end.encrypted_log_preimages_length = public_inputs.end.encrypted_log_preimages_length +\n                                                           private_call_public_inputs.encrypted_log_preimages_length;\n    public_inputs.end.unencrypted_log_preimages_length = public_inputs.end.unencrypted_log_preimages_length + private_call_public_inputs.unencrypted_log_preimages_length;\n}\n\npub fn contract_logic(\n    private_call: PrivateCallData,\n    public_inputs: &mut KernelCircuitPublicInputsBuilder,\n    contract_dep_data: ContractDeploymentData,\n    function_data: FunctionData\n) {\n    let private_call_public_inputs = private_call.call_stack_item.public_inputs;\n    let portal_contract_address = private_call.portal_contract_address;\n    let contract_address = private_call.call_stack_item.contract_address;\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3062): Why is this using a hash function from the stdlib::recursion namespace\n    let private_call_vk_hash = stdlib_recursion_verification_key_compress_native_vk(private_call.vk);\n\n    let is_contract_deployment = public_inputs.constants.tx_context.is_contract_deployment_tx;\n\n    // input storage contract address must be 0 if its a constructor call and non-zero otherwise\n    if is_contract_deployment {\n        let computed_initialization_hash = compute_initialization_hash(\n            function_data.selector.to_field(),\n            private_call_public_inputs.args_hash\n        );\n\n        assert(\n            computed_initialization_hash == contract_dep_data.initialization_hash, \"initialization hash does not match computed one\"\n        );\n\n        let new_contract_address = AztecAddress::compute_from_public_key(\n            contract_dep_data.public_key,\n            contract_dep_data.contract_class_id,\n            contract_dep_data.contract_address_salt,\n            contract_dep_data.initialization_hash,\n            contract_dep_data.portal_contract_address\n        );\n\n        let new_contract_data = NewContractData {\n            contract_address: new_contract_address,\n            portal_contract_address,\n            contract_class_id: contract_dep_data.contract_class_id\n        };\n        public_inputs.end.new_contracts.push(new_contract_data);\n\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3062) VKs are mocked out for now\n        // assert(contract_dep_data.constructor_vk_hash == private_call_vk_hash, \"constructor_vk_hash doesn't match private_call_vk_hash\");\n\n        assert(\n            contract_address.eq(new_contract_address), \"contract address supplied does not match derived address\"\n        );\n\n        let new_contract_address_nullifier = compute_new_contract_address_hash(new_contract_address);\n\n        public_inputs.end.new_nullifiers.push(\n            SideEffectLinkedToNoteHash { value: new_contract_address_nullifier, note_hash: 0, counter: 1 }\n        );\n    } else {\n        // non-contract deployments must specify contract address being interacted with\n        assert(!contract_address.is_zero(), \"contract address cannot be zero\");\n        // std::println(f\"contract_address={contract_address}\");\n        // std::println(f\"private_call_vk_hash={private_call_vk_hash}\");\n\n        // Recompute the contract class id\n        let computed_private_functions_root = private_functions_root_from_siblings(\n            private_call.call_stack_item.function_data.selector,\n            private_call_vk_hash,\n            private_call.function_leaf_membership_witness.leaf_index,\n            private_call.function_leaf_membership_witness.sibling_path\n        );\n        // std::println(f\"computed_private_functions_root={computed_private_functions_root}\");\n\n        let computed_contract_class_id = ContractClassId::compute(\n            private_call.contract_class_artifact_hash,\n            computed_private_functions_root,\n            private_call.contract_class_public_bytecode_commitment\n        );\n        // std::println(f\"computed_contract_class_id={computed_contract_class_id}\");\n\n        // Recompute contract address using the preimage which includes the class_id\n        let computed_partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            computed_contract_class_id,\n            private_call.salted_initialization_hash\n        );\n        // std::println(f\"computed_partial_address={computed_partial_address}\");\n\n        let computed_address = AztecAddress::compute(private_call.public_keys_hash, computed_partial_address);\n        // std::println(f\"computed_address={computed_address}\");\n\n        assert(\n            computed_address.eq(contract_address), \"computed contract address does not match expected one\"\n        );\n    }\n}\n\npub fn validate_previous_kernel_values(end: CombinedAccumulatedData) {\n    assert(end.new_nullifiers[0].value != 0, \"The 0th nullifier in the accumulated nullifier array is zero\");\n}\n\npub fn validate_call_against_request(private_call: PrivateCallData, request: CallRequest) {\n    let call_stack_item = private_call.call_stack_item;\n    assert(\n        request.hash == call_stack_item.hash(), \"calculated private_call_hash does not match provided private_call_hash at the top of the call stack\"\n    );\n\n    let call_context = call_stack_item.public_inputs.call_context;\n\n    // Ensures that if the function is internal, only the contract itself can call it.\n    if call_stack_item.function_data.is_internal {\n        assert(\n            call_context.msg_sender.eq(call_context.storage_contract_address), \"call is internal but msg_sender is not self\"\n        );\n    }\n\n    if call_context.is_delegate_call {\n        let caller_context = request.caller_context;\n        assert(!caller_context.is_empty(), \"caller context cannot be empty for delegate calls\");\n        assert(\n            call_context.msg_sender.eq(caller_context.msg_sender), \"call stack msg_sender does not match expected msg_sender for delegate calls\"\n        );\n        assert(\n            call_context.storage_contract_address.eq(caller_context.storage_contract_address), \"call stack storage address does not match expected contract address for delegate calls\"\n        );\n        assert(\n            !call_stack_item.contract_address.eq(call_context.storage_contract_address), \"curent contract address must not match storage contract address for delegate calls\"\n        );\n    } else {\n        let caller_contract_address = request.caller_contract_address;\n        assert(\n            call_context.msg_sender.eq(caller_contract_address), \"call stack msg_sender does not match caller contract address\"\n        );\n        assert(\n            call_context.storage_contract_address.eq(call_stack_item.contract_address), \"call stack storage address does not match expected contract address\"\n        );\n    }\n}\n\nfn field_to_grumpkin_private_key(val: Field) -> GrumpkinPrivateKey {\n    let bytes = val.to_be_bytes(32);\n    let mut v = 1;\n    let mut high = 0;\n    let mut low = 0;\n\n    for i in 0..16 {\n        high = high + (bytes[15 - i] as Field) * v;\n        low = low + (bytes[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    GrumpkinPrivateKey { high, low }\n}\n\npub fn compute_siloed_nullifier_secret_key(secret_key: GrumpkinPrivateKey, contract_address: AztecAddress) -> GrumpkinPrivateKey {\n    // TODO: Temporary hack. Should replace it with a secure way to derive the secret key.\n    // Match the way keys are derived in circuits.js/src/keys/index.ts\n    let hash = pedersen_hash(\n        [secret_key.high, secret_key.low, contract_address.to_field()],\n        0\n    );\n    field_to_grumpkin_private_key(hash)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/private-kernel-lib/src/common.nr"},"118":{"source":"use dep::private_kernel_lib::PrivateKernelInputsOrdering;\nuse dep::types::KernelCircuitPublicInputsFinal;\n\nunconstrained fn main(input: PrivateKernelInputsOrdering) -> distinct pub KernelCircuitPublicInputsFinal {\n    input.native_private_kernel_circuit_ordering()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/private-kernel-ordering-simulated/src/main.nr"}}}