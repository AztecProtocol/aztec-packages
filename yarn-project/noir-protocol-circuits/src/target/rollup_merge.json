{"noir_version":"0.23.0+f1b91511124df89bbe9e059b87536901bdf0d6f3","hash":2649556954082081384,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"rollup_lib::merge::merge_rollup_inputs::MergeRollupInputs","fields":[{"name":"previous_rollup_data","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"rollup_lib::abis::previous_rollup_data::PreviousRollupData","fields":[{"name":"base_or_merge_rollup_public_inputs","type":{"kind":"struct","path":"rollup_lib::abis::base_or_merge_rollup_public_inputs::BaseOrMergeRollupPublicInputs","fields":[{"name":"rollup_type","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"rollup_subtree_height","type":{"kind":"field"}},{"name":"aggregation_object","type":{"kind":"struct","path":"rollup_lib::types::mocked::AggregationObject","fields":[]}},{"name":"constants","type":{"kind":"struct","path":"rollup_lib::abis::constant_rollup_data::ConstantRollupData","fields":[{"name":"last_archive","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_kernel_vk_tree_root","type":{"kind":"field"}},{"name":"public_kernel_vk_tree_root","type":{"kind":"field"}},{"name":"base_rollup_vk_hash","type":{"kind":"field"}},{"name":"merge_rollup_vk_hash","type":{"kind":"field"}},{"name":"global_variables","type":{"kind":"struct","path":"rollup_lib::types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"rollup_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"rollup_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"start","type":{"kind":"struct","path":"rollup_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"end","type":{"kind":"struct","path":"rollup_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"calldata_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"proof","type":{"kind":"struct","path":"rollup_lib::types::mocked::Proof","fields":[]}},{"name":"vk","type":{"kind":"struct","path":"rollup_lib::types::mocked::VerificationKey","fields":[]}},{"name":"vk_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"vk_sibling_path","type":{"kind":"struct","path":"rollup_lib::types::abis::membership_witness::VKMembershipWitness","fields":[{"name":"leaf_index","type":{"kind":"field"}},{"name":"sibling_path","type":{"kind":"array","length":8,"type":{"kind":"field"}}}]}}]}}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":84}]},"return_type":{"abi_type":{"kind":"struct","path":"rollup_lib::abis::base_or_merge_rollup_public_inputs::BaseOrMergeRollupPublicInputs","fields":[{"name":"rollup_type","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"rollup_subtree_height","type":{"kind":"field"}},{"name":"aggregation_object","type":{"kind":"struct","path":"rollup_lib::types::mocked::AggregationObject","fields":[]}},{"name":"constants","type":{"kind":"struct","path":"rollup_lib::abis::constant_rollup_data::ConstantRollupData","fields":[{"name":"last_archive","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_kernel_vk_tree_root","type":{"kind":"field"}},{"name":"public_kernel_vk_tree_root","type":{"kind":"field"}},{"name":"base_rollup_vk_hash","type":{"kind":"field"}},{"name":"merge_rollup_vk_hash","type":{"kind":"field"}},{"name":"global_variables","type":{"kind":"struct","path":"rollup_lib::types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"rollup_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"rollup_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"start","type":{"kind":"struct","path":"rollup_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"end","type":{"kind":"struct","path":"rollup_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"calldata_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]},"visibility":"public"},"return_witnesses":[232,233,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,64,65,66,67,68,69,70,71,234,235]},"bytecode":"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","debug_symbols":"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","file_map":{"19":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"40":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\n\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo,hi)\n    }\n\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1; \n        if N <= 18 {\n            for i in 0..N-2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N-1 {           \n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            if ascii < 71 {\n                ascii - 55\n            } else {\n                ascii - 87\n            }\n            \n        } as Field\n    }\n\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if self < b {\n            (U128::from_u64s_le(0, 0), self)\n        } else {\n            //TODO check if this can overflow?\n            let (q,r) = self.unconstrained_div(b * U128::from_u64s_le(2,0));\n            let q_mul_2 = q * U128::from_u64s_le(2,0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::from_u64s_le(1,0), r - b)\n            }\n\n        }  \n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f-lo) / pow64;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo+self.hi*pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64))as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift left with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift right with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n","path":"std/uint128.nr"},"92":{"source":"// This is a quick struct made to pack 32 bytes into 4 u64s\n// and then pack those into two u128s.\n//\n// Creating a u256 was made for convenience.\n//\n// This is needed because in the cpp code, we have accumulate_sha256\n// which returns 2 field elements, one for the high and low limb.\nstruct U256 {\n    // This is in big-endian order, typically because\n    // sha256 is usually in big endian order.\n    // Note: this means that inner[0] has the most significant 64 bits.\n    inner : [u64; 4]\n}\n\nimpl U256 {\n    pub fn from_bytes32(bytes : [u8;32]) -> U256 {\n        // We use addition rather than a bitwise OR as the bitshifts ensure that none of the bytes overlap each other.\n        let high_0 = ((bytes[0] as u64) << 56)\n                + ((bytes[1] as u64) << 48)\n                + ((bytes[2] as u64) << 40)\n                + ((bytes[3] as u64) << 32)\n                + ((bytes[4] as u64) << 24)\n                + ((bytes[5] as u64) << 16)\n                + ((bytes[6] as u64) << 8)\n                +  (bytes[7] as u64);\n        \n        let high_1 = ((bytes[8] as u64) << 56)\n                + ((bytes[9] as u64) << 48)\n                + ((bytes[10] as u64) << 40)\n                + ((bytes[11] as u64) << 32)\n                + ((bytes[12] as u64) << 24)\n                + ((bytes[13] as u64) << 16)\n                + ((bytes[14] as u64) << 8)\n                +  (bytes[15] as u64);\n        \n        let low_0 = ((bytes[16] as u64) << 56)\n                + ((bytes[17] as u64) << 48)\n                + ((bytes[18] as u64) << 40)\n                + ((bytes[19] as u64) << 32)\n                + ((bytes[20] as u64) << 24)\n                + ((bytes[21] as u64) << 16)\n                + ((bytes[22] as u64) << 8)\n                +  (bytes[23] as u64);\n        \n        let low_1 = ((bytes[24] as u64) << 56)\n                + ((bytes[25] as u64) << 48)\n                + ((bytes[26] as u64) << 40)\n                + ((bytes[27] as u64) << 32)\n                + ((bytes[28] as u64) << 24)\n                + ((bytes[29] as u64) << 16)\n                + ((bytes[30] as u64) << 8)\n                +  (bytes[31] as u64);\n\n        U256{inner : [high_0, high_1, low_0, low_1]}\n    }\n\n    // We cannot represent u128 in the type system\n    // so we cannot return a u128 type.\n    // \n    // This as conversion assumes that Field can store 128 bits of information\n    // or else the conversion is lossy.\n    //\n    // TODO: Add a test for this.\n    pub fn to_u128_limbs(self) -> [Field;2] {\n        let two_pow_64 = 2.pow_32(64);\n\n        let high = (self.inner[0] as Field) * two_pow_64 + self.inner[1] as Field;\n        let low  = (self.inner[2] as Field) * two_pow_64 + self.inner[3] as Field;\n        \n        [high,low]\n    }\n}\n\n#[test]\nfn smoke_u256_from_bytes32_all_zeroes() {\n    let input = [0; 32];\n    let result = U256::from_bytes32(input);\n    assert(result.inner[0] == 0);\n    assert(result.inner[1] == 0);\n    assert(result.inner[2] == 0);\n    assert(result.inner[3] == 0);\n}\n\n#[test]\nfn smoke_u256_from_bytes32_one_zero_zero_zero() {\n    // We want to output [1,0,0,0]\n    let input = [\n        0, 0, 0, 0, 0, 0, 0, 1,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    ];\n    let result = U256::from_bytes32(input);\n\n    assert(result.inner[0] == 1);\n    assert(result.inner[1] == 0);\n    assert(result.inner[2] == 0);\n    assert(result.inner[3] == 0);\n}\n\n#[test]\nfn smoke_u256_from_bytes32_test() {\n    /*\n    input:  [   0xAA, 0xBB, 0xCC, 0xDD, \n                0xEE, 0xFF, 0x00, 0x11, \n                0x22, 0x33, 0x44, 0x55, \n                0x66, 0x77, 0x88, 0x99, \n                0x11, 0x22, 0x33, 0x44, \n                0x55, 0x66, 0x77, 0x88, \n                0x99, 0xAA, 0xBB, 0xCC, \n                0xDD, 0xEE, 0xFF, 0x00\n            ]\n    output: inner[0]: 0xAABBCCDDEEFF0011\n            inner[1]: 0x2233445566778899\n            inner[2]: 0x1122334455667788\n            inner[3]: 0x99AABBCCDDEEFF00\n    */\n    let input : [u8;32] = [\n        0xAA, 0xBB, 0xCC, 0xDD,\n        0xEE, 0xFF, 0x00, 0x11,\n        0x22, 0x33, 0x44, 0x55,\n        0x66, 0x77, 0x88, 0x99,\n        0x11, 0x22, 0x33, 0x44,\n        0x55, 0x66, 0x77, 0x88,\n        0x99, 0xAA, 0xBB, 0xCC,\n        0xDD, 0xEE, 0xFF, 0x00\n    ];\n    let result = U256::from_bytes32(input);\n\n    assert(result.inner[0] == 0xAABBCCDDEEFF0011);\n    assert(result.inner[1] == 0x2233445566778899);\n    assert(result.inner[2] == 0x1122334455667788);\n    assert(result.inner[3] == 0x99AABBCCDDEEFF00);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/utils/uint256.nr"},"98":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::{ContractClassFunctionLeafPreimage, FunctionLeafPreimage};\nuse crate::contract_class::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n        ARGS_HASH_CHUNK_COUNT,\n        ARGS_HASH_CHUNK_LENGTH,\n        CONTRACT_TREE_HEIGHT, \n        FUNCTION_TREE_HEIGHT, \n        NOTE_HASH_TREE_HEIGHT,\n        NUM_FIELDS_PER_SHA256,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK,\n        GENERATOR_INDEX__CONSTRUCTOR,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__COMMITMENT_NONCE,\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/hash.nr"},"136":{"source":"use crate::abis::previous_rollup_data::PreviousRollupData;\nuse crate::abis::base_or_merge_rollup_public_inputs::{BaseOrMergeRollupPublicInputs, MERGE_ROLLUP_TYPE};\nuse crate::components;\n\nstruct MergeRollupInputs{\n    // TODO(Kev): Why is this 2?\n    previous_rollup_data : [PreviousRollupData; 2]\n}\n\nimpl MergeRollupInputs {\n    pub fn merge_rollup_circuit(self) -> BaseOrMergeRollupPublicInputs {\n\n        // TODO(Lasse): Verify the previous rollup proofs\n        // TODO(Lasse): Check both previous rollup vks (in previous_rollup_data) against the permitted set of kernel vks.\n        // we don't have a set of permitted kernel vks yet.\n\n        let left = self.previous_rollup_data[0].base_or_merge_rollup_public_inputs;\n        let right = self.previous_rollup_data[1].base_or_merge_rollup_public_inputs;\n\n        // check that both input proofs are either both \"BASE\" or \"MERGE\" and not a mix!\n        // this prevents having wonky commitment, nullifier and contract subtrees.\n        let aggregation_object = components::aggregate_proofs(left, right);\n        components::assert_both_input_proofs_of_same_rollup_type(left, right);\n        let current_height = components::assert_both_input_proofs_of_same_height_and_return(left, right);\n        components::assert_equal_constants(left, right);\n        components::assert_prev_rollups_follow_on_from_each_other(left, right);\n\n        // compute calldata hash:\n        let new_calldata_hash = components::compute_calldata_hash(self.previous_rollup_data);\n\n        let public_inputs = BaseOrMergeRollupPublicInputs {\n            rollup_type : MERGE_ROLLUP_TYPE,\n            rollup_subtree_height : current_height + 1,\n            aggregation_object : aggregation_object,\n            constants : left.constants,\n            start : left.start,\n            end : right.end,\n            calldata_hash : new_calldata_hash,\n        };\n\n        public_inputs\n    }\n}\n\nmod tests {\n    use crate::{\n        merge::merge_rollup_inputs::MergeRollupInputs,\n        tests::merge_rollup_inputs::default_merge_rollup_inputs,\n    };\n    use dep::types::hash::accumulate_sha256;\n\n    #[test(should_fail_with=\"input proofs are of different rollup types\")]\n    fn different_rollup_type_fails() {\n        let mut inputs = default_merge_rollup_inputs();\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.rollup_type = 0;\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.rollup_type = 1;\n        let _output = inputs.merge_rollup_circuit();\n    }\n\n    #[test(should_fail_with=\"input proofs are of different rollup heights\")]\n    fn different_height_fails() {\n        let mut inputs = default_merge_rollup_inputs();\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.rollup_subtree_height = 0;\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.rollup_subtree_height = 1;\n        let _output = inputs.merge_rollup_circuit();\n    }\n\n    #[test(should_fail_with=\"input proofs have different constants\")]\n    fn constants_different_fails() {\n        let mut inputs = default_merge_rollup_inputs();\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.constants.public_kernel_vk_tree_root = 1;\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.constants.public_kernel_vk_tree_root = 0;\n        let _output = inputs.merge_rollup_circuit();\n    }\n\n    #[test(should_fail_with=\"input proofs have different constants\")]\n    fn constants_different_chain_id_fails() {\n        let mut inputs = default_merge_rollup_inputs();\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.constants.global_variables.chain_id = 1;\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.constants.global_variables.chain_id = 0;\n        let _output = inputs.merge_rollup_circuit();\n    }\n\n    #[test(should_fail_with=\"input proofs have different note hash tree snapshots\")]\n    fn previous_rollups_dont_follow_note_hash() {\n        let mut inputs = default_merge_rollup_inputs();\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.end.note_hash_tree.root = 0;\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.start.note_hash_tree.root = 1;\n        let _output = inputs.merge_rollup_circuit();\n    }\n\n    #[test(should_fail_with=\"input proofs have different nullifier tree snapshots\")]\n    fn previous_rollups_dont_follow_nullifier() {\n        let mut inputs = default_merge_rollup_inputs();\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.end.nullifier_tree.root = 0;\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.start.nullifier_tree.root = 1;\n        let _output = inputs.merge_rollup_circuit();\n    }\n\n    #[test(should_fail_with=\"input proofs have different contract tree snapshots\")]\n    fn previous_rollups_dont_follow_contracts() {\n        let mut inputs = default_merge_rollup_inputs();\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.end.contract_tree.root = 0;\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.start.contract_tree.root = 1;\n        let _output = inputs.merge_rollup_circuit();\n    }\n\n    #[test]\n    fn rollup_fields_are_set_correctly() {\n        let mut inputs = default_merge_rollup_inputs();\n        let mut outputs = inputs.merge_rollup_circuit();\n        assert_eq(outputs.rollup_type, 1);\n        assert_eq(\n            outputs.rollup_subtree_height, inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.rollup_subtree_height + 1\n        );\n\n        // set inputs to have a merge rollup type and set the rollup height and test again.\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.rollup_type = 1;\n        inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.rollup_subtree_height = 1;\n\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.rollup_type = 1;\n        inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.rollup_subtree_height = 1;\n\n        outputs = inputs.merge_rollup_circuit();\n        assert_eq(outputs.rollup_type, 1);\n        assert_eq(outputs.rollup_subtree_height, 2);\n    }\n\n    #[test]\n    fn start_and_end_partial_states() {\n        let mut inputs = default_merge_rollup_inputs();\n        let outputs = inputs.merge_rollup_circuit();\n\n        assert(outputs.start.eq(inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.start));\n        assert(outputs.end.eq(inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.end));\n    }\n\n    #[test]\n    fn calldata_hash() {\n        let mut inputs = default_merge_rollup_inputs();\n        let expected_calldata_hash = accumulate_sha256(\n            [\n            U128::from_integer(0),\n            U128::from_integer(1),\n            U128::from_integer(2),\n            U128::from_integer(3)\n        ]\n        );\n        let outputs = inputs.merge_rollup_circuit();\n\n        assert_eq(outputs.calldata_hash, expected_calldata_hash);\n    }\n\n    #[test]\n    fn constants_dont_change() {\n        let mut inputs = default_merge_rollup_inputs();\n        let outputs = inputs.merge_rollup_circuit();\n\n        assert(\n            inputs.previous_rollup_data[0].base_or_merge_rollup_public_inputs.constants.eq(outputs.constants)\n        );\n        assert(\n            inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.constants.eq(outputs.constants)\n        );\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/merge/merge_rollup_inputs.nr"},"149":{"source":"use crate::abis::base_or_merge_rollup_public_inputs::BaseOrMergeRollupPublicInputs;\nuse dep::types::mocked::AggregationObject;\nuse dep::types::hash::{accumulate_sha256, assert_check_membership, root_from_sibling_path};\nuse dep::types::constants::NUM_FIELDS_PER_SHA256;\nuse crate::abis::previous_rollup_data::PreviousRollupData;\nuse dep::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot;\n\n/**\n * Create an aggregation object for the proofs that are provided\n *          - We add points P0 for each of our proofs\n *          - We add points P1 for each of our proofs\n *          - We concat our public inputs\n * TODO(Kev): This seems similar to the aggregate_proof method in the private-kernel-lib\n */\npub fn aggregate_proofs(\n    left: BaseOrMergeRollupPublicInputs,\n    _right: BaseOrMergeRollupPublicInputs\n) -> AggregationObject {\n    // TODO: Similar to cpp code this does not do anything.\n    left.aggregation_object\n}\n\n/**\n * Asserts that the rollup types are the same. \n * Either both merge or both base\n */\npub fn assert_both_input_proofs_of_same_rollup_type(\n    left: BaseOrMergeRollupPublicInputs,\n    right: BaseOrMergeRollupPublicInputs\n) {\n    assert(left.rollup_type == right.rollup_type, \"input proofs are of different rollup types\");\n}\n\n/**\n * Asserts that the rollup subtree heights are the same and returns the height\n * Returns the height of the rollup subtrees\n */\npub fn assert_both_input_proofs_of_same_height_and_return(\n    left: BaseOrMergeRollupPublicInputs,\n    right: BaseOrMergeRollupPublicInputs\n) -> Field {\n    assert(\n        left.rollup_subtree_height == right.rollup_subtree_height, \"input proofs are of different rollup heights\"\n    );\n    left.rollup_subtree_height\n}\n\n/**\n * Asserts that the constants used in the left and right child are identical\n *\n */\npub fn assert_equal_constants(\n    left: BaseOrMergeRollupPublicInputs,\n    right: BaseOrMergeRollupPublicInputs\n) {\n    assert(left.constants.eq(right.constants), \"input proofs have different constants\");\n}\n\n// asserts that the end snapshot of previous_rollup 0 equals the start snapshot of previous_rollup 1 (i.e. ensure they\n// follow on from one-another). Ensures that right uses the tres that was updated by left.\npub fn assert_prev_rollups_follow_on_from_each_other(\n    left: BaseOrMergeRollupPublicInputs,\n    right: BaseOrMergeRollupPublicInputs\n) {\n    assert(\n        left.end.note_hash_tree.eq(right.start.note_hash_tree), \"input proofs have different note hash tree snapshots\"\n    );\n    assert(\n        left.end.nullifier_tree.eq(right.start.nullifier_tree), \"input proofs have different nullifier tree snapshots\"\n    );\n    assert(\n        left.end.contract_tree.eq(right.start.contract_tree), \"input proofs have different contract tree snapshots\"\n    );\n    assert(\n        left.end.public_data_tree.eq(right.start.public_data_tree), \"input proofs have different public data tree snapshots\"\n    );\n}\n\n/**\n * @brief From two previous rollup data, compute a single calldata hash\n *\n * @param previous_rollup_data\n * @return calldata hash stored in 2 fields\n */\npub fn compute_calldata_hash(previous_rollup_data: [PreviousRollupData; 2]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_rollup_data[0].base_or_merge_rollup_public_inputs.calldata_hash[0]),\n        U128::from_integer(previous_rollup_data[0].base_or_merge_rollup_public_inputs.calldata_hash[1]),\n        U128::from_integer(previous_rollup_data[1].base_or_merge_rollup_public_inputs.calldata_hash[0]),\n        U128::from_integer(previous_rollup_data[1].base_or_merge_rollup_public_inputs.calldata_hash[1])\n    ]\n    )\n}\n\npub fn insert_subtree_to_snapshot_tree<N>(\n    snapshot: AppendOnlyTreeSnapshot,\n    siblingPath: [Field; N],\n    emptySubtreeRoot: Field,\n    subtreeRootToInsert: Field,\n    subtreeDepth: u8\n) -> AppendOnlyTreeSnapshot {\n    // TODO(Lasse): Sanity check len of siblingPath > height of subtree\n    // TODO(Lasse): Ensure height of subtree is correct (eg 3 for commitments, 1 for contracts)\n    let leafIndexAtDepth = snapshot.next_available_leaf_index >> (subtreeDepth as u32);\n\n    // Check that the current root is correct and that there is an empty subtree at the insertion location\n    assert_check_membership(\n        emptySubtreeRoot,\n        leafIndexAtDepth as Field,\n        siblingPath,\n        snapshot.root\n    );\n\n    // if index of leaf is x, index of its parent is x/2 or x >> 1. We need to find the parent `subtreeDepth` levels up.\n    let new_root = root_from_sibling_path(subtreeRootToInsert, leafIndexAtDepth as Field, siblingPath);\n\n    // 2^subtreeDepth is the number of leaves added. 2^x = 1 << x\n    let new_next_available_leaf_index = (snapshot.next_available_leaf_index as u64) + (1 << (subtreeDepth as u64));\n\n    AppendOnlyTreeSnapshot { root: new_root, next_available_leaf_index: new_next_available_leaf_index as u32 }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/components.nr"},"151":{"source":"use dep::rollup_lib::merge::{MergeRollupInputs,BaseOrMergeRollupPublicInputs};\n\nfn main(inputs: MergeRollupInputs) -> pub BaseOrMergeRollupPublicInputs {\n    inputs.merge_rollup_circuit()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/rollup-merge/src/main.nr"}}}