{"noir_version":"0.23.0+f1b91511124df89bbe9e059b87536901bdf0d6f3","hash":2706808969326426587,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"rollup_lib::root::root_rollup_inputs::RootRollupInputs","fields":[{"name":"previous_rollup_data","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"rollup_lib::abis::previous_rollup_data::PreviousRollupData","fields":[{"name":"base_or_merge_rollup_public_inputs","type":{"kind":"struct","path":"rollup_lib::abis::base_or_merge_rollup_public_inputs::BaseOrMergeRollupPublicInputs","fields":[{"name":"rollup_type","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"rollup_subtree_height","type":{"kind":"field"}},{"name":"aggregation_object","type":{"kind":"struct","path":"rollup_lib::types::mocked::AggregationObject","fields":[]}},{"name":"constants","type":{"kind":"struct","path":"rollup_lib::abis::constant_rollup_data::ConstantRollupData","fields":[{"name":"last_archive","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_kernel_vk_tree_root","type":{"kind":"field"}},{"name":"public_kernel_vk_tree_root","type":{"kind":"field"}},{"name":"base_rollup_vk_hash","type":{"kind":"field"}},{"name":"merge_rollup_vk_hash","type":{"kind":"field"}},{"name":"global_variables","type":{"kind":"struct","path":"rollup_lib::types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"rollup_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"rollup_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"start","type":{"kind":"struct","path":"rollup_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"end","type":{"kind":"struct","path":"rollup_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"calldata_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"proof","type":{"kind":"struct","path":"rollup_lib::types::mocked::Proof","fields":[]}},{"name":"vk","type":{"kind":"struct","path":"rollup_lib::types::mocked::VerificationKey","fields":[]}},{"name":"vk_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"vk_sibling_path","type":{"kind":"struct","path":"rollup_lib::types::abis::membership_witness::VKMembershipWitness","fields":[{"name":"leaf_index","type":{"kind":"field"}},{"name":"sibling_path","type":{"kind":"array","length":8,"type":{"kind":"field"}}}]}}]}}},{"name":"new_l1_to_l2_messages","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"new_l1_to_l2_message_tree_root_sibling_path","type":{"kind":"array","length":12,"type":{"kind":"field"}}},{"name":"start_l1_to_l2_message_tree_snapshot","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"start_archive_snapshot","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"new_archive_sibling_path","type":{"kind":"array","length":16,"type":{"kind":"field"}}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":132}]},"return_type":{"abi_type":{"kind":"struct","path":"rollup_lib::root::root_rollup_public_inputs::RootRollupPublicInputs","fields":[{"name":"aggregation_object","type":{"kind":"struct","path":"rollup_lib::types::mocked::AggregationObject","fields":[]}},{"name":"archive","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"header","type":{"kind":"struct","path":"rollup_lib::types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"rollup_lib::types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"rollup_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"rollup_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"rollup_lib::types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"rollup_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"rollup_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"l1_to_l2_messages_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]},"visibility":"public"},"return_witnesses":[582,585,2,3,420,421,268,271,64,65,66,67,68,69,70,71,8,9,10,11,12,13,1158,1159]},"bytecode":"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","debug_symbols":"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","file_map":{"19":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"27":{"source":"mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [u8; N], _state_length: u32) -> [u8; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n","path":"std/hash.nr"},"40":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\n\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo,hi)\n    }\n\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1; \n        if N <= 18 {\n            for i in 0..N-2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N-1 {           \n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            if ascii < 71 {\n                ascii - 55\n            } else {\n                ascii - 87\n            }\n            \n        } as Field\n    }\n\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if self < b {\n            (U128::from_u64s_le(0, 0), self)\n        } else {\n            //TODO check if this can overflow?\n            let (q,r) = self.unconstrained_div(b * U128::from_u64s_le(2,0));\n            let q_mul_2 = q * U128::from_u64s_le(2,0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::from_u64s_le(1,0), r - b)\n            }\n\n        }  \n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f-lo) / pow64;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo+self.hi*pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64))as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift left with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift right with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n","path":"std/uint128.nr"},"71":{"source":"use crate::{\n    abis::{\n        append_only_tree_snapshot::{\n            AppendOnlyTreeSnapshot,\n            APPEND_ONLY_TREE_SNAPSHOT_LENGTH,\n        },\n        global_variables::{\n            GlobalVariables,\n            GLOBAL_VARIABLES_LENGTH,\n        },\n    },\n    constants::{\n        GENERATOR_INDEX__BLOCK_HASH,\n        HEADER_LENGTH,\n        NUM_FIELDS_PER_SHA256,\n        STATE_REFERENCE_LENGTH,\n    },\n    hash::pedersen_hash,\n    state_reference::StateReference,\n    traits::{\n        Deserialize,\n        Empty,\n        Hash,\n        Serialize,\n    },\n    utils::{\n        arr_copy_slice,\n    },\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    body_hash: [Field; NUM_FIELDS_PER_SHA256],\n    state: StateReference,\n    global_variables: GlobalVariables,\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        (self.body_hash == other.body_hash) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new(0);\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.body_hash);\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let body_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n        offset = offset + NUM_FIELDS_PER_SHA256;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            body_hash,\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            body_hash: [0; NUM_FIELDS_PER_SHA256],\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let _hashed = header.hash();\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/header.nr"},"92":{"source":"// This is a quick struct made to pack 32 bytes into 4 u64s\n// and then pack those into two u128s.\n//\n// Creating a u256 was made for convenience.\n//\n// This is needed because in the cpp code, we have accumulate_sha256\n// which returns 2 field elements, one for the high and low limb.\nstruct U256 {\n    // This is in big-endian order, typically because\n    // sha256 is usually in big endian order.\n    // Note: this means that inner[0] has the most significant 64 bits.\n    inner : [u64; 4]\n}\n\nimpl U256 {\n    pub fn from_bytes32(bytes : [u8;32]) -> U256 {\n        // We use addition rather than a bitwise OR as the bitshifts ensure that none of the bytes overlap each other.\n        let high_0 = ((bytes[0] as u64) << 56)\n                + ((bytes[1] as u64) << 48)\n                + ((bytes[2] as u64) << 40)\n                + ((bytes[3] as u64) << 32)\n                + ((bytes[4] as u64) << 24)\n                + ((bytes[5] as u64) << 16)\n                + ((bytes[6] as u64) << 8)\n                +  (bytes[7] as u64);\n        \n        let high_1 = ((bytes[8] as u64) << 56)\n                + ((bytes[9] as u64) << 48)\n                + ((bytes[10] as u64) << 40)\n                + ((bytes[11] as u64) << 32)\n                + ((bytes[12] as u64) << 24)\n                + ((bytes[13] as u64) << 16)\n                + ((bytes[14] as u64) << 8)\n                +  (bytes[15] as u64);\n        \n        let low_0 = ((bytes[16] as u64) << 56)\n                + ((bytes[17] as u64) << 48)\n                + ((bytes[18] as u64) << 40)\n                + ((bytes[19] as u64) << 32)\n                + ((bytes[20] as u64) << 24)\n                + ((bytes[21] as u64) << 16)\n                + ((bytes[22] as u64) << 8)\n                +  (bytes[23] as u64);\n        \n        let low_1 = ((bytes[24] as u64) << 56)\n                + ((bytes[25] as u64) << 48)\n                + ((bytes[26] as u64) << 40)\n                + ((bytes[27] as u64) << 32)\n                + ((bytes[28] as u64) << 24)\n                + ((bytes[29] as u64) << 16)\n                + ((bytes[30] as u64) << 8)\n                +  (bytes[31] as u64);\n\n        U256{inner : [high_0, high_1, low_0, low_1]}\n    }\n\n    // We cannot represent u128 in the type system\n    // so we cannot return a u128 type.\n    // \n    // This as conversion assumes that Field can store 128 bits of information\n    // or else the conversion is lossy.\n    //\n    // TODO: Add a test for this.\n    pub fn to_u128_limbs(self) -> [Field;2] {\n        let two_pow_64 = 2.pow_32(64);\n\n        let high = (self.inner[0] as Field) * two_pow_64 + self.inner[1] as Field;\n        let low  = (self.inner[2] as Field) * two_pow_64 + self.inner[3] as Field;\n        \n        [high,low]\n    }\n}\n\n#[test]\nfn smoke_u256_from_bytes32_all_zeroes() {\n    let input = [0; 32];\n    let result = U256::from_bytes32(input);\n    assert(result.inner[0] == 0);\n    assert(result.inner[1] == 0);\n    assert(result.inner[2] == 0);\n    assert(result.inner[3] == 0);\n}\n\n#[test]\nfn smoke_u256_from_bytes32_one_zero_zero_zero() {\n    // We want to output [1,0,0,0]\n    let input = [\n        0, 0, 0, 0, 0, 0, 0, 1,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    ];\n    let result = U256::from_bytes32(input);\n\n    assert(result.inner[0] == 1);\n    assert(result.inner[1] == 0);\n    assert(result.inner[2] == 0);\n    assert(result.inner[3] == 0);\n}\n\n#[test]\nfn smoke_u256_from_bytes32_test() {\n    /*\n    input:  [   0xAA, 0xBB, 0xCC, 0xDD, \n                0xEE, 0xFF, 0x00, 0x11, \n                0x22, 0x33, 0x44, 0x55, \n                0x66, 0x77, 0x88, 0x99, \n                0x11, 0x22, 0x33, 0x44, \n                0x55, 0x66, 0x77, 0x88, \n                0x99, 0xAA, 0xBB, 0xCC, \n                0xDD, 0xEE, 0xFF, 0x00\n            ]\n    output: inner[0]: 0xAABBCCDDEEFF0011\n            inner[1]: 0x2233445566778899\n            inner[2]: 0x1122334455667788\n            inner[3]: 0x99AABBCCDDEEFF00\n    */\n    let input : [u8;32] = [\n        0xAA, 0xBB, 0xCC, 0xDD,\n        0xEE, 0xFF, 0x00, 0x11,\n        0x22, 0x33, 0x44, 0x55,\n        0x66, 0x77, 0x88, 0x99,\n        0x11, 0x22, 0x33, 0x44,\n        0x55, 0x66, 0x77, 0x88,\n        0x99, 0xAA, 0xBB, 0xCC,\n        0xDD, 0xEE, 0xFF, 0x00\n    ];\n    let result = U256::from_bytes32(input);\n\n    assert(result.inner[0] == 0xAABBCCDDEEFF0011);\n    assert(result.inner[1] == 0x2233445566778899);\n    assert(result.inner[2] == 0x1122334455667788);\n    assert(result.inner[3] == 0x99AABBCCDDEEFF00);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/utils/uint256.nr"},"98":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::{ContractClassFunctionLeafPreimage, FunctionLeafPreimage};\nuse crate::contract_class::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n        ARGS_HASH_CHUNK_COUNT,\n        ARGS_HASH_CHUNK_LENGTH,\n        CONTRACT_TREE_HEIGHT, \n        FUNCTION_TREE_HEIGHT, \n        NOTE_HASH_TREE_HEIGHT,\n        NUM_FIELDS_PER_SHA256,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK,\n        GENERATOR_INDEX__CONSTRUCTOR,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__COMMITMENT_NONCE,\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/hash.nr"},"141":{"source":"struct MerkleTree<N> {\n    leaves: [Field; N],\n    nodes: [Field; N],\n}\n\nimpl<N> MerkleTree<N> {\n    pub fn new(leaves: [Field; N]) -> Self {\n        let mut nodes = [0; N];\n        \n        // We need one less node than leaves, but we cannot have computed array lengths\n        let total_nodes = N - 1;\n        let half_size = N/2;\n        \n        // hash base layer\n        for i in 0..half_size {\n            nodes[i] = dep::std::hash::pedersen_hash([leaves[2*i], leaves[2*i+1]]);\n        }\n\n        // hash the other layers\n        for i in 0..(total_nodes - half_size) {\n            nodes[half_size+i] = dep::std::hash::pedersen_hash([nodes[2*i], nodes[2*i+1]]);\n        }\n\n        MerkleTree {\n            leaves,\n            nodes,\n        }\n    }\n\n    fn get_root(self) -> Field {\n        self.nodes[N-2]\n    }\n}\n\npub fn calculate_subtree<N>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: Field) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed\n    } else if depth == 2 {\n        0x21dbfd1d029bf447152fcf89e355c334610d1632436ba170f738107266a71550\n    } else if depth == 3 {\n        0x0bcd1f91cf7bdd471d0a30c58c4706f3fdab3807a954b8f5b5e3bfec87d001bb\n    } else if depth == 4 {\n        0x06e62084ee7b602fe9abc15632dda3269f56fb0c6e12519a2eb2ec897091919d\n    } else if depth == 5 {\n        0x03c9e2e67178ac638746f068907e6677b4cc7a9592ef234ab6ab518f17efffa0\n    } else if depth == 6 {\n        0x15d28cad4c0736decea8997cb324cf0a0e0602f4d74472cd977bce2c8dd9923f\n    } else if depth == 7 {\n        0x268ed1e1c94c3a45a14db4108bc306613a1c23fab68e0466a002dfb0a3f8d2ab\n    } else if depth == 8 {\n        0x0cd8d5695bc2dde99dd531671f76f1482f14ddba8eeca7cb9686d4a62359c257\n    } else if depth == 9 {\n        0x047fbb7eb974155702149e58ea6ad91f4c6e953e693db35e953e250d8ceac9a9\n    } else if depth == 10 {\n        0x00c5ae2526e665e2c7c698c11a06098b7159f720606d50e7660deb55758b0b02\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x17e8bb70a11d0c946345950879484d2f4f9fef397ff6adbfdec3baab2d41faab == root);\n\n    let empty_root = calculate_subtree([0; 16]);\n    assert(0x06e62084ee7b602fe9abc15632dda3269f56fb0c6e12519a2eb2ec897091919d == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/merkle_tree.nr"},"149":{"source":"use crate::abis::base_or_merge_rollup_public_inputs::BaseOrMergeRollupPublicInputs;\nuse dep::types::mocked::AggregationObject;\nuse dep::types::hash::{accumulate_sha256, assert_check_membership, root_from_sibling_path};\nuse dep::types::constants::NUM_FIELDS_PER_SHA256;\nuse crate::abis::previous_rollup_data::PreviousRollupData;\nuse dep::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot;\n\n/**\n * Create an aggregation object for the proofs that are provided\n *          - We add points P0 for each of our proofs\n *          - We add points P1 for each of our proofs\n *          - We concat our public inputs\n * TODO(Kev): This seems similar to the aggregate_proof method in the private-kernel-lib\n */\npub fn aggregate_proofs(\n    left: BaseOrMergeRollupPublicInputs,\n    _right: BaseOrMergeRollupPublicInputs\n) -> AggregationObject {\n    // TODO: Similar to cpp code this does not do anything.\n    left.aggregation_object\n}\n\n/**\n * Asserts that the rollup types are the same. \n * Either both merge or both base\n */\npub fn assert_both_input_proofs_of_same_rollup_type(\n    left: BaseOrMergeRollupPublicInputs,\n    right: BaseOrMergeRollupPublicInputs\n) {\n    assert(left.rollup_type == right.rollup_type, \"input proofs are of different rollup types\");\n}\n\n/**\n * Asserts that the rollup subtree heights are the same and returns the height\n * Returns the height of the rollup subtrees\n */\npub fn assert_both_input_proofs_of_same_height_and_return(\n    left: BaseOrMergeRollupPublicInputs,\n    right: BaseOrMergeRollupPublicInputs\n) -> Field {\n    assert(\n        left.rollup_subtree_height == right.rollup_subtree_height, \"input proofs are of different rollup heights\"\n    );\n    left.rollup_subtree_height\n}\n\n/**\n * Asserts that the constants used in the left and right child are identical\n *\n */\npub fn assert_equal_constants(\n    left: BaseOrMergeRollupPublicInputs,\n    right: BaseOrMergeRollupPublicInputs\n) {\n    assert(left.constants.eq(right.constants), \"input proofs have different constants\");\n}\n\n// asserts that the end snapshot of previous_rollup 0 equals the start snapshot of previous_rollup 1 (i.e. ensure they\n// follow on from one-another). Ensures that right uses the tres that was updated by left.\npub fn assert_prev_rollups_follow_on_from_each_other(\n    left: BaseOrMergeRollupPublicInputs,\n    right: BaseOrMergeRollupPublicInputs\n) {\n    assert(\n        left.end.note_hash_tree.eq(right.start.note_hash_tree), \"input proofs have different note hash tree snapshots\"\n    );\n    assert(\n        left.end.nullifier_tree.eq(right.start.nullifier_tree), \"input proofs have different nullifier tree snapshots\"\n    );\n    assert(\n        left.end.contract_tree.eq(right.start.contract_tree), \"input proofs have different contract tree snapshots\"\n    );\n    assert(\n        left.end.public_data_tree.eq(right.start.public_data_tree), \"input proofs have different public data tree snapshots\"\n    );\n}\n\n/**\n * @brief From two previous rollup data, compute a single calldata hash\n *\n * @param previous_rollup_data\n * @return calldata hash stored in 2 fields\n */\npub fn compute_calldata_hash(previous_rollup_data: [PreviousRollupData; 2]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_rollup_data[0].base_or_merge_rollup_public_inputs.calldata_hash[0]),\n        U128::from_integer(previous_rollup_data[0].base_or_merge_rollup_public_inputs.calldata_hash[1]),\n        U128::from_integer(previous_rollup_data[1].base_or_merge_rollup_public_inputs.calldata_hash[0]),\n        U128::from_integer(previous_rollup_data[1].base_or_merge_rollup_public_inputs.calldata_hash[1])\n    ]\n    )\n}\n\npub fn insert_subtree_to_snapshot_tree<N>(\n    snapshot: AppendOnlyTreeSnapshot,\n    siblingPath: [Field; N],\n    emptySubtreeRoot: Field,\n    subtreeRootToInsert: Field,\n    subtreeDepth: u8\n) -> AppendOnlyTreeSnapshot {\n    // TODO(Lasse): Sanity check len of siblingPath > height of subtree\n    // TODO(Lasse): Ensure height of subtree is correct (eg 3 for commitments, 1 for contracts)\n    let leafIndexAtDepth = snapshot.next_available_leaf_index >> (subtreeDepth as u32);\n\n    // Check that the current root is correct and that there is an empty subtree at the insertion location\n    assert_check_membership(\n        emptySubtreeRoot,\n        leafIndexAtDepth as Field,\n        siblingPath,\n        snapshot.root\n    );\n\n    // if index of leaf is x, index of its parent is x/2 or x >> 1. We need to find the parent `subtreeDepth` levels up.\n    let new_root = root_from_sibling_path(subtreeRootToInsert, leafIndexAtDepth as Field, siblingPath);\n\n    // 2^subtreeDepth is the number of leaves added. 2^x = 1 << x\n    let new_next_available_leaf_index = (snapshot.next_available_leaf_index as u64) + (1 << (subtreeDepth as u64));\n\n    AppendOnlyTreeSnapshot { root: new_root, next_available_leaf_index: new_next_available_leaf_index as u32 }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/components.nr"},"150":{"source":"mod root_rollup_inputs;\nuse root_rollup_inputs::RootRollupInputs;\nmod root_rollup_public_inputs;\nuse root_rollup_public_inputs::RootRollupPublicInputs;\nuse dep::types::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot,\n    constants::{\n        NUM_FIELDS_PER_SHA256,\n        NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP,\n        L1_TO_L2_MSG_SUBTREE_HEIGHT,\n    },\n    header::Header,\n    state_reference::StateReference,\n    utils::uint256::U256,\n};\nuse crate::components;\nuse crate::merkle_tree::{calculate_subtree, calculate_empty_tree_root};\n\nimpl RootRollupInputs {\n    pub fn root_rollup_circuit(self) -> RootRollupPublicInputs {\n\n        let left = self.previous_rollup_data[0].base_or_merge_rollup_public_inputs;\n        let right = self.previous_rollup_data[1].base_or_merge_rollup_public_inputs;\n\n        let aggregation_object = components::aggregate_proofs(left, right);\n        components::assert_both_input_proofs_of_same_rollup_type(left, right);\n        let _ = components::assert_both_input_proofs_of_same_height_and_return(left, right);\n        components::assert_equal_constants(left, right);\n        components::assert_prev_rollups_follow_on_from_each_other(left, right);\n\n        // Check correct l1 to l2 tree given\n        // Compute subtree inserting l1 to l2 messages\n        let l1_to_l2_subtree_root = calculate_subtree(self.new_l1_to_l2_messages);\n\n        // Insert subtree into the l1 to l2 data tree\n        let empty_l1_to_l2_subtree_root = calculate_empty_tree_root(L1_TO_L2_MSG_SUBTREE_HEIGHT);\n        let new_l1_to_l2_message_tree_snapshot = components::insert_subtree_to_snapshot_tree(\n            self.start_l1_to_l2_message_tree_snapshot,\n            self.new_l1_to_l2_message_tree_root_sibling_path,\n            empty_l1_to_l2_subtree_root,\n            l1_to_l2_subtree_root,\n            // TODO(Kev): For now we can add a test that this fits inside of \n            // a u8.\n            L1_TO_L2_MSG_SUBTREE_HEIGHT as u8 \n        );\n\n        let state = StateReference {\n            l1_to_l2_message_tree : new_l1_to_l2_message_tree_snapshot,\n            partial: right.end,\n        };\n\n        let header = Header {\n            last_archive: left.constants.last_archive,\n            body_hash: components::compute_calldata_hash(self.previous_rollup_data),\n            state,\n            global_variables : left.constants.global_variables\n        };\n\n        // Build the block hash for this by hashing the header and then insert the new leaf to archive tree.\n        let block_hash = header.hash();\n\n        // Update the archive\n        let archive = components::insert_subtree_to_snapshot_tree(\n            self.start_archive_snapshot,\n            self.new_archive_sibling_path,\n            0,\n            block_hash,\n            0\n        );\n\n        RootRollupPublicInputs{\n            aggregation_object,\n            archive,\n            header,\n            // TODO(#3938): Nuke this once body hash/calldata hash is updated\n            l1_to_l2_messages_hash : compute_messages_hash(self.new_l1_to_l2_messages),\n        }\n    }\n}\n\n// See `test_message_input_flattened_length` on keeping this in sync,\n// why its here and how this constant was computed.\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP_NUM_BYTES = 512;\n\n// Computes the messages hash from the leaves array\n//\n// Returns the hash split into two field elements\nfn compute_messages_hash(leaves: [Field; NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // Slice variation\n    // let mut hash_input_flattened = [];\n    // for leaf in leaves {\n    //     let input_as_bytes = leaf.to_be_bytes(32);\n    //     for i in 0..32 {\n    //         // TODO(Kev): should check the complexity of repeatedly pushing\n    //         hash_input_flattened.push(input_as_bytes[i]);\n    //     }\n    // }\n\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP_NUM_BYTES];\n    for offset in 0..NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP {\n        let input_as_bytes = leaves[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    // Hash bytes and convert to 2 128 bit limbs\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n    // TODO(Kev): The CPP implementation is returning [high, low]\n    // and so is `to_u128_limbs`, so this matches.\n    // We should say why we are doing this vs [low, high]\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\n#[test]\nfn test_message_input_flattened_length() {\n    // This is here so that the global doesn't become outdated.\n    // \n    // The short term solution to remove this is to use slices, though\n    // those are a bit experimental right now, so TODO I'll add a test that the\n    // slice version of compute_messages_hash is the same as the array version.\n    // which uses the NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP_NUM_BYTES global.\n    assert(NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP * 32 == NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP_NUM_BYTES);\n}\n\nmod tests {\n    use crate::{\n        root::{\n            root_rollup_inputs::RootRollupInputs,\n            NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP_NUM_BYTES,\n        },\n        tests::root_rollup_inputs::default_root_rollup_inputs,\n    };\n    use dep::types::utils::uint256::U256;\n    use dep::types::hash::accumulate_sha256;\n\n    #[test]\n    fn check_block_hashes_empty_blocks() {\n        let expected_messages_hash = U256::from_bytes32(dep::std::hash::sha256([0; NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP_NUM_BYTES])).to_u128_limbs();\n\n        let expected_calldata_hash = accumulate_sha256(\n            [\n            U128::from_integer(0),\n            U128::from_integer(1),\n            U128::from_integer(2),\n            U128::from_integer(3)\n        ]\n        );\n\n        let inputs = default_root_rollup_inputs();\n        let outputs = inputs.root_rollup_circuit();\n\n        // check calldata hash\n        assert_eq(outputs.header.body_hash, expected_calldata_hash);\n        // Check messages hash\n        assert_eq(outputs.l1_to_l2_messages_hash, expected_messages_hash);\n    }\n\n    #[test]\n    fn end_state() {\n        let inputs = default_root_rollup_inputs();\n        let outputs = inputs.root_rollup_circuit();\n\n        assert(\n            outputs.header.state.partial.note_hash_tree.eq(inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.end.note_hash_tree)\n        );\n\n        assert(\n            outputs.header.state.partial.nullifier_tree.eq(inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.end.nullifier_tree)\n        );\n\n        assert(\n            outputs.header.state.partial.contract_tree.eq(inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.end.contract_tree)\n        );\n\n        assert(\n            outputs.header.state.partial.public_data_tree.eq(inputs.previous_rollup_data[1].base_or_merge_rollup_public_inputs.end.public_data_tree)\n        );\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/root.nr"},"154":{"source":"use dep::rollup_lib::root::{RootRollupInputs,RootRollupPublicInputs};\n\nfn main(inputs: RootRollupInputs) -> pub RootRollupPublicInputs {\n    inputs.root_rollup_circuit()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/rollup-root/src/main.nr"}}}