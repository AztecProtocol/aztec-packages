{"noir_version":"0.23.0+f1b91511124df89bbe9e059b87536901bdf0d6f3","hash":1069714965185668368,"abi":{"parameters":[{"name":"input","type":{"kind":"struct","path":"private_kernel_lib::private_kernel_init::PrivateKernelInputsInit","fields":[{"name":"tx_request","type":{"kind":"struct","path":"private_kernel_lib::types::transaction::request::TxRequest","fields":[{"name":"origin","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"tx_context","type":{"kind":"struct","path":"private_kernel_lib::types::transaction::context::TxContext","fields":[{"name":"is_fee_payment_tx","type":{"kind":"boolean"}},{"name":"is_rebate_payment_tx","type":{"kind":"boolean"}},{"name":"is_contract_deployment_tx","type":{"kind":"boolean"}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"private_kernel_lib::types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"private_kernel_lib::types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}},{"name":"function_data","type":{"kind":"struct","path":"private_kernel_lib::types::abis::function_data::FunctionData","fields":[{"name":"selector","type":{"kind":"struct","path":"private_kernel_lib::types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_internal","type":{"kind":"boolean"}},{"name":"is_private","type":{"kind":"boolean"}},{"name":"is_constructor","type":{"kind":"boolean"}}]}}]}},{"name":"private_call","type":{"kind":"struct","path":"private_kernel_lib::types::abis::private_kernel::private_call_data::PrivateCallData","fields":[{"name":"call_stack_item","type":{"kind":"struct","path":"private_kernel_lib::types::abis::private_call_stack_item::PrivateCallStackItem","fields":[{"name":"contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_data","type":{"kind":"struct","path":"private_kernel_lib::types::abis::function_data::FunctionData","fields":[{"name":"selector","type":{"kind":"struct","path":"private_kernel_lib::types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_internal","type":{"kind":"boolean"}},{"name":"is_private","type":{"kind":"boolean"}},{"name":"is_constructor","type":{"kind":"boolean"}}]}},{"name":"public_inputs","type":{"kind":"struct","path":"private_kernel_lib::types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"private_kernel_lib::types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"meta_hwm","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"private_kernel_lib::types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"private_kernel_lib::types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"private_kernel_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"private_kernel_lib::types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"private_kernel_lib::types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"private_kernel_lib::types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]}},{"name":"private_call_stack","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"proof","type":{"kind":"struct","path":"private_kernel_lib::types::mocked::Proof","fields":[]}},{"name":"vk","type":{"kind":"struct","path":"private_kernel_lib::types::mocked::VerificationKey","fields":[]}},{"name":"salted_initialization_hash","type":{"kind":"struct","path":"private_kernel_lib::types::address::SaltedInitializationHash","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"public_keys_hash","type":{"kind":"struct","path":"private_kernel_lib::types::address::PublicKeysHash","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_class_artifact_hash","type":{"kind":"field"}},{"name":"contract_class_public_bytecode_commitment","type":{"kind":"field"}},{"name":"function_leaf_membership_witness","type":{"kind":"struct","path":"private_kernel_lib::types::abis::membership_witness::FunctionLeafMembershipWitness","fields":[{"name":"leaf_index","type":{"kind":"field"}},{"name":"sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}}}]}},{"name":"read_request_membership_witnesses","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::membership_witness::ReadRequestMembershipWitness","fields":[{"name":"leaf_index","type":{"kind":"field"}},{"name":"sibling_path","type":{"kind":"array","length":32,"type":{"kind":"field"}}},{"name":"is_transient","type":{"kind":"boolean"}},{"name":"hint_to_commitment","type":{"kind":"field"}}]}}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"acir_hash","type":{"kind":"field"}}]}}]},"visibility":"private"}],"param_witnesses":{"input":[{"start":0,"end":1409}]},"return_type":{"abi_type":{"kind":"struct","path":"private_kernel_lib::types::abis::kernel_circuit_public_inputs::KernelCircuitPublicInputs","fields":[{"name":"aggregation_object","type":{"kind":"struct","path":"private_kernel_lib::types::mocked::AggregationObject","fields":[]}},{"name":"meta_hwm","type":{"kind":"field"}},{"name":"end","type":{"kind":"struct","path":"private_kernel_lib::types::abis::combined_accumulated_data::CombinedAccumulatedData","fields":[{"name":"read_requests","type":{"kind":"array","length":128,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::nullifier_key_validation_request::NullifierKeyValidationRequestContext","fields":[{"name":"public_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"caller_context","type":{"kind":"struct","path":"private_kernel_lib::types::abis::call_request::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"new_contracts","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::new_contract_data::NewContractData","fields":[{"name":"contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_class_id","type":{"kind":"struct","path":"private_kernel_lib::types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}},{"name":"public_data_update_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::public_data_update_request::PublicDataUpdateRequest","fields":[{"name":"leaf_slot","type":{"kind":"field"}},{"name":"old_value","type":{"kind":"field"}},{"name":"new_value","type":{"kind":"field"}}]}}},{"name":"public_data_reads","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"private_kernel_lib::types::abis::public_data_read::PublicDataRead","fields":[{"name":"leaf_slot","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}}]}}}]}},{"name":"constants","type":{"kind":"struct","path":"private_kernel_lib::types::abis::combined_constant_data::CombinedConstantData","fields":[{"name":"historical_header","type":{"kind":"struct","path":"private_kernel_lib::types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"private_kernel_lib::types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"private_kernel_lib::types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"private_kernel_lib::types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"private_kernel_lib::types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"private_kernel_lib::types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"tx_context","type":{"kind":"struct","path":"private_kernel_lib::types::transaction::context::TxContext","fields":[{"name":"is_fee_payment_tx","type":{"kind":"boolean"}},{"name":"is_rebate_payment_tx","type":{"kind":"boolean"}},{"name":"is_contract_deployment_tx","type":{"kind":"boolean"}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"private_kernel_lib::types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"private_kernel_lib::types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"private_kernel_lib::types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"private_kernel_lib::types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]}},{"name":"is_private","type":{"kind":"boolean"}}]},"visibility":"public"},"return_witnesses":[2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249,2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299,2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349,2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399,2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449,2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499,2500,2501,2502,2503,2504,2505,2506,2507,2508,2509,2510,2511,2512,2513,2514,2515,2516,2517,2518,2519,2520,2521,2522,2523,2524,2525,2526,2527,2528,2529,2530,2531,2532,2533,2534,2535,2536,2537,2538,2539,2540,2541,2542,2543,2544,2545,2546,2547,2548,2549,2550,2551,2552,2553,2554,2555,2556,2557,2558,2559,2560,2561,2562,2563,2564,2565,2566,2567,2568,2569,2570,2571,2572,2573,2574,2575,2576,2577,2578,2579,2580,2581,2582,2583,2584,2585,2586,2587,2588,2589,2590,2591,2592,2593,2594,2595,2596,2597,2598,2599,2600,2601,2602,2603,2604,2605,2606,2607,2608,2609,2610,2611,2612,2613,2614,2615,2616,2617,2618,2619,2620,2621,2622,2623,2624,2625,2626,2627,2628,2629,2630,2631,2632,2633,2634,2635,2636,2637,2638,2639,2640,2641,2642,2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,2691,2692,2693,2694,2695,2696,2697,2698,2699,2700,2701,2702,2703,2704,2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,2721,2722,2723,2724,2725,2726,2727,2728,2729,2730,2731,2732,2733,2734,2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,2751,2752,2753,2754,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,2766,2767,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,2780,2781,2782,2783,2784,2785,2786,2787,2788,2789,2790,2791,2792,2793,2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,2810,2811,2812,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,2857,2858,2859,2860,2861,2862,2863,2864,2865,2866,2867,2868,2869,2870,2871,2872,2873,2874,2875,2876,2877,2878,2879,2880,2881,2882,2883,2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,2900,2901,2902,2903,2904,2905,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,2916,2917,2918,2919,2920,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,2944,2945,2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,2962,2963,2964,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3013,3014,3015,3016,3017,3018,3019,3020,3021,3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,3038,3039,3040]},"bytecode":"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N7M88maWtxm/ftvRbzf67Ue/w+h3HP1Oo9959LuMftfR7zb63Ue/x+j3HP1eo582+r1Hv8/o9x39fqPff/QHjP7A0R80+oNHf8joDx39YaM/fPRHjP7I0R91871/9M3Pj3mGP0cfO379cTf/2cff/PyEm5+fePPzk25+fvLNz0+5+fmpNz8/7ebnp9/8/Iybn5958/Ozbn5+9s3Pz7n5+bk3Pz/v5ufn3/z8gpufX3jz84tufn7xzc8vufn5pTc/v+zm55ff/PyKm59fefPzq277/n/yv//4Lup/6pFq0x1Z8m3/bxPG4v/37/Xed1JT3V39z/f99P/ObZ89fQdud8tnN3+obn/LZ0//7e5wy2d3fvpvd8tnT5/tTrd8dvMVqDvf8tndbj67yy2f3f3ms7ve8tk9bj672y2f3fPpM93y2bPcfHaPWz571pvP7nnLZ89289mz3PLZvW4+e9ZbPrv3zWfPdstn97n57F63fHbfm8/ufctnT//n9fvc8tn9bz677y2fPeDms/vd8tkDbz67/y2fPejmswfc8tmDbz574C2fPeTmswfd8tlDbz578C2fPezms4fc8tnDbz576C2fPeLms4fd8tmz33z28Fs+e+TNZ4+4+ey2N/AcN5/d9p895uaPj/8nZc7b/rFKPefu3/e2/1/r4/d41M3v9ahbZniu7TNct/0jrnpuwAy3/b7Ps12v+y+9zwvS+3z79d52MqjnB+l9ge16w3/pfUGQ3hfarjf/l94XBul99H69t51l6kVAeo/testtJ7E6AXpv+2vcdfN7fc8tf43T+2e47ZRXBvSd2/16b/tXDsqBvnN/83v94C1/vww3n/3QLZ/Fm89++JbPXvTmsx+55c/Xi+2f/7Z/faFefPfvezP/S9z8Xj9+y1wvefPZT9zy2UvdfPaTt3z2dB0/dctnL33z2U/f8tnL3Hz2M7d89rI3n/3sLZ+93M1nP3fLZy9/89nP3/LZK9x89gu3fPaKN5/94i2fvdLNZ790y2evfPPZL9/y2avcfPYrt3z2qjef/eotn73azWe/dstnr37z2a/f8tlr3Hz2G7d89po3n/3mLZ+91s1nv3XLZ69989lv3/LZ69x89ju3fPbYm89+95bPXvfms9+75T2+3s1nj1S73mP7r318/d2/781fP95gu95+27/2U28I0Hvbd/5GN7/X/e/0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+U9JmGtfSiPGXyte9GlvX4/X+4PH6/3B482H1/uDx+v9wePNh9f7g8fr/cHjzYe3K/hDhOcUhjUJ+U7pAjZNgQz7sei7ANg/dZpFdrpFltmjHsqgVJ7fFLQlU5nDmY5SZZ9Q4hn3Y5UBMeJcCuVVZqmnZUo+Vcp8itKI0eP1eP8XvBgzPF7vDx6vx+vjwy/DG+E5k2FNQj66trgxkgzbpvQ9H2xfnm2RnWORnWuRnWeRnW/OA9B7AZNFtimXtk1jQwOWA1OZOdJwXq7sTyo8G9rbsBVAjDiXg80rLDGpQskfy5k/ZuwK8kXFiz7iAl5vX29fb9/i4fX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry5eb19dvN6+uni9fXXxevvq4vX21cXr7auL19tXF6+3ry7ermDfCM+FDGsS8l3YBWyaAlkZyC4yv6Fyj2TTLbIZQUd7V4pzaWxBuzGVOfzoqFQufx2eDQ3RPaqAGHGuhLKpstTJKiX/qWT+Q2nE6PF6vB6vx+vxerwer8fr8Xq8Hq/H+1vEG+GZybAmId/MLoIx834MsouDXDtGskssskstssssssstsiuYLLJDUtwO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Q0iDjPoQ8Pul1IcwTLeN0um6h8Yi6M637qEYukcy3SOLqDvfuodi6M637qEYuvOteyiG7nzrHoqhO9+6h2LozrfuoRi68617KIbufOseiqE737qHYujOt+6hGLrzrXsohu7JTPfkIupuYG0EShdDt39+++d3sXT757d/fhdLt39+++d3sXT7Z6h/hhZLt3+G+mdosXT/3DM06hsfZGR3QV/xHOgr/jXu/bEourW+OVLIdzds3xwJBfHgdzdQl8Z3DDuz+/wuplt6v6V/MF1RHXtypqbexpzvgtB+SxxHAvKcCvstPWuwVcN1rBsK3xyNy4hw8e9D4zdHKc9LbIxYy2/ytRWK4bOLojtQeHbg3h90dBan6GIq6PjNcS2MndknCLuWbul48k+mK6qzH1qe2drxhHCQPownO0M8+dQST9CHteJJvu/NYzyhPF9BPClWGyjfe6ffc87vOSet2+85l/ve6fec+3XuObc449pkpntyEXX7mJo/piq8yzf9knd5+W+ptjTgHn6Lggfb5xrvLzo82+coa7Sr49uGHcuLOKQC+3foNfYaDIPcb9OmIR3q6o7tUPIzdsh8nxOwlBTZDohxUfEGjuH19vX29fYtHl5vX1283r66eL19dfF6++ri9fbVxevtq4vX21cXr7evLl5vX1283r66eL19dfF6++ri9fbVxevtq4vX21cXr7evLl5vX1283r66eL19dfF6++ri9fbVxevtq4vX21cXr7evLl5vX1283r66eL19cw5v3y6A17bGGr+jjvPUFydGks1XxpNkeKIjZOk0nNswoh8mlDCWhIuOMQEYbXWlVAljogCMpYAxwepHdK9/sZvEe+9fkuVAcrk5903xmlLCQGtKOY4E5HnnkSy2FoOtGq5TXcL1y9p7OoRB7lrpNKRJXzWzH8n4WmlcH0t+FMmo7PBbbmVKsQKdKA3psi6guxrOL8pmzXwbFfNiHKPv7rYFcuskoltWgN42wFEJ9YrO8XuoSXE8E2I8VVCX2kBPJeimbw+Hgawt6PuptNaasKSgHlOeP5i6S3s31CjFx+oC4mMNxMdqhh0xSq/l34npj/dth7hbpRR3kyzuEo4qKC/KMwXi7kYQd6muXWh+i88kkmm2axIsXlC6s9hZDefTg6yMfjPDyFLAoQzqc2jhFyjxCxk/vv4M16Th851iYznIiCu2VYhr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","debug_symbols":"7P3brizLrp6Hvsu8FjYyIhin9SobvhB8AAwYsmHpTtC7O9tcvWVV18yWkX2sGFEfk7RuJoxarch/9CR/ZsXH+O//+L/+7//1P/+3//P//i//9R//9t//sf3/UpMU/vFv/////o//+v/85//y9f/vv/63//z//rd//Fvctv/0j//9v/xv+/+S/D/+0z/+j//z//rf//FvIcj/+E//8lkJ9fvDElp5+3T4H//Lf/r1LXHJt6Ql3yJLviUv+Zay5Fvqkm9pS76lr/gW2ZZ8y5JnX5Y8+7Lk2Zclz74sefZlybMvS559WfLsy5JnPy959vOSZz8vefbzkmc/L3n285JnPy959vOSZz8vefbzkme/LHn2y5Jnvyx59suSZ78sefbLkme/LHn2y5Jnvyx59suSZ78uefbrkme/Lnn265Jnvy559uuSZ78uefbrkme/Lnn265Jnvy159tuSZ78tefbbkme/LXn225Jnvy159tuSZ78tefbbkme/L3n2+5Jnvy959vuSZ78vefb7kme/L3n2+5Jnvy959vuKZz9v25JvCUu+JS75lrTkW2TJt+Ql31KWfEtd8i1tybcsefbDkmc/LHn2w5JnPyx59sOSZz8sefbDkmc/LHn2w5JnPyx59uOSZz8uefbjkmc/Lnn245JnPy559uOSZz8uefbjkmc/Lnn205Jnf8m5vrzkXF9ecq4vLznXl5ec68tLzvXlJef68pJzfXnJub685FxfXnKuLy8515eXnOvLS8715SXn+vKSc315ybm+vORcX15yri8vOdeXl5zry0vO9eUl5/ryknN9ecm5vrzkXF9ecq4vLznXl5ec68tLzvXlJef68pJzfXnJub685FxfXnKuLy8515eXnOvLS8715SXn+vKSc315ybm+vORcX15yri8vOdeXl5zry0vO9eUl5/ryknN9ecm5vrzkXF9ecq4vLznXl5ec68tLzvXlJef68pJzfXnJub685FxfXnKuLy8515eXnOvLS8715SXn+vKSc315ybm+vORcX15yri8vOdeXl5zrK0vO9ZUl5/rKknN9Zcm5vrLJkm/JS76lLPmWuuRb2pJvWfLsLznXV5ac6ytLzvWVJef6ypJzfWXJub6y5FxfWXKuryw511eWnOsrS871lSXn+sqSc31lybm+suRcX1lyrq8sOddXlpzrK0vO9ZUl5/rKknN9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IYzDF93ho3v5OHx0gx6Hr7vrsi9ZGoevu+uyLysah6+767Iv/RmHr7vrsi/PGYevu+uyL6EZh6+767IvcxmHr7vrsi9FGYe/vOtucoRf0+DTMYRvMCCG9LayWV4JRHICRb7fs5W392zpFX1SHb2ojj4rib6Ws+iL6uir6uib6ui73ujTtv7ahanRo9vtMHotvfY8ei299jx6Lb32PHrFvXaPXnGv3aNX3Gv36BX32j161b02qO61Ad1ra/z+0zWFs+jRvXYYPbrXDqNH99ph9OheO4we3WuH0aN77TB6dK8dRo/utaPoI7rXDqNX3Wuj6l4bVffa9Vtbp0avutdG1b02qu61UXWvjap7bVLda5PqXptU99qkuteu3y04NXrVvTap7rVJda9NqnttUt1rRXWvFdW9VlT3WlHda9evkZsavepeK6p7rajutaK614rqXptV99qsutdm1b02q+6169eRTY1eda/NqnttVt1rs+pem1X32qK61xbVvbao7rVFda9dv9ZqavSqe21R3WuL6l5bVPfaorrXVtW9tqrutVV1r62qe+36XVJTo1fda6vqXltV99qqutdW1b22qe61TXWvbap7bVPda9dvkJoavepe21T32qa61zbVvbap7rVdda9lr44aRq+617L3Rg2jV91r2XujhtGr7rXsvVHD6FX3WvbeqEH0gb03ahi95l4b2HujhtFr7rVh09xrA3tvVJXvVay1xLPo2b12FD27146iZ/faUfTsXjuInr03ahg9u9eOomf32lH07F47ip7da0fR/6299viWsuRb6pJvaUu+pa/4lr93/9DxLWHJt8Ql35KWfIss+ZYlz35c8uzHJc9+XPLsxyXPflry7Kclz35a8uynJc9+WvLspyXPflry7Kclz35a8uynJc++LHn2ZcmzL0uefVny7MuSZ1+WPPuy5NmfwM337XultPSve7Ov56l4XK60/892fHr/n0dIjRdSx4U0AVufHlLghRR5ISVeSMILKfNCKryQeNU786p35lXvwqvehVe9C696F171LrzqXXjVu/Cqd+FV78Kr3oVXvSuvelde9a686l151bvyqnflVe/Kq951cfVucSu/Pt2ilLdPx7NfuWP49eEUz363rk119F1z9G1THX1QHX1UHX1SHb2ojj6rjr6ojl51r22qe21T3Wu76l7bVffarrrXdtW9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ybPflzz7fcmz35c8+33Fs5+2bcm3hCXfEpd8S1ryLbLkW/KSbylLvqUu+Za25FuWPPthybMfljz7YcmzH5Y8+2HJsx+WPPthybMfljz7YcmzH5Y8+3HJsx+XPPtxybMflzz7ccmzH5c8+3HJsx+XPPtxybMflzz7acmzv+RcX1pyri8tOdeXlpzrS0vO9aUl5/rSknN9acm5vrTkXF9acq4vLTnXl5ac60tLzvWlJef60pJzfWnJub605FxfWnKuLy0515eWnOtLS871pSXn+tKSc31pybm+tORcX1pyri8tOdeXlpzrS0vO9aUl5/rSknN9acm5vrTkXF9acq4vLTnXl5ac60tLzvWlJef60pJzfWnJub605FxfWnKuLy0515eWnOtLS871pSXn+tKSc31pybm+tORcX1pyri8tOdeXlpzrS0vO9aUl5/rSknN9acm5vrTkXF9acq4vLTnXl5ac60tLzvWlJef60pJzfWnJub605FxfWnKuLy0515eWnOtLS871yZJzfbLkXJ8sOdcnS871ySZLviUv+Zay5Fvqkm9pS75lybO/5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXJ0vO9cmSc32y5FyfLDnXl5ec68tLzvXlJef68pJzfXmTJd+Sl3xLWfItdcm3tCXfsuTZX3KuLy8515eXnOvLS8715SXn+vKSc315ybm+vORcX15yri8vOdeXl5zry0vO9eUl5/ryknN9ecm5vrzkXF9ecq4vLznXl5ec68tLzvXlJef68pJzfXnJub685FxfXnKuLy8515eXnOvLS8715SXn+vKSc315ybm+vORcX15yri8vOdeXl5zry0vO9eUl5/ryknN9ecm5vrzkXF9ecq4vLznXl5ec68tLzvXlJef68pJzfXnJub685FxfXnKuLy8515eXnOvLS8715SXn+vKSc315ybm+vORcX15yri8vOdeXl5zry0vO9eUl5/ryknN9ecm5vrzkXF9ecq4vLznXl5ec68tLzvXlJef68pJzfXnJub685FxfXnKuLy8515eXnOvLS8715SXn+vKSc315ybm+vORcX15yri8vOdeXl5zry0vO9eUl5/ryknN9ecm5vrzkXF9ecq4vLznXV5ac6ytLzvWVJef6yoRzfXst/P6WEtJv3/Jnnz5iEmBMGRhTAcZUgTE1YEydF9OEk5HzYwrAmCIwJmAdD8A6HoB1PADreADW8QCs4wFYxyOwjkdgHY/AOh6BdTwC63gE1vEIrONxcR0PseVfnw5pi8eni/zZh4/4m/L4u+7406Y8/qA8/qg8/qQ8flEef1Yef1Eev/L+m5T336S8/4ry/ivK+68o77+ivP9OIEQ+G7/y/ivK+68o77+ivP+K8v6blfffzOm/R0iclnqExOmSR0icxneExOllR0ic9nSExOk4R0icJnKExOkL3yEVTqk/QuJV78Kr3oVXvQuvehde9S686l141bvwqnfhVe/Kq96VV70rr3pXXvWuvOpdedW74qp3/Y9zGdK37y+RXvoopNSkHTH1+H7GPp59ftvkyGGL7ZVEbycf7y33X5/ue1zXH455q99p5vCKvJ8FEkM+PhzyW5r9pWV1Ladp2VzLm1pWObRs26mW3bW8p2Xcvqvr/j/ziZbtP85LuZaHlsG1nKZldC2naZlcy2laims5TcvsWt70RL2/tCynWvrcM09Ln3vmaelzzzwtfe6ZpmXwuWeelj73zNPS5555WvrcM09LcS2naelzzzwtfe6Zp6XPPfO09LlnnpY+90zTMvrcM09Ln3vmaelzzzwtfe6Zp6W4ltO09LlnnpY+98zT0ueeeVr63DNPS597pmmZfO6Zp6XPPfO09LlnnpY+98zTUlzLaVr63DNPS5975mnpc888LX3umaelzz3TtBSfe+Zp6XPPPC197pmnpc8987QU13Kalj73zNPS5555WvrcM09Ln3vmaelzzzQts88987T0uWeelj73zNPS5555WoprOU1Ln3vmaelzzzwtfe6Zp6XPPfO09LlnmpbF5555WvrcM09Ln3vmaelzzzwtxbWcpqXPPfO09LlnnpY+98zT0ueeeVr63DNNy+pzzzwtfe6Zp6XPPfO09LlnnpbiWk7T0ueeeVr63DNPS5975mnpc888LX3umaZl87lnnpY+98zT0ueeeVr63DNPS3Etp2npc888LX3umaelzz3ztPS5Z56WPvdM07L73DNPS5975mnpc888LX3umaeluJbTtPS5Z56WPvfM09Lnnnla+twzT0ufe2Zp2Tefe+Zp6XPPPC197pmnpc8987QU13Kalj73zNPS5555WvrcM09Ln3vmaelzzzQtg88987T0uWeelj73zNPS5555WoprOU1Ln3vmaelzzzwtfe6Zp6XPPfO09LlnmpbR5555WvrcM09Ln3vmaelzzzwtxbWcpqXPPfO09LlnnpY+98zT0ueeeVr63DNNy+Rzzzwtfe6Zp6XPPfO09LlnnpbiWk7T0ueeeVr63DNPS5975mnpc888LX3umaal+NwzT0ufe+Zp6XPPPC197pmnpbiW07T0uWeelj73zNPS5555WvrcM09Ln3umaZl97vkLWoZ8qqXPPTe13P81HlrGdqqlzz3ztPS55/Yz3l5a9lMtxbW8+e8yveqlpFMtfe6Zp6XPPfO09LlnnpY+99zWsr60lFMtfe6ZpmXxuWeelj73zNPS5555WvrcM09LcS2naelzzzwtfe6Zp6XPPfO09LlnnpY+90zTsvrcM09Ln3vmaelzzzwtfe6Zp6W4ltO09LlnnpY+98zT0ueeeVr63DNPS597pmnZfO6Zp6XPPfO09LlnnpY+98zTUlzLaVr63DNPS5975mnpc888LX3umaelzz3TtOw+98zT0ueeeVr63DNPS5975mkpruU0LX3umaelzz3ztPS5Z56WPvfM09Lnnklatm3zuWeelj73zNPS5555WvrcM09LcS2naelzzzwtfe6Zp6XPPfO09LlnnpY+90zTMvjcM09Ln3vmaelzzzwtfe6Zp6W4ltO09LlnnpY+98zT0ueeeVr63DNPS597pmkZfe6Zp6XPPfO09LlnnpY+98zTUlzLaVr63DNPS5975mnpc888LX3umaelzz3TtEw+98zT0ueeeVr63DNPS5975mkpruU0LX3umaelzz3ztPS5Z56WPvfM09Ln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5555WvrcM03L7nPPPC197pmnpc8987T0uWeeluJaTtPS5555WvrcM09Ln3vmaelzzzwtfe6ZpWXZfO6Zp6XPPfO09LlnnpY+98zTUlzLaVr63DNPS5975mnpc888LX3umaelzz3TtAw+98zT0ueeeVr63DNPS5975mkpruU0LX3umaelzz3ztPS5Z56WPvfM09LnnmlaRp975mnpc888LX3umaelzz3ztBTXcpqWPvfM09Lnnnla+twzT0ufe+Zp6XPPNC2Tzz3ztPS5Z56WPvfM09Lnnnlaims5TUufe+Zp6XPPPC197pmnpc8987T0uWealuJzzzwtfe6Zp6XPPfO09LlnnpbiWk7T0ueeeVr63DNPS5975mnpc888LX3umaZl9rlnnpY+98zT0ueeeVr63DNPS3Etp2npc888LX3umaelzz3ztPS5Z56WPvdM07L43DNPS5975mnpc888LX3umaeluJbTtPS5Z56WPvfM09Lnnnla+twzT0ufe6ZpWX3umaelzz3ztPS5Z56WPvfM01Jcy2la+twzT0ufe+Zp6XPPPC197pmnpc8907RsPvfM09Lnnnla+twzT0ufe+ZpKa7lNC197pmnpc8987T0uWeelj73zNPS555pWnafe+Zp6XPPPC197pmnpc8987QU13Kalj73zNPS5555WvrcM09Ln3vmaelzzywt6+Zzzzwtfe6Zp6XPPX9By5BPtfS556aW+7/GQ8v3sN+0FNdympY+99x+xttLy36qpc89d/9dple9lHSqpc8987T0uWeelj73TNMy+NxzW8v60lJOtfS5Z56WPvfM09Lnnnlaims5TUufe+Zp6XPPPC197pmnpc8987T0uWealtHnnnla+twzT0ufe+Zp6XPPPC3FtZympc8987T0uWeelj73zNPS5555WvrcM03L5HPPPC197pmnpc8987T0uWeeluJaTtPS5555WvrcM09Ln3vmaelzzzwtfe6ZpqX43DNPS5975mnpc888LX3umaeluJbTtPS5Z56WPvfM09Lnnnla+twzT0ufe6ZpmX3umaelzz3ztPS5Z56WPvfM01Jcy2la+twzT0ufe+Zp6XPPPC197pmnpc8907QsPvfM09Lnnnla+twzT0ufe+ZpKa7lNC197pmnpc8987T0uWeelj73zNPS555pWlafe+Zp6XPPPC197pmn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7wrL+neFZf27wrL+XWFZ/66wrH9XWNa/Kyzr3xWW9e8Ky/p3hWX9u8Ky/l1hWf+usKx/V1jWvyss698VlvXvCsv6d4Vl/bvCsv5dYVn/rrCsf1dY1r8rLOvfFZb17wrL+neFZf27wrL+XWFZ/66wrH9XWNa/Kyzr3xWW9e8Ky/p3hWX9u8Ky/l1hWf+usKx/V1jRvyus6N8VVvTvCiv6d4WVTX13Lvp3hRX9u8KK/l1hRf+usKJ/V1jRvyus6N8VVvTvCiv6d4UV/bvCiv5dYUX/rrCif1dY0b8rrOjfFVb07wor+neFFf27wor+XWFF/66won9XWNG/K6zo3xVW9O8KK/p3hRX9u8KK/l1hRf+usKJ/V1jRvyus6N8VVvTvCiv6d4UV/bvCiv5dYUX/rrCif1dY0b8rrOjfFVb07wor+neFFf27wor+XWFF/66won9XWNG/K6zo3xVW9O8KK/p3hRX9u8KK/l1hRf+usKJ/V1jRvyus6N8VVvTvCiv6d4UV/bvCiv5dYUX/rrCif1dY0b8rrOjfFVb07wor+neFFf27wor+XWFF/66won9XWNG/K6zo3xVW9O8KK/p3hRX9u8KK/l1hRf+usKJ/V1jRvyus6N8VVvTvCiv6d4UV/bvCiv5dYUX/rrCif1dY0b8rrOjfFVb07wor+neFFf27wor+XWFF/66won9XWNG/K6zo3xVW9e8Kq/p3hVX9u8Kq/l1hdVPfnav+XWFV/66wqn9XWNW/K6zq3xVW9e8Kq/p3hVX9u8Kq/l1hVf+usKp/V1jVvyus6t8VVvXvCqv6d4VV/bvCqv5dYVX/rrCqf1dY1b8rrOrfFVb17wqr+neFVf27wqr+XWFV/66wqn9XWNW/K6zq3xVW9e8Kq/p3hVX9u8Kq/l1hVf+usKp/V1jVvyus6t8VVvXvCqv6d4VV/bvCqv5dYVX/rrCqf1dY1b8rrOrfFVb17wqr+neFVf27wqr+XWFV/66wqn9XWNW/K6zq3xVW9e8Kq/p3hVX9u8Kq/l1hVf+usKp/V1jVvyus6t8VVvXvCqv6d4VV/bvCqv5dYVX/rrCqf1dY1b8rrOrfFVb17wqr+neFVf27wqr+XWFV/66wqn9XWNW/K6zq3xVW9e8Kq/p3hVX9u8Kq/l1hVf+usKp/V1jVvyus6t8VVvXvCqv6d4VV/bvCqv5dYVX/rrCqf1dY1b8rrOrfFVb17wqr+neFNf27wpr+XWFN/66wpn9XWNvUd+emf1dY078rrOnfFdb07wpr+neFNf27wpr+XWFN/66wpn9XWNO/K6zp3xXW9O8Ka/p3hTX9u8Ka/l1hTf+usKZ/V1jTvyus6d8V1vTvCmv6d4U1/bvCmv5dYU3/rrCmf1dY078rrOnfFdb07wpr+neFNf27wpr+XWFN/66wpn9XWNO/K6zp3xXW9O8Ka/p3hTX9u8Ka/l1hTf+usKZ/V1jTvyus6d8V1vTvCmv6d4U1/bvCmv5dYU3/rrCmf1dY078rrOnfFdb07wpr+neFNf27wpr+XWFN/66wpn9XWNO/K6zp3xXW9O8Ka/p3hTX9u8Ka/l1hTf+usKZ/V1jTvyus6d8V1vTvCmv6d4U1/bvCmv5dYU3/rrCmf1dY078rrOnfFdb07wpr+neFNf27wpr+XWFN/66wpn9XWNO/K6zp3xXW9O8Ka/p3hTX9u8Ka/l1hTf+usKZ/V1jTvyus6d8V1vTvCmv6d4U1/bvCmv5dYV3/rrCuf1dY178rrOvfFdY39d25698V1vXvCuv6d4V1/bvCuv5dYV3/rrCuf1dY178rrOvfFdb17wrr+neFdf27wrr+XWFd/66wrn9XWNe/K6zr3xXW9e8K6/p3hXX9u8K6/l1hXf+usK5/V1jXvyus698V1vXvCuv6d4V1/bvCuv5dYV3/rrCuf1dY178rrOvfFdb17wrr+neFdf27wrr+XWFd/66wrn9XWNe/K6zr3xXW9e8K6/p3hXX9u8K6/l1hXf+usK5/V1jXvyus698V1vXvCuv6d4V1/bvCuv5dYV3/rrCuf1dY178rrOvfFdb17wrr+neFdf27wrr+XWFd/66wrn9XWNe/K6zr3xXW9e8K6/p3hXX9u8K6/l1hXf+usK5/V1jXvyus698V1vXvCuv6d4V1/bvCuv5dYV3/rrCuf1dY178rrOvfFdb17wrr+neFdf27wrr+XWFd/66wrn9XWNe/K6zr3xXW9e8K6/p3hXX9u8K6/l1hXf+usK59V1jeNu27wr5SUN6dv1JQ3p2/UlDenb9SUN6dv1JQ3p2/UlDenb9SUN6dv1JQ3p2/UtDfnbXvCvtKQX931r4r7CsF/d1Z+66wrxT0d2ftu8K+UtDfnbXvCvtKQX931r4r7CsF/d1Z+66w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","file_map":{"0":{"source":"\n// TODO: Once we fully move to the new SSA pass this module can be removed and replaced\n// by the methods in the `slice` module\nimpl<T, N> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> Field {}\n\n    #[builtin(arraysort)]\n    pub fn sort(self) -> Self {}\n\n    // Sort with a custom sorting function.\n    pub fn sort_via<Env>(mut a: Self, ordering: fn[Env](T, T) -> bool) -> Self { \n        for i in 1 .. a.len() {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                }\n            }\n        }\n        a\n    }\n\n    // Converts an array into a slice.\n    pub fn as_slice(self) -> [T] {\n        let mut slice = [];\n        for elem in self {\n            slice = slice.push_back(elem);\n        }\n        slice\n    }\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1 .. self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1 .. self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/array.nr"},"2":{"source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u16 { fn eq(self, other: u16) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i16 { fn eq(self, other: i16) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, N> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<N> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, N> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n","path":"std/cmp.nr"},"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}","path":"std/collections/bounded_vec.nr"},"19":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"27":{"source":"mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [u8; N], _state_length: u32) -> [u8; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n","path":"std/hash.nr"},"40":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\n\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo,hi)\n    }\n\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1; \n        if N <= 18 {\n            for i in 0..N-2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N-1 {           \n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            if ascii < 71 {\n                ascii - 55\n            } else {\n                ascii - 87\n            }\n            \n        } as Field\n    }\n\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if self < b {\n            (U128::from_u64s_le(0, 0), self)\n        } else {\n            //TODO check if this can overflow?\n            let (q,r) = self.unconstrained_div(b * U128::from_u64s_le(2,0));\n            let q_mul_2 = q * U128::from_u64s_le(2,0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::from_u64s_le(1,0), r - b)\n            }\n\n        }  \n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f-lo) / pow64;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo+self.hi*pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64))as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift left with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift right with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n","path":"std/uint128.nr"},"44":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint,\n    grumpkin_private_key::GrumpkinPrivateKey,\n};\n\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN = 5;\n\nstruct NullifierKeyValidationRequest {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\nimpl Eq for NullifierKeyValidationRequest {\n    fn eq(self, request: NullifierKeyValidationRequest) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequest {\n    fn empty() -> Self {\n        NullifierKeyValidationRequest {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN> for NullifierKeyValidationRequest {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN> for NullifierKeyValidationRequest {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_SERIALIZED_LEN]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n        }\n    }\n}\n\nimpl NullifierKeyValidationRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> NullifierKeyValidationRequestContext {\n        NullifierKeyValidationRequestContext {\n            public_key: self.public_key,\n            secret_key: self.secret_key,\n            contract_address,\n        }\n    }\n}\n\nstruct NullifierKeyValidationRequestContext {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n    contract_address: AztecAddress,\n}\n\nimpl Eq for NullifierKeyValidationRequestContext {\n    fn eq(self, request: NullifierKeyValidationRequestContext) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n            & (request.contract_address.eq(self.contract_address))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequestContext {\n    fn empty() -> Self {\n        NullifierKeyValidationRequestContext {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN> for NullifierKeyValidationRequestContext {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n            self.contract_address.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN> for NullifierKeyValidationRequestContext {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_SERIALIZED_LEN]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n            contract_address: AztecAddress::from_field(fields[4]),\n        }\n    }\n}\n\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/nullifier_key_validation_request.nr"},"49":{"source":"use crate::abis::function_selector::FunctionSelector;\nuse crate::constants::GENERATOR_INDEX__FUNCTION_LEAF;\nuse crate::traits::Hash;\n\nstruct FunctionLeafPreimage {\n    selector : FunctionSelector,\n    is_internal : bool,\n    is_private : bool,\n    vk_hash : Field,\n    acir_hash : Field\n}\n\nimpl Hash for FunctionLeafPreimage {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator([\n            self.selector.to_field(),\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.vk_hash,\n            self.acir_hash\n        ], GENERATOR_INDEX__FUNCTION_LEAF)\n    }\n}\n\nstruct ContractClassFunctionLeafPreimage {\n    selector : FunctionSelector,\n    vk_hash : Field,\n}\n\nimpl Hash for ContractClassFunctionLeafPreimage {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator([\n            self.selector.to_field(),\n            self.vk_hash,\n        ], GENERATOR_INDEX__FUNCTION_LEAF)\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/function_leaf_preimage.nr"},"50":{"source":"use crate::constants::{GENERATOR_INDEX__SIDE_EFFECT};\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Hash, Serialize, Deserialize};\n\ntrait Ordered {\n    fn counter(self) -> u32;\n}\n\nstruct SideEffect{\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffect {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffect {\n    fn eq(self, side_effect: SideEffect) -> bool {\n        (self.value == side_effect.value)\n        & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffect {\n    fn empty() -> Self {\n        SideEffect {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffect {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize() , GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<2> for SideEffect {\n    fn serialize(self) -> [Field; 2] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<2> for SideEffect {\n    fn deserialize(values: [Field; 2]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nstruct SideEffectLinkedToNoteHash{\n    value: Field,\n    note_hash: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffectLinkedToNoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffectLinkedToNoteHash {\n    fn eq(self, side_effect: SideEffectLinkedToNoteHash) -> bool {\n        (self.value == side_effect.value)\n            & (self.note_hash == side_effect.note_hash) \n            & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffectLinkedToNoteHash {\n    fn empty() -> Self {\n        SideEffectLinkedToNoteHash {\n            value: 0,\n            note_hash: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffectLinkedToNoteHash {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize(),\n        GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<3> for SideEffectLinkedToNoteHash {\n    fn serialize(self) -> [Field; 3] {\n        [self.value, self.note_hash, self.counter as Field]\n    }\n}\n\nimpl Deserialize<3> for SideEffectLinkedToNoteHash {\n    fn deserialize(values: [Field; 3]) -> Self {\n        Self {\n            value: values[0],\n            note_hash: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/side_effect.nr"},"58":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{\n        GENERATOR_INDEX__FUNCTION_DATA,\n        FUNCTION_DATA_LENGTH,\n    },\n    hash::pedersen_hash,\n    traits::{\n        Serialize,\n        Hash,\n        Deserialize,\n    },\n};\n\nstruct FunctionData {\n    // First four bytes of the abi encoding \n    // of a function. \n    selector : FunctionSelector,\n    is_internal : bool,\n    is_private : bool,\n    is_constructor : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_internal == other.is_internal &\n        self.is_private == other.is_private &\n        self.is_constructor == other.is_constructor\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_internal: serialized[1] as bool,\n            is_private: serialized[2] as bool,\n            is_constructor: serialized[3] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    assert_eq(hash, 0x200569267c0f73ac89aaa414239398db9445dd4ad3a8cf37015cd55b8d4c5e8d);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/function_data.nr"},"61":{"source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_u32(value: u32) -> Self {\n        Self {\n            inner : value,\n        }\n    }\n\n    pub fn from_field(value : Field) -> Self {\n        Self {\n            inner : value as u32,\n        }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/function_selector.nr"},"62":{"source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::Empty;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, caller_context: CallerContext) -> bool {\n        caller_context.msg_sender.eq(self.msg_sender)\n            & caller_context.storage_contract_address.eq(self.storage_contract_address)\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nstruct CallRequest {\n    hash: Field,\n    caller_contract_address: AztecAddress,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Eq for CallRequest {\n    fn eq(self, call_request: CallRequest) -> bool {\n        (call_request.hash == self.hash)\n            & (call_request.caller_contract_address.eq(self.caller_contract_address))\n            & (call_request.caller_context.eq(self.caller_context))\n            & (call_request.start_side_effect_counter == self.start_side_effect_counter)\n            & (call_request.end_side_effect_counter == self.end_side_effect_counter)\n    }\n}\n\nimpl Empty for CallRequest {\n    fn empty() -> Self {\n        CallRequest {\n            hash: 0,\n            caller_contract_address: AztecAddress::zero(),\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl CallRequest {\n    pub fn is_empty(self) -> bool {\n        self.hash == 0\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/call_request.nr"},"64":{"source":"use crate::abis::{\n    combined_accumulated_data::{\n        CombinedAccumulatedData,\n        FinalAccumulatedData,\n        AccumulatedMetaData,\n        AccumulatedMetaDataBuilder,\n        CombinedAccumulatedDataBuilder,\n    },\n    combined_constant_data::CombinedConstantData\n};\nuse crate::mocked::AggregationObject;\n\nstruct KernelCircuitPublicInputs {\n    aggregation_object: AggregationObject,\n    meta_hwm: Field,\n    end: CombinedAccumulatedData,\n    constants: CombinedConstantData,\n    is_private: bool,\n}\n\nstruct KernelCircuitPublicInputsFinal {\n    aggregation_object: AggregationObject,\n    meta_hwm: Field,\n    end_meta: AccumulatedMetaData,\n    // TODO(fees) change this to end_app_logic\n    end: FinalAccumulatedData,\n    constants: CombinedConstantData,\n    is_private: bool,\n}\n\nstruct KernelCircuitPublicInputsBuilder {\n    aggregation_object: AggregationObject,\n    meta_hwm: Field,\n    end_meta: AccumulatedMetaDataBuilder,\n    end: CombinedAccumulatedDataBuilder,\n    constants: CombinedConstantData,\n    is_private: bool,\n}\n\nimpl KernelCircuitPublicInputsBuilder {\n    pub fn finish(self) -> KernelCircuitPublicInputs {\n        KernelCircuitPublicInputs {\n            aggregation_object: self.aggregation_object,\n            meta_hwm: self.meta_hwm,\n            end: self.end.finish(),\n            constants: self.constants,\n            is_private: self.is_private,\n        }\n    }\n\n    pub fn to_final(self) -> KernelCircuitPublicInputsFinal {\n        let meta = self.end_meta.finish();\n        let app = self.end.to_final();\n        KernelCircuitPublicInputsFinal {\n            aggregation_object: self.aggregation_object,\n            meta_hwm: self.meta_hwm,\n            end_meta: meta,\n            end: app,\n            constants: self.constants,\n            is_private: self.is_private,\n        }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/abis/kernel_circuit_public_inputs.nr"},"69":{"source":"use crate::constants::GENERATOR_INDEX__TX_REQUEST;\nuse crate::address::AztecAddress;\nuse crate::transaction::context::TxContext;\nuse crate::abis::function_data::FunctionData;\nuse crate::traits::Hash;\n\nstruct TxRequest {\n    origin : AztecAddress,\n    args_hash : Field,\n    tx_context : TxContext,\n    function_data : FunctionData\n}\n\nimpl Hash for TxRequest {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator([\n            self.origin.to_field(),\n            self.function_data.hash(),\n            self.args_hash,\n            self.tx_context.hash(),\n        ], GENERATOR_INDEX__TX_REQUEST)\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/transaction/request.nr"},"70":{"source":"use crate::constants::GENERATOR_INDEX__TX_CONTEXT;\nuse crate::contrakt::deployment_data::ContractDeploymentData;\nuse crate::traits::Hash;\n\nstruct TxContext {\n    is_fee_payment_tx : bool,\n    is_rebate_payment_tx : bool,\n    is_contract_deployment_tx : bool,\n\n    contract_deployment_data : ContractDeploymentData,\n\n    chain_id : Field,\n    version : Field,\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator([\n            self.is_fee_payment_tx as Field,\n            self.is_rebate_payment_tx as Field,\n            self.is_contract_deployment_tx as Field,\n            self.contract_deployment_data.hash(),\n            self.chain_id,\n            self.version,\n        ], GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/transaction/context.nr"},"74":{"source":"use crate::{\n    constants::{\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONSTRUCTOR\n    },\n    hash::pedersen_hash,\n    contract_class::ContractClassId,\n    utils,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, ToField, Serialize, Deserialize};\nuse crate::type_serialization::{ETH_ADDRESS_SERIALIZED_LEN, AZTEC_ADDRESS_SERIALIZED_LEN};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_SERIALIZED_LEN> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_SERIALIZED_LEN] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_SERIALIZED_LEN> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_SERIALIZED_LEN]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute_from_public_key(pub_key: GrumpkinPoint, contract_class_id: ContractClassId, salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> AztecAddress {\n        AztecAddress::compute(PublicKeysHash::compute(pub_key), PartialAddress::compute(contract_class_id, salt, initialization_hash, portal_contract_address))\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n    \n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n}\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_SERIALIZED_LEN> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_SERIALIZED_LEN] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_SERIALIZED_LEN> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_SERIALIZED_LEN]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\nimpl EthAddress{\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n}\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(contract_class_id: ContractClassId, salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(contract_class_id, SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address))\n    }\n\n    pub fn compute_from_salted_initialization_hash(contract_class_id: ContractClassId, salted_initialization_hash: SaltedInitializationHash) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash([\n                contract_class_id.to_field(),\n                salted_initialization_hash.to_field()\n            ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n        )\n    }\n\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(salt : Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash([\n                salt,\n                initialization_hash,\n                portal_contract_address.to_field(),\n            ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash([\n                public_key.x,\n                public_key.y,\n            ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\npub fn compute_initialization_hash(selector: Field, args_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        selector,\n        args_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/address.nr"},"90":{"source":"use dep::std::array;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, N>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len, empty_value: T::empty() }\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, N>(array: [T; N]) where T: Empty + Eq {\n    let array_length = array.len();\n\n    let mut first_zero_pos = array_length;\n    let mut last_non_zero_pos = 0;\n\n    for i in 0..array_length {\n        let is_empty = is_empty(array[i]);\n        if !is_empty {\n            last_non_zero_pos = i;\n        } else if is_empty & (first_zero_pos == array_length) {\n            first_zero_pos = i;\n        }\n    }\n    assert((last_non_zero_pos as u64) <= (first_zero_pos as u64), \"invalid array\");\n}\n\n// Helper method to determine the number of non-zero/empty elements in a validated array (ie, validate_array(array) \n// should be true).\npub fn array_length<T, N>(array: [T; N]) -> Field where T: Empty + Eq {\n    let mut length = 0;\n    let mut end = false;\n    for elem in array {\n        end |= is_empty(elem);\n        if !end {\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_eq<T, N, S>(array: [T; N], expected: [T; S]) -> bool where T: Empty + Eq {\n    let mut eq = array_length(array) == S;\n\n    for i in 0..S {\n        eq &= array[i].eq(expected[i]);\n    }\n\n    eq\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array = [];\n    validate_array(valid_array);\n\n    let valid_array = [0];\n    validate_array(valid_array);\n\n    let valid_array = [1, 2, 3];\n    validate_array(valid_array);\n\n    let valid_array = [1, 2, 3, 0];\n    validate_array(valid_array);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    validate_array(valid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid() {\n    let invalid_array = [0, 1];\n    validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([]), 0);\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n    assert_eq(array_length([123, 0, 456]), 1);\n    assert_eq(array_length([0, 123, 0, 456]), 0);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/utils/arrays.nr"},"92":{"source":"// This is a quick struct made to pack 32 bytes into 4 u64s\n// and then pack those into two u128s.\n//\n// Creating a u256 was made for convenience.\n//\n// This is needed because in the cpp code, we have accumulate_sha256\n// which returns 2 field elements, one for the high and low limb.\nstruct U256 {\n    // This is in big-endian order, typically because\n    // sha256 is usually in big endian order.\n    // Note: this means that inner[0] has the most significant 64 bits.\n    inner : [u64; 4]\n}\n\nimpl U256 {\n    pub fn from_bytes32(bytes : [u8;32]) -> U256 {\n        // We use addition rather than a bitwise OR as the bitshifts ensure that none of the bytes overlap each other.\n        let high_0 = ((bytes[0] as u64) << 56)\n                + ((bytes[1] as u64) << 48)\n                + ((bytes[2] as u64) << 40)\n                + ((bytes[3] as u64) << 32)\n                + ((bytes[4] as u64) << 24)\n                + ((bytes[5] as u64) << 16)\n                + ((bytes[6] as u64) << 8)\n                +  (bytes[7] as u64);\n        \n        let high_1 = ((bytes[8] as u64) << 56)\n                + ((bytes[9] as u64) << 48)\n                + ((bytes[10] as u64) << 40)\n                + ((bytes[11] as u64) << 32)\n                + ((bytes[12] as u64) << 24)\n                + ((bytes[13] as u64) << 16)\n                + ((bytes[14] as u64) << 8)\n                +  (bytes[15] as u64);\n        \n        let low_0 = ((bytes[16] as u64) << 56)\n                + ((bytes[17] as u64) << 48)\n                + ((bytes[18] as u64) << 40)\n                + ((bytes[19] as u64) << 32)\n                + ((bytes[20] as u64) << 24)\n                + ((bytes[21] as u64) << 16)\n                + ((bytes[22] as u64) << 8)\n                +  (bytes[23] as u64);\n        \n        let low_1 = ((bytes[24] as u64) << 56)\n                + ((bytes[25] as u64) << 48)\n                + ((bytes[26] as u64) << 40)\n                + ((bytes[27] as u64) << 32)\n                + ((bytes[28] as u64) << 24)\n                + ((bytes[29] as u64) << 16)\n                + ((bytes[30] as u64) << 8)\n                +  (bytes[31] as u64);\n\n        U256{inner : [high_0, high_1, low_0, low_1]}\n    }\n\n    // We cannot represent u128 in the type system\n    // so we cannot return a u128 type.\n    // \n    // This as conversion assumes that Field can store 128 bits of information\n    // or else the conversion is lossy.\n    //\n    // TODO: Add a test for this.\n    pub fn to_u128_limbs(self) -> [Field;2] {\n        let two_pow_64 = 2.pow_32(64);\n\n        let high = (self.inner[0] as Field) * two_pow_64 + self.inner[1] as Field;\n        let low  = (self.inner[2] as Field) * two_pow_64 + self.inner[3] as Field;\n        \n        [high,low]\n    }\n}\n\n#[test]\nfn smoke_u256_from_bytes32_all_zeroes() {\n    let input = [0; 32];\n    let result = U256::from_bytes32(input);\n    assert(result.inner[0] == 0);\n    assert(result.inner[1] == 0);\n    assert(result.inner[2] == 0);\n    assert(result.inner[3] == 0);\n}\n\n#[test]\nfn smoke_u256_from_bytes32_one_zero_zero_zero() {\n    // We want to output [1,0,0,0]\n    let input = [\n        0, 0, 0, 0, 0, 0, 0, 1,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    ];\n    let result = U256::from_bytes32(input);\n\n    assert(result.inner[0] == 1);\n    assert(result.inner[1] == 0);\n    assert(result.inner[2] == 0);\n    assert(result.inner[3] == 0);\n}\n\n#[test]\nfn smoke_u256_from_bytes32_test() {\n    /*\n    input:  [   0xAA, 0xBB, 0xCC, 0xDD, \n                0xEE, 0xFF, 0x00, 0x11, \n                0x22, 0x33, 0x44, 0x55, \n                0x66, 0x77, 0x88, 0x99, \n                0x11, 0x22, 0x33, 0x44, \n                0x55, 0x66, 0x77, 0x88, \n                0x99, 0xAA, 0xBB, 0xCC, \n                0xDD, 0xEE, 0xFF, 0x00\n            ]\n    output: inner[0]: 0xAABBCCDDEEFF0011\n            inner[1]: 0x2233445566778899\n            inner[2]: 0x1122334455667788\n            inner[3]: 0x99AABBCCDDEEFF00\n    */\n    let input : [u8;32] = [\n        0xAA, 0xBB, 0xCC, 0xDD,\n        0xEE, 0xFF, 0x00, 0x11,\n        0x22, 0x33, 0x44, 0x55,\n        0x66, 0x77, 0x88, 0x99,\n        0x11, 0x22, 0x33, 0x44,\n        0x55, 0x66, 0x77, 0x88,\n        0x99, 0xAA, 0xBB, 0xCC,\n        0xDD, 0xEE, 0xFF, 0x00\n    ];\n    let result = U256::from_bytes32(input);\n\n    assert(result.inner[0] == 0xAABBCCDDEEFF0011);\n    assert(result.inner[1] == 0x2233445566778899);\n    assert(result.inner[2] == 0x1122334455667788);\n    assert(result.inner[3] == 0x99AABBCCDDEEFF00);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/utils/uint256.nr"},"94":{"source":"use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u16 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/traits.nr"},"98":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::{ContractClassFunctionLeafPreimage, FunctionLeafPreimage};\nuse crate::contract_class::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n        ARGS_HASH_CHUNK_COUNT,\n        ARGS_HASH_CHUNK_LENGTH,\n        CONTRACT_TREE_HEIGHT, \n        FUNCTION_TREE_HEIGHT, \n        NOTE_HASH_TREE_HEIGHT,\n        NUM_FIELDS_PER_SHA256,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK,\n        GENERATOR_INDEX__CONSTRUCTOR,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__COMMITMENT_NONCE,\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/hash.nr"},"99":{"source":"use crate::abis::{\n    function_data::FunctionData,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n};\nuse crate::address::AztecAddress;\nuse crate::constants::{\n    GENERATOR_INDEX__CONTRACT_LEAF,\n};\nuse crate::traits::Hash;\n\nstruct ContractClassId {\n  inner: Field\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(artifact_hash: Field, private_functions_root: Field, public_bytecode_commitment: Field) -> Self {\n        let hash = dep::std::hash::pedersen_hash_with_separator([\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment,\n        ], GENERATOR_INDEX__CONTRACT_LEAF); // TODO(@spalladino): Update generator index\n        \n        ContractClassId::from_field(hash)\n    }\n\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_field(value : Field) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n\n    pub fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/contract_class.nr"},"101":{"source":"use crate::traits::{Serialize, Deserialize};\nuse dep::std::cmp::Eq;\n\nglobal GRUMPKIN_POINT_SERIALIZED_LEN: Field = 2;\n\nstruct GrumpkinPoint {\n    x: Field,\n    y: Field,\n}\n\nimpl Serialize<GRUMPKIN_POINT_SERIALIZED_LEN> for GrumpkinPoint {\n    fn serialize(self) -> [Field; GRUMPKIN_POINT_SERIALIZED_LEN] {\n        [self.x, self.y]\n    }\n}\n\nimpl Deserialize<GRUMPKIN_POINT_SERIALIZED_LEN> for GrumpkinPoint {\n    fn deserialize(serialized: [Field; GRUMPKIN_POINT_SERIALIZED_LEN]) -> Self {\n        Self {\n            x: serialized[0],\n            y: serialized[1],\n        }\n    }\n}\n\nimpl Eq for GrumpkinPoint {\n    fn eq(self, point: GrumpkinPoint) -> bool {\n        (point.x == self.x) & (point.y == self.y)\n    }\n}\n\nimpl GrumpkinPoint {\n    pub fn new(x: Field, y: Field) -> Self {\n        Self { x, y }\n    }\n\n    pub fn zero() -> Self {\n        Self {\n            x: 0,\n            y: 0,\n        }\n    }\n\n    pub fn is_zero(self) -> bool {\n        (self.x == 0) & (self.y == 0)\n    }\n\n    // TODO(David): Would be quite careful here as (0,0) is not a point\n    // on the curve. A boolean flag may be the better approach here,\n    // would also cost less constraints. It seems like we don't need to \n    // group arithmetic either. \n    fn assert_is_zero(self) {\n        assert(self.x == 0);\n        assert(self.y == 0);\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/grumpkin_point.nr"},"104":{"source":"use dep::std::{\n    cmp::Eq,\n    grumpkin_scalar::GrumpkinScalar,\n    grumpkin_scalar_mul::grumpkin_fixed_base,\n};\nuse crate::grumpkin_point::GrumpkinPoint;\n\nglobal GRUMPKIN_PRIVATE_KEY_SERIALIZED_LEN: Field = 2;\n\nstruct GrumpkinPrivateKey {\n    high: Field,\n    low: Field,\n}\n\nimpl Eq for GrumpkinPrivateKey {\n    fn eq(self, key: GrumpkinPrivateKey) -> bool {\n        (key.high == self.high) & (key.low == self.low)\n    }\n}\n\nimpl GrumpkinPrivateKey {\n    pub fn new(high: Field, low: Field) -> Self {\n        GrumpkinPrivateKey { high, low }\n    }\n\n    pub fn zero() -> Self {\n        Self {\n            high: 0,\n            low: 0,\n        }\n    }\n\n    pub fn is_zero(self) -> bool {\n        (self.high == 0) & (self.low == 0)\n    }\n\n    pub fn serialize(self) -> [Field; GRUMPKIN_PRIVATE_KEY_SERIALIZED_LEN] {\n        [self.high, self.low]\n    }\n\n    pub fn derive_public_key(self) -> GrumpkinPoint {\n        let public_key = grumpkin_fixed_base(GrumpkinScalar { high: self.high, low: self.low });\n        GrumpkinPoint { x: public_key[0], y: public_key[1] }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/grumpkin_private_key.nr"},"107":{"source":"use crate::{\n    address::EthAddress,\n    contract_class::ContractClassId,\n    constants::{\n        CONTRACT_DEPLOYMENT_DATA_LENGTH,\n        GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n    },\n    grumpkin_point::GrumpkinPoint,\n    hash::pedersen_hash,\n    traits::{\n        Deserialize,\n        Hash,\n        Serialize,\n    },\n};\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    public_key : GrumpkinPoint,\n    initialization_hash : Field,\n    contract_class_id : ContractClassId,\n    contract_address_salt : Field,\n    portal_contract_address : EthAddress,\n}\n// docs:end:contract-deployment-data\n\nimpl Eq for ContractDeploymentData {\n    fn eq(self, other: Self) -> bool {\n        self.public_key.eq(other.public_key) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.contract_address_salt.eq(other.contract_address_salt) &\n        self.portal_contract_address.eq(other.portal_contract_address)\n    }\n}\n\nimpl Hash for ContractDeploymentData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\nimpl Serialize<CONTRACT_DEPLOYMENT_DATA_LENGTH> for ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.initialization_hash,\n            self.contract_class_id.to_field(),\n            self.contract_address_salt,\n            self.portal_contract_address.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_DEPLOYMENT_DATA_LENGTH> for ContractDeploymentData {\n    fn deserialize(serialized: [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint {\n                x: serialized[0],\n                y: serialized[1],\n            },\n            initialization_hash: serialized[2],\n            contract_class_id: ContractClassId::from_field(serialized[3]),\n            contract_address_salt: serialized[4],\n            portal_contract_address: EthAddress::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl ContractDeploymentData {\n    fn assert_is_zero(self) {\n        self.public_key.assert_is_zero();\n        assert(self.initialization_hash == 0);\n        self.contract_class_id.assert_is_zero();\n        assert(self.contract_address_salt == 0);\n        self.portal_contract_address.assert_is_zero();\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: ContractDeploymentData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = ContractDeploymentData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/types/src/contrakt/deployment_data.nr"},"111":{"source":"use crate::common;\nuse dep::std::unsafe;\nuse dep::types::{\n    abis::{\n        combined_constant_data::CombinedConstantData,\n        private_kernel::private_call_data::PrivateCallData,\n        kernel_circuit_public_inputs::{KernelCircuitPublicInputs, KernelCircuitPublicInputsBuilder},\n        side_effect::{SideEffect, SideEffectLinkedToNoteHash},\n    },\n    address::{AztecAddress, PublicKeysHash, compute_initialization_hash},\n    mocked::{Proof, verify_previous_kernel_state},\n    transaction::request::TxRequest,\n    traits::is_empty_array,\n};\n\n// Initialization struct for private inputs to the private kernel\nstruct PrivateKernelInputsInit {\n    tx_request: TxRequest,\n    private_call: PrivateCallData,\n}\n\nimpl PrivateKernelInputsInit {\n    fn initialize_end_values(self, public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n        public_inputs.constants = CombinedConstantData {\n            historical_header: self.private_call.call_stack_item.public_inputs.historical_header,\n            tx_context: self.tx_request.tx_context,\n        };\n    }\n\n    // Confirm that the TxRequest (user's intent) \n    // matches the private call being executed\n    fn validate_this_private_call_against_tx_request(self) {\n        let tx_request = self.tx_request;\n        // Call stack item for the initial call\n        let call_stack_item = self.private_call.call_stack_item;\n        \n        // Checks to ensure that the user's intent matches the initial private call\n        //\n        // We use the word correct to denote whether it matches the user intent.\n        //\n        // Ensure we are calling the correct initial contract\n        let origin_address_matches = tx_request.origin.eq(call_stack_item.contract_address);\n        assert(origin_address_matches, \"origin address does not match call stack items contract address\");\n        //\n        // Ensure we are calling the correct initial function in the contract\n        let entry_point_function_matches = tx_request.function_data.hash() == call_stack_item.function_data.hash();\n        assert(entry_point_function_matches, \"tx_request function_data must match call_stack_item function_data\");\n        //\n        // Ensure we are passing the correct arguments to the function.\n        let args_match = tx_request.args_hash == call_stack_item.public_inputs.args_hash;\n        assert(args_match, \"noir function args passed to tx_request must match args in the call_stack_item\");\n    }\n\n    fn validate_inputs(self) {\n        let call_stack_item = self.private_call.call_stack_item;\n\n        let function_data = call_stack_item.function_data;\n        assert(function_data.is_private, \"Private kernel circuit can only execute a private function\");\n        assert(function_data.is_internal == false, \"Cannot call an internal function directly\");\n\n        let call_context = call_stack_item.public_inputs.call_context;\n        assert(call_context.is_delegate_call == false, \"Users cannot make a delegatecall\");\n        assert(call_context.is_static_call == false, \"Users cannot make a static call\");\n        // The below also prevents delegatecall/staticcall in the base case\n        assert(call_context.storage_contract_address.eq(call_stack_item.contract_address), \"Storage contract address must be that of the called contract\");\n    }\n\n    fn update_end_values(self, public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n        // Since it's the first iteration, we need to push the the tx hash nullifier into the `new_nullifiers` array\n        public_inputs.end.new_nullifiers.push(SideEffectLinkedToNoteHash{\n            value: self.tx_request.hash(),\n            note_hash: 0,\n            counter: 0,\n        });\n\n        // Note that we do not need to nullify the transaction request nonce anymore.\n        // Should an account want to additionally use nonces for replay protection or handling cancellations,\n        // they will be able to do so in the account contract logic:\n        // https://github.com/AztecProtocol/aztec-packages/issues/660\n    }\n\n    pub fn native_private_kernel_circuit_initial(self) -> KernelCircuitPublicInputs {\n        let mut public_inputs: KernelCircuitPublicInputsBuilder = unsafe::zeroed();\n        public_inputs.is_private = true;\n        \n        self.initialize_end_values(&mut public_inputs);\n\n        self.validate_inputs();\n\n        common::validate_arrays(self.private_call.call_stack_item.public_inputs);\n\n        self.validate_this_private_call_against_tx_request();\n\n        common::validate_read_requests(\n            public_inputs.constants.historical_header.state.partial.note_hash_tree.root,\n            self.private_call.call_stack_item.public_inputs.read_requests,\n            self.private_call.read_request_membership_witnesses\n        );\n\n        // TODO(dbanks12): feels like update_end_values should happen after contract logic\n        self.update_end_values(&mut public_inputs);\n        common::update_end_values(self.private_call, &mut public_inputs);\n\n        common::contract_logic(self.private_call,\n                          &mut public_inputs,\n                          self.tx_request.tx_context.contract_deployment_data,\n                          self.tx_request.function_data);\n\n        // TODO(David): What previous kernel proof are we talking about, since this is private-kernel-init\n        let (is_previous_state_valid, updated_aggregation_object) = verify_previous_kernel_state(public_inputs.aggregation_object,self.private_call.proof);\n        assert(is_previous_state_valid);\n\n        public_inputs.aggregation_object = updated_aggregation_object;\n\n        public_inputs.finish()\n    }\n}\n\nmod tests {\n    use crate::private_kernel_init::PrivateKernelInputsInit;\n    use dep::types::constants::{\n        MAX_READ_REQUESTS_PER_CALL,\n    };\n    use dep::types::{\n        abis::{\n            kernel_circuit_public_inputs::KernelCircuitPublicInputs,\n            nullifier_key_validation_request::NullifierKeyValidationRequest,\n            private_kernel::private_call_data::PrivateCallData,\n            side_effect::{SideEffect, SideEffectLinkedToNoteHash},\n        },\n        grumpkin_point::GrumpkinPoint,\n        grumpkin_private_key::GrumpkinPrivateKey,\n        address::{AztecAddress, compute_initialization_hash},\n        hash::{\n            compute_constructor_hash,\n            compute_logs_hash,\n            stdlib_recursion_verification_key_compress_native_vk,\n        },\n        tests::private_call_data_builder::PrivateCallDataBuilder,\n        transaction::request::TxRequest,\n        utils::arrays::array_length,\n    };\n\n    struct PrivateKernelInitInputsBuilder {\n        tx_request: TxRequest,\n        private_call: PrivateCallDataBuilder,\n    }\n\n    impl PrivateKernelInitInputsBuilder {\n        pub fn new() -> Self {\n            PrivateKernelInitInputsBuilder::new_with_config(false)\n        }\n\n        pub fn new_constructor() -> Self {\n            PrivateKernelInitInputsBuilder::new_with_config(true)\n        }\n\n        fn new_with_config(is_constructor: bool) -> Self {\n            let private_call = PrivateCallDataBuilder::new(is_constructor);\n            let tx_request = private_call.build_tx_request();\n\n            PrivateKernelInitInputsBuilder {\n                tx_request,\n                private_call,\n            }\n        }\n\n        pub fn execute(self) -> KernelCircuitPublicInputs {\n            let kernel = PrivateKernelInputsInit {\n                tx_request: self.tx_request,\n                private_call: self.private_call.finish(),\n            };\n\n            kernel.native_private_kernel_circuit_initial()\n        }\n\n        pub fn failed(self) {\n            let _ = self.execute();\n        }\n    }\n\n    pub fn validate_deployed_contract_address(\n        tx_request: TxRequest,\n        private_call: PrivateCallDataBuilder,\n        public_inputs: KernelCircuitPublicInputs\n    ) {\n        assert_eq(public_inputs.end.new_contracts.len(), 1);\n        let cdd = tx_request.tx_context.contract_deployment_data;\n\n        let computed_initialization_hash = compute_initialization_hash(\n            tx_request.function_data.selector.to_field(),\n            tx_request.args_hash\n        );\n        assert(\n            computed_initialization_hash == cdd.initialization_hash, \"initialization hash does not match computed one\"\n        );\n        let contract_address = AztecAddress::compute_from_public_key(\n            cdd.public_key,\n            cdd.contract_class_id,\n            cdd.contract_address_salt,\n            cdd.initialization_hash,\n            cdd.portal_contract_address\n        );\n        assert(public_inputs.end.new_contracts[0].contract_address.eq(contract_address));\n    }\n\n    pub fn validate_no_new_deployed_contract(public_inputs: KernelCircuitPublicInputs) {\n        for new_contract in public_inputs.end.new_contracts {\n            assert(new_contract.is_empty());\n        }\n    }\n\n    #[test]\n    fn deposit() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        // Logs for the private call.\n        let encrypted_logs_hash = [16, 69];\n        let encrypted_log_preimages_length = 100;\n        let unencrypted_logs_hash = [26, 47];\n        let unencrypted_log_preimages_length = 50;\n        builder.private_call.set_encrypted_logs(encrypted_logs_hash, encrypted_log_preimages_length);\n        builder.private_call.set_unencrypted_logs(unencrypted_logs_hash, unencrypted_log_preimages_length);\n\n        let public_inputs = builder.execute();\n\n        validate_no_new_deployed_contract(public_inputs);\n\n        // Check the first nullifier is hash of the signed tx request\n        let tx_hash = builder.tx_request.hash();\n        assert_eq(public_inputs.end.new_nullifiers[0].value, tx_hash);\n\n        // Log preimages length should increase by `(un)encrypted_log_preimages_length` from private input\n        assert_eq(public_inputs.end.encrypted_log_preimages_length, encrypted_log_preimages_length);\n        assert_eq(public_inputs.end.unencrypted_log_preimages_length, unencrypted_log_preimages_length);\n\n        // Logs hashes should be a sha256 hash of a 0 value (the previous log hash) and the `(un)encrypted_logs_hash` from private input\n        let expected_encrypted_logs_hash = compute_logs_hash([0, 0], encrypted_logs_hash);\n        assert_eq(public_inputs.end.encrypted_logs_hash, expected_encrypted_logs_hash);\n\n        let expected_unencrypted_logs_hash = compute_logs_hash([0, 0], unencrypted_logs_hash);\n        assert_eq(public_inputs.end.unencrypted_logs_hash, expected_unencrypted_logs_hash);\n    }\n\n    #[test]\n    fn basic_contract_deployment() {\n        let builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        let public_inputs = builder.execute();\n\n        validate_deployed_contract_address(builder.tx_request, builder.private_call, public_inputs);\n\n        // Since there are no logs, log preimages length should be 0 and both logs hashes should be a sha256 hash of 2 zero\n        // values\n        assert_eq(public_inputs.end.encrypted_log_preimages_length, 0);\n        assert_eq(public_inputs.end.unencrypted_log_preimages_length, 0);\n\n        let expected_logs_hash = compute_logs_hash([0, 0], [0, 0]);\n        assert_eq(public_inputs.end.encrypted_logs_hash, expected_logs_hash);\n        assert_eq(public_inputs.end.unencrypted_logs_hash, expected_logs_hash);\n    }\n\n    #[test(should_fail_with = \"invalid array\")]\n    fn input_validation_malformed_arrays_return_values() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.private_call.public_inputs.return_values.extend_from_array([0, 9123]);\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with = \"invalid array\")]\n    fn input_validation_malformed_arrays_read_requests() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.private_call.public_inputs.read_requests.extend_from_array(\n            [\n            SideEffect { value: 0, counter: 0 },\n            SideEffect { value: 9123, counter: 1 }\n        ]\n        );\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with = \"invalid array\")]\n    fn input_validation_malformed_arrays_commitments() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.private_call.public_inputs.new_commitments.extend_from_array(\n            [\n            SideEffect { value: 0, counter: 0 },\n            SideEffect { value: 9123, counter: 1 }\n        ]\n        );\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with = \"invalid array\")]\n    fn input_validation_malformed_arrays_nullifiers() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.private_call.public_inputs.new_nullifiers.extend_from_array(\n            [\n            SideEffectLinkedToNoteHash { value: 0, note_hash: 0, counter: 0 },\n            SideEffectLinkedToNoteHash { value: 9123, note_hash: 0, counter: 1 }\n        ]\n        );\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with = \"invalid array\")]\n    fn input_validation_malformed_arrays_private_call_stack() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.private_call.public_inputs.private_call_stack_hashes.extend_from_array([0, 9123]);\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with = \"invalid array\")]\n    fn input_validation_malformed_arrays_public_call_stack() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.private_call.public_inputs.public_call_stack_hashes.extend_from_array([0, 9123]);\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with = \"invalid array\")]\n    fn input_validation_malformed_arrays_new_l2_to_l1_msgs() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.private_call.public_inputs.new_l2_to_l1_msgs.extend_from_array([0, 9123]);\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"contract address supplied does not match derived address\")]\n    fn contract_deployment_incorrect_contract_address_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        let random_address = AztecAddress::from_field(27);\n        builder.private_call.public_inputs.call_context.storage_contract_address = random_address;\n        builder.tx_request.origin = random_address;\n        builder.private_call.contract_address = random_address;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"origin address does not match call stack items contract address\")]\n    fn contract_deployment_contract_address_mismatch_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        let random_address = AztecAddress::from_field(27);\n        builder.private_call.public_inputs.call_context.storage_contract_address = random_address;\n        builder.private_call.contract_address = random_address;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"tx_request function_data must match call_stack_item function_data\")]\n    fn contract_deployment_function_data_mismatch_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.tx_request.function_data.selector.inner = 27;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"noir function args passed to tx_request must match args in the call_stack_item\")]\n    fn contract_deployment_args_hash_mismatch_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        // Modify the args hash in tx request.\n        builder.tx_request.args_hash = 29;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"Private kernel circuit can only execute a private function\")]\n    fn private_function_is_private_false_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        // Set is_private in function data to false.\n        builder.private_call.function_data.is_private = false;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"Cannot call an internal function directly\")]\n    fn private_function_is_internal_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        builder.private_call.function_data.is_internal = true;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"Users cannot make a static call\")]\n    fn private_function_static_call_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        // Set is_static_call to true.\n        builder.private_call.public_inputs.call_context.is_static_call = true;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"Users cannot make a delegatecall\")]\n    fn private_function_delegate_call_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        // Set is_delegate_call to true.\n        builder.private_call.public_inputs.call_context.is_delegate_call = true;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"Storage contract address must be that of the called contract\")]\n    fn private_function_incorrect_storage_contract_address_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        // Set the storage_contract_address to a random scalar.\n        builder.private_call.public_inputs.call_context.storage_contract_address = AztecAddress::from_field(356);\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"computed contract address does not match expected one\")]\n    fn private_function_incorrect_function_leaf_index_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        // Set the leaf index of the function leaf to a wrong value (the correct value + 1).\n        let leaf_index = builder.private_call.function_leaf_membership_witness.leaf_index;\n        builder.private_call.function_leaf_membership_witness.leaf_index = leaf_index + 1;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"computed contract address does not match expected one\")]\n    fn private_function_incorrect_function_leaf_sibling_path_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        // Set the first value of the sibling path to a wrong value (the correct value + 1).\n        let sibling_path_0 = builder.private_call.function_leaf_membership_witness.sibling_path[0];\n        builder.private_call.function_leaf_membership_witness.sibling_path[0] = sibling_path_0 + 1;\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"computed contract address does not match expected one\")]\n    fn private_function_incorrect_contract_class_preimage_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n        builder.private_call.contract_class_artifact_hash = builder.private_call.contract_class_artifact_hash + 1;\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"computed contract address does not match expected one\")]\n    fn private_function_incorrect_partial_address_preimage_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n        builder.private_call.salted_initialization_hash.inner = builder.private_call.salted_initialization_hash.inner + 1;\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"computed contract address does not match expected one\")]\n    fn private_function_incorrect_address_preimage_fails() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n        builder.private_call.public_keys_hash.inner = builder.private_call.public_keys_hash.inner + 1;\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"note hash tree root mismatch\")]\n    fn native_read_request_bad_request() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_read_requests(2);\n\n        // tweak read_request so it gives wrong root when paired with its sibling path\n        let read_request = builder.private_call.public_inputs.read_requests.pop();\n        builder.private_call.public_inputs.read_requests.push(SideEffect { value: read_request.value + 1, counter: read_request.counter });\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"note hash tree root mismatch\")]\n    fn native_read_request_bad_leaf_index() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_read_requests(2);\n\n        // tweak leaf index so it gives wrong root when paired with its request and sibling path\n        let mut read_request_membership_witness = builder.private_call.read_request_membership_witnesses.pop();\n        read_request_membership_witness.leaf_index += 1;\n        builder.private_call.read_request_membership_witnesses.push(read_request_membership_witness);\n\n        builder.failed();\n    }\n\n    #[test(should_fail_with=\"note hash tree root mismatch\")]\n    fn native_read_request_bad_sibling_path() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_read_requests(2);\n\n        // tweak sibling path so it gives wrong root when paired with its request\n        let mut read_request_membership_witness = builder.private_call.read_request_membership_witnesses.pop();\n        read_request_membership_witness.sibling_path[1] += 1;\n        builder.private_call.read_request_membership_witnesses.push(read_request_membership_witness);\n\n        builder.failed();\n    }\n\n    #[test]\n    fn native_no_read_requests_works() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        let public_inputs = builder.execute();\n\n        validate_no_new_deployed_contract(public_inputs);\n        // Check the first nullifier is hash of the signed tx request\n        assert_eq(public_inputs.end.new_nullifiers[0].value, builder.tx_request.hash());\n\n        // non-transient read requests are NOT forwarded\n        assert_eq(array_length(public_inputs.end.read_requests), 0);\n    }\n\n    #[test]\n    fn native_one_read_requests_works() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_read_requests(1);\n\n        let public_inputs = builder.execute();\n\n        validate_no_new_deployed_contract(public_inputs);\n        // Check the first nullifier is hash of the signed tx request\n        assert_eq(public_inputs.end.new_nullifiers[0].value, builder.tx_request.hash());\n\n        // non-transient read requests are NOT forwarded\n        assert_eq(array_length(public_inputs.end.read_requests), 0);\n    }\n\n    #[test]\n    fn native_two_read_requests_works() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_read_requests(2);\n\n        let public_inputs = builder.execute();\n\n        validate_no_new_deployed_contract(public_inputs);\n        // Check the first nullifier is hash of the signed tx request\n        assert_eq(public_inputs.end.new_nullifiers[0].value, builder.tx_request.hash());\n\n        // non-transient read requests are NOT forwarded\n        assert_eq(array_length(public_inputs.end.read_requests), 0);\n    }\n\n    #[test]\n    fn native_max_read_requests_works() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_read_requests(MAX_READ_REQUESTS_PER_CALL);\n\n        let public_inputs = builder.execute();\n\n        validate_no_new_deployed_contract(public_inputs);\n        // Check the first nullifier is hash of the signed tx request\n        assert_eq(public_inputs.end.new_nullifiers[0].value, builder.tx_request.hash());\n\n        // non-transient read requests are NOT forwarded\n        assert_eq(array_length(public_inputs.end.read_requests), 0);\n    }\n\n    #[test]\n    fn native_one_transient_read_requests_works() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_transient_read_requests(1);\n\n        let public_inputs = builder.execute();\n\n        validate_no_new_deployed_contract(public_inputs);\n        // Check the first nullifier is hash of the signed tx request\n        assert_eq(public_inputs.end.new_nullifiers[0].value, builder.tx_request.hash());\n\n        // non-transient read requests are NOT forwarded\n        assert_eq(array_length(public_inputs.end.read_requests), 1);\n    }\n\n    #[test]\n    fn native_max_read_requests_one_transient_works() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_transient_read_requests(1);\n        builder.private_call.append_read_requests(MAX_READ_REQUESTS_PER_CALL - 1);\n\n        let public_inputs = builder.execute();\n\n        validate_no_new_deployed_contract(public_inputs);\n        // Check the first nullifier is hash of the signed tx request\n        assert_eq(public_inputs.end.new_nullifiers[0].value, builder.tx_request.hash());\n\n        // non-transient read requests are NOT forwarded\n        assert_eq(array_length(public_inputs.end.read_requests), 1);\n    }\n\n    #[test]\n    fn native_max_read_requests_all_transient_works() {\n        let mut builder = PrivateKernelInitInputsBuilder::new();\n\n        builder.private_call.append_transient_read_requests(MAX_READ_REQUESTS_PER_CALL);\n\n        let public_inputs = builder.execute();\n\n        validate_no_new_deployed_contract(public_inputs);\n        // Check the first nullifier is hash of the signed tx request\n        assert_eq(public_inputs.end.new_nullifiers[0].value, builder.tx_request.hash());\n\n        // non-transient read requests are NOT forwarded\n        assert_eq(array_length(public_inputs.end.read_requests), MAX_READ_REQUESTS_PER_CALL);\n    }\n\n    #[test]\n    fn propagate_nullifier_key_validation_requests() {\n        let mut builder = PrivateKernelInitInputsBuilder::new_constructor();\n\n        let request = NullifierKeyValidationRequest { public_key: GrumpkinPoint { x: 1, y: 2 }, secret_key: GrumpkinPrivateKey { high: 3, low: 4 } };\n        builder.private_call.public_inputs.nullifier_key_validation_requests.push(request);\n\n        let public_inputs = builder.execute();\n\n        assert_eq(array_length(public_inputs.end.nullifier_key_validation_requests), 1);\n\n        let request_context = public_inputs.end.nullifier_key_validation_requests[0];\n        assert_eq(request_context.public_key, request.public_key);\n        assert_eq(request_context.secret_key, request.secret_key);\n        assert_eq(\n            request_context.contract_address, builder.private_call.public_inputs.call_context.storage_contract_address\n        );\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/private-kernel-lib/src/private_kernel_init.nr"},"112":{"source":"use dep::std;\nuse dep::types::{\n    abis::{\n        call_request::CallRequest,\n        combined_accumulated_data::CombinedAccumulatedData,\n        function_data::FunctionData,\n        kernel_circuit_public_inputs::KernelCircuitPublicInputsBuilder,\n        membership_witness::ReadRequestMembershipWitness,\n        new_contract_data::NewContractData,\n        nullifier_key_validation_request::NullifierKeyValidationRequestContext,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_kernel::private_call_data::PrivateCallData,\n        previous_kernel_data::PreviousKernelData,\n        side_effect::{SideEffect, SideEffectLinkedToNoteHash},\n    },\n    address::{AztecAddress, EthAddress, PartialAddress, compute_initialization_hash},\n    contract_class::ContractClassId,\n    contrakt::deployment_data::ContractDeploymentData,\n    constants::{\n        MAX_NEW_NULLIFIERS_PER_CALL,\n        MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NEW_COMMITMENTS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n        MAX_READ_REQUESTS_PER_CALL,\n        MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL,\n    },\n    grumpkin_private_key::GrumpkinPrivateKey,\n    hash::{\n        compute_constructor_hash,\n        compute_l2_to_l1_hash,\n        compute_logs_hash,\n        compute_new_contract_address_hash,\n        contract_tree_root_from_siblings,\n        function_tree_root_from_siblings,\n        pedersen_hash,\n        private_functions_root_from_siblings,\n        read_request_root_from_siblings,\n        silo_commitment,\n        silo_nullifier,\n        stdlib_recursion_verification_key_compress_native_vk,\n    },\n    utils::{\n        arrays::{\n            array_length,\n            array_to_bounded_vec,\n            validate_array,\n        },\n    },\n    traits::{is_empty, is_empty_array},\n};\n\npub fn validate_arrays(app_public_inputs: PrivateCircuitPublicInputs) {\n    // Each of the following arrays is expected to be zero-padded.\n    // In addition, some of the following arrays (new_commitments, etc...) are passed\n    // to extend_from_array_to_array() routines which rely on the passed arrays to be well-formed.\n\n    validate_array(app_public_inputs.return_values);\n    validate_array(app_public_inputs.read_requests);\n    validate_array(app_public_inputs.nullifier_key_validation_requests);\n    validate_array(app_public_inputs.new_commitments);\n    validate_array(app_public_inputs.new_nullifiers);\n    validate_array(app_public_inputs.private_call_stack_hashes);\n    validate_array(app_public_inputs.public_call_stack_hashes);\n    validate_array(app_public_inputs.new_l2_to_l1_msgs);\n    // encrypted_logs_hash and unencrypted_logs_hash have their own integrity checks.\n}\n\n// Validate all read requests against the historical note hash tree root.\n// Use their membership witnesses to do so. If the historical root is not yet\n// initialized, initialize it using the first read request here (if present).\n//\n// More info here:\n// - https://discourse.aztec.network/t/to-read-or-not-to-read/178\n// - https://discourse.aztec.network/t/spending-notes-which-havent-yet-been-inserted/180\npub fn validate_read_requests(\n    historical_note_hash_tree_root: Field,\n    read_requests: [SideEffect; MAX_READ_REQUESTS_PER_CALL],\n    read_request_membership_witnesses: [ReadRequestMembershipWitness; MAX_READ_REQUESTS_PER_CALL]\n) {\n    // membership witnesses must resolve to the same note hash tree root\n    // for every request in all kernel iterations\n    for rr_idx in 0..MAX_READ_REQUESTS_PER_CALL {\n        let read_request = read_requests[rr_idx].value;\n        let witness = read_request_membership_witnesses[rr_idx];\n\n        // A pending commitment is the one that is not yet added to note hash tree\n        // A \"transient read\" is when we try to \"read\" a pending commitment within a transaction\n        // between function calls, as opposed to reading the outputs of a previous transaction\n        // which is a \"pending read\".\n        // A transient read is when we try to \"read\" a pending commitment\n        // We determine if it is a transient read depending on the leaf index from the membership witness\n        // Note that the Merkle membership proof would be null and void in case of an transient read\n        // but we use the leaf index as a placeholder to detect a 'pending note read'.\n\n        if (read_request != 0) & (witness.is_transient == false) {\n            let root_for_read_request = read_request_root_from_siblings(read_request, witness.leaf_index, witness.sibling_path);\n            assert(root_for_read_request == historical_note_hash_tree_root, \"note hash tree root mismatch\");\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1354): do we need to enforce\n            // that a non-transient read_request was derived from the proper/current contract address?\n        }\n    }\n}\n\npub fn initialize_end_values(\n    previous_kernel: PreviousKernelData,\n    public_inputs: &mut KernelCircuitPublicInputsBuilder\n) {\n    public_inputs.constants = previous_kernel.public_inputs.constants;\n\n    // Ensure the arrays are the same as previously, before we start pushing more data onto them in other\n    // functions within this circuit:\n    let start = previous_kernel.public_inputs.end;\n\n    public_inputs.end.read_requests = array_to_bounded_vec(start.read_requests);\n    public_inputs.end.nullifier_key_validation_requests = array_to_bounded_vec(start.nullifier_key_validation_requests);\n\n    public_inputs.end.new_commitments = array_to_bounded_vec(start.new_commitments);\n    public_inputs.end.new_nullifiers = array_to_bounded_vec(start.new_nullifiers);\n\n    public_inputs.end.private_call_stack = array_to_bounded_vec(start.private_call_stack);\n    public_inputs.end.public_call_stack = array_to_bounded_vec(start.public_call_stack);\n    public_inputs.end.new_l2_to_l1_msgs = array_to_bounded_vec(start.new_l2_to_l1_msgs);\n\n    public_inputs.end.encrypted_logs_hash = start.encrypted_logs_hash;\n    public_inputs.end.unencrypted_logs_hash = start.unencrypted_logs_hash;\n\n    public_inputs.end.encrypted_log_preimages_length = start.encrypted_log_preimages_length;\n    public_inputs.end.unencrypted_log_preimages_length = start.unencrypted_log_preimages_length;\n\n    public_inputs.end.new_contracts = array_to_bounded_vec(start.new_contracts);\n}\n\nfn perform_static_call_checks(private_call: PrivateCallData) {\n    let public_inputs = private_call.call_stack_item.public_inputs;\n    let is_static_call = public_inputs.call_context.is_static_call;\n    if is_static_call {\n        // No state changes are allowed for static calls:\n        assert(\n            is_empty_array(public_inputs.new_commitments), \"new_commitments must be empty for static calls\"\n        );\n        assert(\n            is_empty_array(public_inputs.new_nullifiers), \"new_nullifiers must be empty for static calls\"\n        );\n    }\n}\n\nfn is_valid_caller(request: CallRequest, private_call: PrivateCallData) -> bool {\n    let call_context = private_call.call_stack_item.public_inputs.call_context;\n    let valid_caller_context = request.caller_context.msg_sender.eq(call_context.msg_sender)\n        & request.caller_context.storage_contract_address.eq(call_context.storage_contract_address);\n    request.caller_contract_address.eq(private_call.call_stack_item.contract_address)\n        & (request.caller_context.is_empty() | valid_caller_context)\n}\n\nfn validate_call_requests<N>(\n    call_requests: BoundedVec<CallRequest, N>,\n    hashes: [Field; N],\n    private_call: PrivateCallData\n) {\n    assert_eq(\n        array_length(hashes), call_requests.len(), \"call requests length does not match the expected length\"\n    );\n    for i in 0..N {\n        let hash = hashes[i];\n        if hash != 0 {\n            let request = call_requests.get_unchecked(i);\n            assert_eq(request.hash, hash, \"call stack hash does not match call request hash\");\n            assert(is_valid_caller(request, private_call), \"invalid caller\");\n        }\n    }\n}\n\npub fn update_end_values(private_call: PrivateCallData, public_inputs: &mut KernelCircuitPublicInputsBuilder) {\n    // If this call is a static call, certain operations are disallowed, such as creating new state.\n    perform_static_call_checks(private_call);\n\n    let private_call_public_inputs = private_call.call_stack_item.public_inputs;\n\n    let read_requests = private_call_public_inputs.read_requests;\n    let read_request_membership_witnesses = private_call.read_request_membership_witnesses;\n\n    let nullifier_key_validation_requests = private_call_public_inputs.nullifier_key_validation_requests;\n\n    let new_commitments = private_call_public_inputs.new_commitments;\n    let new_nullifiers = private_call_public_inputs.new_nullifiers;\n\n    let storage_contract_address = private_call_public_inputs.call_context.storage_contract_address;\n\n    // Transient read requests and witnesses are accumulated in public_inputs.end\n    // We silo the read requests (domain separation per contract address)\n    let mut siloed_read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL> = BoundedVec::new(SideEffect::empty());\n    for i in 0..MAX_READ_REQUESTS_PER_CALL {\n        let read_request = read_requests[i].value;\n        let witness = read_request_membership_witnesses[i];\n        if witness.is_transient & (read_request != 0) { // only forward transient to public inputs\n            siloed_read_requests.push(\n                SideEffect { counter: read_requests[i].counter, value: silo_commitment(storage_contract_address, read_request) }\n            )\n        }\n    }\n    public_inputs.end.read_requests.extend_from_bounded_vec(siloed_read_requests);\n\n    // Nullifier key validation requests.\n    for i in 0..MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL {\n        let request = nullifier_key_validation_requests[i];\n        if !is_empty(request) {\n            public_inputs.end.nullifier_key_validation_requests.push(request.to_context(storage_contract_address));\n        }\n    }\n\n    // Enhance commitments and nullifiers with domain separation whereby domain is the contract.\n    //\n    // nullifiers\n    let mut siloed_new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL> = BoundedVec::new(SideEffectLinkedToNoteHash::empty());\n    for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n        let new_nullifier = new_nullifiers[i];\n        if new_nullifier.value != 0 {\n            let siloed_note_hash = if new_nullifier.note_hash == 0 {\n                0\n            } else {\n                silo_commitment(storage_contract_address, new_nullifier.note_hash)\n            };\n            siloed_new_nullifiers.push(\n                SideEffectLinkedToNoteHash {\n                value: silo_nullifier(storage_contract_address, new_nullifier.value),\n                counter: new_nullifier.counter,\n                note_hash: siloed_note_hash\n            }\n            );\n        }\n    }\n    public_inputs.end.new_nullifiers.extend_from_bounded_vec(siloed_new_nullifiers);\n\n    // commitments\n    let mut siloed_new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL> = BoundedVec::new(SideEffect::empty());\n    for i in 0..MAX_NEW_COMMITMENTS_PER_CALL {\n        let new_commitment = new_commitments[i].value;\n        if new_commitment != 0 {\n            siloed_new_commitments.push(\n                SideEffect { value: silo_commitment(storage_contract_address, new_commitment), counter: new_commitments[i].counter }\n            );\n        }\n    }\n    public_inputs.end.new_commitments.extend_from_bounded_vec(siloed_new_commitments);\n\n    // Call stacks\n    // Private call stack.\n    let private_call_stack = array_to_bounded_vec(private_call.private_call_stack);\n    validate_call_requests(\n        private_call_stack,\n        private_call_public_inputs.private_call_stack_hashes,\n        private_call\n    );\n    public_inputs.end.private_call_stack.extend_from_bounded_vec(private_call_stack);\n    // Public call stack.\n    let public_call_stack = array_to_bounded_vec(private_call.public_call_stack);\n    validate_call_requests(\n        public_call_stack,\n        private_call_public_inputs.public_call_stack_hashes,\n        private_call\n    );\n    public_inputs.end.public_call_stack.extend_from_bounded_vec(public_call_stack);\n\n    // new l2 to l1 messages\n    let portal_contract_address = private_call.portal_contract_address;\n    let new_l2_to_l1_msgs = private_call_public_inputs.new_l2_to_l1_msgs;\n    let mut new_l2_to_l1_msgs_to_insert : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL> = BoundedVec::new(0);\n    for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n        let msg_is_zero = new_l2_to_l1_msgs[i] == 0;\n        if msg_is_zero == false {\n            let new_l2_to_l1_msgs = compute_l2_to_l1_hash(\n                storage_contract_address,\n                private_call_public_inputs.version,\n                portal_contract_address,\n                private_call_public_inputs.chain_id,\n                new_l2_to_l1_msgs[i]\n            );\n            new_l2_to_l1_msgs_to_insert.push(new_l2_to_l1_msgs)\n        }\n    }\n    public_inputs.end.new_l2_to_l1_msgs.extend_from_bounded_vec(new_l2_to_l1_msgs_to_insert);\n\n    // logs hashes\n    // See the following thread if not clear:\n    // https://discourse.aztec.network/t/proposal-forcing-the-sequencer-to-actually-submit-data-to-l1/426\n    let previous_encrypted_logs_hash = public_inputs.end.encrypted_logs_hash;\n    let current_encrypted_logs_hash = private_call_public_inputs.encrypted_logs_hash;\n    public_inputs.end.encrypted_logs_hash = compute_logs_hash(previous_encrypted_logs_hash,current_encrypted_logs_hash);\n    let previous_unencrypted_logs_hash = public_inputs.end.unencrypted_logs_hash;\n    let current_unencrypted_logs_hash = private_call_public_inputs.unencrypted_logs_hash;\n    public_inputs.end.unencrypted_logs_hash = compute_logs_hash(previous_unencrypted_logs_hash,current_unencrypted_logs_hash);\n\n    // Add log preimages lengths from current iteration to accumulated lengths\n    public_inputs.end.encrypted_log_preimages_length = public_inputs.end.encrypted_log_preimages_length +\n                                                           private_call_public_inputs.encrypted_log_preimages_length;\n    public_inputs.end.unencrypted_log_preimages_length = public_inputs.end.unencrypted_log_preimages_length + private_call_public_inputs.unencrypted_log_preimages_length;\n}\n\npub fn contract_logic(\n    private_call: PrivateCallData,\n    public_inputs: &mut KernelCircuitPublicInputsBuilder,\n    contract_dep_data: ContractDeploymentData,\n    function_data: FunctionData\n) {\n    let private_call_public_inputs = private_call.call_stack_item.public_inputs;\n    let portal_contract_address = private_call.portal_contract_address;\n    let contract_address = private_call.call_stack_item.contract_address;\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3062): Why is this using a hash function from the stdlib::recursion namespace\n    let private_call_vk_hash = stdlib_recursion_verification_key_compress_native_vk(private_call.vk);\n\n    let is_contract_deployment = public_inputs.constants.tx_context.is_contract_deployment_tx;\n\n    // input storage contract address must be 0 if its a constructor call and non-zero otherwise\n    if is_contract_deployment {\n        let computed_initialization_hash = compute_initialization_hash(\n            function_data.selector.to_field(),\n            private_call_public_inputs.args_hash\n        );\n\n        assert(\n            computed_initialization_hash == contract_dep_data.initialization_hash, \"initialization hash does not match computed one\"\n        );\n\n        let new_contract_address = AztecAddress::compute_from_public_key(\n            contract_dep_data.public_key,\n            contract_dep_data.contract_class_id,\n            contract_dep_data.contract_address_salt,\n            contract_dep_data.initialization_hash,\n            contract_dep_data.portal_contract_address\n        );\n\n        let new_contract_data = NewContractData {\n            contract_address: new_contract_address,\n            portal_contract_address,\n            contract_class_id: contract_dep_data.contract_class_id\n        };\n        public_inputs.end.new_contracts.push(new_contract_data);\n\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3062) VKs are mocked out for now\n        // assert(contract_dep_data.constructor_vk_hash == private_call_vk_hash, \"constructor_vk_hash doesn't match private_call_vk_hash\");\n\n        assert(\n            contract_address.eq(new_contract_address), \"contract address supplied does not match derived address\"\n        );\n\n        let new_contract_address_nullifier = compute_new_contract_address_hash(new_contract_address);\n\n        public_inputs.end.new_nullifiers.push(\n            SideEffectLinkedToNoteHash { value: new_contract_address_nullifier, note_hash: 0, counter: 1 }\n        );\n    } else {\n        // non-contract deployments must specify contract address being interacted with\n        assert(!contract_address.is_zero(), \"contract address cannot be zero\");\n        // std::println(f\"contract_address={contract_address}\");\n        // std::println(f\"private_call_vk_hash={private_call_vk_hash}\");\n\n        // Recompute the contract class id\n        let computed_private_functions_root = private_functions_root_from_siblings(\n            private_call.call_stack_item.function_data.selector,\n            private_call_vk_hash,\n            private_call.function_leaf_membership_witness.leaf_index,\n            private_call.function_leaf_membership_witness.sibling_path\n        );\n        // std::println(f\"computed_private_functions_root={computed_private_functions_root}\");\n\n        let computed_contract_class_id = ContractClassId::compute(\n            private_call.contract_class_artifact_hash,\n            computed_private_functions_root,\n            private_call.contract_class_public_bytecode_commitment\n        );\n        // std::println(f\"computed_contract_class_id={computed_contract_class_id}\");\n\n        // Recompute contract address using the preimage which includes the class_id\n        let computed_partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            computed_contract_class_id,\n            private_call.salted_initialization_hash\n        );\n        // std::println(f\"computed_partial_address={computed_partial_address}\");\n\n        let computed_address = AztecAddress::compute(private_call.public_keys_hash, computed_partial_address);\n        // std::println(f\"computed_address={computed_address}\");\n\n        assert(\n            computed_address.eq(contract_address), \"computed contract address does not match expected one\"\n        );\n    }\n}\n\npub fn validate_previous_kernel_values(end: CombinedAccumulatedData) {\n    assert(end.new_nullifiers[0].value != 0, \"The 0th nullifier in the accumulated nullifier array is zero\");\n}\n\npub fn validate_call_against_request(private_call: PrivateCallData, request: CallRequest) {\n    let call_stack_item = private_call.call_stack_item;\n    assert(\n        request.hash == call_stack_item.hash(), \"calculated private_call_hash does not match provided private_call_hash at the top of the call stack\"\n    );\n\n    let call_context = call_stack_item.public_inputs.call_context;\n\n    // Ensures that if the function is internal, only the contract itself can call it.\n    if call_stack_item.function_data.is_internal {\n        assert(\n            call_context.msg_sender.eq(call_context.storage_contract_address), \"call is internal but msg_sender is not self\"\n        );\n    }\n\n    if call_context.is_delegate_call {\n        let caller_context = request.caller_context;\n        assert(!caller_context.is_empty(), \"caller context cannot be empty for delegate calls\");\n        assert(\n            call_context.msg_sender.eq(caller_context.msg_sender), \"call stack msg_sender does not match expected msg_sender for delegate calls\"\n        );\n        assert(\n            call_context.storage_contract_address.eq(caller_context.storage_contract_address), \"call stack storage address does not match expected contract address for delegate calls\"\n        );\n        assert(\n            !call_stack_item.contract_address.eq(call_context.storage_contract_address), \"curent contract address must not match storage contract address for delegate calls\"\n        );\n    } else {\n        let caller_contract_address = request.caller_contract_address;\n        assert(\n            call_context.msg_sender.eq(caller_contract_address), \"call stack msg_sender does not match caller contract address\"\n        );\n        assert(\n            call_context.storage_contract_address.eq(call_stack_item.contract_address), \"call stack storage address does not match expected contract address\"\n        );\n    }\n}\n\nfn field_to_grumpkin_private_key(val: Field) -> GrumpkinPrivateKey {\n    let bytes = val.to_be_bytes(32);\n    let mut v = 1;\n    let mut high = 0;\n    let mut low = 0;\n\n    for i in 0..16 {\n        high = high + (bytes[15 - i] as Field) * v;\n        low = low + (bytes[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    GrumpkinPrivateKey { high, low }\n}\n\npub fn compute_siloed_nullifier_secret_key(secret_key: GrumpkinPrivateKey, contract_address: AztecAddress) -> GrumpkinPrivateKey {\n    // TODO: Temporary hack. Should replace it with a secure way to derive the secret key.\n    // Match the way keys are derived in circuits.js/src/keys/index.ts\n    let hash = pedersen_hash(\n        [secret_key.high, secret_key.low, contract_address.to_field()],\n        0\n    );\n    field_to_grumpkin_private_key(hash)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/private-kernel-lib/src/common.nr"},"114":{"source":"use dep::private_kernel_lib::PrivateKernelInputsInit;\nuse dep::types::KernelCircuitPublicInputs;\n\nunconstrained fn main(input: PrivateKernelInputsInit) -> distinct pub KernelCircuitPublicInputs {\n    input.native_private_kernel_circuit_initial()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/yarn-project/noir-protocol-circuits/src/crates/private-kernel-init-simulated/src/main.nr"}}}