{"noir_version":"0.24.0+756d3976575283a2aa7544ef246e2946f34ae006","name":"MeaningOfLife","functions":[{"name":"get_value","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284]},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[{"start":4,"end":24}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[24,25,26,27]},"bytecode":"H4sIAAAAAAAA/+2aTW/bNhjHKVuO7ciMX+LUTtI0TPMFpNYdgp00YJedh2HnOHawYptdZO6yfslddtwu22UYsPt62mZqfOq/GNmxMz6FCZSAIEqU+Pz+D19F6lgIEYj/Qnl+VMTdQOmpOcf/LyQO84o5OQNPOEuecJYdcmq2ruCtpyGDX10zVjxg3PGAseoBY80DxroHjLseMEYeMDY8YJQeMO55wNj0gLHlAWPbA8aOB4z7HjB2PWA88IDxkQeMPYeMATCGJt6fH4fz42h+HM+PqnmoJhYhdcUwSK70nJ2M90U+6LlJiS7Cxb0yccM94i/BPVpjKIcLDTvONcQDnW/Vdb7mW4F8UgON7tiTixr4ySE7l0+yOkt1kb73yE4FfFU3cYdrKwnaDsxRB5vClBHFe2IR6hCnOk3cDbGol/Ul74TWOxLSdwp0p8Kt7iqwpHBN9ipGhw56ftQP89w1SP/7YWwvrq4uLi6eD8fxcHD9UTKKL4eDFzqPCHxUAZ/SPUr/GFgfF3C5XIermTJynG9WFhHoCIBfFmg+M+em0do016k7pkEE9gRoxpBCvAm+33PPkzDpzMq0ZfJ6YB0uDDqPNvgnsvwkIb0Fvmsz+C4Au5Q3XSPjB94PvG3gq1us+rxr4tTGdX/1I/BGTLzLxqpoS2w33Nt+tmkf3AAejj44Ahvr8OwBj2TgYdIZ41jjekxoibvlRRokpON42mLwXQB2KW+6bgFPZLFG8Fy0JYzoP+LhqBeRWHwHYP/3OdhlqOcxzgdpz65maQ7hmZ/g2S9NvCHyZUjnorJkmGetLMsmMErLv5z9urR4ZIEvuPsX15qoXews8XEIz1xZaav6pgb4BecnDONeNs5g2eiw7rjH0Q9tOu6hfzjKORL5srqPB8cSjvlkJPLzyft42sDTYeJpb8BDDFLc7QP0NZV9Ce6R/8twD9sY6WuC/dSNvhi/FbBsudriJr7kbotMOmMqQwptS09R3eCa1+J4T3nb60HoByXcjk0cbVKPI3Xwa6fAv6Sr697+xt9SXeDZZ/AHk86sHh+AjsjSIyEd+6kDBo32f3YpXCPjurxyC3iZbD+j9hFZ9hqWP7T9HoP9TedcPeB55J4nYdKZtQ/ck5SWHgnpJdDYZ9AYiPx+UgrXyLgub3cLeLHclDvb2d7joXtN79od+fXQ8i/qesxgX7e7I5EPq9od7nEdu+dJmHRm7e4EdBxZeiSkl0HjCYPGAOxS3nSNjOvy9reAF8tNubP9XOf7xL2md+2O/PrE8i/qOnNvP9vfPBX5sKrdnQGPcs+TMOnM2t1T0HFq6ZGQjuPHUwaNAdilvOkaGdfl7XvGe7IFvGjb9d7G+T1+OC9gOX/PfiB7uL95Cvdof1OZM+5v4jck7o3SHH0X7pUgTmca1xqQh8/r8u55kkHRGnbN4sE17F+sNFwXxX+oSIe9f8S5x95ZoqMNOuiZ30AH1xoMl1adxz5okgU6Kf13c9bt6g8Tx/Vs3Od6W5BOYZ31XKZv9Ww/jr55qWwPCmz3gNWR7QRt0/+KZIfuhxD/SywCfruRn3GdoVvwHMZb1jsS0pnXJzLduE6UwjXZ03XmT4i/BSaOvhN1o39wb5bSuf+FKOrH7T1iXFeuWs/Qu7iPTI2sKfL/ApBOHPtwnOJYL121Jr4POuleE7hW7dnb/YhTYBrwcQFH3y+ZNPq5VXciVbH42XcXnEs/OGhB2vG6U+0Y0bpy6UagGzs21GU//lcKRCtzpor6xeTryfR2oibT2VjN3rwaq88+xeeH5kwLJZ/c3Fy+US8no/EPavp6pqbXajh9PRl9hy/9/JCXfn3IS/+YM31HXs5m429fzdRsqi5HI3X7cvaVmn4/vrn+Znor/gWea109wUAAAA==","debug_symbols":"5Z1vS+NAEIe/S16XY+ffzm6/ynEvenceCKKi5eAQv/tFTGLFUiHp1t+Qd6nsZJ6J7jOJ7W6fupu7X7v99d3tY7d96tI31m77/al7vN/dvvzgcb972Hdb5bzprm5/90dOz5vuz/XNVbdlLs8/Ni9BNieoHAvKeQzKR4PqjCBJc4JoThDPCLIy4+pZnRGUj14IrTTipfouaPNxrOVxcH/I02iTIQM1z8DLM/BBBjnM8HEwEXkaRhOx6NvJkw1EAkekcEQGR5ThiByOqMARVTQiT3BEBEcE52yHc7bDOdvhnO1wznY4Zzucsx3O2eWys99SHcYalWko1TrQKBTNZf+iTWSkOfhNvdEUKJqKRFMTFA1B0bS843jNIM0znMEL6SCDnr6iLuNY18MT54HGoGgyFI1D0RQomopEQylh4VBDnCEFt08h7VNo+xTWPkVun8LbpyjtU9TmKSi1T9F+dlP72U3tZze1n93UfnbT8tmdy5TCOS1+0O1H4CEVPKQKh8QJD4nwkJbbr78vm5C8nEYqPj501h7h5NDK42nru3di89xKZTWV6moqtdVUmldTqa+m0rKaSutaKpW0mkppNZWu5h5JVnOPJHrRSuv0Acb+H5Z5+W27WGz8HBvfY+OX2Pg1NL6m2PgUG59j40ts/NhdV2N3XY3ddTV219XYXVeXd92Syohf/JO3/bWMY011Ob2l0PQUmp5D00toeg1Nb6Hpc2h6D01fQtOH7rU5dK/NoXttDt1rc+hee4Y1w19Jv7zXVpo+m1Kzn0bKeXyUcbYz0OfQ9B6avoSmr5Hpz7B2+ivpKTQ9h6aX0PQamj50r/XQvdZD91oP3Ws9dK8tkXst04VXF59eI8/EWDhQ+xnwOVbznBPHsHAuu4mJyfSgbXIMx7FwChZOhcLhhIVDWDgXtvLpLSiYBQtHsXAMCydj4UDtwsMMtQ0PM9Q+PCxQG/GwQO3Ew4JlZcGysmBZWbCsLFhWFiwrC5aVBcvKimVlxbKyYllZsaysWFZWLCsrlpUVy8qKZWXFsrJhWdmwrGxYVjYsKxuWlQ3LyoZlZcOysmFZ2bCsnGGs3L/6u3u43v28uXr5RqL+5f7f/evh838="},{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262]},"bytecode":"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","debug_symbols":"1dJBCsIwEAXQu8w6i5mpiTZXERejRgiEtDRBkJC7m2KtC3uBrmY+vMVf/AJhuEn2Q0xgCxCBPRdIo8Q5pixTBosKXLy3WxU8fHBgmU9V/TmNxixUE5pVG72BCZEXTMi0Yuq7DX3ov1jz8VcDsV4UEO+ydbe/1i09ZfJyDW7eS4v5NX7e+gY="},{"name":"set_value","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"value":[{"start":41,"end":42}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272]},"bytecode":"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","debug_symbols":"3ZfdasMwDEbfxddhSLL8o7zK6EW2dVAobWnDYJS++5wtdrzONNBAtuwqMRw7J4r0Qc5qu39u2s1+d1L1WSGq+vGsTodm1y1PbXNsVQ2VWu9ewvVSqdfNdq1qIn+pfnBopCfRY2IRucCSZtfDxMDDyWBKJyO6aIEY9n7jV5VCWqq4nk2cPUZxwzhZnKeIG7C2Rw2CTbQtugBQVAHK3lN0gWaJsCGXWcOntVmktV2ktStZO2v6LR7ciDkZl2bN4mCOUBwGSTaEoMfo0Qb3y9aXyfqWbNK3Y/rsHPc0e6C8y4INwZ+ywek2w6d1euxjeY4y3g8uhkoHg0jqgu7RES6Nn3e6Z6UL8VuoUDxWXJb9ZO/pLaL/UT9JwYiQzWeRHS+KnrcoIcp98hHJy9LZ8O/ZhMJf25iZbYhMsrH+dsswp2RhNnydFXa56voBi7mLAjE4ULIh6eKg34d37ismg8E4vzbL4pBDq7B4a46b5mm77n5AwrJ9P3zdXj4A"},{"name":"get_meaning_of_life","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[],"param_witnesses":{},"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"return_witnesses":[0]},"bytecode":"H4sIAAAAAAAA/62R3QmAMAyEL/W39MURHCEVB3AV919CixGv2jf7QWi5hHBcAEBw0eBBkOPtHUnbrBL6h1Vjn5a0KDKc1dk/0JwzbSJNyOfdn2v51GUPlJMjT+6Vocc3w0omNAryYzFSEg8ZDG/Z5gEAAA==","debug_symbols":"q1bKyU9OLMnMzytWsqqu1VEqSyzKTEzKSYVySyoLIMxaAA=="},{"name":"get_public_value","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[],"param_witnesses":{},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[0]},"bytecode":"H4sIAAAAAAAA/81UwU7DMAx12rTr6BBcOYAqcUcp4gPCL/AHRS2Iyyp1mwQ/jyBgq2+ZxWUB8aTIjuPEzotjIiJD38hphqF93LCswOZ5BLhjcOfaMhxiScXicxSs1+CXse0cbAbylPX3VHk6d3tKhxxVwJ1PF6uN38CDngMfsV8N6xnYsmhv4PUa1gtlT6nEEx3fRJ6uVPYiTwXcxbPujsMXTxjLw1zirSCP8g/ywVL2MC/+SexF+tiuork/pL7TEt7OQ/4Sz4LPFcszlmIPwNoPWAEv4lcrnOH/seCPfz9hn2krmuvUJzwX7yb4qc/89l85YW4DNttx6p6Hh6HrDaRmozRRGuUaGdhQzxUb0X6rsmCTEtFKANtcXFJLOqQ06V/ISYdGBtouWV6wvJ+m7q15WffDazPuts341DyOu3W/oQ//EHNfFggAAA==","debug_symbols":"zZfNaoNAFIXf5a6l3J/RmfFVShfT1oIgJkQpBPHdY4gxiwRCJMLZzYVzPd/C+WAGanY/qa93bUflQPyRU/k5ULdP7Xnu+nToqczZMqra3+lkPGb0VzcVlaphzO6yIuLnsIgLS1o4Pkib1znsxJasz8evbIIpkGA8EkxAgolIMMJQNAJFo1A0BkXjoGigPCxQIhYoEwuUigXKxQrlYt3UxZcK3b7Ctq9w21e8wW95WCoCP/kzhOX6aWHVWzq6GahAA/JoQAENKIIBGaMBCRrQw2uvxVUWxu5O21as2PErdsKKnfj6juPXdqbhPx3q9N1U5zf6NPbH/eU4ngA="},{"name":"public_function_to_call","function_type":"Open","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"public_global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":39}],"value":[{"start":39,"end":40}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"contract_storage_update_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest","fields":[{"name":"storage_slot","type":{"kind":"field"}},{"name":"new_value","type":{"kind":"field"}}]}}},{"name":"contract_storage_reads","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::contrakt::storage_read::StorageRead","fields":[{"name":"storage_slot","type":{"kind":"field"}},{"name":"current_value","type":{"kind":"field"}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"prover_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"public"},"return_witnesses":[40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233]},"bytecode":"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","debug_symbols":"1Z3bqmZZcl7fpa4bs+Iw46BXMb5o2zIIhCTUjcEIvbt/4dpZEkqr68vqNTX6qnZt1pwrIDK+vWtUjPz/6ae//fv/8fs//s3f/90ffvqrf/rp+S8e+9Nf/dd/+ukP//D7v/uX7/zhj7//xz/+9FfP737667/7n59//vPvfvpff/O3f/3TX7nPP/+33/3LiXzkEyafcPlEyCdSPnF+/Ynf/bvnIuznJ+Pst2fN8uv2evX2fvX2efX2ffP287x6u716u796e7x6e756+6uzel6d1fPqrJ5XZ/W8Oqv16qzWq7Nar85qvTqr9eqs1m+aVTv785M29m9u/86zXfn1cNf55ebnfNVSoFoaVMuAallOLf2AajFQLQ6qJUC1JKgWUO42KHcblLsNyt0G5e6AcndAuTug3B1Q7g4odweUuwPK3QHl7oByd0C5u6DcXVDuLih3F5S7C8rdBeXugnJ3Qbm7oNxdTu7Gw8ndeDi5Gw8nd+Ph5G48nNyNh5O78XByNx5O7sbDyd14QLlroNw1UO4aKHcNlLsGyl0D5a6BctdAuWug3DVQ7joodx2Uuw7KXQflroNy10G566DcdVDuOih3HZS7AcrdAOVugHI3QLkboNwNUO4GKHcDlLsByt0A5W6CcjdBuZug3E1Q7iYodxOUuwnK3QTlboJyN0G5e0C5e0C5e0C5e0C5e0C5e0C5e0C5e0C5e0C5e0C5W6DcLVDuFih3C5S7BcpdkK8WIF8tQL5agHy1APlqAfLVAuSrBchXC5CvFiBfLUC+WoB8tQD5agHy1QLkqwXIVwuQrxYgXy1AvlqAfLUA+WoB8tUC5KsFyFcLkK8WIF8tQL5agHy1APlqAfLVAuSrBchXC5CvFiBfLUC+WoJ8tQT5agny1RLkq+XDyd0E+WoJ8tXyogs1Zt8eDv9eLQaq5dqfXc+snx/+fNnfq+WAailQLQ2qZUC13PudwWb96+nP1/nL81M/V3PR+vk11di9Ps1XxvhJ+zd90p7+uXL/i608mJWbWT/f/rx45Pdqz7/g2s9fcO1Cnv58Qv1b7zMe+YTJJ1w+EfKJ3/Rn9PO/mr4e/fzflV/+Lt+Kr+vPu9fXu9f3u9fPu9fvq9f/NkMhP7+B/fzo58v5zvX27vX+7vXx7vX57vXn3etLTSllc/7nE/LPgJR/Bhz5Z8CRfwYc+WfAkX8GKDvMP5848gm550fu+ZF7fuSel9zzkntecs9L7nnJPS+55yX3vOSel9zzknvecs9b7nnLPW+55y33vOWet9zzlnvecs9b7vnIPR+55yP3fOSej9zzkXs+cs9H7vnIPR+55yv3fOWer9zzlXu+cs9X7vnKPV+55yv3fNWen+eRT5h8wuUTIZ9I+cSRT5R8ouUTI5+Qe25yz03uuck9N7nnJvfc5J6b3HOTe25yz03uucs9d7nnLvfc5Z673HOXe+5yz13uucxoj8xoj8xoj8xoj8xoj8xoT8g9D7nnIfc85J6H3HP502iP/Gm0R/402iN/Gu2RP432yJ9Ge1LuuczhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw9XIPZc5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzOHtkEPc5YvoR14+EfiT1I0c/UvqR1o+MfkTvvundN737pnff9O6b3n3Tu296903vvundN737rnff9e673n3Xu+96913vvuvdd737rnff9e6H3v3Qux9690PvfujdD737oXc/9O6H3v3Qu59691PvfurdT737qXc/9e6n3v3Uu59691Pv/tG7f/TuH737R+/+0bt/9O4fvftH7/7Ru3/07pfe/dK7X3r3S+9+6d0vvfuld7/07pfe/dK733r3W+9+691vvfutd7/17rfe/da733r3W+/+6N0fvfujd3/07o/e/dG7P3r3R+/+6N0fvfurd3/17q/e/dW7v3r3V+/+6t1fvfurd19nfaazPtNZn+msz3TW9/mtVz9y9COlH2n9yOhH9O7rrM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901pc660ud9aXO+lJnfamzvtRZ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"}],"events":[],"file_map":{"34":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"51":{"source":"use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"52":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"53":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"63":{"source":"use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = StorageRead::empty();\n        let empty_storage_update = StorageUpdateRequest::empty();\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn is_deployment(self) -> bool {\n        // TODO(#4738): Implement this\n        false\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, false, true)\n    }\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"65":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn is_deployment(self) -> bool {\n        // TODO(#4738): Implement this\n        false\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"71":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"75":{"source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"92":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/context.nr"},"108":{"source":"use dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, Context};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes}, note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateImmutable<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateImmutable<T> {}\n\nimpl<Note> PrivateImmutable<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor. \n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot)\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note  where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr"},"109":{"source":"use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T> Storage<T> for PublicMutable<T> {}\n\nimpl<T> PublicMutable<T> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable reads only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"114":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/aztec/src/hasher.nr"},"186":{"source":"global ARGS_LENGTH: u64 = 16;\nglobal RETURN_VALUES_LENGTH: u64 = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX ≥ MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX ≥ MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: u64 = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: u64 = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: u64 = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u64 = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: u64 = 16;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u64 = 32;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u64 = 2; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: u64 = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u64 = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: u64 = 2;\nglobal MAX_NEW_CONTRACTS_PER_TX: u64 = 1;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u64 = 128;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_TX: u64 = 8; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: u64 = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u64 = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: u64 = 3;\nglobal FUNCTION_TREE_HEIGHT: u64 = 5;\nglobal CONTRACT_TREE_HEIGHT: u64 = 16;\nglobal NOTE_HASH_TREE_HEIGHT: u64 = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: u64 = 40;\nglobal NULLIFIER_TREE_HEIGHT: u64 = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: u64 = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: u64 = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\n\n// SUB-TREES RELATED CONSTANTS\nglobal CONTRACT_SUBTREE_HEIGHT: u64 = 0;\nglobal CONTRACT_SUBTREE_SIBLING_PATH_LENGTH: u64 = 16;\nglobal NOTE_HASH_SUBTREE_HEIGHT: u64 = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u64 = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: u64 = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: u64 = 5;\nglobal ARCHIVE_HEIGHT: u64 = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u64 = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u64 = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: u64 = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u64 = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: u64 = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u64 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u64 = 32;\n// The following is used in immutable state variables to compute an initialization slot whose value is used to\n// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).\n// The initialization slot is computed by adding the constant bellow to the variable's storage slot. This constant has\n// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.\nglobal INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;\nglobal INITIAL_L2_BLOCK_NUM: Field = 1;\n// 126976 = 31 * 4096;\nglobal BLOB_SIZE_IN_BYTES: Field = 126976;\n\n// CONTRACT CLASS CONSTANTS\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u64 = 8000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u64 = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u64 = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\nglobal DEPLOYER_CONTRACT_ADDRESS = 0x0747a20ed0c86035e44ea5606f30de459f40b55c5e82012640aa554546af9044;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\nglobal MAX_NOTE_FIELDS_LENGTH: u64 = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: u64 = 23;\nglobal MAX_NOTES_PER_PAGE: u64 = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: u64 = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: u64 = 8;\nglobal CONTENT_COMMITMENT_LENGTH: u64 = 7;\nglobal CONTRACT_DEPLOYMENT_DATA_LENGTH: u64 = 6;\nglobal CONTRACT_INSTANCE_LENGTH: u64 = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: u64 = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u64 = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: u64 = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: u64 = 5;\nglobal GLOBAL_VARIABLES_LENGTH: u64 = 6;\nglobal HEADER_LENGTH: u64 = 25; // 2 for last_archive, 7 for content commitment, 10 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: u64 = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: u64 = 2;\nglobal NEW_CONTRACT_DATA_LENGTH: u64 = 3;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: u64 = 8;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: u64 = 223;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 218;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 194;\nglobal STATE_REFERENCE_LENGTH: u64 = 10; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: u64 = 11;\nglobal TX_REQUEST_LENGTH: u64 = 17;\n\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: u64 = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |\n * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |\n * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size ≤ 8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size ≤ 16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size ≤ 44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\nglobal GENERATOR_INDEX__AUTHWIT_INNER = 45;\nglobal GENERATOR_INDEX__AUTHWIT_OUTER = 46;\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/noir-protocol-circuits/crates/types/src/constants.nr"},"193":{"source":"use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"194":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<1> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<1> for U128 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"199":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr"},"200":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"205":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS,\n    GENERATOR_INDEX__CONTRACT_ADDRESS, GENERATOR_INDEX__NOTE_HASH_NONCE,\n    GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"226":{"source":"use dep::aztec::{\n    note::{note_header::NoteHeader, note_interface::NoteInterface}, hash::pedersen_hash,\n    context::PrivateContext\n};\n\nglobal FIELD_NOTE_LEN: Field = 1;\n\n// A note which stores a field and is expected to be passed around using the `addNote` function.\n// WARNING: This Note is not private as it does not contain randomness and hence it can be easy to perform serialized_note\n// attack on it.\nstruct FieldNote {\n    value: Field,\n    header: NoteHeader,\n}\n\nimpl NoteInterface<FIELD_NOTE_LEN> for FieldNote {\n    fn serialize_content(self) -> [Field; FIELD_NOTE_LEN]{\n        [self.value]\n    }\n\n    fn deserialize_content(serialized_note: [Field; FIELD_NOTE_LEN]) -> Self {\n        FieldNote {\n            value: serialized_note[0],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(), 0)\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext) -> Field {\n        // This note is expected to be shared between users and for this reason can't be nullified using a secret.\n        0\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        // This note is expected to be shared between users and for this reason can't be nullified using a secret.\n        0\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        assert(\n            false, \"FieldNote does not support broadcast. Add it to PXE directly using the `.addNote` function.\"\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'FieldNote')))\"\n        7010510110810078111116101\n    }\n}\n\nimpl FieldNote {\n    pub fn new(value: Field) -> Self {\n        FieldNote { value, header: NoteHeader::empty() }\n    }\n}\n\n","path":"/Users/drgorilla/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.26.0/noir-projects/aztec-nr/field-note/src/field_note.nr"},"228":{"source":"contract MeaningOfLife {\n    use dep::aztec::prelude::{AztecAddress,PrivateImmutable};\n    use dep::aztec::state_vars::public_mutable::PublicMutable;\n    use dep::field_note::field_note::FieldNote;\n    \n    struct Storage {\n        value: PrivateImmutable<FieldNote>,\n        public_value: PublicMutable<Field>,\n    }\n\n    #[aztec(private)]\n    fn constructor() {}\n\n    unconstrained fn get_meaning_of_life() -> pub u32 {\n        42\n    }\n\n    unconstrained fn get_public_value() -> pub Field {\n        storage.public_value.read()\n    }\n\n    #[aztec(public)]\n    fn public_function_to_call(value: Field) {\n        storage.public_value.write(value);\n    }\n\n    #[aztec(private)]\n    fn set_value(value: Field) {\n        let mut note = FieldNote::new(value);\n        storage.value.initialize(&mut note, false);\n    }\n\n    #[aztec(private)]\n    fn get_value() -> Field {\n        storage.value.get_note().value\n    }\n}","path":"/Users/drgorilla/Documents/defiSucks/noir-wonderland/aztec-integration-testing/mocks/meaning-of-life/src/main.nr"}}}