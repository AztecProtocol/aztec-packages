use crate::{
    abis::{CheckpointRollupPublicInputs, RollupProofData, RootRollupPublicInputs},
    checkpoint_merge::{merge_checkpoint_rollups, validate_consecutive_checkpoint_rollups},
};
use types::{
    constants::{
        CHECKPOINT_MERGE_ROLLUP_VK_INDEX, CHECKPOINT_PADDING_ROLLUP_VK_INDEX,
        CHECKPOINT_ROOT_ROLLUP_VK_INDEX, CHECKPOINT_ROOT_SINGLE_BLOCK_ROLLUP_VK_INDEX,
        PROOF_TYPE_ROOT_ROLLUP_HONK,
    },
    traits::Empty,
};

global ALLOWED_LEFT_ROLLUP_VK_INDICES: [u32; 3] = [
    CHECKPOINT_ROOT_ROLLUP_VK_INDEX,
    CHECKPOINT_ROOT_SINGLE_BLOCK_ROLLUP_VK_INDEX,
    CHECKPOINT_MERGE_ROLLUP_VK_INDEX,
];

global ALLOWED_RIGHT_ROLLUP_VK_INDICES: [u32; 4] = [
    CHECKPOINT_ROOT_ROLLUP_VK_INDEX,
    CHECKPOINT_ROOT_SINGLE_BLOCK_ROLLUP_VK_INDEX,
    CHECKPOINT_MERGE_ROLLUP_VK_INDEX,
    // Padding checkpoint rollup can only be the right child of the root rollup.
    CHECKPOINT_PADDING_ROLLUP_VK_INDEX,
];

pub struct RootRollupPrivateInputs {
    pub(crate) previous_rollups: [RollupProofData<CheckpointRollupPublicInputs>; 2],
}

impl RootRollupPrivateInputs {
    /// VkIndex: ROOT_ROLLUP_VK_INDEX
    pub fn execute(self) -> RootRollupPublicInputs {
        // Verify the previous rollup proofs
        if !dep::std::runtime::is_unconstrained() {
            let vk_tree_root = self.previous_rollups[0].public_inputs.constants.vk_tree_root;

            self.previous_rollups[0].verify(PROOF_TYPE_ROOT_ROLLUP_HONK); // root rollup honk proof type so we do full IPA recursive verifier
            // The vk validation below ensures that the left rollup can never be a padding block root rollup,
            // because `CHECKPOINT_PADDING_ROLLUP_VK_INDEX` is not included in `ALLOWED_LEFT_ROLLUP_VK_INDICES`.
            self.previous_rollups[0].vk_data.validate_allowed_in_vk_tree(
                vk_tree_root,
                ALLOWED_LEFT_ROLLUP_VK_INDICES,
            );

            self.previous_rollups[1].verify(PROOF_TYPE_ROOT_ROLLUP_HONK); // root rollup honk proof type so we do full IPA recursive verifier
            self.previous_rollups[1].vk_data.validate_allowed_in_vk_tree(
                vk_tree_root,
                ALLOWED_RIGHT_ROLLUP_VK_INDICES,
            );
        }

        let left = self.previous_rollups[0].public_inputs;
        let right = self.previous_rollups[1].public_inputs;
        let is_right_padding =
            self.previous_rollups[1].vk_data.leaf_index == CHECKPOINT_PADDING_ROLLUP_VK_INDEX;

        if is_right_padding {
            // Padding checkpoint root rollup is needed when the epoch has only 1 checkpoint, which must be on the left.
            assert_eq(left.num_checkpoints(), 1, "unnecessary padding checkpoint root rollup");
        } else {
            validate_consecutive_checkpoint_rollups(left, right);
        }

        let merged = if is_right_padding {
            left
        } else {
            merge_checkpoint_rollups(left, right)
        };

        // Note: for blob batching, in validate_consecutive_block_rollups > assert_prev_block_rollups_follow_on_from_each_other we have checked:
        // - left.end_blob_accumulator == right.start_blob_accumulator
        // - left.challenge_z == right.challenge_z
        // - left.challenge_gamma == right.challenge_gamma
        // Below we check:
        // - first (left.start_blob_accumulator) acc is empty
        // Finally, we call finalize_and_validate() on the end_blob_accumulator which calculates final_gamma and checks:
        // - end_blob_accumulator.z == injected.challenge_z
        // - final_gamma == injected.challenge_gamma
        // => Validated public inputs from acc are: FinalBlobAccumulatorPublicInputs { blob_commitments_hash, z, y, C } (gamma is not required)
        merged.start_blob_accumulator.assert_empty("Epoch did not start with empty blob state.");

        let blob_public_inputs =
            merged.end_blob_accumulator.finalize_and_validate(merged.final_blob_challenges);

        RootRollupPublicInputs {
            previous_archive_root: merged.previous_archive.root,
            new_archive_root: merged.new_archive.root,
            checkpoint_header_hashes: merged.checkpoint_header_hashes,
            fees: merged.fees,
            constants: merged.constants,
            blob_public_inputs,
        }
    }
}
