use crate::{
    abis::{BaseOrMergeRollupPublicInputs, BlockRollupPublicInputs},
    merge::utils::merge_rollups::merge_rollups,
};
use parity_lib::ParityPublicInputs;
use types::{
    abis::{
        append_only_tree_snapshot::AppendOnlyTreeSnapshot, block_header::BlockHeader,
        checkpoint_constant_data::CheckpointConstantData, global_variables::GlobalVariables,
        partial_state_reference::PartialStateReference, sponge_blob::SpongeBlob,
        state_reference::StateReference,
    },
    constants::{
        ARCHIVE_HEIGHT, BLOCK_END_PREFIX, L1_TO_L2_MSG_SUBTREE_HEIGHT,
        L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH,
    },
    merkle_tree::{append_only_tree, calculate_empty_tree_root},
    traits::Hash,
};

pub struct BlockRollupPublicInputsComposer {
    // The following values are initialized from the previous rollups or block.
    constants: CheckpointConstantData,
    previous_archive: AppendOnlyTreeSnapshot,
    previous_l1_to_l2: AppendOnlyTreeSnapshot,
    start_partial_state: PartialStateReference,
    end_partial_state: PartialStateReference,
    start_sponge_blob: SpongeBlob,
    end_sponge_blob: SpongeBlob,
    timestamp: u64,
    out_hash: Field,
    accumulated_fees: Field,
    accumulated_mana_used: Field,

    // The followings are set only if `with_l1_to_l2_roots` is called explicitly.
    in_hash: Field,
    new_l1_to_l2: AppendOnlyTreeSnapshot,
}

impl BlockRollupPublicInputsComposer {
    pub fn new_from_no_rollups(
        previous_archive: AppendOnlyTreeSnapshot,
        previous_state: StateReference,
        constants: CheckpointConstantData,
        start_sponge_blob: SpongeBlob,
        timestamp: u64,
    ) -> Self {
        let block_end_marker = Self::create_block_end_marker(0 /* num_txs */);
        let mut end_sponge_blob = start_sponge_blob;
        end_sponge_blob.absorb([block_end_marker], 1 /* num_fields */);

        Self {
            constants,
            previous_archive,
            previous_l1_to_l2: previous_state.l1_to_l2_message_tree,
            // The state remains the same since there are no tx effects in this block.
            start_partial_state: previous_state.partial,
            end_partial_state: previous_state.partial,
            start_sponge_blob,
            end_sponge_blob,
            timestamp,
            // The followings are 0 since there are no tx effects in this block.
            out_hash: 0,
            accumulated_fees: 0,
            accumulated_mana_used: 0,
            // The followings are set/updated only if `with_l1_to_l2_roots` is called explicitly.
            in_hash: 0,
            new_l1_to_l2: previous_state.l1_to_l2_message_tree,
        }
    }

    pub fn new_from_single_rollup(rollup: BaseOrMergeRollupPublicInputs) -> Self {
        let global_variables = rollup.constants.global_variables;
        let constants = CheckpointConstantData {
            chain_id: global_variables.chain_id,
            version: global_variables.version,
            vk_tree_root: rollup.constants.vk_tree_root,
            protocol_contract_tree_root: rollup.constants.protocol_contract_tree_root,
            prover_id: rollup.constants.prover_id,
            slot_number: global_variables.slot_number,
            coinbase: global_variables.coinbase,
            fee_recipient: global_variables.fee_recipient,
            gas_fees: global_variables.gas_fees,
        };

        let mut end_sponge_blob = rollup.end_sponge_blob;
        let block_end_marker = Self::create_block_end_marker(rollup.num_txs);
        end_sponge_blob.absorb([block_end_marker], 1 /* num_fields */);

        Self {
            constants,
            previous_archive: rollup.constants.last_archive,
            previous_l1_to_l2: rollup.constants.last_l1_to_l2,
            start_partial_state: rollup.start,
            end_partial_state: rollup.end,
            start_sponge_blob: rollup.start_sponge_blob,
            end_sponge_blob,
            timestamp: global_variables.timestamp,
            out_hash: rollup.out_hash,
            accumulated_fees: rollup.accumulated_fees,
            accumulated_mana_used: rollup.accumulated_mana_used,
            // The followings are set/updated only if `with_l1_to_l2_roots` is called explicitly.
            in_hash: 0,
            new_l1_to_l2: rollup.constants.last_l1_to_l2,
        }
    }

    pub fn new_from_two_rollups(rollups: [BaseOrMergeRollupPublicInputs; 2]) -> Self {
        let merged_rollup = merge_rollups(rollups[0], rollups[1]);
        Self::new_from_single_rollup(merged_rollup)
    }

    pub fn with_l1_to_l2_roots(
        &mut self,
        parity: ParityPublicInputs,
        subtree_sibling_path: [Field; L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH],
    ) -> Self {
        self.in_hash = parity.sha_root;

        // Insert subtree into the l1 to l2 data tree.
        let empty_l1_to_l2_subtree_root = calculate_empty_tree_root(L1_TO_L2_MSG_SUBTREE_HEIGHT);
        self.new_l1_to_l2 = append_only_tree::insert_subtree_to_snapshot_tree(
            self.previous_l1_to_l2,
            subtree_sibling_path,
            empty_l1_to_l2_subtree_root,
            parity.converted_root,
            L1_TO_L2_MSG_SUBTREE_HEIGHT as u8,
        );

        *self
    }

    pub fn finish(
        self,
        new_archive_sibling_path: [Field; ARCHIVE_HEIGHT],
    ) -> BlockRollupPublicInputs {
        // Build the header of this block and then insert its hash to the archive tree.
        let block_header = self.create_block_header();
        let block_hash = block_header.hash();
        let new_archive = append_only_tree::insert_subtree_to_snapshot_tree(
            self.previous_archive,
            new_archive_sibling_path,
            0,
            block_hash,
            0,
        );

        let start_state = StateReference {
            l1_to_l2_message_tree: self.previous_l1_to_l2,
            partial: self.start_partial_state,
        };

        BlockRollupPublicInputs {
            constants: self.constants,
            previous_archive: self.previous_archive,
            new_archive,
            start_state,
            end_state: block_header.state,
            start_sponge_blob: self.start_sponge_blob,
            end_sponge_blob: self.end_sponge_blob,
            start_timestamp: self.timestamp,
            end_timestamp: self.timestamp,
            in_hash: self.in_hash,
            out_hash: self.out_hash,
            accumulated_fees: self.accumulated_fees,
            accumulated_mana_used: self.accumulated_mana_used,
        }
    }

    /// Demarcates the end of a block in a checkpoint's blobs.
    fn create_block_end_marker(num_txs: u32) -> Field {
        // BLOCK_END_PREFIX | num_txs (2 bytes)
        (BLOCK_END_PREFIX * 256 * 256) + num_txs as Field
    }

    fn create_block_header(self) -> BlockHeader {
        let state = StateReference {
            l1_to_l2_message_tree: self.new_l1_to_l2,
            partial: self.end_partial_state,
        };

        // Assign the `end_sponge_blob` to a mutable variable so that we can squeeze it.
        // This is because `squeeze` will mutate the sponge to be in squeeze mode (and may absorb an extra field if not
        // full). But we want to propagate the un-squeezed sponge so that it can keep absorbing data in the next blocks.
        let mut end_sponge_blob_for_block = self.end_sponge_blob;
        let sponge_blob_hash = end_sponge_blob_for_block.squeeze();

        // Block number equals the index at which the new block header hash is inserted into the archive tree.
        let block_number = self.previous_archive.next_available_leaf_index;

        let global_variables = GlobalVariables {
            chain_id: self.constants.chain_id,
            version: self.constants.version,
            block_number,
            slot_number: self.constants.slot_number,
            timestamp: self.timestamp,
            coinbase: self.constants.coinbase,
            fee_recipient: self.constants.fee_recipient,
            gas_fees: self.constants.gas_fees,
        };

        BlockHeader {
            last_archive: self.previous_archive,
            state,
            sponge_blob_hash,
            global_variables,
            total_fees: self.accumulated_fees,
            total_mana_used: self.accumulated_mana_used,
        }
    }
}
