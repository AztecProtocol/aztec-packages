pub mod reset_output_hints;

pub use reset_output_hints::ResetOutputHints;

use crate::{
    abis::PaddedSideEffects,
    components::reset_output_composer::reset_output_hints::generate_reset_output_hints,
};
use dep::reset_kernel_lib::{PrivateValidationRequestProcessor, TransientDataIndexHint};
use dep::types::{
    abis::{
        kernel_circuit_public_inputs::PrivateKernelCircuitPublicInputs,
        note_hash::{NoteHash, ScopedNoteHash},
        nullifier::{Nullifier, ScopedNullifier},
        private_log::PrivateLogData,
        side_effect::{Ordered, scoped::Scoped},
    },
    address::AztecAddress,
    constants::{
        MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_PRIVATE_LOGS_PER_TX, MAX_U32_VALUE,
        SIDE_EFFECT_MASKING_ADDRESS,
    },
    hash::{compute_unique_siloed_note_hash, silo_note_hash, silo_nullifier, silo_private_log},
    utils::arrays::{ClaimedLengthArray, sort_by_counter_asc, validate_padded_items},
};

pub struct ResetOutputComposer<let NH_RR_PENDING: u32, let NH_RR_SETTLED: u32, let NLL_RR_PENDING: u32, let NLL_RR_SETTLED: u32, let KEY_VALIDATION_HINTS_LEN: u32> {
    pub previous_kernel: PrivateKernelCircuitPublicInputs,
    pub validation_request_processor: PrivateValidationRequestProcessor<NH_RR_PENDING, NH_RR_SETTLED, NLL_RR_PENDING, NLL_RR_SETTLED, KEY_VALIDATION_HINTS_LEN>,
    pub padded_side_effects: PaddedSideEffects, // this is a hint, of sorts. TODO(MC): consider renaming.
    pub note_hash_siloing_amount: u32,
    pub nullifier_siloing_amount: u32,
    pub private_log_siloing_amount: u32,
    pub hints: ResetOutputHints,
}

// On hints:
// There are a few kinds of hints:
// 1. Hints that are passed directly into the circuit as private inputs:
//    - I don't consider private inputs that are verified as public inputs of a prev
//      snark as "hints", because they are easily validated by verifying the proof.
//    - The private inputs that I consider "hints" are anything that _isn't_ the
//      the public input of a previous proof. I.e. new data passed-in by typescript.
// 2. Hints that are generated by unconstrained functions during execution of this circuit.
//
// Maybe we should name these two kinds of hints distinctly?
// Or maybe calling them all "hint" is ok?
//

impl<let NH_RR_PENDING: u32, let NH_RR_SETTLED: u32, let NLL_RR_PENDING: u32, let NLL_RR_SETTLED: u32, let KEY_VALIDATION_HINTS_LEN: u32> ResetOutputComposer<NH_RR_PENDING, NH_RR_SETTLED, NLL_RR_PENDING, NLL_RR_SETTLED, KEY_VALIDATION_HINTS_LEN> {
    pub unconstrained fn new<let TRANSIENT_DATA_SQUASHING_HINTS_LEN: u32>(
        previous_kernel: PrivateKernelCircuitPublicInputs,
        validation_request_processor: PrivateValidationRequestProcessor<NH_RR_PENDING, NH_RR_SETTLED, NLL_RR_PENDING, NLL_RR_SETTLED, KEY_VALIDATION_HINTS_LEN>,
        padded_side_effects: PaddedSideEffects,
        transient_data_index_hints: [TransientDataIndexHint; TRANSIENT_DATA_SQUASHING_HINTS_LEN],
        note_hash_siloing_amount: u32,
        nullifier_siloing_amount: u32,
        private_log_siloing_amount: u32,
    ) -> Self {
        // Hints for:
        // - Squashing:
        //    - "Kept" arrays - Arrays containing only the to-be-propagated side-effects (i.e. with the transient note_hashes/nullifiers/private_logs splice-removed).
        //    - Sorting: Indices of the kept arrays, if the side-effects were to be sorted by counter.
        let hints = generate_reset_output_hints(previous_kernel, transient_data_index_hints);

        ResetOutputComposer {
            previous_kernel,
            validation_request_processor,
            padded_side_effects,
            note_hash_siloing_amount,
            nullifier_siloing_amount,
            private_log_siloing_amount,
            hints,
        }
    }

    // Q: why is this a separate function call, instead of handled within the constructor?
    pub unconstrained fn finish(self) -> PrivateKernelCircuitPublicInputs {
        let mut output = self.previous_kernel;

        // The "propagated" validation requests (read requests & key validation requests)
        // whose processing will be deferred to later Reset circuit iterations.
        output.validation_requests = self.validation_request_processor.compose();

        // Before we propagate side-effects, we might be in the final reset circuit,
        // in which case we'll also silo all of them, and then pad them for better privacy.

        // Q: `note_hash_siloing_amount` is a confusing name.

        output.end.note_hashes = if self.note_hash_siloing_amount == 0 {
            // Some transient note_hashes have been removed (squashed).
            self.hints.kept_note_hashes
        } else {
            self.get_padded_unique_siloed_sorted_kept_note_hashes()
        };

        output.end.nullifiers = if self.nullifier_siloing_amount == 0 {
            // Some transient nullifiers have been removed (squashed).
            self.hints.kept_nullifiers
        } else {
            self.get_padded_siloed_sorted_kept_nullifiers()
        };

        output.end.private_logs = if self.private_log_siloing_amount == 0 {
            // The logs of transient notes have been removed (squashed).
            self.hints.kept_private_logs
        } else {
            self.get_padded_siloed_sorted_kept_private_logs()
        };

        output
    }

    unconstrained fn get_padded_unique_siloed_sorted_kept_note_hashes(
        self,
    ) -> ClaimedLengthArray<ScopedNoteHash, MAX_NOTE_HASHES_PER_TX> {
        // Sort:
        let sorted_kept_note_hashes = ClaimedLengthArray {
            array: sort_by_counter_asc(self.hints.kept_note_hashes.array),
            // If an array is already a DenseTrimmedArray, then the sorted version of
            // that array will have the same length.
            // If the LHS is at all sparse, then the sorted version of the array will
            // get left-packed and the resulting length will be shorter.
            // This is interesting, and might enable optimisations in the constrained checks of this or the tail circuit.
            length: self.hints.kept_note_hashes.length,
        };
        let num_kept_note_hashes = sorted_kept_note_hashes.length;
        let padded_note_hashes = self.padded_side_effects.note_hashes;

        // Calling this in the unconstrained context is not a problem. Since it doesn't matter if there are non-empty
        // items outside of the range [num_kept_note_hashes, self.note_hash_siloing_amount). The values will simply be ignored.
        // Having the check here is useful to catch any bugs where the padded values are not configured correctly by mistake.
        validate_padded_items(
            padded_note_hashes,
            num_kept_note_hashes,
            self.note_hash_siloing_amount,
        );

        // The ordering of adjectives in this name is intentional (back to front).
        let mut padded_unique_siloed_sorted_kept_note_hashes = sorted_kept_note_hashes;

        for i in 0..sorted_kept_note_hashes.array.len() {
            // Push padding:
            if (i >= num_kept_note_hashes) & (padded_note_hashes[i] != 0) {
                // We 'push' so that the length increments.
                // Note: beyond NOTE_HASH_SILOING_AMOUNT, these so-called "padded" note_hashes
                // will be empty. I.e. we don't pad 64; it depends on the dimensions
                // of this variant of the reset circuit.
                padded_unique_siloed_sorted_kept_note_hashes.push(
                    ScopedNoteHash {
                        note_hash: NoteHash {
                            value: padded_note_hashes[i],
                            counter: MAX_U32_VALUE, // TODO: consider using Option::none,
                        },
                        contract_address: SIDE_EFFECT_MASKING_ADDRESS,
                    },
                );
            }

            // Silo:
            let note_hash = padded_unique_siloed_sorted_kept_note_hashes.array[i];
            let siloed_note_hash = silo_note_hash(note_hash);
            let unique_siloed_note_hash = compute_unique_siloed_note_hash(
                siloed_note_hash,
                self.previous_kernel.claimed_first_nullifier,
                i,
            );

            let is_private_only = self.previous_kernel.is_private_only;
            let min_revertible_side_effect_counter =
                self.previous_kernel.min_revertible_side_effect_counter;

            // We don't silo revertible note hashes with a note_nonce, since we don't know their final position in the tx.
            let is_non_revertible = note_hash.counter() < min_revertible_side_effect_counter;

            padded_unique_siloed_sorted_kept_note_hashes.array[i].note_hash.value = if is_private_only
                | is_non_revertible {
                unique_siloed_note_hash
            } else {
                siloed_note_hash
            };

            // Why is it doing this? Is the contract_address being overloaded to mean something else?
            // Oh, is it being used to say "This has already been siloed"?
            // TODO: Why not use an extra bool to convey that?
            padded_unique_siloed_sorted_kept_note_hashes.array[i].contract_address =
                AztecAddress::zero();
        }
        padded_unique_siloed_sorted_kept_note_hashes
    }

    unconstrained fn get_padded_siloed_sorted_kept_nullifiers(
        self,
    ) -> ClaimedLengthArray<ScopedNullifier, MAX_NULLIFIERS_PER_TX> {
        // Sort:
        let sorted_kept_nullifiers = ClaimedLengthArray {
            array: sort_by_counter_asc(self.hints.kept_nullifiers.array),
            length: self.hints.kept_nullifiers.length,
        };

        let num_kept_nullifiers = sorted_kept_nullifiers.length;
        let padded_nullifiers = self.padded_side_effects.nullifiers;

        // Calling this in the unconstrained context is not a problem. Since it doesn't matter if there are non-empty
        // items outside of the range [num_nullifiers, self.nullifier_siloing_amount). The values will simply be ignored.
        // Having the check here is useful to catch any bugs where the padded values are not configured correctly by mistake.
        validate_padded_items(
            padded_nullifiers,
            num_kept_nullifiers,
            self.nullifier_siloing_amount,
        );

        // The ordering of adjectives in this name is intentional (back to front).
        let mut padded_siloed_sorted_kept_nullifiers = sorted_kept_nullifiers;

        for i in 0..sorted_kept_nullifiers.array.len() {
            // Push padding:
            if (i >= num_kept_nullifiers) {
                padded_siloed_sorted_kept_nullifiers.push(
                    ScopedNullifier {
                        nullifier: Nullifier {
                            value: padded_nullifiers[i],
                            counter: MAX_U32_VALUE, // TODO: consider using Option::none,
                            note_hash: 0,
                        },
                        contract_address: SIDE_EFFECT_MASKING_ADDRESS,
                    },
                );
            }

            // Silo:
            padded_siloed_sorted_kept_nullifiers.array[i].nullifier.value =
                silo_nullifier(padded_siloed_sorted_kept_nullifiers.array[i]);
            padded_siloed_sorted_kept_nullifiers.array[i].contract_address = AztecAddress::zero();
        }
        padded_siloed_sorted_kept_nullifiers
    }

    unconstrained fn get_padded_siloed_sorted_kept_private_logs(
        self,
    ) -> ClaimedLengthArray<Scoped<PrivateLogData>, MAX_PRIVATE_LOGS_PER_TX> {
        // Sort:
        let sorted_kept_private_logs = ClaimedLengthArray {
            array: sort_by_counter_asc(self.hints.kept_private_logs.array),
            length: self.hints.kept_private_logs.length,
        };

        let num_kept_private_logs = sorted_kept_private_logs.length;
        let padded_private_logs = self.padded_side_effects.private_logs;

        // Calling this in the unconstrained context is not a problem. Since it doesn't matter if there are non-empty
        // items outside of the range [num_private_logs, self.private_log_siloing_amount). The values will simply be ignored.
        // Having the check here is useful to catch any bugs where the padded values are not configured correctly by mistake.
        validate_padded_items(
            padded_private_logs,
            num_kept_private_logs,
            self.private_log_siloing_amount,
        );

        // The ordering of adjectives in this name is intentional (back to front).
        let mut padded_siloed_sorted_kept_private_logs = sorted_kept_private_logs;

        for i in 0..sorted_kept_private_logs.array.len() {
            // Pad:
            if (i >= num_kept_private_logs) & (padded_private_logs[i].length != 0) {
                padded_siloed_sorted_kept_private_logs.push(
                    Scoped {
                        inner: PrivateLogData {
                            log: padded_private_logs[i],
                            note_hash_counter: 0,
                            counter: MAX_U32_VALUE, // TODO: consider using Option::none,
                        },
                        contract_address: SIDE_EFFECT_MASKING_ADDRESS,
                    },
                );
            }

            // Silo:
            padded_siloed_sorted_kept_private_logs.array[i].inner.log =
                silo_private_log(padded_siloed_sorted_kept_private_logs.array[i]);
            padded_siloed_sorted_kept_private_logs.array[i].contract_address = AztecAddress::zero();
        }

        padded_siloed_sorted_kept_private_logs
    }
}
