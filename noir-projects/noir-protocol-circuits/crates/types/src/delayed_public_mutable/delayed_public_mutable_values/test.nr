use crate::{constants::MAX_FIELD_VALUE, traits::Packable};
use crate::delayed_public_mutable::{
    delayed_public_mutable_values::DelayedPublicMutableValues,
    scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,
};

global TEST_INITIAL_DELAY: u64 = 13;

#[derive(Eq, Packable)]
pub struct MockStruct {
    pub a: Field,
    pub b: Field,
}

unconstrained fn assert_equal_after_conversion<T>(
    original: DelayedPublicMutableValues<T, TEST_INITIAL_DELAY>,
)
where
    T: Packable + Eq,
{
    let converted = DelayedPublicMutableValues::<T, TEST_INITIAL_DELAY>::unpack(original.pack());

    assert_eq(original, converted);
}

#[test]
unconstrained fn test_packable() {
    let pre_delay = 1;
    let post_delay = 2;
    let timestamp_of_change = 50;

    let pre_value = MockStruct { a: 3, b: 3 };
    let post_value = MockStruct { a: 4, b: 4 };

    let test_case = |sdc_pre, sdc_post| {
        let sdc = ScheduledDelayChange::new(sdc_pre, sdc_post, timestamp_of_change);
        let svc = ScheduledValueChange::new(pre_value, post_value, timestamp_of_change);
        assert_equal_after_conversion(DelayedPublicMutableValues::new(svc, sdc));
    };

    test_case(Option::some(pre_delay), Option::some(post_delay));
    test_case(Option::some(pre_delay), Option::none());
    test_case(Option::none(), Option::some(post_delay));
    test_case(Option::none(), Option::none());
}

#[test]
unconstrained fn test_packable_large_values() {
    // We test max u32 even when the actual timestamp is u64 because the timestamp is packed in 32 bits. This makes
    // the code fail in year 2106. This is a tech debt that is not worth tackling.
    let max_u32 = ((1 as u64 << 32) - 1) as u64;

    let pre_delay = max_u32;
    let post_delay = max_u32 - 1;
    let timestamp_of_change = max_u32 - 2;

    let pre_value = MockStruct { a: MAX_FIELD_VALUE, b: MAX_FIELD_VALUE };
    let post_value = MockStruct { a: MAX_FIELD_VALUE - 1, b: MAX_FIELD_VALUE - 1 };

    let test_case = |sdc_pre, sdc_post| {
        let sdc = ScheduledDelayChange::new(sdc_pre, sdc_post, timestamp_of_change);
        let svc = ScheduledValueChange::new(pre_value, post_value, timestamp_of_change);
        assert_equal_after_conversion(DelayedPublicMutableValues::new(svc, sdc));
    };

    test_case(Option::some(pre_delay), Option::some(post_delay));
    test_case(Option::some(pre_delay), Option::none());
    test_case(Option::none(), Option::some(post_delay));
    test_case(Option::none(), Option::none());
}

#[test]
unconstrained fn packed_delayed_public_mutable_values_match_typescript() {
    let pre_value = MockStruct { a: 1, b: 2 };
    let post_value = MockStruct { a: 3, b: 4 };

    let sdc = ScheduledDelayChange::<0>::new(Option::some(1), Option::some(50), 2);
    let svc = ScheduledValueChange::new(pre_value, post_value, 50);
    let dpmv = DelayedPublicMutableValues::new(svc, sdc);

    let packed_dpmv = dpmv.pack();

    // The following value was generated by `delayed_public_mutable_values.test.ts`
    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.
    let packed_dpmv_from_typescript = [
        0x0000000000000000000000000000000000010100000032010000000200000032,
        0x0000000000000000000000000000000000000000000000000000000000000001,
        0x0000000000000000000000000000000000000000000000000000000000000002,
        0x0000000000000000000000000000000000000000000000000000000000000003,
        0x0000000000000000000000000000000000000000000000000000000000000004,
    ];

    assert_eq(packed_dpmv, packed_dpmv_from_typescript);
}
