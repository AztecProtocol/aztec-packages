use crate::constants::{
    VK_TREE_HEIGHT, PRIVATE_KERNEL_INIT_INDEX, PRIVATE_KERNEL_INNER_INDEX, PRIVATE_KERNEL_RESET_INDEX,
    PRIVATE_KERNEL_TAIL_INDEX, PRIVATE_KERNEL_TAIL_TO_PUBLIC_INDEX, EMPTY_NESTED_INDEX,
    PRIVATE_KERNEL_EMPTY_INDEX, PUBLIC_KERNEL_INNER_INDEX, PUBLIC_KERNEL_MERGE_INDEX,
    PUBLIC_KERNEL_TAIL_INDEX, BASE_PARITY_INDEX, ROOT_PARITY_INDEX, BASE_ROLLUP_INDEX,
    MERGE_ROLLUP_INDEX, BLOCK_ROOT_ROLLUP_INDEX, BLOCK_MERGE_ROLLUP_INDEX, ROOT_ROLLUP_INDEX,
    BLOCK_ROOT_ROLLUP_EMPTY_INDEX
};
use crate::merkle_tree::merkle_tree::MerkleTree;

global VK_TREE_WIDTH: u32 = (1 as u8 << VK_TREE_HEIGHT as u8) as u32;

pub fn get_vk_merkle_tree() -> MerkleTree<VK_TREE_WIDTH> {
    let mut leaves = [0; VK_TREE_WIDTH];

    // Fake VK hashes for testing purposes
    leaves[PRIVATE_KERNEL_INIT_INDEX] = 0;
    leaves[PRIVATE_KERNEL_INNER_INDEX] = 1;
    leaves[PRIVATE_KERNEL_TAIL_INDEX] = 10;
    leaves[PRIVATE_KERNEL_TAIL_TO_PUBLIC_INDEX] = 11;
    leaves[EMPTY_NESTED_INDEX] = 12;
    leaves[PRIVATE_KERNEL_EMPTY_INDEX] = 13;
    leaves[PUBLIC_KERNEL_INNER_INDEX] = 15;
    leaves[PUBLIC_KERNEL_MERGE_INDEX] = 16;
    leaves[PUBLIC_KERNEL_TAIL_INDEX] = 17;
    leaves[BASE_PARITY_INDEX] = 18;
    leaves[ROOT_PARITY_INDEX] = 19;
    leaves[BASE_ROLLUP_INDEX] = 20;
    leaves[MERGE_ROLLUP_INDEX] = 21;
    leaves[BLOCK_ROOT_ROLLUP_INDEX] = 22;
    leaves[BLOCK_MERGE_ROLLUP_INDEX] = 23;
    leaves[ROOT_ROLLUP_INDEX] = 24;
    leaves[BLOCK_ROOT_ROLLUP_EMPTY_INDEX] = 25;
    leaves[PRIVATE_KERNEL_RESET_INDEX] = 26;

    MerkleTree::new(leaves)
}
