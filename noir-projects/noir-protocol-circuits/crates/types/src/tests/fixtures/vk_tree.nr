use crate::constants::{
    VK_TREE_HEIGHT, PRIVATE_KERNEL_INIT_INDEX, PRIVATE_KERNEL_INNER_INDEX,
    PRIVATE_KERNEL_RESET_FULL_INDEX, PRIVATE_KERNEL_RESET_BIG_INDEX, PRIVATE_KERNEL_RESET_MEDIUM_INDEX,
    PRIVATE_KERNEL_RESET_SMALL_INDEX, PRIVATE_KERNEL_TAIL_INDEX, PRIVATE_KERNEL_TAIL_TO_PUBLIC_INDEX,
    EMPTY_NESTED_INDEX, PRIVATE_KERNEL_EMPTY_INDEX, PUBLIC_KERNEL_SETUP_INDEX,
    PUBLIC_KERNEL_APP_LOGIC_INDEX, PUBLIC_KERNEL_TEARDOWN_INDEX, PUBLIC_KERNEL_TAIL_INDEX,
    BASE_PARITY_INDEX, ROOT_PARITY_INDEX, BASE_ROLLUP_INDEX, MERGE_ROLLUP_INDEX, ROOT_ROLLUP_INDEX
};
use crate::merkle_tree::merkle_tree::MerkleTree;

global VK_TREE_WIDTH = 32;

#[test]
fn check_vk_tree_width() {
    assert_eq(2.pow_32(VK_TREE_HEIGHT as Field), VK_TREE_WIDTH as Field, "Incorrect VK tree width");
}

pub fn get_vk_merkle_tree() -> MerkleTree<VK_TREE_WIDTH> {
    let mut leaves = [0; VK_TREE_WIDTH];

    // Fake VK hashes for testing purposes
    leaves[PRIVATE_KERNEL_INIT_INDEX] = 0;
    leaves[PRIVATE_KERNEL_INNER_INDEX] = 1;
    leaves[PRIVATE_KERNEL_RESET_FULL_INDEX] = 2;
    leaves[PRIVATE_KERNEL_RESET_BIG_INDEX] = 3;
    leaves[PRIVATE_KERNEL_RESET_MEDIUM_INDEX] = 4;
    leaves[PRIVATE_KERNEL_RESET_SMALL_INDEX] = 5;
    leaves[PRIVATE_KERNEL_TAIL_INDEX] = 10;
    leaves[PRIVATE_KERNEL_TAIL_TO_PUBLIC_INDEX] = 11;
    leaves[EMPTY_NESTED_INDEX] = 12;
    leaves[PRIVATE_KERNEL_EMPTY_INDEX] = 13;
    leaves[PUBLIC_KERNEL_SETUP_INDEX] = 14;
    leaves[PUBLIC_KERNEL_APP_LOGIC_INDEX] = 15;
    leaves[PUBLIC_KERNEL_TEARDOWN_INDEX] = 16;
    leaves[PUBLIC_KERNEL_TAIL_INDEX] = 17;
    leaves[BASE_PARITY_INDEX] = 18;
    leaves[ROOT_PARITY_INDEX] = 19;
    leaves[BASE_ROLLUP_INDEX] = 20;
    leaves[MERGE_ROLLUP_INDEX] = 21;
    leaves[ROOT_ROLLUP_INDEX] = 22;

    MerkleTree::new(leaves)
}
