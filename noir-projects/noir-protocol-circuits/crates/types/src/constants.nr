use crate::address::AztecAddress;

global MAX_FIELD_VALUE: Field =
    21888242871839275222246405745257275088548364400416034343698204186575808495616;
global ARGS_LENGTH: u32 = 16;

/**
 * Convention for constant array lengths are mainly divided in 2 classes:
 *  - FUNCTION CALL
 *  - TRANSACTION
 *
 * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as
 * commitment, or nullifier, e.g.,:
 *  - MAX_NULLIFIERS_PER_CALL
 *  - MAX_NOTE_HASHES_PER_TX
 *
 * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a
 * transaction. Therefore, we always must have:
 * MAX_XXX_PER_TX >= MAX_XXX_PER_CALL
 *
 * For instance:
 * MAX_NOTE_HASHES_PER_TX >= MAX_NOTE_HASHES_PER_CALL
 * MAX_NULLIFIERS_PER_TX >= MAX_NULLIFIERS_PER_CALL
 *
 */

// docs:start:constants
// "PER CALL" CONSTANTS
global MAX_NOTE_HASHES_PER_CALL: u32 = 16;
global MAX_NULLIFIERS_PER_CALL: u32 = 16;
global MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u32 = 4;
global MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u32 = 16;
global MAX_L2_TO_L1_MSGS_PER_CALL: u32 = 2;
global MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u32 = 64;
global MAX_PUBLIC_DATA_READS_PER_CALL: u32 = 64;
global MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u32 = 16;
global MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u32 = 16;
global MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL: u32 = 16;
global MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL: u32 = 16;
global MAX_KEY_VALIDATION_REQUESTS_PER_CALL: u32 = 16;
global MAX_NOTE_ENCRYPTED_LOGS_PER_CALL: u32 = 16;
global MAX_ENCRYPTED_LOGS_PER_CALL: u32 = 4;
global MAX_UNENCRYPTED_LOGS_PER_CALL: u32 = 4;

// TREES RELATED CONSTANTS
global ARCHIVE_HEIGHT: u32 = 16;
global VK_TREE_HEIGHT: u32 = 6;
global PROTOCOL_CONTRACT_TREE_HEIGHT: u32 = 3;
global FUNCTION_TREE_HEIGHT: u32 = 5;
global NOTE_HASH_TREE_HEIGHT: u32 = 32;
global PUBLIC_DATA_TREE_HEIGHT: u32 = 40;
global NULLIFIER_TREE_HEIGHT: u32 = 20;
global L1_TO_L2_MSG_TREE_HEIGHT: u32 = 16;
global ARTIFACT_FUNCTION_TREE_MAX_HEIGHT: u32 = 5;
global NULLIFIER_TREE_ID = 0;
global NOTE_HASH_TREE_ID = 1;
global PUBLIC_DATA_TREE_ID = 2;
global L1_TO_L2_MESSAGE_TREE_ID = 3;
global ARCHIVE_TREE_ID = 4;

// SUB-TREES RELATED CONSTANTS
global NOTE_HASH_SUBTREE_HEIGHT: u32 = 6;
global NULLIFIER_SUBTREE_HEIGHT: u32 = 6;
global PUBLIC_DATA_SUBTREE_HEIGHT: u32 = 6;
global L1_TO_L2_MSG_SUBTREE_HEIGHT: u32 = 4;
global NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u32 =
    NOTE_HASH_TREE_HEIGHT - NOTE_HASH_SUBTREE_HEIGHT;
global NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u32 =
    NULLIFIER_TREE_HEIGHT - NULLIFIER_SUBTREE_HEIGHT;
global PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u32 =
    PUBLIC_DATA_TREE_HEIGHT - PUBLIC_DATA_SUBTREE_HEIGHT;
global L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u32 =
    L1_TO_L2_MSG_TREE_HEIGHT - L1_TO_L2_MSG_SUBTREE_HEIGHT;

// "PER TRANSACTION" CONSTANTS
global MAX_NOTE_HASHES_PER_TX: u32 = (1 as u8 << NOTE_HASH_SUBTREE_HEIGHT as u8) as u32;
global MAX_NULLIFIERS_PER_TX: u32 = (1 as u8 << NULLIFIER_SUBTREE_HEIGHT as u8) as u32;
global MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u32 = 8;
global MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u32 = 32;
global PROTOCOL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u32 = 1;
global MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u32 =
    (1 as u8 << PUBLIC_DATA_SUBTREE_HEIGHT as u8) as u32;
global MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u32 =
    MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX - PROTOCOL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX;
global MAX_PUBLIC_DATA_READS_PER_TX: u32 = 64;
global MAX_L2_TO_L1_MSGS_PER_TX: u32 = 8;
global MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u32 = 64;
global MAX_NULLIFIER_READ_REQUESTS_PER_TX: u32 = 64;
global MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX: u32 = 64;
global MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_TX: u32 = 64;
// TODO: for large multisends we might run out of key validation requests here but not dealing with this now as
// databus will hopefully make the issue go away.
global MAX_KEY_VALIDATION_REQUESTS_PER_TX: u32 = 64;
global MAX_NOTE_ENCRYPTED_LOGS_PER_TX: u32 = 64;
global MAX_ENCRYPTED_LOGS_PER_TX: u32 = 8;
global MAX_UNENCRYPTED_LOGS_PER_TX: u32 = 8;
// docs:end:constants

// KERNEL CIRCUIT PRIVATE INPUTS CONSTANTS
// global MAX_PUBLIC_DATA_HINTS: u32 = MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX + MAX_PUBLIC_DATA_READS_PER_TX;
// FIX: Sadly, writing this as above causes a type error in type_conversion.ts.
global MAX_PUBLIC_DATA_HINTS: u32 = 128;

// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts
global NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u32 = 16;

// VK TREE CONSTANTS
comptime global EMPTY_NESTED_INDEX: u32 = 0;
comptime global PRIVATE_KERNEL_EMPTY_INDEX: u32 = 1;
comptime global PRIVATE_KERNEL_INIT_INDEX: u32 = 2;
comptime global PRIVATE_KERNEL_INNER_INDEX: u32 = 3;
comptime global PRIVATE_KERNEL_TAIL_INDEX: u32 = 4;
comptime global PRIVATE_KERNEL_TAIL_TO_PUBLIC_INDEX: u32 = 5;
comptime global PUBLIC_KERNEL_MERGE_INDEX: u32 = 6;
comptime global PUBLIC_KERNEL_TAIL_INDEX: u32 = 7;
comptime global PUBLIC_KERNEL_INNER_INDEX: u32 = 8; // TODO(#7124): To be deprecated.
comptime global BASE_PARITY_INDEX: u32 = 10;
comptime global ROOT_PARITY_INDEX: u32 = 11;
comptime global BASE_ROLLUP_INDEX: u32 = 12;
comptime global MERGE_ROLLUP_INDEX: u32 = 13;
comptime global BLOCK_ROOT_ROLLUP_INDEX: u32 = 14;
comptime global BLOCK_MERGE_ROLLUP_INDEX: u32 = 15;
comptime global ROOT_ROLLUP_INDEX: u32 = 16;
comptime global BLOCK_ROOT_ROLLUP_EMPTY_INDEX: u32 = 17;
comptime global TUBE_INDEX: u32 = 18;
comptime global PRIVATE_KERNEL_RESET_INDEX: u32 = 20;
// Important: Do not define indexes after the PRIVATE_KERNEL_RESET_INDEX. They are allocated for the variants of private kernel reset.

// MISC CONSTANTS
global FUNCTION_SELECTOR_NUM_BYTES: Field = 4;
// The following is used in immutable state variables to compute an initialization slot whose value is used to
// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).
// The initialization slot is computed by adding the constant below to the variable's storage slot. This constant has
// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.
global INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;
global INITIAL_L2_BLOCK_NUM: Field = 1;
global BLOB_SIZE_IN_BYTES: Field = 31 * 4096;
global ETHEREUM_SLOT_DURATION: u32 = 12;
// AZTEC_SLOT_DURATION should be a multiple of ETHEREUM_SLOT_DURATION
global AZTEC_SLOT_DURATION: u32 = ETHEREUM_SLOT_DURATION * 2;
global AZTEC_EPOCH_DURATION: u32 = 16;
global AZTEC_TARGET_COMMITTEE_SIZE: u32 = 48;
// The number of AZTEC_SLOTS that we can wait for a proof of an epoch to be produced.
global AZTEC_EPOCH_PROOF_CLAIM_WINDOW_IN_L2_SLOTS: u32 = 13;
// The following is taken from building a block and looking at the `lastArchive` value in it.
// You can run the `integration_l1_publisher.test.ts` and look at the first blocks in the fixtures.
global GENESIS_ARCHIVE_ROOT: Field =
    0x1200a06aae1368abe36530b585bd7a4d2ba4de5037b82076412691a187d7621e;
// The following and the value in `deploy_l1_contracts` must match. We should not have the code both places, but
// we are running into circular dependency issues. #3342
global FEE_JUICE_INITIAL_MINT: Field = 20000000000;
// Last 4 bytes of the Poseidon2 hash of 'public_dispatch(Field)'.
global PUBLIC_DISPATCH_SELECTOR: Field = 0xd5441b0d;

// CONTRACT CLASS CONSTANTS
global MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u32 = 3000;
// Bytecode size for private functions is per function, not for the entire contract.
// Note that private functions bytecode includes a mix of acir and brillig.
global MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u32 = 3000;
// Same for unconstrained functions: the size is per function.
global MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u32 = 3000;
// How many fields are on the serialized ClassPrivateFunctionBroadcasted event in addition to MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS.
global REGISTERER_PRIVATE_FUNCTION_BROADCASTED_ADDITIONAL_FIELDS: u32 = 19;
// How many fields are on the serialized ClassUnconstrainedFunctionBroadcasted event in addition to MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS.
global REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_ADDITIONAL_FIELDS: u32 = 12;
// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.
// This is just a stopgap until we implement proper selectors.
// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'
global REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE =
    0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;
// sha224sum 'struct ClassPrivateFunctionBroadcasted'
global REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE =
    0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;
// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'
global REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE =
    0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;

// CONTRACT INSTANCE CONSTANTS
// sha224sum 'struct ContractInstanceDeployed'
global DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE =
    0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;

// GAS DEFAULTS
global DEFAULT_GAS_LIMIT: u32 = 1_000_000_000;
global DEFAULT_TEARDOWN_GAS_LIMIT: u32 = 100_000_000;
global MAX_L2_GAS_PER_ENQUEUED_CALL: u32 = 12_000_000;
global DEFAULT_MAX_FEE_PER_GAS: Field = 10;
global DEFAULT_INCLUSION_FEE: Field = 0;
global DA_BYTES_PER_FIELD: u32 = 32;
global DA_GAS_PER_BYTE: u32 = 16;
// pays for preamble information in TX Effects
global FIXED_DA_GAS: u32 = 512;
// pays for fixed tx costs like validation, and updating state roots
global FIXED_L2_GAS: u32 = 512;
// base cost for a single public call
global FIXED_AVM_STARTUP_L2_GAS: u32 = 1024;

// Some tree insertions incur an additional cost associated with
// the new database entry to be stored by all network participants.
global L2_GAS_DISTRIBUTED_STORAGE_PREMIUM: u32 = 1024;

// Kernel and/or rollup circuits perform a hash per tree-level for insertions and reads.
// All network participants need to perform tree insertions.
// Not _all_ network participants need to perform membership checks, so they're cheaper.
global L2_GAS_PER_READ_MERKLE_HASH: u32 = 30;
global L2_GAS_PER_WRITE_MERKLE_HASH: u32 = 40;

// Gas for tree insertions and associated storage
global L2_GAS_PER_PUBLIC_DATA_UPDATE: u32 =
    L2_GAS_DISTRIBUTED_STORAGE_PREMIUM + (PUBLIC_DATA_TREE_HEIGHT * L2_GAS_PER_WRITE_MERKLE_HASH);
global L2_GAS_PER_NOTE_HASH: u32 =
    L2_GAS_DISTRIBUTED_STORAGE_PREMIUM + (NOTE_HASH_TREE_HEIGHT * L2_GAS_PER_WRITE_MERKLE_HASH);
// 2x because insertion into indexed tree requires a low-leaf membership check and a standard insertion
global L2_GAS_PER_NULLIFIER: u32 =
    L2_GAS_DISTRIBUTED_STORAGE_PREMIUM + (2 * NULLIFIER_TREE_HEIGHT * L2_GAS_PER_WRITE_MERKLE_HASH);

// Gas for tree read requests
global L2_GAS_PER_PUBLIC_DATA_READ: u32 = PUBLIC_DATA_TREE_HEIGHT * L2_GAS_PER_READ_MERKLE_HASH;
global L2_GAS_PER_NOTE_HASH_READ_REQUEST: u32 = NOTE_HASH_TREE_HEIGHT * L2_GAS_PER_READ_MERKLE_HASH;
// 2x because non-membership checks are really 2 membership checks
global L2_GAS_PER_NULLIFIER_READ_REQUEST: u32 =
    2 * NULLIFIER_TREE_HEIGHT * L2_GAS_PER_READ_MERKLE_HASH;
global L2_GAS_PER_L1_TO_L2_MSG_READ_REQUEST: u32 =
    L1_TO_L2_MSG_TREE_HEIGHT * L2_GAS_PER_READ_MERKLE_HASH;

// Gas for hashing and validating logs
global L2_GAS_PER_LOG_BYTE: u32 = 4;

// Gas for writing message to L1 portal
global L2_GAS_PER_L2_TO_L1_MSG: u32 = 200;

// CANONICAL CONTRACT ADDRESSES
global MAX_PROTOCOL_CONTRACTS: u32 = (1 << PROTOCOL_CONTRACT_TREE_HEIGHT as u8) - 1; // Index 0 can't be used.
global CANONICAL_AUTH_REGISTRY_ADDRESS = AztecAddress::from_field(1);
global DEPLOYER_CONTRACT_ADDRESS = AztecAddress::from_field(2);
global REGISTERER_CONTRACT_ADDRESS = AztecAddress::from_field(3);
global MULTI_CALL_ENTRYPOINT_ADDRESS = AztecAddress::from_field(4);
global FEE_JUICE_ADDRESS = AztecAddress::from_field(5);
global ROUTER_ADDRESS = AztecAddress::from_field(6);

// CANONICAL DEFAULT KEYS
// This below are:
// "az_null_npk"
// "az_null_ivpk"
// "az_null_ovpk"
// "az_null_tpk"
// as bytes, hashed to curve using grumpkin::g1::affine_element::hash_to_curve(<X>, 0);
global DEFAULT_NPK_M_X = 0x01498945581e0eb9f8427ad6021184c700ef091d570892c437d12c7d90364bbd;
global DEFAULT_NPK_M_Y = 0x170ae506787c5c43d6ca9255d571c10fa9ffa9d141666e290c347c5c9ab7e344;
global DEFAULT_IVPK_M_X = 0x00c044b05b6ca83b9c2dbae79cc1135155956a64e136819136e9947fe5e5866c;
global DEFAULT_IVPK_M_Y = 0x1c1f0ca244c7cd46b682552bff8ae77dea40b966a71de076ec3b7678f2bdb151;
global DEFAULT_OVPK_M_X = 0x1b00316144359e9a3ec8e49c1cdb7eeb0cedd190dfd9dc90eea5115aa779e287;
global DEFAULT_OVPK_M_Y = 0x080ffc74d7a8b0bccb88ac11f45874172f3847eb8b92654aaa58a3d2b8dc7833;
global DEFAULT_TPK_M_X = 0x019c111f36ad3fc1d9b7a7a14344314d2864b94f030594cd67f753ef774a1efb;
global DEFAULT_TPK_M_Y = 0x2039907fe37f08d10739255141bb066c506a12f7d1e8dfec21abc58494705b6f;

// LENGTH OF STRUCTS SERIALIZED TO FIELDS
global AZTEC_ADDRESS_LENGTH: u32 = 1;
global GAS_FEES_LENGTH: u32 = 2;
global GAS_LENGTH: u32 = 2;
global GAS_SETTINGS_LENGTH: u32 = GAS_LENGTH * 2 + GAS_FEES_LENGTH + /* inclusion_fee */ 1;
global CALL_CONTEXT_LENGTH: u32 = 4;
global CONTENT_COMMITMENT_LENGTH: u32 = 4;
global CONTRACT_INSTANCE_LENGTH: u32 = 16;
global CONTRACT_STORAGE_READ_LENGTH: u32 = 3;
global CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u32 = 3;
global ETH_ADDRESS_LENGTH: u32 = 1;
global FUNCTION_DATA_LENGTH: u32 = 2;
global FUNCTION_LEAF_PREIMAGE_LENGTH: u32 = 5;
global GLOBAL_VARIABLES_LENGTH: u32 = 7 + GAS_FEES_LENGTH;
global APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;
global L1_TO_L2_MESSAGE_LENGTH: u32 = 6;
global L2_TO_L1_MESSAGE_LENGTH: u32 = 3;
global SCOPED_L2_TO_L1_MESSAGE_LENGTH: u32 = L2_TO_L1_MESSAGE_LENGTH + 1;
global MAX_BLOCK_NUMBER_LENGTH: u32 = 2; // 1 for the option flag, 1 for the value
global KEY_VALIDATION_REQUEST_LENGTH: u32 = 4;
global KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH: u32 = KEY_VALIDATION_REQUEST_LENGTH + 1;
global SCOPED_KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH: u32 =
    KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH + 1;
global PARTIAL_STATE_REFERENCE_LENGTH: u32 = 6;
global READ_REQUEST_LENGTH: u32 = 2;
global TREE_LEAF_READ_REQUEST_LENGTH: u32 = 2;
global LOG_HASH_LENGTH: u32 = 3;
global SCOPED_LOG_HASH_LENGTH: u32 = LOG_HASH_LENGTH + 1;
global ENCRYPTED_LOG_HASH_LENGTH: u32 = 4;
global SCOPED_ENCRYPTED_LOG_HASH_LENGTH: u32 = ENCRYPTED_LOG_HASH_LENGTH + 1;
global NOTE_LOG_HASH_LENGTH: u32 = 4;
global NOTE_HASH_LENGTH: u32 = 2;
global SCOPED_NOTE_HASH_LENGTH: u32 = NOTE_HASH_LENGTH + 1;
global NULLIFIER_LENGTH: u32 = 3;
global SCOPED_NULLIFIER_LENGTH: u32 = NULLIFIER_LENGTH + 1;
global PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH: u32 =
    AZTEC_ADDRESS_LENGTH + CALL_CONTEXT_LENGTH + 3 + 2 * GAS_LENGTH;
global PRIVATE_CALL_REQUEST_LENGTH: u32 = CALL_CONTEXT_LENGTH + 4;
global PUBLIC_CALL_REQUEST_LENGTH: u32 = CALL_CONTEXT_LENGTH + 1 /* args_hash */ + 1 /* counter */;
global PUBLIC_INNER_CALL_REQUEST_LENGTH: u32 =
    PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH + 1 /* counter */;
global ROLLUP_VALIDATION_REQUESTS_LENGTH: u32 = MAX_BLOCK_NUMBER_LENGTH;
global STATE_REFERENCE_LENGTH: u32 =
    APPEND_ONLY_TREE_SNAPSHOT_LENGTH + PARTIAL_STATE_REFERENCE_LENGTH;
global TX_CONTEXT_LENGTH: u32 = 2 + GAS_SETTINGS_LENGTH;
global TX_REQUEST_LENGTH: u32 = 2 + TX_CONTEXT_LENGTH + FUNCTION_DATA_LENGTH;
global TOTAL_FEES_LENGTH: u32 = 1;
global HEADER_LENGTH: u32 = APPEND_ONLY_TREE_SNAPSHOT_LENGTH
    + CONTENT_COMMITMENT_LENGTH
    + STATE_REFERENCE_LENGTH
    + GLOBAL_VARIABLES_LENGTH
    + TOTAL_FEES_LENGTH;
global PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u32 = CALL_CONTEXT_LENGTH
    + 4
    + MAX_BLOCK_NUMBER_LENGTH
    + (READ_REQUEST_LENGTH * MAX_NOTE_HASH_READ_REQUESTS_PER_CALL)
    + (READ_REQUEST_LENGTH * MAX_NULLIFIER_READ_REQUESTS_PER_CALL)
    + (KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH * MAX_KEY_VALIDATION_REQUESTS_PER_CALL)
    + (NOTE_HASH_LENGTH * MAX_NOTE_HASHES_PER_CALL)
    + (NULLIFIER_LENGTH * MAX_NULLIFIERS_PER_CALL)
    + (PRIVATE_CALL_REQUEST_LENGTH * MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL)
    + (PUBLIC_CALL_REQUEST_LENGTH * MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL)
    + PUBLIC_CALL_REQUEST_LENGTH
    + (L2_TO_L1_MESSAGE_LENGTH * MAX_L2_TO_L1_MSGS_PER_CALL)
    + 2
    + (NOTE_LOG_HASH_LENGTH * MAX_NOTE_ENCRYPTED_LOGS_PER_CALL)
    + (ENCRYPTED_LOG_HASH_LENGTH * MAX_ENCRYPTED_LOGS_PER_CALL)
    + (LOG_HASH_LENGTH * MAX_UNENCRYPTED_LOGS_PER_CALL)
    + HEADER_LENGTH
    + TX_CONTEXT_LENGTH;
global PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u32 = CALL_CONTEXT_LENGTH
    + /*argsHash + returnsHash*/ 2
    + (TREE_LEAF_READ_REQUEST_LENGTH * MAX_NOTE_HASH_READ_REQUESTS_PER_CALL)
    + (READ_REQUEST_LENGTH * MAX_NULLIFIER_READ_REQUESTS_PER_CALL)
    + (READ_REQUEST_LENGTH * MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL)
    + (TREE_LEAF_READ_REQUEST_LENGTH * MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL)
    + (CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH * MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL)
    + (CONTRACT_STORAGE_READ_LENGTH * MAX_PUBLIC_DATA_READS_PER_CALL)
    + (PUBLIC_INNER_CALL_REQUEST_LENGTH * MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL)
    + (NOTE_HASH_LENGTH * MAX_NOTE_HASHES_PER_CALL)
    + (NULLIFIER_LENGTH * MAX_NULLIFIERS_PER_CALL)
    + (L2_TO_L1_MESSAGE_LENGTH * MAX_L2_TO_L1_MSGS_PER_CALL)
    + 2
    + (LOG_HASH_LENGTH * MAX_UNENCRYPTED_LOGS_PER_CALL)
    + HEADER_LENGTH
    + GLOBAL_VARIABLES_LENGTH
    + AZTEC_ADDRESS_LENGTH
    + /* revert_code */ 1
    + 2 * GAS_LENGTH
    + /* transaction_fee */ 1;
global PRIVATE_CONTEXT_INPUTS_LENGTH: u32 =
    CALL_CONTEXT_LENGTH + HEADER_LENGTH + TX_CONTEXT_LENGTH + 1;
global PUBLIC_CONTEXT_INPUTS_LENGTH: u32 =
    CALL_CONTEXT_LENGTH + HEADER_LENGTH + GLOBAL_VARIABLES_LENGTH + GAS_LENGTH + 2;
global FEE_RECIPIENT_LENGTH: u32 = 2;

global AGGREGATION_OBJECT_LENGTH: u32 = 16;

global SCOPED_READ_REQUEST_LEN: u32 = READ_REQUEST_LENGTH + 1;
global PUBLIC_DATA_READ_LENGTH: u32 = 3;
global PRIVATE_VALIDATION_REQUESTS_LENGTH: u32 = ROLLUP_VALIDATION_REQUESTS_LENGTH
    + (SCOPED_READ_REQUEST_LEN * MAX_NOTE_HASH_READ_REQUESTS_PER_TX)
    + (SCOPED_READ_REQUEST_LEN * MAX_NULLIFIER_READ_REQUESTS_PER_TX)
    + (SCOPED_KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH * MAX_KEY_VALIDATION_REQUESTS_PER_TX)
    + 2;
global NUM_PUBLIC_VALIDATION_REQUEST_ARRAYS: u32 = 5;
global PUBLIC_VALIDATION_REQUESTS_LENGTH: u32 = ROLLUP_VALIDATION_REQUESTS_LENGTH
    + (TREE_LEAF_READ_REQUEST_LENGTH * MAX_NOTE_HASH_READ_REQUESTS_PER_TX)
    + (SCOPED_READ_REQUEST_LEN * MAX_NULLIFIER_READ_REQUESTS_PER_TX)
    + (SCOPED_READ_REQUEST_LEN * MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX)
    + (PUBLIC_DATA_READ_LENGTH * MAX_PUBLIC_DATA_READS_PER_TX)
    + (TREE_LEAF_READ_REQUEST_LENGTH * MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_TX);

global PUBLIC_DATA_UPDATE_REQUEST_LENGTH: u32 = 3;
global COMBINED_ACCUMULATED_DATA_LENGTH: u32 = MAX_NOTE_HASHES_PER_TX
    + MAX_NULLIFIERS_PER_TX
    + (MAX_L2_TO_L1_MSGS_PER_TX * SCOPED_L2_TO_L1_MESSAGE_LENGTH)
    + (LOG_HASH_LENGTH * MAX_NOTE_ENCRYPTED_LOGS_PER_TX)
    + (SCOPED_LOG_HASH_LENGTH * MAX_ENCRYPTED_LOGS_PER_TX)
    + 3
    + (MAX_UNENCRYPTED_LOGS_PER_TX * SCOPED_LOG_HASH_LENGTH)
    + (MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * PUBLIC_DATA_UPDATE_REQUEST_LENGTH)
    + GAS_LENGTH;
global COMBINED_CONSTANT_DATA_LENGTH: u32 = HEADER_LENGTH
    + TX_CONTEXT_LENGTH
    + GLOBAL_VARIABLES_LENGTH
    + 1 /* vk_tree_root */
    + 1 /* protocol_contract_tree_root */;

global PRIVATE_ACCUMULATED_DATA_LENGTH: u32 = (SCOPED_NOTE_HASH_LENGTH * MAX_NOTE_HASHES_PER_TX)
    + (SCOPED_NULLIFIER_LENGTH * MAX_NULLIFIERS_PER_TX)
    + (MAX_L2_TO_L1_MSGS_PER_TX * SCOPED_L2_TO_L1_MESSAGE_LENGTH)
    + (NOTE_LOG_HASH_LENGTH * MAX_NOTE_ENCRYPTED_LOGS_PER_TX)
    + (SCOPED_ENCRYPTED_LOG_HASH_LENGTH * MAX_ENCRYPTED_LOGS_PER_TX)
    + (SCOPED_LOG_HASH_LENGTH * MAX_UNENCRYPTED_LOGS_PER_TX)
    + (PRIVATE_CALL_REQUEST_LENGTH * MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX)
    + (PUBLIC_CALL_REQUEST_LENGTH * MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX);
global PRIVATE_KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH: u32 = 1
    + PRIVATE_VALIDATION_REQUESTS_LENGTH
    + PRIVATE_ACCUMULATED_DATA_LENGTH
    + COMBINED_CONSTANT_DATA_LENGTH
    + PUBLIC_CALL_REQUEST_LENGTH
    + AZTEC_ADDRESS_LENGTH;

global PUBLIC_ACCUMULATED_DATA_LENGTH: u32 = (MAX_NOTE_HASHES_PER_TX * SCOPED_NOTE_HASH_LENGTH)
    + (MAX_NULLIFIERS_PER_TX * NULLIFIER_LENGTH)
    + (MAX_L2_TO_L1_MSGS_PER_TX * SCOPED_L2_TO_L1_MESSAGE_LENGTH)
    + (MAX_NOTE_ENCRYPTED_LOGS_PER_TX * LOG_HASH_LENGTH)
    + (MAX_ENCRYPTED_LOGS_PER_TX * SCOPED_LOG_HASH_LENGTH)
    + (MAX_UNENCRYPTED_LOGS_PER_TX * SCOPED_LOG_HASH_LENGTH)
    + (MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * PUBLIC_DATA_UPDATE_REQUEST_LENGTH)
    + (MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX * PUBLIC_CALL_REQUEST_LENGTH)
    + GAS_LENGTH;
global NUM_PUBLIC_ACCUMULATED_DATA_ARRAYS: u32 = 8;
global PUBLIC_KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH: u32 = COMBINED_CONSTANT_DATA_LENGTH
    + PUBLIC_VALIDATION_REQUESTS_LENGTH
    + PUBLIC_ACCUMULATED_DATA_LENGTH
    + PUBLIC_ACCUMULATED_DATA_LENGTH
    + 1 /* end_side_effect_counter */
    + PUBLIC_CALL_REQUEST_LENGTH
    + AZTEC_ADDRESS_LENGTH
    + 1 /* revert_code */;
global VM_CIRCUIT_PUBLIC_INPUTS_LENGTH: u32 = COMBINED_CONSTANT_DATA_LENGTH
    + PUBLIC_CALL_REQUEST_LENGTH
    + PUBLIC_VALIDATION_REQUESTS_LENGTH
    + NUM_PUBLIC_VALIDATION_REQUEST_ARRAYS
    + PUBLIC_ACCUMULATED_DATA_LENGTH
    + NUM_PUBLIC_ACCUMULATED_DATA_ARRAYS
    + 1 /* start_side_effect_counter */
    + 1 /* end_side_effect_counter */
    + GAS_LENGTH
    + 1
    + 1
    + (PUBLIC_INNER_CALL_REQUEST_LENGTH * MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX);

global KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH: u32 = ROLLUP_VALIDATION_REQUESTS_LENGTH
    + COMBINED_ACCUMULATED_DATA_LENGTH
    + COMBINED_CONSTANT_DATA_LENGTH
    + PARTIAL_STATE_REFERENCE_LENGTH
    + 1
    + AZTEC_ADDRESS_LENGTH;

global CONSTANT_ROLLUP_DATA_LENGTH: u32 = APPEND_ONLY_TREE_SNAPSHOT_LENGTH
    + 1 /* vk_tree_root */
    + 1 /* protocol_contract_tree_root */
    + GLOBAL_VARIABLES_LENGTH;

// + 5 for rollup_type, height_in_block_tree, txs_effects_hash, out_hash, accumulated_fees
global BASE_OR_MERGE_PUBLIC_INPUTS_LENGTH: u32 = CONSTANT_ROLLUP_DATA_LENGTH
    + PARTIAL_STATE_REFERENCE_LENGTH
    + PARTIAL_STATE_REFERENCE_LENGTH
    + 5;
global BLOCK_ROOT_OR_BLOCK_MERGE_PUBLIC_INPUTS_LENGTH: u32 = 2 * APPEND_ONLY_TREE_SNAPSHOT_LENGTH
    + 1 /* previous_block_hash */
    + 1 /* end_block_hash */
    + 2 * GLOBAL_VARIABLES_LENGTH
    + 1 /* out_hash */
    + AZTEC_EPOCH_DURATION * FEE_RECIPIENT_LENGTH
    + 1 /* vk_tree_root */
    + 1 /* protocol_contract_tree_root */
    + 1 /* prover_id */;
global ROOT_ROLLUP_PUBLIC_INPUTS_LENGTH: u32 =
    2 * APPEND_ONLY_TREE_SNAPSHOT_LENGTH + 8 + AZTEC_EPOCH_DURATION * FEE_RECIPIENT_LENGTH;

global GET_NOTES_ORACLE_RETURN_LENGTH: u32 = 674;
global NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: u32 = 32 * MAX_NOTE_HASHES_PER_TX;
global NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: u32 = 32 * MAX_NULLIFIERS_PER_TX;
global PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: u32 =
    64 * MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX; // 1 write is 64 bytes
global CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;
global CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;
global CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;
global L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 256;
global LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;
global NUM_MSGS_PER_BASE_PARITY: u32 = 4;
// global NUM_BASE_PARITY_PER_ROOT_PARITY: u32 = NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP / NUM_MSGS_PER_BASE_PARITY;
// FIX: Sadly, writing this as above causes a type error in type_conversion.ts.
global NUM_BASE_PARITY_PER_ROOT_PARITY: u32 = 4;

// Lengths of the different types of proofs in fields
global RECURSIVE_PROOF_LENGTH: u32 = 463;
global NESTED_RECURSIVE_PROOF_LENGTH: u32 = 463;
global TUBE_PROOF_LENGTH: u32 = RECURSIVE_PROOF_LENGTH; // in the future these can differ

global HONK_VERIFICATION_KEY_LENGTH_IN_FIELDS: u32 = 128;

global CLIENT_IVC_VERIFICATION_KEY_LENGTH_IN_FIELDS: u32 = 145;
// VK is composed of
// - circuit size encoded as a fr field element (32 bytes)
// - num of inputs encoded as a fr field element (32 bytes)
// - 21 affine elements (curve base field fq) encoded as fr elements takes (21 * 4 * 32 bytes)
// 21 above refers to the constant AvmFlavor::NUM_PRECOMPUTED_ENTITIES
global AVM_VERIFICATION_KEY_LENGTH_IN_FIELDS: u32 = 2 + 21 * 4;

// `AVM_PROOF_LENGTH_IN_FIELDS` must be updated when AVM circuit changes.
// To determine latest value, hover `COMPUTED_AVM_PROOF_LENGTH_IN_FIELDS`
// in barretenberg/cpp/src/barretenberg/vm/avm/generated/flavor.hpp
global AVM_PROOF_LENGTH_IN_FIELDS: u32 = 4166;
global AVM_PUBLIC_COLUMN_MAX_SIZE: u32 = 1024;
global AVM_PUBLIC_INPUTS_FLATTENED_SIZE: u32 =
    2 * AVM_PUBLIC_COLUMN_MAX_SIZE + PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH;
/**
 * Enumerate the hash_indices which are used for pedersen hashing.
 * We start from 1 to avoid the default generators. The generator indices are listed
 * based on the number of elements each index hashes. The following conditions must be met:
 *
 * +-----------+-------------------------------+----------------------+
 * | Hash size | Number of elements hashed (n) | Condition to use     |
 * |-----------+-------------------------------+----------------------|
 * | LOW       | n <= 8                         | 0 < hash_index <= 32  |
 * | MID       | 8 < n <= 16                    | 32 < hash_index <= 40 |
 * | HIGH      | 16 < n <= 48                   | 40 < hash_index <= 48 |
 * +-----------+-------------------------------+----------------------+
 */
// Indices with size <= 8
global GENERATOR_INDEX__NOTE_HASH: u32 = 1;
global GENERATOR_INDEX__NOTE_HASH_NONCE: u32 = 2;
global GENERATOR_INDEX__UNIQUE_NOTE_HASH: u32 = 3;
global GENERATOR_INDEX__SILOED_NOTE_HASH: u32 = 4;
global GENERATOR_INDEX__MESSAGE_NULLIFIER: u32 = 5;
global GENERATOR_INDEX__INITIALIZATION_NULLIFIER: u32 = 6;
global GENERATOR_INDEX__OUTER_NULLIFIER: u32 = 7;
global GENERATOR_INDEX__PUBLIC_DATA_READ: u32 = 8;
global GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST: u32 = 9;
global GENERATOR_INDEX__FUNCTION_DATA: u32 = 10;
global GENERATOR_INDEX__FUNCTION_LEAF: u32 = 11;
global GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA: u32 = 12;
global GENERATOR_INDEX__CONSTRUCTOR: u32 = 13;
global GENERATOR_INDEX__CONSTRUCTOR_ARGS: u32 = 14;
global GENERATOR_INDEX__CONTRACT_ADDRESS_V1: u32 = 15;
global GENERATOR_INDEX__CONTRACT_LEAF: u32 = 16;
global GENERATOR_INDEX__CALL_CONTEXT: u32 = 17;
global GENERATOR_INDEX__CALL_STACK_ITEM: u32 = 18;
global GENERATOR_INDEX__CALL_STACK_ITEM_2: u32 = 19;
global GENERATOR_INDEX__SECRET_HASH: u32 = 20;
global GENERATOR_INDEX__L2_TO_L1_MSG: u32 = 21;
global GENERATOR_INDEX__TX_CONTEXT: u32 = 22;
global GENERATOR_INDEX__PUBLIC_LEAF_INDEX: u32 = 23;
global GENERATOR_INDEX__PUBLIC_DATA_LEAF: u32 = 24;
global GENERATOR_INDEX__SIGNED_TX_REQUEST: u32 = 25;
global GENERATOR_INDEX__GLOBAL_VARIABLES: u32 = 26;
global GENERATOR_INDEX__PARTIAL_ADDRESS: u32 = 27;
global GENERATOR_INDEX__BLOCK_HASH: u32 = 28;
global GENERATOR_INDEX__SIDE_EFFECT: u32 = 29;
global GENERATOR_INDEX__FEE_PAYLOAD: u32 = 30;
global GENERATOR_INDEX__COMBINED_PAYLOAD: u32 = 31;
global GENERATOR_INDEX__TX_NULLIFIER: u32 = 32;
// Indices with size <= 16
global GENERATOR_INDEX__TX_REQUEST: u32 = 33;
global GENERATOR_INDEX__SIGNATURE_PAYLOAD: u32 = 34;
// Indices with size <= 44
global GENERATOR_INDEX__VK: u32 = 41;
global GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS: u32 = 42;
global GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS: u32 = 43;
// TODO: Function args generator index is being used to hash 64 items
global GENERATOR_INDEX__FUNCTION_ARGS: u32 = 44;
global GENERATOR_INDEX__AUTHWIT_INNER: u32 = 45;
global GENERATOR_INDEX__AUTHWIT_OUTER: u32 = 46;
global GENERATOR_INDEX__AUTHWIT_NULLIFIER: u32 = 47;
// Key related generators follow
global GENERATOR_INDEX__NSK_M: u32 = 48;
global GENERATOR_INDEX__IVSK_M: u32 = 49;
global GENERATOR_INDEX__OVSK_M: u32 = 50;
global GENERATOR_INDEX__TSK_M: u32 = 51;
global GENERATOR_INDEX__PUBLIC_KEYS_HASH: u32 = 52;
global GENERATOR_INDEX__NOTE_NULLIFIER: u32 = 53;
global GENERATOR_INDEX__NOTE_HIDING_POINT: u32 = 54;
global GENERATOR_INDEX__SYMMETRIC_KEY: u8 = 55;

// AVM memory tags
global MEM_TAG_FF = 0;
global MEM_TAG_U1 = 1;
global MEM_TAG_U8 = 2;
global MEM_TAG_U16 = 3;
global MEM_TAG_U32 = 4;
global MEM_TAG_U64 = 5;
global MEM_TAG_U128 = 6;

// AVM CIRCUIT - PUBLIC KERNEL INPUTS COLUMN OFFSETS
// Keep the number of offsets aligned with KERNEL_INPUTS_LENGTH defined in constants.hpp
global SENDER_KERNEL_INPUTS_COL_OFFSET: u32 = 0;
global ADDRESS_KERNEL_INPUTS_COL_OFFSET: u32 = 1;
global FUNCTION_SELECTOR_KERNEL_INPUTS_COL_OFFSET: u32 = 2;
global IS_STATIC_CALL_KERNEL_INPUTS_COL_OFFSET: u32 = 3;
// Global Variables
global CHAIN_ID_KERNEL_INPUTS_COL_OFFSET: u32 = 4;
global VERSION_KERNEL_INPUTS_COL_OFFSET: u32 = 5;
global BLOCK_NUMBER_KERNEL_INPUTS_COL_OFFSET: u32 = 6;
global TIMESTAMP_KERNEL_INPUTS_COL_OFFSET: u32 = 7;
// Global Variables - fees
global FEE_PER_DA_GAS_KERNEL_INPUTS_COL_OFFSET: u32 = 8;
global FEE_PER_L2_GAS_KERNEL_INPUTS_COL_OFFSET: u32 = 9;
// Gas - start and end values
global DA_START_GAS_KERNEL_INPUTS_COL_OFFSET = 10;
global L2_START_GAS_KERNEL_INPUTS_COL_OFFSET = 11;
global DA_END_GAS_KERNEL_INPUTS_COL_OFFSET = 12;
global L2_END_GAS_KERNEL_INPUTS_COL_OFFSET = 13;
// Top-level members
global TRANSACTION_FEE_KERNEL_INPUTS_COL_OFFSET: u32 = 14;

// AVM CIRCUIT - PUBLIC KERNEL OUTPUTS COLUMN OFFSETS
// Side effects
global START_NOTE_HASH_EXISTS_WRITE_OFFSET: u32 = 0;
global START_NULLIFIER_EXISTS_OFFSET: u32 =
    START_NOTE_HASH_EXISTS_WRITE_OFFSET + MAX_NOTE_HASH_READ_REQUESTS_PER_CALL;
global START_NULLIFIER_NON_EXISTS_OFFSET: u32 =
    START_NULLIFIER_EXISTS_OFFSET + MAX_NULLIFIER_READ_REQUESTS_PER_CALL;
global START_L1_TO_L2_MSG_EXISTS_WRITE_OFFSET: u32 =
    START_NULLIFIER_NON_EXISTS_OFFSET + MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL;
global START_SSTORE_WRITE_OFFSET: u32 =
    START_L1_TO_L2_MSG_EXISTS_WRITE_OFFSET + MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL;
global START_SLOAD_WRITE_OFFSET: u32 =
    START_SSTORE_WRITE_OFFSET + MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL;
global START_EMIT_NOTE_HASH_WRITE_OFFSET: u32 =
    START_SLOAD_WRITE_OFFSET + MAX_PUBLIC_DATA_READS_PER_CALL;
global START_EMIT_NULLIFIER_WRITE_OFFSET: u32 =
    START_EMIT_NOTE_HASH_WRITE_OFFSET + MAX_NOTE_HASHES_PER_CALL;
global START_EMIT_L2_TO_L1_MSG_WRITE_OFFSET: u32 =
    START_EMIT_NULLIFIER_WRITE_OFFSET + MAX_NULLIFIERS_PER_CALL;
global START_EMIT_UNENCRYPTED_LOG_WRITE_OFFSET: u32 =
    START_EMIT_L2_TO_L1_MSG_WRITE_OFFSET + MAX_L2_TO_L1_MSGS_PER_CALL;

/**
 * GAS COSTS FOR AVM OPCODES
 * They are used in TS and C++
 */
// Base L2 GAS
// Note: magic numbers here are derived from each op's AVM circuit trace area
global AVM_ADD_BASE_L2_GAS: u32 = 32;
global AVM_SUB_BASE_L2_GAS: u32 = 32;
global AVM_MUL_BASE_L2_GAS: u32 = 33;
global AVM_DIV_BASE_L2_GAS: u32 = 43;
global AVM_FDIV_BASE_L2_GAS: u32 = 32;
global AVM_EQ_BASE_L2_GAS: u32 = 32;
global AVM_LT_BASE_L2_GAS: u32 = 64;
global AVM_LTE_BASE_L2_GAS: u32 = 64;
global AVM_AND_BASE_L2_GAS: u32 = 33;
global AVM_OR_BASE_L2_GAS: u32 = 33;
global AVM_XOR_BASE_L2_GAS: u32 = 33;
global AVM_NOT_BASE_L2_GAS: u32 = 27;
global AVM_SHL_BASE_L2_GAS: u32 = 32;
global AVM_SHR_BASE_L2_GAS: u32 = 32;
global AVM_CAST_BASE_L2_GAS: u32 = 30;
global AVM_GETENVVAR_BASE_L2_GAS: u16 = 20;
global AVM_CALLDATACOPY_BASE_L2_GAS: u32 = 29;
global AVM_JUMP_BASE_L2_GAS: u32 = 12;
global AVM_JUMPI_BASE_L2_GAS: u32 = 18;
global AVM_INTERNALCALL_BASE_L2_GAS: u32 = 18;
global AVM_INTERNALRETURN_BASE_L2_GAS: u32 = 18;
global AVM_SET_BASE_L2_GAS: u32 = 18;
global AVM_MOV_BASE_L2_GAS: u32 = 23;
global AVM_SLOAD_BASE_L2_GAS: u32 = 18 + L2_GAS_PER_PUBLIC_DATA_READ;
global AVM_SSTORE_BASE_L2_GAS: u32 = 18 + L2_GAS_PER_PUBLIC_DATA_UPDATE;
global AVM_NOTEHASHEXISTS_BASE_L2_GAS: u32 = 26 + L2_GAS_PER_NOTE_HASH_READ_REQUEST;
global AVM_EMITNOTEHASH_BASE_L2_GAS: u32 = 26 + L2_GAS_PER_NOTE_HASH;
global AVM_NULLIFIEREXISTS_BASE_L2_GAS: u32 = 26 + L2_GAS_PER_NULLIFIER_READ_REQUEST;
global AVM_EMITNULLIFIER_BASE_L2_GAS: u32 = 26 + L2_GAS_PER_NULLIFIER;
global AVM_L1TOL2MSGEXISTS_BASE_L2_GAS: u32 = 26 + L2_GAS_PER_L1_TO_L2_MSG_READ_REQUEST;
global AVM_GETCONTRACTINSTANCE_BASE_L2_GAS: u32 = 48 + L2_GAS_PER_NULLIFIER_READ_REQUEST; // does a nullifier check
global AVM_EMITUNENCRYPTEDLOG_BASE_L2_GAS: u32 = 18;
global AVM_SENDL2TOL1MSG_BASE_L2_GAS: u32 = 26 + L2_GAS_PER_L2_TO_L1_MSG;
// On CALL, AVM performs nullifier checks for contract address & contract class ID
global AVM_CALL_BASE_L2_GAS: u32 = 45 + (2 * L2_GAS_PER_NULLIFIER_READ_REQUEST);
global AVM_STATICCALL_BASE_L2_GAS: u32 = 45 + (2 * L2_GAS_PER_NULLIFIER_READ_REQUEST);
global AVM_RETURN_BASE_L2_GAS: u32 = 28;
global AVM_REVERT_BASE_L2_GAS: u32 = 28;
global AVM_DEBUGLOG_BASE_L2_GAS: u32 = 12; // Must be equal to AVM_JUMP_BASE_L2_GAS as long as circuit implements debugLog as a jump
global AVM_POSEIDON2_BASE_L2_GAS: u32 = 78;
global AVM_SHA256COMPRESSION_BASE_L2_GAS: u32 = 261;
global AVM_KECCAKF1600_BASE_L2_GAS: u32 = 300;
global AVM_ECADD_BASE_L2_GAS: u32 = 62;
global AVM_MSM_BASE_L2_GAS: u32 = 1000;
global AVM_TORADIXLE_BASE_L2_GAS: u32 = 46;

// Dynamic L2 GAS
global AVM_CALLDATACOPY_DYN_L2_GAS: u32 = 6;
// a single increment here corresponds to an entire additional field (hence x32 bytes per field)
global AVM_EMITUNENCRYPTEDLOG_DYN_L2_GAS: u32 = 18 + (DA_BYTES_PER_FIELD * L2_GAS_PER_LOG_BYTE);
global AVM_CALL_DYN_L2_GAS: u32 = 4;
global AVM_STATICCALL_DYN_L2_GAS: u32 = 4;
global AVM_RETURN_DYN_L2_GAS: u32 = 6;
global AVM_REVERT_DYN_L2_GAS: u32 = 6;
global AVM_MSM_DYN_L2_GAS: u32 = 100;
global AVM_TORADIXLE_DYN_L2_GAS: u32 = 20;

// Base DA Gas
global AVM_SSTORE_BASE_DA_GAS: u32 = DA_BYTES_PER_FIELD * DA_GAS_PER_BYTE;
global AVM_EMITNOTEHASH_BASE_DA_GAS: u32 = DA_BYTES_PER_FIELD * DA_GAS_PER_BYTE;
global AVM_EMITNULLIFIER_BASE_DA_GAS: u32 = DA_BYTES_PER_FIELD * DA_GAS_PER_BYTE;
global AVM_SENDL2TOL1MSG_BASE_DA_GAS: u32 = DA_BYTES_PER_FIELD * DA_GAS_PER_BYTE;

// Dynamic DA Gas
// a single increment here corresponds to an entire additional field (hence x32 bytes per field)
global AVM_EMITUNENCRYPTEDLOG_DYN_DA_GAS: u32 = DA_BYTES_PER_FIELD * DA_GAS_PER_BYTE;

// Constants related to proof type of a recursive proof verification.
// Keep following constants in sync with the enum acir_format::PROOF_TYPE in recursion_constraint.hpp
global PROOF_TYPE_PLONK: u32 = 0;
global PROOF_TYPE_HONK: u32 = 1;
global PROOF_TYPE_OINK: u32 = 2;
global PROOF_TYPE_PG: u32 = 3;
global PROOF_TYPE_AVM: u32 = 4;
