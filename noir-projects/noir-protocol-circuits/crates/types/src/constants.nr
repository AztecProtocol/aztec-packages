global ARGS_LENGTH: u32 = 16;

/**
 * Convention for constant array lengths are mainly divided in 2 classes:
 *  - FUNCTION CALL
 *  - TRANSACTION
 *
 * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as
 * commitment, or nullifier, e.g.,:
 *  - MAX_NULLIFIERS_PER_CALL
 *  - MAX_NOTE_HASHES_PER_TX
 *
 * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a
 * transaction. Therefore, we always must have:
 * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL
 *
 * For instance:
 * MAX_NOTE_HASHES_PER_TX ≥ MAX_NOTE_HASHES_PER_CALL
 * MAX_NULLIFIERS_PER_TX ≥ MAX_NULLIFIERS_PER_CALL
 *
 */

// docs:start:constants
// "PER CALL" CONSTANTS
global MAX_NOTE_HASHES_PER_CALL: u32 = 16;
global MAX_NULLIFIERS_PER_CALL: u32 = 16;
global MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u32 = 4;
global MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u32 = 16;
global MAX_L2_TO_L1_MSGS_PER_CALL: u32 = 2;
global MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u32 = 32;
global MAX_PUBLIC_DATA_READS_PER_CALL: u32 = 32;
global MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u32 = 16;
global MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u32 = 16;
global MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL: u32 = 16;
global MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL: u32 = 16;
global MAX_KEY_VALIDATION_REQUESTS_PER_CALL: u32 = 16;
global MAX_NOTE_ENCRYPTED_LOGS_PER_CALL: u32 = 16;
global MAX_ENCRYPTED_LOGS_PER_CALL: u32 = 4; // If modifying, update DEPLOYER_CONTRACT_ADDRESS.
global MAX_UNENCRYPTED_LOGS_PER_CALL: u32 = 4; // If modifying, update DEPLOYER_CONTRACT_ADDRESS.

// "PER TRANSACTION" CONSTANTS
global MAX_NOTE_HASHES_PER_TX: u32 = 64;
global MAX_NULLIFIERS_PER_TX: u32 = 64;
global MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u32 = 8;
global MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u32 = 32;
// If you touch any of the constants below don't forget to update MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX.
global MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u32 = 63;
global PROTOCOL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u32 = 1;
// We cannot do constant propagation below and instead we have to hardcode the value because the generated code in TS
// would then result in the type of the constant be a number and not a literal type. This would mess up the types.
// Pain.
global MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u32 = 64; // MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX + PROTOCOL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX;
global MAX_PUBLIC_DATA_READS_PER_TX: u32 = 64;
global MAX_L2_TO_L1_MSGS_PER_TX: u32 = 8;
global MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u32 = 64;
global MAX_NULLIFIER_READ_REQUESTS_PER_TX: u32 = 64;
global MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX: u32 = 64;
global MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_TX: u32 = 64;
// TODO: for large multisends we might run out of key validation requests here but not dealing with this now as
// databus will hopefully make the issue go away.
global MAX_KEY_VALIDATION_REQUESTS_PER_TX: u32 = 64;
global MAX_NOTE_ENCRYPTED_LOGS_PER_TX: u32 = 64;
global MAX_ENCRYPTED_LOGS_PER_TX: u32 = 8;
global MAX_UNENCRYPTED_LOGS_PER_TX: u32 = 8;
// docs:end:constants

// KERNEL CIRCUIT PRIVATE INPUTS CONSTANTS
// global MAX_PUBLIC_DATA_HINTS: u32 = MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX + MAX_PUBLIC_DATA_READS_PER_TX;
// FIX: Sadly, writing this as above causes a type error in type_conversion.ts.
global MAX_PUBLIC_DATA_HINTS: u32 = 128;

// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts
global NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u32 = 16;

// TREES RELATED CONSTANTS
global VK_TREE_HEIGHT: u32 = 5;
global FUNCTION_TREE_HEIGHT: u32 = 5;
global NOTE_HASH_TREE_HEIGHT: u32 = 32;
global PUBLIC_DATA_TREE_HEIGHT: u32 = 40;
global NULLIFIER_TREE_HEIGHT: u32 = 20;
global L1_TO_L2_MSG_TREE_HEIGHT: u32 = 16;
global ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;
global NULLIFIER_TREE_ID = 0;
global NOTE_HASH_TREE_ID = 1;
global PUBLIC_DATA_TREE_ID = 2;
global L1_TO_L2_MESSAGE_TREE_ID = 3;
global ARCHIVE_TREE_ID = 4;

// SUB-TREES RELATED CONSTANTS
global NOTE_HASH_SUBTREE_HEIGHT: u32 = 6;
global NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u32 = 26;
global NULLIFIER_SUBTREE_HEIGHT: u32 = 6;
global PUBLIC_DATA_SUBTREE_HEIGHT: u32 = 6;
global ARCHIVE_HEIGHT: u32 = 16;
global NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u32 = 14;
global PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u32 = 34;
global L1_TO_L2_MSG_SUBTREE_HEIGHT: u32 = 4;
global L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u32 = 12;

// VK TREE CONSTANTS
global PRIVATE_KERNEL_INIT_INDEX: u32 = 0;
global PRIVATE_KERNEL_INNER_INDEX: u32 = 1;
global PRIVATE_KERNEL_RESET_FULL_INDEX: u32 = 2;
global PRIVATE_KERNEL_RESET_BIG_INDEX: u32 = 3;
global PRIVATE_KERNEL_RESET_MEDIUM_INDEX: u32 = 4;
global PRIVATE_KERNEL_RESET_SMALL_INDEX: u32 = 5;
global PRIVATE_KERNEL_TAIL_INDEX: u32 = 10;
global PRIVATE_KERNEL_TAIL_TO_PUBLIC_INDEX: u32 = 11;
global EMPTY_NESTED_INDEX: u32 = 12;
global PRIVATE_KERNEL_EMPTY_INDEX: u32 = 13;
global PUBLIC_KERNEL_SETUP_INDEX: u32 = 14;
global PUBLIC_KERNEL_APP_LOGIC_INDEX: u32 = 15;
global PUBLIC_KERNEL_TEARDOWN_INDEX: u32 = 16;
global PUBLIC_KERNEL_TAIL_INDEX: u32 = 17;
global BASE_PARITY_INDEX: u32 = 18;
global ROOT_PARITY_INDEX: u32 = 19;
global BASE_ROLLUP_INDEX: u32 = 20;
global MERGE_ROLLUP_INDEX: u32 = 21;
global ROOT_ROLLUP_INDEX: u32 = 22;

// MISC CONSTANTS
global FUNCTION_SELECTOR_NUM_BYTES: Field = 4;
global ARGS_HASH_CHUNK_LENGTH: u32 = 16;
global ARGS_HASH_CHUNK_COUNT: u32 = 16;
global MAX_ARGS_LENGTH: u32 = ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH;
// The following is used in immutable state variables to compute an initialization slot whose value is used to
// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).
// The initialization slot is computed by adding the constant below to the variable's storage slot. This constant has
// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.
global INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;
global INITIAL_L2_BLOCK_NUM: Field = 1;
global BLOB_SIZE_IN_BYTES: Field = 31 * 4096;

// CONTRACT CLASS CONSTANTS
global MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u32 = 20000;
// Bytecode size for private functions is per function, not for the entire contract.
// Note that private functions bytecode includes a mix of acir and brillig.
global MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u32 = 3000;
// Same for unconstrained functions: the size is per function.
global MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u32 = 3000;
// How many fields are on the serialized ClassPrivateFunctionBroadcasted event in addition to MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS.
global REGISTERER_PRIVATE_FUNCTION_BROADCASTED_ADDITIONAL_FIELDS: u32 = 19;
// How many fields are on the serialized ClassUnconstrainedFunctionBroadcasted event in addition to MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS.
global REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_ADDITIONAL_FIELDS: u32 = 12;
// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.
// This is just a stopgap until we implement proper selectors.
// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'
global REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;
// sha224sum 'struct ClassPrivateFunctionBroadcasted'
global REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;
// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'
global REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;

// CONTRACT INSTANCE CONSTANTS
// sha224sum 'struct ContractInstanceDeployed'
global DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;

// GAS DEFAULTS
global DEFAULT_GAS_LIMIT: u32 = 1_000_000_000;
global DEFAULT_TEARDOWN_GAS_LIMIT: u32 = 100_000_000;
global DEFAULT_MAX_FEE_PER_GAS: Field = 10;
global DEFAULT_INCLUSION_FEE: Field = 0;
global DA_BYTES_PER_FIELD: u32 = 32;
global DA_GAS_PER_BYTE: u32 = 16;
// pays for preamble information in TX Effects
global FIXED_DA_GAS: u32 = 512;
// pays for fixed tx costs like validation, and updating state roots
global FIXED_L2_GAS: u32 = 512;
// base cost for a single public call
global FIXED_AVM_STARTUP_L2_GAS = 1024;
// pays for hashing/validating logs
global L2_GAS_PER_LOG_BYTE = 4;
// pays for tree insertions. 
global L2_GAS_PER_NOTE_HASH = 32;
// nullifiers are more expensive to insert/validate:
// they are inserted into an indexed tree and must be checked for duplicates 
global L2_GAS_PER_NULLIFIER = 64;

// CANONICAL CONTRACT ADDRESSES
global CANONICAL_KEY_REGISTRY_ADDRESS = 0x04c2d010f88e8c238882fbbcbce5c81fdc1dc8ece85e8dbf3f602b4d81ec0351;
global CANONICAL_AUTH_REGISTRY_ADDRESS = 0x27ffa4fb3da8a80b6365315f9798c887474854c71c0720e1c5236861288ce147;
global DEPLOYER_CONTRACT_ADDRESS = 0x2b231c13768709b1ba51c1f86275b47e38dfac16e3d7f242cb578d92a4e2d934;
global REGISTERER_CONTRACT_ADDRESS = 0x1da1c95bfa44d2d94cda61564e0b28a3515f0b2ad4bd8d30d86572f02e2fba00;
global GAS_TOKEN_ADDRESS = 0x06fc7badd50bb8ee32439b52e8874b5a16ddd2aa1d5647ec46b2a0f51356f889;

// LENGTH OF STRUCTS SERIALIZED TO FIELDS
global AZTEC_ADDRESS_LENGTH = 1;
global GAS_FEES_LENGTH: u32 = 2;
global GAS_LENGTH: u32 = 2;
global GAS_SETTINGS_LENGTH: u32 = GAS_LENGTH * 2 + GAS_FEES_LENGTH + /* inclusion_fee */ 1;
global CALL_CONTEXT_LENGTH: u32 = 5;
global CONTENT_COMMITMENT_LENGTH: u32 = 4;
global CONTRACT_INSTANCE_LENGTH: u32 = 5;
global CONTRACT_STORAGE_READ_LENGTH: u32 = 3;
global CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u32 = 3;
global ETH_ADDRESS_LENGTH = 1;
global FUNCTION_DATA_LENGTH: u32 = 2;
global FUNCTION_LEAF_PREIMAGE_LENGTH: u32 = 5;
global GLOBAL_VARIABLES_LENGTH: u32 = 6 + GAS_FEES_LENGTH;
global APPEND_ONLY_TREE_SNAPSHOT_LENGTH = 2;
global L1_TO_L2_MESSAGE_LENGTH: u32 = 6;
global L2_TO_L1_MESSAGE_LENGTH: u32 = 3;
global SCOPED_L2_TO_L1_MESSAGE_LENGTH = L2_TO_L1_MESSAGE_LENGTH + 1;
global MAX_BLOCK_NUMBER_LENGTH: u32 = 2; // 1 for the option flag, 1 for the value
global KEY_VALIDATION_REQUEST_LENGTH = 4;
global KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH = KEY_VALIDATION_REQUEST_LENGTH + 1;
global SCOPED_KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH = KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH + 1;
global PARTIAL_STATE_REFERENCE_LENGTH: u32 = 6;
global READ_REQUEST_LENGTH = 2;
global LOG_HASH_LENGTH = 3;
global SCOPED_LOG_HASH_LENGTH = LOG_HASH_LENGTH + 1;
global ENCRYPTED_LOG_HASH_LENGTH = 4;
global SCOPED_ENCRYPTED_LOG_HASH_LENGTH = ENCRYPTED_LOG_HASH_LENGTH + 1;
global NOTE_LOG_HASH_LENGTH = 4;
global NOTE_HASH_LENGTH = 2;
global SCOPED_NOTE_HASH_LENGTH = NOTE_HASH_LENGTH + 1;
global NULLIFIER_LENGTH = 3;
global SCOPED_NULLIFIER_LENGTH = NULLIFIER_LENGTH + 1;
global CALLER_CONTEXT_LENGTH = 2 * AZTEC_ADDRESS_LENGTH + 1;
global PRIVATE_CALL_REQUEST_LENGTH = AZTEC_ADDRESS_LENGTH + CALL_CONTEXT_LENGTH + FUNCTION_DATA_LENGTH + 4 + CALLER_CONTEXT_LENGTH;
global SCOPED_PRIVATE_CALL_REQUEST_LENGTH = PRIVATE_CALL_REQUEST_LENGTH + AZTEC_ADDRESS_LENGTH;
global ROLLUP_VALIDATION_REQUESTS_LENGTH = MAX_BLOCK_NUMBER_LENGTH;
global STATE_REFERENCE_LENGTH: u32 = APPEND_ONLY_TREE_SNAPSHOT_LENGTH + PARTIAL_STATE_REFERENCE_LENGTH;
global TX_CONTEXT_LENGTH: u32 = 2 + GAS_SETTINGS_LENGTH;
global TX_REQUEST_LENGTH: u32 = 2 + TX_CONTEXT_LENGTH + FUNCTION_DATA_LENGTH;
global TOTAL_FEES_LENGTH = 1;
global HEADER_LENGTH: u32 = APPEND_ONLY_TREE_SNAPSHOT_LENGTH + CONTENT_COMMITMENT_LENGTH + STATE_REFERENCE_LENGTH + GLOBAL_VARIABLES_LENGTH + TOTAL_FEES_LENGTH;
global PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u32 = CALL_CONTEXT_LENGTH + 4 + MAX_BLOCK_NUMBER_LENGTH + (READ_REQUEST_LENGTH * MAX_NOTE_HASH_READ_REQUESTS_PER_CALL) + (READ_REQUEST_LENGTH * MAX_NULLIFIER_READ_REQUESTS_PER_CALL) + (KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH * MAX_KEY_VALIDATION_REQUESTS_PER_CALL) + (NOTE_HASH_LENGTH * MAX_NOTE_HASHES_PER_CALL) + (NULLIFIER_LENGTH * MAX_NULLIFIERS_PER_CALL) + (PRIVATE_CALL_REQUEST_LENGTH * MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL) + MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL + 1 + (L2_TO_L1_MESSAGE_LENGTH * MAX_L2_TO_L1_MSGS_PER_CALL) + 2 + (NOTE_LOG_HASH_LENGTH * MAX_NOTE_ENCRYPTED_LOGS_PER_CALL) + (ENCRYPTED_LOG_HASH_LENGTH * MAX_ENCRYPTED_LOGS_PER_CALL) + (LOG_HASH_LENGTH * MAX_UNENCRYPTED_LOGS_PER_CALL) + HEADER_LENGTH + TX_CONTEXT_LENGTH;
global PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u32 = CALL_CONTEXT_LENGTH + /*argsHash + returnsHash*/ 2 + (READ_REQUEST_LENGTH * MAX_NOTE_HASH_READ_REQUESTS_PER_CALL) + (READ_REQUEST_LENGTH * MAX_NULLIFIER_READ_REQUESTS_PER_CALL) + (READ_REQUEST_LENGTH * MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL) + (READ_REQUEST_LENGTH * MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL) + (CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH * MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL) + (CONTRACT_STORAGE_READ_LENGTH * MAX_PUBLIC_DATA_READS_PER_CALL) + MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL + (NOTE_HASH_LENGTH * MAX_NOTE_HASHES_PER_CALL) + (NULLIFIER_LENGTH * MAX_NULLIFIERS_PER_CALL) + (L2_TO_L1_MESSAGE_LENGTH * MAX_L2_TO_L1_MSGS_PER_CALL) + 2 + (LOG_HASH_LENGTH * MAX_UNENCRYPTED_LOGS_PER_CALL) + HEADER_LENGTH + GLOBAL_VARIABLES_LENGTH + AZTEC_ADDRESS_LENGTH + /* revert_code */ 1 + 2 * GAS_LENGTH + /* transaction_fee */ 1;
global PRIVATE_CALL_STACK_ITEM_LENGTH: u32 = AZTEC_ADDRESS_LENGTH + FUNCTION_DATA_LENGTH + PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH;
global PUBLIC_CONTEXT_INPUTS_LENGTH: u32 = CALL_CONTEXT_LENGTH + HEADER_LENGTH + GLOBAL_VARIABLES_LENGTH + GAS_LENGTH + 2;

global AGGREGATION_OBJECT_LENGTH: u32 = 16;

global SCOPED_READ_REQUEST_LEN = READ_REQUEST_LENGTH + 1;
global PUBLIC_DATA_READ_LENGTH = 2;
global VALIDATION_REQUESTS_LENGTH = ROLLUP_VALIDATION_REQUESTS_LENGTH + (SCOPED_READ_REQUEST_LEN * MAX_NOTE_HASH_READ_REQUESTS_PER_TX) + (SCOPED_READ_REQUEST_LEN * MAX_NULLIFIER_READ_REQUESTS_PER_TX) + (SCOPED_READ_REQUEST_LEN * MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX) + (SCOPED_KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH * MAX_KEY_VALIDATION_REQUESTS_PER_TX) + (PUBLIC_DATA_READ_LENGTH * MAX_PUBLIC_DATA_READS_PER_TX);

global PUBLIC_DATA_UPDATE_REQUEST_LENGTH = 3;
global COMBINED_ACCUMULATED_DATA_LENGTH = MAX_NOTE_HASHES_PER_TX + MAX_NULLIFIERS_PER_TX + MAX_L2_TO_L1_MSGS_PER_TX + 6 + (MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * PUBLIC_DATA_UPDATE_REQUEST_LENGTH) + GAS_LENGTH;
global COMBINED_CONSTANT_DATA_LENGTH = HEADER_LENGTH + TX_CONTEXT_LENGTH + GLOBAL_VARIABLES_LENGTH + 1;

global PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH = AZTEC_ADDRESS_LENGTH + CALL_CONTEXT_LENGTH + FUNCTION_DATA_LENGTH + 3 + 2 * GAS_LENGTH;
global CALL_REQUEST_LENGTH = 1 + AZTEC_ADDRESS_LENGTH + CALLER_CONTEXT_LENGTH + 2;
global PRIVATE_ACCUMULATED_DATA_LENGTH = (SCOPED_NOTE_HASH_LENGTH * MAX_NOTE_HASHES_PER_TX) + (SCOPED_NULLIFIER_LENGTH * MAX_NULLIFIERS_PER_TX) + (MAX_L2_TO_L1_MSGS_PER_TX * SCOPED_L2_TO_L1_MESSAGE_LENGTH) + (NOTE_LOG_HASH_LENGTH * MAX_NOTE_ENCRYPTED_LOGS_PER_TX) + (SCOPED_ENCRYPTED_LOG_HASH_LENGTH * MAX_ENCRYPTED_LOGS_PER_TX) + (SCOPED_LOG_HASH_LENGTH * MAX_UNENCRYPTED_LOGS_PER_TX) + (SCOPED_PRIVATE_CALL_REQUEST_LENGTH * MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX) + (CALL_REQUEST_LENGTH * MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX);
global PRIVATE_KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH = 1 + VALIDATION_REQUESTS_LENGTH + PRIVATE_ACCUMULATED_DATA_LENGTH + COMBINED_CONSTANT_DATA_LENGTH + CALL_REQUEST_LENGTH + AZTEC_ADDRESS_LENGTH;

global PUBLIC_ACCUMULATED_DATA_LENGTH = (MAX_NOTE_HASHES_PER_TX * NOTE_HASH_LENGTH) + (MAX_NULLIFIERS_PER_TX * NULLIFIER_LENGTH) + (MAX_L2_TO_L1_MSGS_PER_TX * 1) + (MAX_NOTE_ENCRYPTED_LOGS_PER_TX * LOG_HASH_LENGTH) + (MAX_ENCRYPTED_LOGS_PER_TX * LOG_HASH_LENGTH) + (MAX_UNENCRYPTED_LOGS_PER_TX * LOG_HASH_LENGTH) + (MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * PUBLIC_DATA_UPDATE_REQUEST_LENGTH) + (MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX * CALL_REQUEST_LENGTH) + GAS_LENGTH;
global PUBLIC_KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH = VALIDATION_REQUESTS_LENGTH + PUBLIC_ACCUMULATED_DATA_LENGTH + PUBLIC_ACCUMULATED_DATA_LENGTH + COMBINED_CONSTANT_DATA_LENGTH + 1 + (MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX * CALL_REQUEST_LENGTH) + AZTEC_ADDRESS_LENGTH;

global KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH = ROLLUP_VALIDATION_REQUESTS_LENGTH + COMBINED_ACCUMULATED_DATA_LENGTH + COMBINED_CONSTANT_DATA_LENGTH + PARTIAL_STATE_REFERENCE_LENGTH + 1 + AZTEC_ADDRESS_LENGTH;

global CONSTANT_ROLLUP_DATA_LENGTH = APPEND_ONLY_TREE_SNAPSHOT_LENGTH + 1 + GLOBAL_VARIABLES_LENGTH;

// + 5 for rollup_type, height_in_block_tree, txs_effects_hash, out_hash, accumulated_fees
global BASE_OR_MERGE_PUBLIC_INPUTS_LENGTH = CONSTANT_ROLLUP_DATA_LENGTH + PARTIAL_STATE_REFERENCE_LENGTH + PARTIAL_STATE_REFERENCE_LENGTH + 5;

global ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH: u32 = 4 + CALL_CONTEXT_LENGTH;
global GET_NOTES_ORACLE_RETURN_LENGTH: u32 = 674;
global NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: u32 = 32 * MAX_NOTE_HASHES_PER_TX;
global NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: u32 = 32 * MAX_NULLIFIERS_PER_TX;
global PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: u32 = 64 * MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX; // 1 write is 64 bytes
global CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;
global CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;
global CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;
global L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 256;
global LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;
global NUM_MSGS_PER_BASE_PARITY: u32 = 4;
// global NUM_BASE_PARITY_PER_ROOT_PARITY: u32 = NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP / NUM_MSGS_PER_BASE_PARITY;
// FIX: Sadly, writing this as above causes a type error in type_conversion.ts.
global NUM_BASE_PARITY_PER_ROOT_PARITY: u32 = 4;

// Lengths of the different types of proofs in fields
global RECURSIVE_PROOF_LENGTH = 93;
global NESTED_RECURSIVE_PROOF_LENGTH = 109;

global VERIFICATION_KEY_LENGTH_IN_FIELDS = 114;

/**
 * Enumerate the hash_indices which are used for pedersen hashing.
 * We start from 1 to avoid the default generators. The generator indices are listed
 * based on the number of elements each index hashes. The following conditions must be met:
 *
 * +-----------+-------------------------------+----------------------+
 * | Hash size | Number of elements hashed (n) | Condition to use     |
 * |-----------+-------------------------------+----------------------|
 * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |
 * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |
 * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |
 * +-----------+-------------------------------+----------------------+
 */
// Indices with size ≤ 8
global GENERATOR_INDEX__NOTE_HASH = 1;
global GENERATOR_INDEX__NOTE_HASH_NONCE = 2;
global GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;
global GENERATOR_INDEX__SILOED_NOTE_HASH = 4;
global GENERATOR_INDEX__MESSAGE_NULLIFIER = 5;
global GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;
global GENERATOR_INDEX__OUTER_NULLIFIER = 7;
global GENERATOR_INDEX__PUBLIC_DATA_READ = 8;
global GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;
global GENERATOR_INDEX__FUNCTION_DATA = 10;
global GENERATOR_INDEX__FUNCTION_LEAF = 11;
global GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;
global GENERATOR_INDEX__CONSTRUCTOR = 13;
global GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;
global GENERATOR_INDEX__CONTRACT_ADDRESS_V1 = 15;
global GENERATOR_INDEX__CONTRACT_LEAF = 16;
global GENERATOR_INDEX__CALL_CONTEXT = 17;
global GENERATOR_INDEX__CALL_STACK_ITEM = 18;
global GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;
global GENERATOR_INDEX__SECRET_HASH = 20;
global GENERATOR_INDEX__L2_TO_L1_MSG = 21;
global GENERATOR_INDEX__TX_CONTEXT = 22;
global GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;
global GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;
global GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;
global GENERATOR_INDEX__GLOBAL_VARIABLES = 26;
global GENERATOR_INDEX__PARTIAL_ADDRESS = 27;
global GENERATOR_INDEX__BLOCK_HASH = 28;
global GENERATOR_INDEX__SIDE_EFFECT = 29;
global GENERATOR_INDEX__FEE_PAYLOAD = 30;
// Indices with size ≤ 16
global GENERATOR_INDEX__TX_REQUEST = 33;
global GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;
// Indices with size ≤ 44
global GENERATOR_INDEX__VK = 41;
global GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;
global GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;
// TODO: Function args generator index is being used to hash 64 items
global GENERATOR_INDEX__FUNCTION_ARGS = 44;
global GENERATOR_INDEX__AUTHWIT_INNER = 45;
global GENERATOR_INDEX__AUTHWIT_OUTER = 46;
global GENERATOR_INDEX__AUTHWIT_NULLIFIER = 47;
// Key related generators follow
global GENERATOR_INDEX__NSK_M = 48;
global GENERATOR_INDEX__IVSK_M = 49;
global GENERATOR_INDEX__OVSK_M = 50;
global GENERATOR_INDEX__TSK_M = 51;
global GENERATOR_INDEX__PUBLIC_KEYS_HASH = 52;
global GENERATOR_INDEX__NOTE_NULLIFIER = 53;
global GENERATOR_INDEX__INNER_NOTE_HASH = 54;
global GENERATOR_INDEX__NOTE_CONTENT_HASH = 55;
global GENERATOR_INDEX__SYMMETRIC_KEY: u8 = 56;

global SENDER_SELECTOR: u32 = 0;
// "address" actually does not exist in PublicCircuitPublicInputs,
// so this is just an alias to "storage address" for now
global ADDRESS_SELECTOR: u32 = SENDER_SELECTOR + 1;
global STORAGE_ADDRESS_SELECTOR: u32 = ADDRESS_SELECTOR;
global FUNCTION_SELECTOR_SELECTOR: u32 = ADDRESS_SELECTOR + 1;
// Global Variables
global START_GLOBAL_VARIABLES: u32 = CALL_CONTEXT_LENGTH + HEADER_LENGTH;
global CHAIN_ID_SELECTOR: u32 = START_GLOBAL_VARIABLES;
global VERSION_SELECTOR: u32 = CHAIN_ID_SELECTOR + 1;
global BLOCK_NUMBER_SELECTOR: u32 = VERSION_SELECTOR + 1;
global TIMESTAMP_SELECTOR: u32 = BLOCK_NUMBER_SELECTOR + 1;
global COINBASE_SELECTOR: u32 = TIMESTAMP_SELECTOR + 1;
global UNUSED_FEE_RECIPIENT_SELECTOR: u32 = COINBASE_SELECTOR + 1;
// Global Variables - fees
global FEE_PER_DA_GAS_SELECTOR: u32 = UNUSED_FEE_RECIPIENT_SELECTOR + 1;
global FEE_PER_L2_GAS_SELECTOR: u32 = FEE_PER_DA_GAS_SELECTOR + 1;
global END_GLOBAL_VARIABLES: u32 = START_GLOBAL_VARIABLES + GLOBAL_VARIABLES_LENGTH;
// Top-level members
global START_SIDE_EFFECT_COUNTER: u32 = END_GLOBAL_VARIABLES;
global TRANSACTION_FEE_SELECTOR: u32 = PUBLIC_CONTEXT_INPUTS_LENGTH - 1;
// Side effects
global START_NOTE_HASH_EXISTS_WRITE_OFFSET: u32 = 0;
global START_NULLIFIER_EXISTS_OFFSET: u32 = START_NOTE_HASH_EXISTS_WRITE_OFFSET + MAX_NOTE_HASH_READ_REQUESTS_PER_CALL;
global START_NULLIFIER_NON_EXISTS_OFFSET: u32 = START_NULLIFIER_EXISTS_OFFSET + MAX_NULLIFIER_READ_REQUESTS_PER_CALL;
global START_L1_TO_L2_MSG_EXISTS_WRITE_OFFSET: u32 = START_NULLIFIER_NON_EXISTS_OFFSET + MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL;
global START_SSTORE_WRITE_OFFSET: u32 = START_L1_TO_L2_MSG_EXISTS_WRITE_OFFSET + MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL;
global START_SLOAD_WRITE_OFFSET: u32 = START_SSTORE_WRITE_OFFSET + MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL;
global START_EMIT_NOTE_HASH_WRITE_OFFSET: u32 = START_SLOAD_WRITE_OFFSET + MAX_PUBLIC_DATA_READS_PER_CALL;
global START_EMIT_NULLIFIER_WRITE_OFFSET: u32 = START_EMIT_NOTE_HASH_WRITE_OFFSET + MAX_NOTE_HASHES_PER_CALL;
global START_EMIT_L2_TO_L1_MSG_WRITE_OFFSET: u32 = START_EMIT_NULLIFIER_WRITE_OFFSET + MAX_NULLIFIERS_PER_CALL;
global START_EMIT_UNENCRYPTED_LOG_WRITE_OFFSET: u32 = START_EMIT_L2_TO_L1_MSG_WRITE_OFFSET + MAX_L2_TO_L1_MSGS_PER_CALL;
