use std::{
    aes128::aes128_encrypt,
    embedded_curve_ops::{fixed_base_scalar_mul, multi_scalar_mul},
    field::bn254::decompose,
    hash::{from_field_unsafe as fr_to_fq_unsafe, sha256},
};

use dep::protocol_types::{
    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},
    hash::{poseidon2_hash, poseidon2_hash_with_separator},
    point::Point,
    scalar::Scalar,
};

use crate::{
    oracle::{
        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},
        random::random,
    },
    utils::{bytes::be_bytes_31_to_fields, point::point_to_bytes},
};

fn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(
    shared_secret: Point,
) -> [u8; 32] {
    let rand1: Field = poseidon2_hash_with_separator(
        [shared_secret.x, shared_secret.y],
        GENERATOR_INDEX__SYMMETRIC_KEY,
    );
    let rand2: Field = poseidon2_hash_with_separator(
        [shared_secret.x, shared_secret.y],
        GENERATOR_INDEX__SYMMETRIC_KEY_2,
    );
    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();
    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();
    let mut bytes: [u8; 32] = [0; 32];
    for i in 0..16 {
        bytes[i] = rand1_bytes[i];
        bytes[i + 1] = rand2_bytes[i];
    }
    bytes
}

fn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(
    shared_secret: Point,
) -> [u8; 32] {
    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);

    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();
    for i in 0..shared_secret_bytes.len() {
        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];
    }
    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;

    sha256(shared_secret_bytes_with_separator)
}

fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(
    shared_secret: Point,
    randomness_extraction_fn: fn(Point) -> [u8; 32],
) -> ([u8; 16], [u8; 16]) {
    let random_256_bits = randomness_extraction_fn(shared_secret);
    let mut sym_key = [0; 16];
    let mut iv = [0; 16];
    for i in 0..16 {
        sym_key[i] = random_256_bits[i];
        iv[i] = random_256_bits[i + 16];
    }
    (sym_key, iv)
}

pub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(
    shared_secret: Point,
) -> ([u8; 16], [u8; 16]) {
    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(
        shared_secret,
        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,
    )
}

pub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(
    shared_secret: Point,
) -> ([u8; 16], [u8; 16]) {
    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(
        shared_secret,
        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,
    )
}

fn fields_to_buffer<let N: u32>(fields: [Field; N]) -> [u8; N * 32] {
    let mut buffer: [u8; N * 32] = [0; N * 32];
    for i in 0..N {
        let bytes: [u8; 32] = fields[i].to_le_bytes();
        for j in 0..32 {
            buffer[i * 32 + j] = bytes[j];
        }
    }
    buffer
}

fn plaintexts_to_padded_buffer<let N: u32>(
    plaintext: [Field; N],
    extra_plaintext_bytes: [u8; 15],
) -> [u8; N * 32 + 16] {
    let plaintext_bytes = fields_to_buffer(plaintext);
    let mut buffer: [u8; N * 32 + 16] = [0; N * 32 + 16];
    for i in 0..N * 32 {
        buffer[i] = plaintext_bytes[i];
    }
    for i in 0..15 {
        let j = N * 32 + i;
        buffer[j] = extra_plaintext_bytes[i];
    }
    // One byte of AES padding for the final element:
    buffer[N * 32 + 16 - 1] = 0;
    buffer
}

/*
 * An input Field is 254-bits. Here, we convert each Field to 32-bytes (wasting 2 bits of "empty space" for each input Field):
 *
 * Input: [Field; N]
 * Input as bytes: [[u8; 32]; N] // N * 2-bits  = 2N bits of wastage.
 * Input padded, according to AES conventions: ([[u8; 32]; N], [u8; 16]) ~= [u8; N * 32 + 16]
 *
 * Output as bytes: [u8; N * 32 + 16] ~=  ([[u8; 32]; N], [u8; 16]) // All bits are important ciphertext data.
 *
 * These output bytes don't have any empty space. All 256-bits of each 32-byte output is important information that we need to retain. So when we convert back to Fields, all those new nonzero "2-bit" values that were generated by AES cause the output to expand to be larger than the input. Since we work with bytes for convenience, we actually convert each of the extra 2-bits to a byte. If you don't like that, we could go further and work with bits.
 *
 * Output coarsely converted to fit in fields: ([[u8; 32]; N], [u8; 16]) -> ([[u8; 31]; N], [u8; N], [u8; 16])
 *
 * where the 2nd element of the tuple is all of the "top bytes" of the `[[u8; 32]; N]`.
 *
 * If N <= 31, then that 2nd item in the tuple -- the [u8; N] -- fits nicely within a Field, but the [u8; 16] will spill into another Field.
 * If N <= 15, then the 2nd & 3rd items combined fit nicely within a Field.
 *
 * If N <= 15:
 *     Output as Fields: [Field; N + 1]
 * If N <= 31:
 *     Output as Fields: [Field; N + 2]
 *
 *******
 *
 * Since we padded the input with an entire [u8; 16], we could put that to better use.
 * We could use 15 of those 16 bytes, without causing extra padding to be added.
 * So perhaps the input to the function shouldn't just be [Field; N], it should be ([Field; N], [u8; 15]),
 * with output [Field; N + 1], provided N <= 15.
 *
 *******
 *
 * But you might argue that the above annoying padding of [u8; 16] arose because we were lazily converting inputs of type [Field; N]
 * to type [[u8; 32], N], wasting 2 bits of space. Indeed, for N >= 4, we would have wasted at least a whole byte. Let's explore what
 * would happen if we dealt with bits instead:
 *
 * Input: [Field; N]
 * Input as bits: [[u1; 254]; N]
 *
 * Pack it, in a constraint-efficient way (so that we only need to bit-decompose the "top" byte of each input Field):
 * Express each [u1; 254] as ([u8; 31], [u1; 6])
 * Then we can express [[u1; 254]; N] as ([[u8; 31]; N], [[u1; 6]; N]), or rather ([u8; N * 31], [u1; N * 6]).
 * We can convert the [u1; N * 6] into bytes as [u8; ceil(N * 6 / 8)]
 * In all, we have ([u8; N * 31], [u8; ceil(N * 6 / 8)]), which we can concatenate as [u8; N * 31 + ceil(N * 6 / 8)]
 *
 * Notice (with some effort): for 4 <= N <= 67, we need floor(N / 4) bytes of padding, to create a multiple of 16 bytes.
 *
 * So the input, converted to an AES-padded input, would be:
 *
 * [u8; N * 31 + ceil(N * 6 / 8) + floor(N / 4)]
 *
 * for 4 <= N <= 67.
 *
 * Notice:
 *     ceil(N * 6 / 8) + floor(N / 4) = N
 *
 * So the input, converted to an AES-padded input, would actually be:
 *
 * [u8; N * 32]
 *
 * Output as bytes: [u8; N * 32]
 * Output coarsely converted to fit in fields: ([[u8; 31]; N], [u8; N])
 * Output as fields: [Field; N + 1], if N <= 31.
 *
 ********
 *
 * So what are our options?
 *
 * [Field; N] -> [Field; N + 1] // N <= 15
 * [Field; N] -> [Field; N + 2] // 15 < N <= 31
 * ([Field; N]; [u8; 15]) -> [Field; N + 1] // N <= 15
 * [Field; N] -> [Field; N + 1] // 4 < N <= 31
 *
 * Logs on the whole network should ideally all be the same size, so N > 15 seems too extreme, so perhaps the added complexity of the final "bit decomposition" approach, is too much. Let's go with the 3rd option, where the interface is strange, but it yields an output of [Field; N + 1].
 *
 *********
 *
 * Summary:
 *
 * Input: ([Field; N], [u8; 15])
 * Input as bytes: ([[u8; 32]; N], [u8; 15])
 * Input padded, according to AES conventions: ([[u8; 32]; N], [u8; 15], [u8; 1]) ~= [u8; N * 32 + 16]
 *
 * Output as bytes:
 * [u8; N * 32 + 16] ->
 * 1.    ([u8; 31], [u8])
 * 2.    ([u8; 31], [u8])
 *     ...
 * N.    ([u8; 31], [u8])
 *       [u8; 16]
 *
 * Convert each of those [u8; 31]'s into the first N output fields.
 * Collect those N "top" bytes into the N first positions of the (N+1)st output field.
 * Push that final [u8; 16] to the Nth position of that (N+1)st field.
 *
 */
pub fn aes_encrypt_fields<let N: u32>(
    plaintext: [Field; N],
    extra_plaintext_bytes: [u8; 15],
    shared_secret: Point,
) -> [Field; N + 1] {
    std::static_assert(N <= 15, "Plaintext input to AES should be <= 15 bytes");

    let mut plaintext_bytes: [u8; N * 32 + 16] =
        plaintexts_to_padded_buffer(plaintext, extra_plaintext_bytes);

    let (sym_key, iv) =
        derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(shared_secret);

    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);

    assert(ciphertext_bytes.len() == N * 32 + 16); // For testing; not needed in prod.

    let mut output_fields: [Field; N + 1] = [0; N + 1];
    let mut final_output_field_bytes: [u8; N + 16] = [0; N + 16];

    for i in 0..N {
        let mut bytes_31: [u8; 31] = [0; 31];
        for j in 0..31 {
            bytes_31[i] = ciphertext_bytes[i * 32 + j];
        }

        output_fields[i] = Field::from_le_bytes::<31>(bytes_31);

        // Push the "top" byte to the final output field:
        final_output_field_bytes[i] = ciphertext_bytes[i * 32 + 32];
    }
    // By this point, the first N bytes of `final_output_field_bytes` have been
    // populated with the N "top" bytes of the first N fields.
    // We have 16 bytes left to allocate. We allocate them from index N of the
    // `final_output_field_bytes`.
    for i in 0..N {
        final_output_field_bytes[N + i] = ciphertext_bytes[N * 32 + N + i];
    }

    output_fields[N] = Field::from_le_bytes::<N + 16>(final_output_field_bytes);

    output_fields
}
