use crate::note::note_metadata::NoteMetadata;
use protocol_types::{
    address::AztecAddress,
    traits::{FromField, Packable, Serialize, ToField},
    utils::arrays,
};

// Number of fields a RetrievedNote adds to the packed or serialized representation of a note
// +1 for the contract address
// +2 for the note metadata
pub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;

/// A container of a note and the metadata required to prove its existence, regardless of whether the note is
/// pending (created in the current transaction) or settled (created in a previous transaction).
#[derive(Eq)]
pub struct RetrievedNote<NOTE> {
    pub note: NOTE,
    pub contract_address: AztecAddress,
    pub metadata: NoteMetadata,
}

impl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>
where
    NOTE: Serialize<N>,
{
    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {
        arrays::array_concat(
            arrays::array_concat(self.note.serialize(), [self.contract_address.to_field()]),
            self.metadata.serialize(),
        )
    }
}

impl<NOTE, let N: u32> Packable<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>
where
    NOTE: Packable<N>,
{
    fn pack(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {
        let packed_note = self.note.pack();
        arrays::array_concat(
            arrays::array_concat(packed_note, [self.contract_address.to_field()]),
            self.metadata.serialize(),
        )
    }

    fn unpack(packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD]) -> Self {
        let contract_address = AztecAddress::from_field(packed_retrieved_note[N]);
        let nonce = packed_retrieved_note[N + 1];
        let nonzero_note_hash_counter = packed_retrieved_note[N + 2] as bool;

        let packed_note = arrays::subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);
        let note = NOTE::unpack(packed_note);

        RetrievedNote {
            note,
            contract_address,
            metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),
        }
    }
}
