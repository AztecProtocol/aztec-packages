use crate::context::PrivateContext;
use dep::protocol_types::traits::Empty;

// Autogenerated by the #[note] macro
// docs:start:note_interfaces
pub trait NoteType {
    /// Returns the unique identifier for the note type. This is typically used when processing note logs.
    fn get_id() -> Field;
}

pub trait NoteHash {
    /// Returns the non-siloed note hash, i.e. the inner hash computed by the contract during private execution. Note
    /// hashes are later siloed by contract address and hashed with note nonce by the kernels before being committed to
    /// the state tree.
    ///
    /// This should be a commitment to the packed note, including the storage slot (for indexing) and some random
    /// value (to prevent brute force trial-hashing attacks).
    fn compute_note_hash(self, storage_slot: Field) -> Field;

    /// Returns the non-siloed nullifier (also called inner-nullifier), which will be later siloed by contract address
    /// by the kernels before being committed to the state tree.
    ///
    /// This function MUST be called with the correct note hash for consumption! It will otherwise silently fail and
    /// compute an incorrect value. The reason why we receive this as an argument instead of computing it ourselves
    /// directly is because the caller will typically already have computed this note hash, and we can reuse that value
    /// to reduce the total gate count of the circuit.
    ///
    /// This function receives the context since nullifier computation typically involves proving nullifying keys, and
    /// we require the kernel's assistance to do this in order to prevent having to reveal private keys to application
    /// circuits.
    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field;

    /// Like `compute_nullifier`, except this variant is unconstrained: there are no guarantees on the returned value
    /// being correct. Because of that it doesn't need to take a context (since it won't perform any kernel key
    /// validation requests).
    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field;
}
// docs:end:note_interfaces

pub trait NoteProperties<T> {
    fn properties() -> T;
}

pub trait PartialNote<S, F>
where
    S: Empty,
    F: Empty,
{
    fn setup_payload() -> S;

    fn finalization_payload() -> F;
}
