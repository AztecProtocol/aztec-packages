use crate::context::PrivateContext;
use crate::note::note_header::NoteHeader;
use dep::protocol_types::traits::{Deserialize, Empty, Serialize};

pub trait NoteProperties<T> {
    fn properties() -> T;
}

pub trait PartialNote<S, F>
where
    S: Empty,
    F: Empty,
{
    fn setup_payload() -> S;

    fn finalization_payload() -> F;
}

pub trait NullifiableNote {
    // This function MUST be called with the correct note hash for consumption! It will otherwise silently fail and
    // compute an incorrect value.
    // The reason why we receive this as an argument instead of computing it ourselves directly is because the
    // caller will typically already have computed this note hash, and we can reuse that value to reduce the total
    // gate count of the circuit.
    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field;

    // Unlike compute_nullifier, this function does not take a note hash since it'll only be invoked in unconstrained
    // contexts, where there is no gate count.
    unconstrained fn compute_nullifier_without_context(self) -> Field;
}

// docs:start:note_interface
// Autogenerated by the #[note] macro

pub trait NoteInterface<let N: u32> {
    // Autogenerated by the #[note] macro
    fn serialize_content(self) -> [Field; N];

    // Autogenerated by the #[note] macro
    fn deserialize_content(fields: [Field; N]) -> Self;

    // Autogenerated by the #[note] macro
    fn get_header(self) -> NoteHeader;

    // Autogenerated by the #[note] macro
    fn set_header(&mut self, header: NoteHeader) -> ();

    // Autogenerated by the #[note] macro
    fn get_note_type_id() -> Field;

    // Autogenerated by the #[note] macro
    fn to_be_bytes(self, storage_slot: Field) -> [u8; N * 32 + 64];

    // Autogenerated by the #[note] macro
    fn compute_note_hash(self) -> Field;
}
// docs:end:note_interface
