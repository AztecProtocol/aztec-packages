use crate::context::PrivateContext;
use dep::protocol_types::address::AztecAddress;
use dep::protocol_types::traits::Empty;
pub trait NoteProperties<T> {
    fn properties() -> T;
}

pub trait PartialNote<S, F>
where
    S: Empty,
    F: Empty,
{
    fn setup_payload() -> S;

    fn finalization_payload() -> F;
}

pub trait NullifiableNote {
    /// Returns the non-siloed nullifier (also called inner-nullifier), which will be later siloed by contract address
    /// by the kernels before being committed to the state tree.
    ///
    /// This function MUST be called with the correct note hash for consumption! It will otherwise silently fail and
    /// compute an incorrect value. The reason why we receive this as an argument instead of computing it ourselves
    /// directly is because the caller will typically already have computed this note hash, and we can reuse that value
    /// to reduce the total gate count of the circuit.
    ///
    /// This function receives the context since nullifier computation typically involves proving nullifying keys, and
    /// we require the kernel's assistance to do this in order to prevent having to reveal private keys to application
    /// circuits.
    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field;

    /// Like `compute_nullifier`, this function also computes a note's nullifier, but there are some key differences.
    ///
    /// First and most importantly, this function is unconstrained: there are no guarantees on the returned value being
    /// correct. Because of that it doesn't need to take a context (since it won't perform any kernel key validation
    /// requests).
    ///
    /// Second, it always computes the nullifier for a **settled** note, i.e. a note that has been created in a previous
    /// transaction, which therefore has a nonce. This is typically fine, since this function will mostly be used in
    /// unconstrained execution contexts, which exist outside of any transaction and therefore have no concept of
    /// pending notes, only settled. This also causes this function to not need to take a note hash for nullification,
    /// since it will just compute the unique note hash internally using the provided nonce.
    unconstrained fn compute_nullifier_without_context(
        self,
        storage_slot: Field,
        contract_address: AztecAddress,
        note_nonce: Field,
    ) -> Field;
}

// docs:start:note_interface
// Autogenerated by the #[note] macro
pub trait NoteInterface {
    fn get_note_type_id() -> Field;

    /// Returns the non-siloed note hash, i.e. the inner hash computed by the contract during private execution. Note
    /// hashes are later siloed by contract address and nonce by the kernels before being committed to the state tree.
    ///
    /// This should be a commitment to the packed note, including the storage slot (for indexing) and some random
    /// value (to prevent brute force trial-hashing attacks).
    fn compute_note_hash(self, storage_slot: Field) -> Field;
}
// docs:end:note_interface
