use crate::context::PrivateContext;
use crate::note::note_header::NoteHeader;
use dep::protocol_types::point::Point;

// docs:start:note_interface
trait NoteInterface<let N: u32, let M: u32> {
    // This function MUST be called with the correct note hash for consumption! It will otherwise silently fail and
    // compute an incorrect value.
    // The reason why we receive this as an argument instead of computing it ourselves directly is because the
    // caller will typically already have computed this note hash, and we can reuse that value to reduce the total
    // gate count of the circuit.
    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field;

    // Unlike compute_nullifier, this function does not take a note hash since it'll only be invoked in unconstrained
    // contexts, where there is no gate count.
    fn compute_nullifier_without_context(self) -> Field;
    
    // Autogenerated by the #[aztec(note)] macro unless it is overridden by a custom implementation
    fn serialize_content(self) -> [Field; N];

    // Autogenerated by the #[aztec(note)] macro unless it is overridden by a custom implementation
    fn deserialize_content(fields: [Field; N]) -> Self;

    // Autogenerated by the #[aztec(note)] macro unless it is overridden by a custom implementation
    fn compute_note_hiding_point(self) -> Point;

    // Autogenerated by the #[aztec(note)] macro unless it is overridden by a custom implementation
    fn get_header(self) -> NoteHeader;

    // Autogenerated by the #[aztec(note)] macro unless it is overridden by a custom implementation
    fn set_header(&mut self, header: NoteHeader) -> ();

    // Autogenerated by the #[aztec(note)] macro unless it is overridden by a custom implementation
    fn get_note_type_id() -> Field;

    // Autogenerated by the #[aztec(note)] macro unless it is overridden by a custom implementation
    fn to_be_bytes(self, storage_slot: Field) -> [u8; M];
}
// docs:end:note_interface

