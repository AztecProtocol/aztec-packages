use crate::note::note_getter_options::PropertySelector;
use std::{collections::bounded_vec::BoundedVec, meta::type_of};

/// Maximum number of note types within 1 contract.
comptime global MAX_NOTE_TYPES: u32 = 128;

/// A BoundedVec containing all the note types within this contract.
pub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();

comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;

/// The note type id is set by enumerating the note types.
comptime fn get_next_note_type_id() -> Field {
    // We assert that the note type id fits within 7 bits
    assert(
        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,
        f"A contract can contain at most {MAX_NOTE_TYPES} different note types",
    );

    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;
    NOTE_TYPE_ID_COUNTER += 1;
    note_type_id
}

/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.
///
/// impl NoteType for NoteStruct {
///     fn get_id() -> Field {
///         ...
///     }
/// }
comptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {
    let name = s.name();
    let typ = s.as_type();

    // TODO: Insert note type name into the static assert message. Currently blocked by:
    // https://github.com/noir-lang/noir/issues/9274

    quote {
        impl aztec::note::note_interface::NoteType for $name {
            fn get_id() -> Field {
                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.
                // While this check would ideally live in the Packable trait implementation, we place it here since
                // this function is always generated by our macros and the Packable trait implementation is not.
                let max_packed_len = $crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;
                std::static_assert(<$typ as Packable>::N  <= max_packed_len, f"Note packed length exceeds the maximum of {max_packed_len} fields");
                $note_type_id
            }
        }
    }
}

/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.
///
/// # Generated Implementation
/// ```
/// impl NoteHash for NoteStruct {
///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }
///
///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }
///
///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }
/// }
/// ```
comptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {
    let name = s.name();

    quote {
        impl aztec::note::note_interface::NoteHash for $name {
            fn compute_note_hash(self, storage_slot: Field) -> Field {
                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);
                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)
            }

            fn compute_nullifier(
                self,
                context: &mut aztec::context::PrivateContext,
                note_hash_for_nullify: Field,
            ) -> Field {
                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;
                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly
                // in the quote to avoid "trait not in scope" compiler warnings.
                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);
                let secret = context.request_nsk_app(owner_npk_m_hash);
                aztec::protocol_types::hash::poseidon2_hash_with_separator(
                    [note_hash_for_nullify, secret],
                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,
                )
            }

            unconstrained fn compute_nullifier_unconstrained(
                self,
                note_hash_for_nullify: Field,
            ) -> Field {
                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;
                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly
                // in the quote to avoid "trait not in scope" compiler warnings.
                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);
                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);
                aztec::protocol_types::hash::poseidon2_hash_with_separator(
                    [note_hash_for_nullify, secret],
                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,
                )
            }
        }
    }
}

/// Generates note properties struct for a given note struct `s`.
///
/// Example:
/// ```
/// struct TokenNoteProperties {
///     amount: aztec::note::note_getter_options::PropertySelector,
///     npk_m_hash: aztec::note::note_getter_options::PropertySelector
///     randomness: aztec::note::note_getter_options::PropertySelector
/// }
///
/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {
///     fn properties() -> TokenNoteProperties {
///         Self {
///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },
///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },
///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }
///         }
///     }
/// }
/// ```
comptime fn generate_note_properties(s: TypeDefinition) -> Quoted {
    let name = s.name();

    let struct_name = f"{name}Properties".quoted_contents();

    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });

    let note_fields = s.fields_as_written();

    let properties_types = note_fields
        .map(|(name, _, _)| quote { pub $name: $property_selector_type })
        .join(quote {,});

    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694
    let mut properties_list = &[];
    for i in 0..note_fields.len() {
        let (name, _, _) = note_fields[i];
        properties_list = properties_list.push_back(
            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },
        );
    }

    let properties = properties_list.join(quote {,});

    quote {
        pub struct $struct_name {
            $properties_types
        }

        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {
            fn properties() -> $struct_name {
                $struct_name {
                    $properties
                }
            }
        }
    }
}

/// Generates the core note functionality for a struct:
///
/// - NoteTypeProperties: Defines the structure and properties of note fields
/// - NoteType trait implementation: Provides the note type ID
/// - NoteHash trait implementation: Handles note hash and nullifier computation
///
/// # Requirements
///
/// The note struct must:
/// - Have an `owner` field
/// - Implement the `Packable` trait
/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed
///
/// # Registration
///
/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.
///
/// # Generated Code
///
/// For detailed documentation on the generated implementations, see:
/// - `generate_note_properties()`
/// - `generate_note_type_impl()`
/// - `generate_note_hash_trait_impl()`
pub comptime fn note(s: TypeDefinition) -> Quoted {
    assert_has_owner(s);
    assert_has_packable(s);

    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro
    // to generate note processing functionality.
    NOTES.push(s.as_type());

    let note_properties = generate_note_properties(s);
    let note_type_id = get_next_note_type_id();
    let note_type_impl = generate_note_type_impl(s, note_type_id);
    let note_hash_impl = generate_note_hash_trait_impl(s);

    quote {
        $note_properties
        $note_type_impl
        $note_hash_impl
    }
}

/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.
///
/// # Generated Code
/// - NoteTypeProperties: Defines the structure and properties of note fields
/// - NoteType trait implementation: Provides the note type ID
///
/// # Requirements
///
/// The note struct must:
/// - Implement the `Packable` trait
/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed
///
/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.
///
/// # Registration
///
/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.
///
/// # Use Cases
/// Use this macro when implementing a note that needs custom:
/// - Note hash computation logic
/// - Nullifier computation logic
///
/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.
///
/// # Example
/// ```
/// #[custom_note]
/// struct CustomNote {
///     value: Field,
///     metadata: Field
/// }
///
/// impl NoteHash for CustomNote {
///     // Custom note hash computation...
///     fn compute_note_hash(...) -> Field { ... }
///
///     // Custom nullifier computation...
///     fn compute_nullifier(...) -> Field { ... }
///     fn compute_nullifier_unconstrained(...) -> Field { ... }
/// }
/// ```
pub comptime fn custom_note(s: TypeDefinition) -> Quoted {
    assert_has_packable(s);

    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro
    // to generate note processing functionality.
    NOTES.push(s.as_type());

    let note_type_id = get_next_note_type_id();
    let note_properties = generate_note_properties(s);
    let note_type_impl = generate_note_type_impl(s, note_type_id);

    quote {
        $note_properties
        $note_type_impl
    }
}

/// Asserts that the given note implements the `Packable` trait.
///
/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as
/// an offchain message.
comptime fn assert_has_packable(note: TypeDefinition) {
    let packable_constraint =
        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();
    assert(
        note.as_type().implements(packable_constraint),
        "Note must implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.",
    );
}

/// Asserts that the note has an 'owner' field.
///
/// We require notes implemented with #[note] macro macro to have an 'owner' field because our
/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.
comptime fn assert_has_owner(note: TypeDefinition) {
    let fields = note.fields_as_written();
    let mut has_owner = false;
    for i in 0..fields.len() {
        let (field_name, _, _) = fields[i];
        if field_name == quote { owner } {
            has_owner = true;
            break;
        }
    }
    assert(
        has_owner,
        "Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.",
    );
}
