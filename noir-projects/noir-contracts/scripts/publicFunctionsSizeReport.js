const path = require("path");
const fs = require("fs");
const fsp = require("fs").promises;

// Simple script to extract the exact bytecode size of a contracts public functions.
// The output of this script is meant to be used with the noir-lang/noir-gates-diff project.
// The noir-gates-diff was made for comparing ACIR/Brillig opcodes.
// However, this script was made to re-use the noir-gates-diff for bytecode sizes as
// to minimize both the amount of changes needed in noir-gates-diff and in nargo.
async function main() {

  let [targetDir] = process.argv.slice(2);
  if (!targetDir) {
    console.log(
      "Usage: node extractPublicFunctionsAsNoirArtifacts.js <targetDir>"
    );
    return;
  }

  let artifactPaths = [];
  fs.readdirSync(targetDir).forEach(file => {
    // We want to exclude any backups that may be generated by the avm-transpiler
    if (path.extname(file) === ".json") {
        artifactPaths.push(path.join(targetDir, file));
    }
  });

  let workspaceReport = {
    programs: []
  }
  for (var i = 0; i < artifactPaths.length; i++) {
    let contractArtifactPath = artifactPaths[i];
    const contractArtifact = JSON.parse(
        await fsp.readFile(contractArtifactPath, "utf8")
    );
    contractArtifact.functions.forEach(async func => {
        if (func.custom_attributes.includes("public")) {
            if (func.brillig_names.length != 1) {
                console.log(
                    "Expected only a single Brillig function"
                );
                return;
            }
            let func_with_contract_name = contractArtifact.name + "::" + func.brillig_names[0];
            let program_report = {
              package_name: "",
              functions: [],
              unconstrained_functions: [],
            }
            // Programs are compared by package name, so we make a unique one for each function here
            program_report.package_name = func_with_contract_name;
            let bytecode_bytes = Buffer.from(func.bytecode, 'base64');
            let func_report = {
              name: "main",
              opcodes: bytecode_bytes,
            };
            func_report.opcodes = bytecode_bytes.length;
            program_report.unconstrained_functions.push(func_report);
            workspaceReport.programs.push(program_report);
        }
    });
  }

  const outPath = path.join("public_functions_report.json");

  console.log(`Writing to ${outPath}`);
  await fsp.writeFile(outPath, JSON.stringify(workspaceReport, null, 2));
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
