use dep::aztec::prelude::{AztecAddress, FunctionSelector, PrivateContext, NoteHeader, NoteGetterOptions, NoteViewerOptions};

use dep::aztec::{
    protocol_types::{
    traits::{ToField, Serialize, FromField}, grumpkin_point::GrumpkinPoint,
    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL
},
    keys::getters::{get_npk_m_hash, get_ivpk_m}, note::note_getter::view_notes, state_vars::PrivateSet,
    note::constants::MAX_NOTES_PER_PAGE
};
use dep::std;
use dep::std::{option::Option};
use dep::value_note::{value_note::{ValueNote, VALUE_NOTE_LEN}};

struct Card {
    // We use u32s since u16s are unsupported
    strength: u32,
    points: u32,
}

impl FromField for Card {
 fn from_field(field: Field) -> Card {
        let value_bytes = field.to_le_bytes(32);
        let strength = (value_bytes[0] as u32) + (value_bytes[1] as u32) * 256;
        let points = (value_bytes[2] as u32) + (value_bytes[3] as u32) * 256;
        Card { strength, points }
    }
}

impl ToField for Card {
 fn to_field(self) -> Field {
        self.strength as Field + (self.points as Field)*65536
    }
}

impl Serialize<2> for Card {
    fn serialize(self) -> [Field; 2] {
        [self.strength as Field, self.points as Field]
    }
}

#[test]
fn test_to_from_field() {
    let field = 1234567890;
    let card = Card::from_field(field);
    assert(card.to_field() == field);
}

struct CardNote {
    card: Card,
    note: ValueNote,
}

impl CardNote {
    fn new(strength: u32, points: u32, npk_m_hash: Field) -> Self {
        let card = Card { strength, points };
        CardNote::from_card(card, npk_m_hash)
    }

    pub fn from_card(card: Card, npk_m_hash: Field) -> CardNote {
        CardNote { card, note: ValueNote::new(card.to_field(), npk_m_hash) }
    }

    pub fn from_note(note: ValueNote) -> CardNote {
        CardNote { card: Card::from_field(note.value), note }
    }
}

struct Deck<Context> {
    set: PrivateSet<ValueNote, Context>,
}

pub fn filter_cards<N>(
    notes: [Option<ValueNote>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],
    desired_cards: [Card; N]
) -> [Option<ValueNote>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {
    let mut selected = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];

    let mut found = [false; N];

    for i in 0..notes.len() {
        let note = notes[i];
        if note.is_some() {
            let card_note = CardNote::from_note(note.unwrap_unchecked());
            for j in 0..N {
                if !found[j]
                    & (card_note.card.strength == desired_cards[j].strength)
                    & (card_note.card.points == desired_cards[j].points) {
                    selected[i] = note;
                    found[j] = true;
                }
            }
        }
    }

    selected
}

impl<Context> Deck<Context> {
    pub fn new(context: Context, storage_slot: Field) -> Self {
        let set = PrivateSet { context, storage_slot };
        Deck { set }
    }
}

impl Deck<&mut PrivateContext> {
    pub fn add_cards<N>(&mut self, cards: [Card; N], owner: AztecAddress) -> [CardNote] {
        let owner_npk_m_hash = get_npk_m_hash(self.set.context, owner);
        let owner_ivpk_m = get_ivpk_m(self.set.context, owner);

        let mut inserted_cards = &[];
        for card in cards {
            let mut card_note = CardNote::from_card(card, owner_npk_m_hash);
            self.set.insert(&mut card_note.note, true, owner_ivpk_m);
            inserted_cards = inserted_cards.push_back(card_note);
        }

        inserted_cards
    }

    pub fn get_cards<N>(&mut self, cards: [Card; N], owner: AztecAddress) -> [CardNote; N] {
        let owner_npk_m_hash = get_npk_m_hash(self.set.context, owner);

        let options = NoteGetterOptions::with_filter(filter_cards, cards);
        let maybe_notes = self.set.get_notes(options);
        let mut found_cards = [Option::none(); N];
        for i in 0..maybe_notes.len() {
            if maybe_notes[i].is_some() {
                let card_note = CardNote::from_note(maybe_notes[i].unwrap_unchecked());
                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while
                // spending someone else's notes).
                // TODO (#6312): This will break with key rotation. Fix this. Will not be able to pass this assert after rotating keys.
                assert(card_note.note.npk_m_hash.eq(owner_npk_m_hash));

                for j in 0..cards.len() {
                    if found_cards[j].is_none()
                        & (cards[j].strength == card_note.card.strength)
                        & (cards[j].points == card_note.card.points) {
                        found_cards[j] = Option::some(card_note);
                    }
                }
            }
        }

        found_cards.map(
            |card_note: Option<CardNote>| {
            assert(card_note.is_some(), "Card not found");
            card_note.unwrap_unchecked()
        }
        )
    }

    pub fn remove_cards<N>(&mut self, cards: [Card; N], owner: AztecAddress) {
        let card_notes = self.get_cards(cards, owner);
        for card_note in card_notes {
            self.set.remove(card_note.note);
        }
    }
}

impl Deck<()> {
    unconstrained pub fn view_cards(self, offset: u32) -> [Option<Card>; MAX_NOTES_PER_PAGE] {
        let mut options = NoteViewerOptions::new();
        let opt_notes = self.set.view_notes(options.set_offset(offset));
        let mut opt_cards = [Option::none(); MAX_NOTES_PER_PAGE];

        for i in 0..opt_notes.len() {
            opt_cards[i] = opt_notes[i].map(|note: ValueNote| Card::from_field(note.value));
        }

        opt_cards
    }
}

global PACK_CARDS = 3; // Limited by number of write requests (max 4)

pub fn get_pack_cards(
    seed: Field,
    owner: AztecAddress,
    context: &mut PrivateContext
) -> [Card; PACK_CARDS] {
    let owner_npk_m_hash = get_npk_m_hash(context, owner);

    // generate pseudo randomness deterministically from 'seed' and user secret
    let secret = context.request_nsk_app(owner_npk_m_hash);
    let mix = secret + seed;
    let mix_bytes: [u8; 32] = mix.to_le_bytes(32).as_array();
    let random_bytes = std::hash::sha256(mix_bytes);

    let mut cards = [Card::from_field(0); PACK_CARDS];
    // we generate PACK_CARDS cards
    assert(PACK_CARDS < 8, "Cannot generate more than 8 cards");
    for i in 0..PACK_CARDS {
        let strength = (random_bytes[i] as u32) + (random_bytes[i + 1] as u32) * 256;
        let points = (random_bytes[i + 2] as u32) + (random_bytes[i + 3] as u32) * 256;
        cards[i] = Card {
            strength, points
        };
    }

    cards
}

pub fn compute_deck_strength<N>(cards: [Card; N]) -> Field {
    cards.fold(
        0,
        |acc, card: Card| {
        acc + card.strength as Field
    }
    )
}
