contract NewKeyRegistry {
    use dep::authwit::auth::assert_current_call_valid_authwit_public;

    use dep::aztec::{
        keys::{PublicKeys, stored_keys::StoredKeys}, state_vars::{PublicMutable, Map},
        protocol_types::{point::Point, address::{AztecAddress, PartialAddress}}
    };

    #[aztec(storage)]
    struct Storage {
        current_keys: Map<AztecAddress, PublicMutable<StoredKeys>>,
    }

    impl<Context> Storage<Context> {
        // The init function is typically automatically generated by the macros - here we implement it manually in order
        // to have control over which storage slot is assigned to the current_keys state variable.
        fn init(context: Context) -> Self {
            Storage {
                // Ideally we'd do KEY_REGISTRY_STORAGE_SLOT instead of hardcoding the 1 here, but that is currently
                // causing compilation errors.
                // TODO(#7829): fix this
                current_keys: Map::new(
                    context,
                    1,
                    |context, slot| { PublicMutable::new(context, slot) }
                )
            }
        }
    }

    unconstrained fn get_current_keys(account: AztecAddress) -> pub PublicKeys {
        // If #7524 were to be implemented, this function could be called by an oracle from an unconstrained function
        // in order to produce the preimage of the stored hash, and hence prove the correctness of the keys.
        storage.current_keys.at(account).read().public_keys
    }

    #[aztec(public)]
    fn register_initial_keys(account: AztecAddress, partial_address: PartialAddress, keys: PublicKeys) {
        let computed_address = AztecAddress::compute(keys.hash(), partial_address);
        assert(computed_address.eq(account), "Computed address does not match supplied address");

        storage.current_keys.at(account).write(StoredKeys::new(keys));
    }

    #[aztec(public)]
    fn rotate_npk_m(account: AztecAddress, new_npk_m: Point, nonce: Field) {
        if (!account.eq(context.msg_sender())) {
            assert_current_call_valid_authwit_public(&mut context, account);
        } else {
            assert(nonce == 0, "invalid nonce");
        }

        let account_key_storage = storage.current_keys.at(account);

        // We read all other current keys so that we can compute the new hash - we can't update just the npk. This means
        // updating all keys at once costs the same as updating just one (unless setting public storage to its current
        // value is cheaper than changing it, e.g. EIP-2200).
        let mut current_keys = account_key_storage.read().public_keys;
        current_keys.npk_m = new_npk_m;

        account_key_storage.write(StoredKeys::new(current_keys));
    }
}
