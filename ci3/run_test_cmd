#!/bin/bash
# Called by 'parallelise' to execute a given test cmd.
NO_CD=1 source $(git rev-parse --show-toplevel)/ci3/source
source $ci3/source_redis
source $ci3/source_refname

cmd=$1
# Remove the rebuild hash (first field) that is in front of the test command.
# Exported for use in yq.
export test_cmd="${cmd#* }"
key=$(hash_str_orig "$cmd")

if [ "${USE_TEST_CACHE:-0}" -eq 1 ] && [ "$CI_REDIS_AVAILABLE" -eq 1 ]; then
  log_key=$(redis_cli GET $key)
  if [ -n "$log_key" ]; then
    log_info=" (${yellow}http://ci.aztec-labs.com/$log_key${reset})"
    echo -e "${blue}SKIPPED${reset}${log_info:-}: $cmd"
    exit 0
  fi
fi

# If the test has a verbose mode, we want it enabled.
export VERBOSE=1

# Run the test, capturing output, with a timeout of 10m.
# We cannot use "output=$(timeout ...)" here as it stymies proper signal propagation.
# To ensure we can propagate SIGTERM to timeouts process group we use a temp file and forward the signal.
set +e
tmp_file=/tmp/$key

cat <<EOF >$tmp_file
Command: $cmd
Commit: https://github.com/AztecProtocol/aztec-packages/commit/$COMMIT_HASH
Env: REF_NAME=$REF_NAME CURRENT_VERSION=$CURRENT_VERSION CI_FULL=$CI_FULL
Date: $(date)

EOF

trap "rm -f $tmp_file" EXIT
if [[ "$test_cmd" = timeout* ]]; then
  bash -c "set -euo pipefail; $test_cmd 2>&1 | add_timestamps" &>> $tmp_file &
else
  timeout -v 600s bash -c "set -euo pipefail; $test_cmd 2>&1 | add_timestamps" &>> $tmp_file &
fi
timeout_pid=$!
trap "kill -- -$timeout_pid" SIGTERM SIGINT
wait $timeout_pid
code=$?

if [ "$CI_REDIS_AVAILABLE" -eq 1 ]; then
  log_key=$(uuid)

  if [ $code -eq 0 ]; then
    # Set success flag for test. This key is unique to the test.
    redis_cli SETEX $key 604800 $log_key &>/dev/null
  fi

  # Set the test log. This key is globally unique.
  cat $tmp_file | redis_setexz $log_key $CI_REDIS_EXPIRE
  log_info=" (${yellow}http://ci.aztec-labs.com/$log_key${reset})"
fi

if [ $code -eq 0 ]; then
  echo -e "${green}PASSED${reset}${log_info:-}: $test_cmd (${SECONDS}s)"
else
  # Send slack message to owners.
  owners=$(yq e -r '.tests[] | .regex as $pattern | select(strenv(test_cmd) | test($pattern)) | .owners[]' .test_patterns.yml | sort -u)

  # To not fail a test, we at least need an owner to notify.
  if [ -z "$owners" ]; then
    # No owner, fail.
    tag="${red}FAILED${reset}"
    exit_code=$code
  else
    # We will not fail a FLAKED test as we slack info to the owner.
    tag="${purple}FLAKED${reset}"

    slack_users=$(curl -s -X GET https://slack.com/api/users.list -H "Authorization: Bearer $SLACK_BOT_TOKEN")
    slack_uids=""
    for email in $owners; do
      uid=$(echo "$slack_users" | jq -r --arg email "$email" '.members[] | select(.profile.email == $email) | .id')
      [ -n "$uid" ] && slack_uids+="<@$uid> "
    done
    read -r -d '' data <<EOF
{
  "channel": "#aztec3-ci",
  "text": "${slack_uids}: Test flaked \`$test_cmd\` http://ci.aztec-labs.com/$log_key"
}
EOF
    curl -X POST https://slack.com/api/chat.postMessage \
      -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
      -H "Content-type: application/json" \
      --data "$data" &>/dev/null

    exit_code=0
  fi

  echo -e "${tag}${reset}${log_info:-}: $test_cmd (${SECONDS}s) (code: $code)"
  cat $tmp_file
  echo -e "${tag}${reset}${log_info:-}: $test_cmd (${SECONDS}s) (code: $code)"
fi

exit $exit_code
