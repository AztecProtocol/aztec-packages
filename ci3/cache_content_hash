#!/usr/bin/env bash
# Calculate the content hash for an artifact that controls rebuilds.
# Takes a list of rebuild pattern files (regex files that match patterns from repo root) or directories.
# Two special test-only environment variables can control the cache.
# These are used when iterating on build infrastructure:
# - AZTEC_CACHE_NO_SCRIPTS: Don't include any shell files (namely bootstrap.sh) in cache patterns.
# - AZTEC_CACHE_COMMIT: Compute the content hash for artifacts from an earlier commit.
NO_CD=1 source ${root:-$(git rev-parse --show-toplevel)}/ci3/source

if [[ "$#" = 0 ]]; then
  echo "Error: No arguments provided."
  exit 1
fi

AZTEC_CACHE_COMMIT=${AZTEC_CACHE_COMMIT:-HEAD}
PLATFORM_TAG="${PLATFORM_TAG:-${OSTYPE:-unknown}-$(uname -m)}"

rebuild_patterns=()
for arg in "$@"; do
  if [[ -f "$arg" ]]; then
    rebuild_patterns+=$(cat "$arg")
    rebuild_patterns+=$'\n'
  else
    rebuild_patterns+="$arg"$'\n'
  fi
done

SUB_REPOS=$(echo "$rebuild_patterns" | grep ".git")

# For sanity when iterating on build scripts as bootstrap.sh scripts are in every .rebuild_patterns.
if [ -n "${AZTEC_CACHE_NO_SCRIPTS:-}" ]; then
  rebuild_patterns=$(echo "$rebuild_patterns" | grep -v '.sh')
fi

# use git repo root because that is where our patterns are focused
cd "$(git rev-parse --show-toplevel)"

# Content hash accumulator
CONTENT_HASH_ACC=""

for repo in $(echo .git $SUB_REPOS); do
  repo_prefix=$(echo $repo | sed 's/.git//g' | sed 's/\^//g')
  # Find all patterns that start with the prefix and trim it from the pattern.
  if [ ! -z "$repo_prefix" ]; then
    d=$'\03' # using some control character to not clash with / in path
    repo_rebuild_patterns=$(echo "$rebuild_patterns" | grep "$repo_prefix" | sed "s${d}$repo_prefix${d}${d}")
    git_ctx="-C $repo_prefix"
    git_commit="HEAD"
  else
    repo_rebuild_patterns="$rebuild_patterns"
    git_ctx=""
    git_commit=$AZTEC_CACHE_COMMIT
  fi
  repo_rebuild_patterns=$(echo "$repo_rebuild_patterns" | grep -v ".git" | grep -v '^$')

  GREP_PATTERN=$(echo "$repo_rebuild_patterns")
  # Concatenate patterns with '|' and double escape backslashes for AWK filter empty lines
  AWK_PATTERN=$(echo "$repo_rebuild_patterns" | sed 's/\\/\\\\/g' | tr '\n' '|' | sed 's/|$//')

  diff="$({
    git $git_ctx diff --name-only
    git $git_ctx diff --staged --name-only
    git $git_ctx ls-files --others --exclude-standard
  } | grep -E "$GREP_PATTERN" || true)"

  # Check for uncommitted files/changes
  if [ -n "$diff" ]; then
    # Fail. We shouldn't be writing files during the build.
    if [ "${CI:-0}" = 1 ]; then
      echo_stderr "WARNING: Noticed changes to rebuild patterns: $diff"
    fi
    # Signal to cache_upload and cache_download to not touch this file.
    echo "disabled-cache"
    exit 0
  fi

  # Calculate a content hash for matched files
  # Use git ls-tree and AWK to filter files matching the rebuild patterns and extract their hashes
  # Sort the hashes and compute the content hash
  CONTENT_HASH="$(
    git $git_ctx ls-tree -r "$git_commit" \
      | awk -v pattern="($AWK_PATTERN)" '$4 ~ pattern {print $3}' \
      | sort \
      | git hash-object --stdin \
      | cut -c1-16
  )"
  # Check if file list was empty by comparing against the result of
  # 'echo '' | git hash-object --stdin | cut -c1-16'
  EMPTY_HASH="8b137891791fe969"
  if [[ "$CONTENT_HASH" == "$EMPTY_HASH" ]]; then
    echo "No files matched the rebuild patterns $repo_rebuild_patterns."
    echo "Awk pattern expanded: $AWK_PATTERN."
    exit 1
  fi

  if [ -z "$CONTENT_HASH_ACC" ]; then
    CONTENT_HASH_ACC=$CONTENT_HASH;
  else
    CONTENT_HASH_ACC=$(hash_str $CONTENT_HASH_ACC-$CONTENT_HASH);
  fi
done

# important: include architecture in content hash because we target x86_64 and arm64
echo $(hash_str $CONTENT_HASH_ACC-$PLATFORM_TAG)
