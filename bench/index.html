<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes"
    />
    <style>
      html {
        font-family: BlinkMacSystemFont, -apple-system, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue",
          Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        background-color: #fff;
        font-size: 16px;
      }
      body {
        color: #4a4a4a;
        margin: 8px;
        font-size: 1em;
        font-weight: 400;
      }
      header {
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
      }
      main {
        width: 100%;
        display: block;
      }
      a {
        color: #3273dc;
        cursor: pointer;
        text-decoration: none;
      }
      a:hover {
        color: #000;
      }
      button {
        color: #fff;
        background-color: #3298dc;
        border-color: transparent;
        cursor: pointer;
        text-align: center;
      }
      button:hover {
        background-color: #2793da;
        flex: none;
      }
      .spacer {
        flex: auto;
      }
      .small {
        font-size: 0.75rem;
      }
      footer {
        margin-top: 16px;
        display: flex;
        align-items: center;
      }
      .header-label {
        margin-right: 4px;
      }
      .benchmark-set {
        margin: 8px 0;
        width: 100%;
        display: flex;
        flex-direction: column;
      }
      .benchmark-title {
        font-size: 3rem;
        font-weight: 600;
        word-break: break-word;
        text-align: center;
      }
      .benchmark-graphs {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
        gap: 16px;
      }
      .chart-container {
        position: relative;
        width: 100%;
        min-height: 300px; /* changed from fixed height */
      }
      /* Dark theme overrides */
      .dark-theme {
        background-color: #242532;
        color: #e0e0e0;
      }
      .dark-theme a {
        color: #70a0ff;
      }
      .dark-theme button {
        background-color: #3a3a5e;
      }
      /* Ensure chart titles use dark text color */
      .dark-theme .benchmark-title {
        color: #e0e0e0;
      }
      .benchmark-group {
        margin-top: 8px;
        margin-bottom: 8px;
      }
    </style>
    <title>Benchmarks - Master</title>
  </head>

  <body>
    <header id="header">
      <div class="header-item">
        <strong class="header-label">Last Update:</strong>
        <span id="last-update"></span>
      </div>
      <div class="header-item">
        <strong class="header-label">Repository:</strong>
        <a id="repository-link" rel="noopener"></a>
      </div>
      <!-- Added toggle switch for light/dark theme -->
      <div class="header-item">
        <label>
          <input type="checkbox" id="theme-toggle" />
          Dark Theme
        </label>
      </div>
    </header>
    <div style="text-align: center; font-size: 0.9em; color: #666; margin: 10px 0;">
      Note: Navigation uses GitHub API (60 requests/hour limit for anonymous users)
      <button id="auth-toggle" style="margin-left: 10px; font-size: 0.8em;">Add GitHub Token</button>
      <div id="auth-input" style="display: none; margin-top: 10px;">
        <input type="password" id="github-token" placeholder="GitHub Personal Access Token" style="width: 300px; margin-right: 5px;">
        <button id="save-token">Save</button>
        <button id="clear-token" style="display: none;">Clear</button>
        <a href="https://github.com/settings/tokens/new?description=Benchmark%20Viewer&scopes=public_repo" target="_blank" style="margin-left: 10px; font-size: 0.8em;">Generate Token</a>
      </div>
    </div>
    <div id="pagination-top" style="display: flex; justify-content: center; margin: 20px 0; gap: 20px;">
      <button id="prev-page-top" style="display: none;">← Previous 100 commits</button>
      <span id="page-info-top" style="display: none;"></span>
      <button id="next-page-top" style="display: none;">Next 100 commits →</button>
    </div>
    <main id="main"></main>
    <div id="pagination" style="display: flex; justify-content: center; margin: 20px 0; gap: 20px;">
      <button id="prev-page" style="display: none;">← Previous 100 commits</button>
      <span id="page-info" style="display: none;"></span>
      <button id="next-page" style="display: none;">Next 100 commits →</button>
    </div>
    <footer>
      <button id="dl-button">Download data as JSON</button>
      <div class="spacer"></div>
      <div class="small">
        Powered by
        <a
          rel="noopener"
          href="https://github.com/marketplace/actions/continuous-benchmark"
          >github-action-benchmark</a
        >
      </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.2/dist/Chart.min.js"></script>
    <script>
      // Parse branch from query params
      function getBranch() {
        const params = new URLSearchParams(window.location.search);
        return params.get("branch") || "master";
      }
      const branch = getBranch();
      // Set page title
      document.title = `Benchmarks - ${branch}`;
      
      // GitHub API configuration
      const GITHUB_OWNER = "AztecProtocol";
      const GITHUB_REPO = "aztec-packages";
      const COMMITS_PER_PAGE = 100;
      let visitedCommits = [null]; // null represents latest, add commits as we go back
      let currentPosition = 0; // Current position in visitedCommits array
      let commitCache = new Map(); // Cache commits by sha
      window.chartsByBenchName = window.chartsByBenchName || new Map(); // Map benchmark names to their chart instances
      
      // GitHub token management
      let githubToken = localStorage.getItem('github-token');
      
      // Setup token UI
      document.getElementById('auth-toggle').onclick = () => {
        const authInput = document.getElementById('auth-input');
        authInput.style.display = authInput.style.display === 'none' ? 'block' : 'none';
      };
      
      document.getElementById('save-token').onclick = () => {
        const token = document.getElementById('github-token').value.trim();
        if (token) {
          localStorage.setItem('github-token', token);
          githubToken = token;
          document.getElementById('auth-input').style.display = 'none';
          document.getElementById('auth-toggle').textContent = 'Token Saved ✓';
          document.getElementById('clear-token').style.display = 'inline';
          document.getElementById('github-token').value = '';
        }
      };
      
      document.getElementById('clear-token').onclick = () => {
        localStorage.removeItem('github-token');
        githubToken = null;
        document.getElementById('auth-toggle').textContent = 'Add GitHub Token';
        document.getElementById('clear-token').style.display = 'none';
      };
      
      // Check if token exists on load
      if (githubToken) {
        document.getElementById('auth-toggle').textContent = 'Token Saved ✓';
        document.getElementById('clear-token').style.display = 'inline';
      }
      
      // Function to fetch commits starting from a specific SHA
      async function fetchCommitsFrom(sha, count = 100) {
        const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/commits?sha=${sha}&per_page=${count}`;
        
        const headers = {};
        if (githubToken) {
          headers['Authorization'] = `token ${githubToken}`;
        }
        
        try {
          const response = await fetch(url, { headers });
          if (!response.ok) {
            if (response.status === 403) {
              const rateLimitRemaining = response.headers.get('X-RateLimit-Remaining');
              if (rateLimitRemaining === '0') {
                const resetTime = response.headers.get('X-RateLimit-Reset');
                const resetDate = new Date(parseInt(resetTime) * 1000);
                const limitType = githubToken ? '5000 requests/hour for authenticated users' : '60 requests/hour for anonymous users';
                throw new Error(`GitHub API rate limit exceeded (${limitType}). Resets at ${resetDate.toLocaleTimeString()}`);
              }
            }
            if (response.status === 401 && githubToken) {
              throw new Error("Invalid GitHub token. Please check your token and try again.");
            }
            throw new Error("Failed to fetch commits");
          }
          const commits = await response.json();
          
          // Cache the commits
          commits.forEach((commit, index) => {
            commitCache.set(commit.sha, { commit, index });
          });
          
          return commits;
        } catch (error) {
          return [];
        }
      }
      
      // Function to find the Nth commit from a starting point
      async function findNthCommit(startSha, n) {
        let currentSha = startSha || 'gh-pages';
        let foundCommits = [];
        let totalFetched = 0;
        
        while (foundCommits.length <= n) {
          // Fetch a batch of commits
          const batch = await fetchCommitsFrom(currentSha, 100);
          if (batch.length === 0) break;
          
          // Add to our list (skip first if not first batch - it's duplicate)
          if (totalFetched > 0) {
            foundCommits = foundCommits.concat(batch.slice(1));
          } else {
            foundCommits = foundCommits.concat(batch);
          }
          
          totalFetched += batch.length;
          
          // If we have enough commits, return the nth one
          if (foundCommits.length > n) {
            return foundCommits[n];
          }
          
          // Set up for next batch - use the last commit's SHA
          currentSha = batch[batch.length - 1].sha;
          
          // Prevent infinite loops
          if (totalFetched > 1000) {
            break;
          }
        }
        
        return foundCommits[n] || null;
      }
      
      // Function to create chart options and data
      function createChartConfig(label, dataset, textColor) {
        const color = "#4a90e2";
        
        const data = {
          labels: dataset.map((d) => d.commit.id.slice(0, 7)),
          datasets: [
            {
              label: label,
              data: dataset.map((d) => d.bench.value),
              borderColor: color,
              backgroundColor: color + "60",
            },
          ],
        };
        
        const options = {
          responsive: true,
          scales: {
            xAxes: [
              {
                scaleLabel: {
                  display: true,
                  labelString: "commit",
                  fontColor: textColor,
                },
                ticks: {
                  fontColor: textColor,
                },
              },
            ],
            yAxes: [
              {
                scaleLabel: {
                  display: true,
                  labelString: dataset.length > 0 ? dataset[0].bench.unit : "",
                  fontColor: textColor,
                },
                ticks: {
                  beginAtZero: true,
                  fontColor: textColor,
                },
              },
            ],
          },
          tooltips: {
            callbacks: {
              afterTitle: (items) => {
                const { index } = items[0];
                const data = dataset[index];
                return (
                  "\n" +
                  data.commit.message +
                  "\n\n" +
                  data.commit.timestamp +
                  " committed by @" +
                  data.commit.committer.username +
                  "\n"
                );
              },
              label: (item) => {
                let label = item.value;
                const { range, unit } = dataset[item.index].bench;
                label += " " + unit;
                if (range) {
                  label += " (" + range + ")";
                }
                return label;
              },
              afterLabel: (item) => {
                const { extra } = dataset[item.index].bench;
                return extra ? "\n" + extra : "";
              },
            },
          },
          onClick: (_mouseEvent, activeElems) => {
            if (activeElems.length === 0) {
              return;
            }
            const index = activeElems[0]._index;
            const url = dataset[index].commit.url;
            window.open(url, "_blank");
          },
        };
        
        return { data, options };
      }
      
      // Expose createChartConfig globally for use in main script
      window.createChartConfig = createChartConfig;
      
      // Function to recreate all charts with new data
      function recreateChartsWithNewData() {
        // Get the new datasets
        if (typeof window.init !== 'function') return;
        const dataSets = window.init();
        
        // Create a map of all available benchmarks
        const allBenchmarks = new Map();
        dataSets.forEach(({ name, dataSet }) => {
          for (const [benchKey, benches] of dataSet.entries()) {
            allBenchmarks.set(benchKey, benches);
          }
        });
        
        
        // For each existing chart
        const chartsToUpdate = [];
        window.chartsByBenchName.forEach((chart, benchKey) => {
          chartsToUpdate.push({ chart, benchKey });
        });
        
        chartsToUpdate.forEach(({ chart, benchKey }) => {
          const canvas = chart.canvas;
          const benches = allBenchmarks.get(benchKey);
          
          if (benches && benches.length > 0) {
            
            // Get the old chart index
            const oldIndex = window.chartInstances.indexOf(chart);
            
            // Destroy the old chart
            chart.destroy();
            
            // Create new chart with the shared config
            const isDark = document.body.classList.contains("dark-theme");
            const textColor = isDark ? "#e0e0e0" : "#4a4a4a";
            const { data, options } = createChartConfig(benchKey.split('/').pop(), benches, textColor);
            const newChart = new Chart(canvas, {
              type: "line",
              data,
              options,
            });
            
            // Update references
            if (oldIndex !== -1) {
              window.chartInstances[oldIndex] = newChart;
            } else {
              window.chartInstances.push(newChart);
            }
            window.chartsByBenchName.set(benchKey, newChart);
          } else {
          }
        });
      }
      
      
      // Function to load data.js from a specific commit
      async function loadDataFromCommit(branch, commit, isInitialLoad = false) {
        try {
          let dataUrl;
          if (commit) {
            // Load from specific commit using raw GitHub URL
            dataUrl = `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${commit}/bench/${branch}/data.js`;
          } else {
            // Load latest from gh-pages
            dataUrl = `${branch}/data.js`;
          }
          
          // Show loading indicator
          if (!isInitialLoad) {
            // Just show a small loading indicator without clearing charts
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'loading-overlay';
            const isDark = document.body.classList.contains('dark-theme');
            loadingDiv.style = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: ${isDark ? 'rgba(36,37,50,0.95)' : 'rgba(255,255,255,0.95)'}; color: ${isDark ? '#e0e0e0' : '#4a4a4a'}; padding: 20px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 1000;`;
            loadingDiv.innerHTML = 'Loading benchmark data...';
            document.body.appendChild(loadingDiv);
          }
          
          // Fetch as text to avoid ORB blocking
          const response = await fetch(dataUrl);
          if (!response.ok) throw new Error("Failed to load data");
          
          const scriptText = await response.text();
          
          // Execute the script
          eval(scriptText);
          
          // Update current position tracking
          if (!isInitialLoad) {
            // Find or update position in visited commits
            const existingIndex = visitedCommits.indexOf(commit);
            if (existingIndex !== -1) {
              currentPosition = existingIndex;
            }
          }
          
          if (isInitialLoad) {
            // Only run main script after data is loaded
            document.getElementById("main-script").removeAttribute("type");
            eval(document.getElementById("main-script").textContent);
            
            // Setup pagination after data loads
            setupPagination();
          } else {
            // Recreate charts in place
            recreateChartsWithNewData();
            updatePaginationControls();
            // Remove loading overlay
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
              loadingOverlay.remove();
            }
          }
        } catch (error) {
          document.getElementById(
            "main"
          ).innerHTML = `<div style='color:red'>Could not load benchmark data for branch: <b>${branch}</b>${
            commit ? " at commit " + commit.substring(0, 7) : ""
          }</div>`;
        }
      }
      
      // Function to update pagination controls
      async function updatePaginationControls() {
        // Update both sets of controls
        ['', '-top'].forEach(suffix => {
          const prevButton = document.getElementById(`prev-page${suffix}`);
          const nextButton = document.getElementById(`next-page${suffix}`);
          const pageInfo = document.getElementById(`page-info${suffix}`);
          
          // Update page info
          const currentCommit = visitedCommits[currentPosition];
          pageInfo.textContent = currentCommit
            ? `Showing data from commit ${currentCommit.substring(0, 7)}`
            : "Showing latest data";
          pageInfo.style.display = "block";
          
          // Always show previous button (we can always go back in history)
          prevButton.style.display = "block";
          prevButton.disabled = false;
          prevButton.onclick = async () => {
            prevButton.disabled = true;
            prevButton.textContent = "Loading...";
            
            try {
              // Find the 100th commit from current position
              const currentCommit = visitedCommits[currentPosition];
              const targetCommit = await findNthCommit(currentCommit || 'gh-pages', COMMITS_PER_PAGE);
              
              if (targetCommit) {
                // Add to visited commits
                visitedCommits.push(targetCommit.sha);
                currentPosition = visitedCommits.length - 1;
                
                await loadDataFromCommit(branch, targetCommit.sha);
              } else {
                prevButton.disabled = true;
              }
            } catch (error) {
              alert(error.message || 'Failed to load commits');
            } finally {
              prevButton.textContent = "← Previous 100 commits";
              prevButton.disabled = false;
            }
          };
          
          // Setup next button - only visible if we can go forward
          if (currentPosition > 0) {
            nextButton.style.display = "block";
            nextButton.disabled = false;
            nextButton.onclick = async () => {
              nextButton.disabled = true;
              nextButton.textContent = "Loading...";
              
              try {
                // Move forward in our visited commits
                currentPosition--;
                const targetCommit = visitedCommits[currentPosition];
                await loadDataFromCommit(branch, targetCommit);
              } finally {
                nextButton.textContent = "Next 100 commits →";
                nextButton.disabled = false;
              }
            };
          } else {
            // At latest, no next button
            nextButton.style.display = "none";
          }
        });
      }
      
      // Function to setup pagination controls
      async function setupPagination() {
        await updatePaginationControls();
      }
      
      // Load the data (always start at latest)
      loadDataFromCommit(branch, null, true);
    </script>
    <script id="main-script" type="text/ignore">
      "use strict";
      (function () {
        // Read and apply saved theme from localStorage on load.
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme === "dark") {
          document.body.classList.add("dark-theme");
          document.documentElement.classList.add("dark-theme");
          document.getElementById("theme-toggle").checked = true;
        }

        // Global array to store chart instances.
        window.chartInstances = [];

        function init() {
          // Only use the last 10 commits for each bench
          // to phase out obsolete benchmarks.
          const NUM_COMMITS_FOR_BENCHMARK_DISCOVERY = 10;
          function collectBenchesPerTestCase(entries) {
            const map = new Map();
            const activeBenches = new Set();
            // Collect all benches from the entries.
            for (const entry of entries.slice(-NUM_COMMITS_FOR_BENCHMARK_DISCOVERY)) {
              for (const bench of entry.benches) {
                activeBenches.add(bench.name);
              }
            }
            for (const entry of entries) {
              const { commit, date, tool, benches } = entry;
              for (const bench of benches) {
                if (!activeBenches.has(bench.name)) {
                  continue; // Skip benches that are not active
                }
                const result = { commit, date, tool, bench };
                const arr = map.get(bench.name);
                if (arr === undefined) {
                  map.set(bench.name, [result]);
                } else {
                  arr.push(result);
                }
              }
            }
            return map;
          }

          const data = window.BENCHMARK_DATA;

          // Render header
          document.getElementById("last-update").textContent = new Date(
            data.lastUpdate
          ).toString();
          const repoLink = document.getElementById("repository-link");
          repoLink.href = data.repoUrl;
          repoLink.textContent = data.repoUrl;

          // Render footer
          document.getElementById("dl-button").onclick = () => {
            const dataUrl = "data:," + JSON.stringify(data, null, 2);
            const a = document.createElement("a");
            a.href = dataUrl;
            a.download = "benchmark_data.json";
            a.click();
          };

          // Prepare data points for charts
          return Object.keys(data.entries).map((name) => ({
            name,
            dataSet: collectBenchesPerTestCase(data.entries[name]),
          }));
        }

        function renderAllChars(dataSets) {
          function renderGraph(parent, name, dataset, fullKey) {
            // Determine theme-specific text color.
            const isDark = document.body.classList.contains("dark-theme");
            const textColor = isDark ? "#e0e0e0" : "#4a4a4a";

            // Find or create grid container inside parent
            let grid = parent.querySelector(".benchmark-graphs");
            if (!grid) {
              grid = document.createElement("div");
              grid.className = "benchmark-graphs";
              parent.appendChild(grid);
            }
            // Create container for responsive chart
            const container = document.createElement("div");
            container.className = "chart-container";
            grid.appendChild(container);

            const canvas = document.createElement("canvas");
            canvas.className = "benchmark-chart";
            container.appendChild(canvas);

            // Use the shared chart config function
            const { data, options } = window.createChartConfig(name, dataset, textColor);
            const chart = new Chart(canvas, {
              type: "line",
              data,
              options,
            });
            // Save chart instance for dynamic theme updates.
            window.chartInstances.push(chart);
            // Also save by benchmark full key for updating
            if (fullKey) {
              window.chartsByBenchName.set(fullKey, chart);
            }
          }

          function renderBenchSet(name, benchSet, main) {
            const setElem = document.createElement("div");
            setElem.className = "benchmark-set";
            main.appendChild(setElem);

            const nameElem = document.createElement("h1");
            nameElem.className = "benchmark-title";
            nameElem.textContent = name;
            setElem.appendChild(nameElem);

            // Build flat list of items
            const items = [];
            for (const [benchKey, benches] of benchSet.entries()) {
              // Use everything except the last path segment as group, last segment as chartName
              const parts = benchKey.split("/");
              let group = "Ungrouped";
              let chartName = benchKey;
              if (parts.length > 1) {
                group = parts.slice(0, -1).join("/");
                chartName = parts[parts.length - 1];
              }
              items.push({ group, chartName, benches, fullKey: benchKey });
            }


            // Build hierarchical tree from group paths.
            const tree = new Map();
            items.forEach((item) => {
              const parts = item.group.split("/");
              let current = tree;
              parts.forEach((part, idx) => {
                if (!current.has(part)) {
                  current.set(part, { children: new Map(), charts: [] });
                }
                if (idx === parts.length - 1) {
                  current.get(part).charts.push({
                    chartName: item.chartName,
                    benches: item.benches,
                    fullKey: item.fullKey,
                  });
                }
                current = current.get(part).children;
              });
            });


            // Recursively render the tree.
            function renderTree(treeNode, container, level = 0) {
              for (const [key, value] of treeNode.entries()) {
                const groupContainer = document.createElement("div");
                groupContainer.className = "benchmark-group";
                // Use a fixed indent for all nested levels
                groupContainer.style.marginLeft = (level > 0 ? 10 : 0) + "px";

                const header = document.createElement("div");
                header.className = "benchmark-group-header";
                header.style.cursor = "pointer";
                const toggleIcon = document.createElement("span");
                // Start collapsed
                toggleIcon.textContent = "[+] ";
                toggleIcon.style.cursor = "pointer"; // indicate clickable
                toggleIcon.style.fontWeight = "bold"; // make text bold
                header.appendChild(toggleIcon);
                const headerText = document.createElement("span");
                headerText.textContent = key;
                headerText.style.cursor = "pointer"; // indicate clickable
                headerText.style.fontWeight = "bold"; // make text bold
                header.appendChild(headerText);

                // Add expand/collapse all buttons
                const expandAllBtn = document.createElement("button");
                expandAllBtn.textContent = "Expand all";
                expandAllBtn.className = "expand-collapse-btn";
                expandAllBtn.style.marginLeft = "8px";
                expandAllBtn.style.fontSize = "0.8em";
                expandAllBtn.style.padding = "0 6px";
                header.appendChild(expandAllBtn);

                const collapseAllBtn = document.createElement("button");
                collapseAllBtn.textContent = "Collapse all";
                collapseAllBtn.className = "expand-collapse-btn";
                collapseAllBtn.style.marginLeft = "4px";
                collapseAllBtn.style.fontSize = "0.8em";
                collapseAllBtn.style.padding = "0 6px";
                header.appendChild(collapseAllBtn);

                const groupContent = document.createElement("div");
                groupContent.className = "benchmark-group-content";
                // Initially collapse the group
                groupContent.style.display = "none";

                // Expand/collapse when clicking either the icon or the text
                function toggleGroup() {
                  if (groupContent.style.display === "none") {
                    groupContent.style.display = "block";
                    toggleIcon.textContent = "[-] ";
                  } else {
                    groupContent.style.display = "none";
                    toggleIcon.textContent = "[+] ";
                  }
                }
                toggleIcon.addEventListener("click", toggleGroup);
                headerText.addEventListener("click", toggleGroup);

                // Recursive expand/collapse for subtree
                function setSubtreeExpanded(node, expand) {
                  // node: groupContainer
                  const content = node.querySelector(
                    ":scope > .benchmark-group-content"
                  );
                  const icon = node.querySelector(
                    ":scope > .benchmark-group-header > span"
                  );
                  if (content && icon) {
                    content.style.display = expand ? "block" : "none";
                    icon.textContent = expand ? "[-] " : "[+] ";
                  }
                  // Recursively expand/collapse child groups
                  const children = content
                    ? content.querySelectorAll(":scope > .benchmark-group")
                    : [];
                  children.forEach((child) =>
                    setSubtreeExpanded(child, expand)
                  );
                }

                expandAllBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  setSubtreeExpanded(groupContainer, true);
                });
                collapseAllBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  setSubtreeExpanded(groupContainer, false);
                });

                groupContainer.appendChild(header);
                groupContainer.appendChild(groupContent);
                container.appendChild(groupContainer);

                // Render charts for this node.
                value.charts.forEach((item) => {
                  renderGraph(groupContent, item.chartName, item.benches, item.fullKey);
                });
                // Recursively render child groups with increased indentation.
                renderTree(value.children, groupContent, level + 1);
              }
            }

            const groupsElem = document.createElement("div");
            groupsElem.className = "benchmark-groups";
            setElem.appendChild(groupsElem);
            renderTree(tree, groupsElem);
          }

          const main = document.getElementById("main");
          for (const { name, dataSet } of dataSets) {
            renderBenchSet(name, dataSet, main);
          }
        }

        // Reusable function to update chart colors
        function updateCharts(textColor, gridColor) {
          window.chartInstances.forEach((chart) => {
            chart.options.scales.xAxes.forEach((axis) => {
              if (axis.scaleLabel) {
                axis.scaleLabel.fontColor = textColor;
              }
              axis.ticks.fontColor = textColor;
              if (axis.gridLines) {
                axis.gridLines.color = gridColor;
              }
            });
            chart.options.scales.yAxes.forEach((axis) => {
              if (axis.scaleLabel) {
                axis.scaleLabel.fontColor = textColor;
              }
              axis.ticks.fontColor = textColor;
              if (axis.gridLines) {
                axis.gridLines.color = gridColor;
              }
            });
            if (chart.options.legend && chart.options.legend.labels) {
              chart.options.legend.labels.fontColor = textColor;
            }
            if (chart.options.title) {
              chart.options.title.fontColor = textColor;
            }
            chart.update();
          });
        }

        // Add theme toggle listener to update charts when theme changes.
        const themeToggle = document.getElementById("theme-toggle");
        themeToggle.addEventListener("change", () => {
          if (themeToggle.checked) {
            document.body.classList.add("dark-theme");
            document.documentElement.classList.add("dark-theme");
            localStorage.setItem("theme", "dark");
          } else {
            document.body.classList.remove("dark-theme");
            document.documentElement.classList.remove("dark-theme");
            localStorage.setItem("theme", "light");
          }
          const isDark = document.body.classList.contains("dark-theme");
          const textColor = isDark ? "#e0e0e0" : "#4a4a4a";
          const gridColor = isDark ? "#555" : "#ccc";
          updateCharts(textColor, gridColor);
        });

        // Expose functions globally for dynamic updates
        window.init = init;
        window.renderAllChars = renderAllChars;
        
        renderAllChars(init()); // Start

        // Update chart colors on page load if dark theme is already enabled.
        if (document.body.classList.contains("dark-theme")) {
          updateCharts("#e0e0e0", "#555");
        }
      })();
    </script>
  </body>
</html>
