<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes"
    />
    <style>
      html {
        font-family: BlinkMacSystemFont, -apple-system, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue",
          Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        background-color: #fff;
        font-size: 16px;
      }
      body {
        color: #4a4a4a;
        margin: 8px;
        font-size: 1em;
        font-weight: 400;
      }
      header {
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
      }
      main {
        width: 100%;
        display: block;
      }
      a {
        color: #3273dc;
        cursor: pointer;
        text-decoration: none;
      }
      a:hover {
        color: #000;
      }
      button {
        color: #fff;
        background-color: #3298dc;
        border-color: transparent;
        cursor: pointer;
        text-align: center;
      }
      button:hover {
        background-color: #2793da;
        flex: none;
      }
      .spacer {
        flex: auto;
      }
      .small {
        font-size: 0.75rem;
      }
      footer {
        margin-top: 16px;
        display: flex;
        align-items: center;
      }
      .header-label {
        margin-right: 4px;
      }
      .benchmark-set {
        margin: 8px 0;
        width: 100%;
        display: flex;
        flex-direction: column;
      }
      .benchmark-title {
        font-size: 3rem;
        font-weight: 600;
        word-break: break-word;
        text-align: center;
      }
      .benchmark-graphs {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
        gap: 16px;
      }
      .chart-container {
        position: relative;
        width: 100%;
        min-height: 300px; /* changed from fixed height */
      }
      /* Dark theme overrides */
      .dark-theme {
        background-color: #242532;
        color: #e0e0e0;
      }
      .dark-theme a {
        color: #70a0ff;
      }
      .dark-theme button {
        background-color: #3a3a5e;
      }
      /* Ensure chart titles use dark text color */
      .dark-theme .benchmark-title {
        color: #e0e0e0;
      }
      .benchmark-group {
        margin-top: 8px;
        margin-bottom: 8px;
      }
    </style>
    <title>Benchmarks - Master</title>
  </head>

  <body>
    <header id="header">
      <div class="header-item">
        <strong class="header-label">Last Update:</strong>
        <span id="last-update"></span>
      </div>
      <div class="header-item">
        <strong class="header-label">Repository:</strong>
        <a id="repository-link" rel="noopener"></a>
      </div>
      <!-- Added toggle switch for light/dark theme -->
      <div class="header-item">
        <label>
          <input type="checkbox" id="theme-toggle" />
          Dark Theme
        </label>
      </div>
    </header>
    <main id="main"></main>
    <footer>
      <button id="dl-button">Download data as JSON</button>
      <div class="spacer"></div>
      <div class="small">
        Powered by
        <a
          rel="noopener"
          href="https://github.com/marketplace/actions/continuous-benchmark"
          >github-action-benchmark</a
        >
      </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.2/dist/Chart.min.js"></script>
    <script>
      // Parse branch from query param, default to 'master'
      function getBranch() {
        const params = new URLSearchParams(window.location.search);
        return params.get("branch") || "master";
      }
      const branch = getBranch();
      // Set page title
      document.title = `Benchmarks - ${branch}`;
      // Dynamically load the correct data.js
      const script = document.createElement("script");
      script.src = `${branch}/data.js`;
      script.onload = function () {
        // Only run main script after data is loaded
        document.getElementById("main-script").removeAttribute("type");
        eval(document.getElementById("main-script").textContent);
      };
      script.onerror = function () {
        document.getElementById(
          "main"
        ).innerHTML = `<div style='color:red'>Could not load benchmark data for branch: <b>${branch}</b></div>`;
      };
      document.head.appendChild(script);
    </script>
    <script id="main-script" type="text/ignore">
      "use strict";
      (function () {
        // Read and apply saved theme from localStorage on load.
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme === "dark") {
          document.body.classList.add("dark-theme");
          document.documentElement.classList.add("dark-theme");
          document.getElementById("theme-toggle").checked = true;
        }

        // Global array to store chart instances.
        window.chartInstances = [];

        function init() {
          // Only use the last 10 commits for each bench
          // to phase out obsolete benchmarks.
          const NUM_COMMITS_FOR_BENCHMARK_DISCOVERY = 10;
          function collectBenchesPerTestCase(entries) {
            const map = new Map();
            const activeBenches = new Set();
            // Collect all benches from the entries.
            for (const entry of entries.slice(-NUM_COMMITS_FOR_BENCHMARK_DISCOVERY)) {
              for (const bench of entry.benches) {
                activeBenches.add(bench.name);
              }
            }
            for (const entry of entries) {
              const { commit, date, tool, benches } = entry;
              for (const bench of benches) {
                if (!activeBenches.has(bench.name)) {
                  continue; // Skip benches that are not active
                }
                const result = { commit, date, tool, bench };
                const arr = map.get(bench.name);
                if (arr === undefined) {
                  map.set(bench.name, [result]);
                } else {
                  arr.push(result);
                }
              }
            }
            return map;
          }

          const data = window.BENCHMARK_DATA;

          // Render header
          document.getElementById("last-update").textContent = new Date(
            data.lastUpdate
          ).toString();
          const repoLink = document.getElementById("repository-link");
          repoLink.href = data.repoUrl;
          repoLink.textContent = data.repoUrl;

          // Render footer
          document.getElementById("dl-button").onclick = () => {
            const dataUrl = "data:," + JSON.stringify(data, null, 2);
            const a = document.createElement("a");
            a.href = dataUrl;
            a.download = "benchmark_data.json";
            a.click();
          };

          // Prepare data points for charts
          return Object.keys(data.entries).map((name) => ({
            name,
            dataSet: collectBenchesPerTestCase(data.entries[name]),
          }));
        }

        function renderAllChars(dataSets) {
          function renderGraph(parent, name, dataset) {
            // Determine theme-specific text color.
            const isDark = document.body.classList.contains("dark-theme");
            const textColor = isDark ? "#e0e0e0" : "#4a4a4a";

            // Find or create grid container inside parent
            let grid = parent.querySelector(".benchmark-graphs");
            if (!grid) {
              grid = document.createElement("div");
              grid.className = "benchmark-graphs";
              parent.appendChild(grid);
            }
            // Create container for responsive chart
            const container = document.createElement("div");
            container.className = "chart-container";
            grid.appendChild(container);

            const canvas = document.createElement("canvas");
            canvas.className = "benchmark-chart";
            container.appendChild(canvas);

            const color = "#4a90e2";

            const data = {
              labels: dataset.map((d) => d.commit.id.slice(0, 7)),
              datasets: [
                {
                  label: name,
                  data: dataset.map((d) => d.bench.value),
                  borderColor: color,
                  backgroundColor: color + "60", // Add alpha for #rrggbbaa
                },
              ],
            };
            const options = {
              responsive: true, // ensure the chart is responsive
              scales: {
                xAxes: [
                  {
                    scaleLabel: {
                      display: true,
                      labelString: "commit",
                      fontColor: textColor,
                    },
                    ticks: {
                      fontColor: textColor,
                    },
                  },
                ],
                yAxes: [
                  {
                    scaleLabel: {
                      display: true,
                      labelString:
                        dataset.length > 0 ? dataset[0].bench.unit : "",
                      fontColor: textColor,
                    },
                    ticks: {
                      beginAtZero: true,
                      fontColor: textColor,
                    },
                  },
                ],
              },
              tooltips: {
                callbacks: {
                  afterTitle: (items) => {
                    const { index } = items[0];
                    const data = dataset[index];
                    return (
                      "\n" +
                      data.commit.message +
                      "\n\n" +
                      data.commit.timestamp +
                      " committed by @" +
                      data.commit.committer.username +
                      "\n"
                    );
                  },
                  label: (item) => {
                    let label = item.value;
                    const { range, unit } = dataset[item.index].bench;
                    label += " " + unit;
                    if (range) {
                      label += " (" + range + ")";
                    }
                    return label;
                  },
                  afterLabel: (item) => {
                    const { extra } = dataset[item.index].bench;
                    return extra ? "\n" + extra : "";
                  },
                },
              },
              onClick: (_mouseEvent, activeElems) => {
                if (activeElems.length === 0) {
                  return;
                }
                // XXX: Undocumented. How can we know the index?
                const index = activeElems[0]._index;
                const url = dataset[index].commit.url;
                window.open(url, "_blank");
              },
            };

            const chart = new Chart(canvas, {
              type: "line",
              data,
              options,
            });
            // Save chart instance for dynamic theme updates.
            window.chartInstances.push(chart);
          }

          function renderBenchSet(name, benchSet, main) {
            const setElem = document.createElement("div");
            setElem.className = "benchmark-set";
            main.appendChild(setElem);

            const nameElem = document.createElement("h1");
            nameElem.className = "benchmark-title";
            nameElem.textContent = name;
            setElem.appendChild(nameElem);

            // Build flat list of items
            const items = [];
            for (const [benchKey, benches] of benchSet.entries()) {
              // Use everything except the last path segment as group, last segment as chartName
              const parts = benchKey.split("/");
              let group = "Ungrouped";
              let chartName = benchKey;
              if (parts.length > 1) {
                group = parts.slice(0, -1).join("/");
                chartName = parts[parts.length - 1];
              }
              items.push({ group, chartName, benches });
            }

            console.log(items);

            // Build hierarchical tree from group paths.
            const tree = new Map();
            items.forEach((item) => {
              const parts = item.group.split("/");
              let current = tree;
              parts.forEach((part, idx) => {
                if (!current.has(part)) {
                  current.set(part, { children: new Map(), charts: [] });
                }
                if (idx === parts.length - 1) {
                  current.get(part).charts.push({
                    chartName: item.chartName,
                    benches: item.benches,
                  });
                }
                current = current.get(part).children;
              });
            });

            console.log(tree);

            // Recursively render the tree.
            function renderTree(treeNode, container, level = 0) {
              for (const [key, value] of treeNode.entries()) {
                const groupContainer = document.createElement("div");
                groupContainer.className = "benchmark-group";
                // Use a fixed indent for all nested levels
                groupContainer.style.marginLeft = (level > 0 ? 10 : 0) + "px";

                const header = document.createElement("div");
                header.className = "benchmark-group-header";
                header.style.cursor = "pointer";
                const toggleIcon = document.createElement("span");
                // Start collapsed
                toggleIcon.textContent = "[+] ";
                toggleIcon.style.cursor = "pointer"; // indicate clickable
                toggleIcon.style.fontWeight = "bold"; // make text bold
                header.appendChild(toggleIcon);
                const headerText = document.createElement("span");
                headerText.textContent = key;
                headerText.style.cursor = "pointer"; // indicate clickable
                headerText.style.fontWeight = "bold"; // make text bold
                header.appendChild(headerText);

                // Add expand/collapse all buttons
                const expandAllBtn = document.createElement("button");
                expandAllBtn.textContent = "Expand all";
                expandAllBtn.className = "expand-collapse-btn";
                expandAllBtn.style.marginLeft = "8px";
                expandAllBtn.style.fontSize = "0.8em";
                expandAllBtn.style.padding = "0 6px";
                header.appendChild(expandAllBtn);

                const collapseAllBtn = document.createElement("button");
                collapseAllBtn.textContent = "Collapse all";
                collapseAllBtn.className = "expand-collapse-btn";
                collapseAllBtn.style.marginLeft = "4px";
                collapseAllBtn.style.fontSize = "0.8em";
                collapseAllBtn.style.padding = "0 6px";
                header.appendChild(collapseAllBtn);

                const groupContent = document.createElement("div");
                groupContent.className = "benchmark-group-content";
                // Initially collapse the group
                groupContent.style.display = "none";

                // Expand/collapse when clicking either the icon or the text
                function toggleGroup() {
                  if (groupContent.style.display === "none") {
                    groupContent.style.display = "block";
                    toggleIcon.textContent = "[-] ";
                  } else {
                    groupContent.style.display = "none";
                    toggleIcon.textContent = "[+] ";
                  }
                }
                toggleIcon.addEventListener("click", toggleGroup);
                headerText.addEventListener("click", toggleGroup);

                // Recursive expand/collapse for subtree
                function setSubtreeExpanded(node, expand) {
                  // node: groupContainer
                  const content = node.querySelector(
                    ":scope > .benchmark-group-content"
                  );
                  const icon = node.querySelector(
                    ":scope > .benchmark-group-header > span"
                  );
                  if (content && icon) {
                    content.style.display = expand ? "block" : "none";
                    icon.textContent = expand ? "[-] " : "[+] ";
                  }
                  // Recursively expand/collapse child groups
                  const children = content
                    ? content.querySelectorAll(":scope > .benchmark-group")
                    : [];
                  children.forEach((child) =>
                    setSubtreeExpanded(child, expand)
                  );
                }

                expandAllBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  setSubtreeExpanded(groupContainer, true);
                });
                collapseAllBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  setSubtreeExpanded(groupContainer, false);
                });

                groupContainer.appendChild(header);
                groupContainer.appendChild(groupContent);
                container.appendChild(groupContainer);

                // Render charts for this node.
                value.charts.forEach((item) => {
                  renderGraph(groupContent, item.chartName, item.benches);
                });
                // Recursively render child groups with increased indentation.
                renderTree(value.children, groupContent, level + 1);
              }
            }

            const groupsElem = document.createElement("div");
            groupsElem.className = "benchmark-groups";
            setElem.appendChild(groupsElem);
            renderTree(tree, groupsElem);
          }

          const main = document.getElementById("main");
          for (const { name, dataSet } of dataSets) {
            renderBenchSet(name, dataSet, main);
          }
        }

        // Reusable function to update chart colors
        function updateCharts(textColor, gridColor) {
          window.chartInstances.forEach((chart) => {
            chart.options.scales.xAxes.forEach((axis) => {
              if (axis.scaleLabel) {
                axis.scaleLabel.fontColor = textColor;
              }
              axis.ticks.fontColor = textColor;
              if (axis.gridLines) {
                axis.gridLines.color = gridColor;
              }
            });
            chart.options.scales.yAxes.forEach((axis) => {
              if (axis.scaleLabel) {
                axis.scaleLabel.fontColor = textColor;
              }
              axis.ticks.fontColor = textColor;
              if (axis.gridLines) {
                axis.gridLines.color = gridColor;
              }
            });
            if (chart.options.legend && chart.options.legend.labels) {
              chart.options.legend.labels.fontColor = textColor;
            }
            if (chart.options.title) {
              chart.options.title.fontColor = textColor;
            }
            chart.update();
          });
        }

        // Add theme toggle listener to update charts when theme changes.
        const themeToggle = document.getElementById("theme-toggle");
        themeToggle.addEventListener("change", () => {
          if (themeToggle.checked) {
            document.body.classList.add("dark-theme");
            document.documentElement.classList.add("dark-theme");
            localStorage.setItem("theme", "dark");
          } else {
            document.body.classList.remove("dark-theme");
            document.documentElement.classList.remove("dark-theme");
            localStorage.setItem("theme", "light");
          }
          const isDark = document.body.classList.contains("dark-theme");
          const textColor = isDark ? "#e0e0e0" : "#4a4a4a";
          const gridColor = isDark ? "#555" : "#ccc";
          updateCharts(textColor, gridColor);
        });

        renderAllChars(init()); // Start

        // Update chart colors on page load if dark theme is already enabled.
        if (document.body.classList.contains("dark-theme")) {
          updateCharts("#e0e0e0", "#555");
        }
      })();
    </script>
  </body>
</html>
