{"noir_version":"0.24.0+e80c5f73a4cdcba3f5cf44576c605ba1e611a2ab","name":"BoxReact","functions":[{"name":"setNumber","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323]},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[{"start":4,"end":24}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[24,25,26,27]},"bytecode":"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","debug_symbols":"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3VR43VR43VR43VR43bT3PkIt0XndVHjdVHjdVHjdVHjdVHndVHndlHcvJOXdC0l590JS3r2QlHcvJOXdC0l590JS3r2QlHcvJOXdC0l590LSznsh1Tq9cPCuweOTtfOGSO35Izl/IufP5PyFnL9y83feLqk9vyfnD+T85P7beQul9vzk/pvI/TeR+28i999E7r+Z3H8zuf9mbv+Nm39AJClMTymQlN3P+aOr0+s+C+6+uolGoGgUiiZC0SQomtyVRqf7TzGGOZoCRVORaDb/sKUtjYei6duL5fZ0mShzNAJFo1A0EYomQdFkKJq+vVim9VYUnaOpSDTBQdF4KJoARSNQNApFE6FoEhRNhqKB6sUBqhcLVC8WqF4sUL1YoHqxQPVigerFAtWLBaoXC1QvFqherFC9WKF6sUL1YoXqxQrVixWqFytUL1aoXqxQvVihenGE6sURqhdHqF4coXrxC9/LTNPT1+OzT0+nLwPHF74MuVBU1hTVFUUvfNduocivKQprimbfALHcJqrOFemaorimKK0pymuKypqiuqJo/tsfseZrUXJppsivKQprimRNka4pimuK0pqi2XdEireiNFdU1hTVFUXzj4hZKvJrisKaIllTNPuOSHm6NFKZuTTmH8KxVJTWFOU1RWVNUV1RNP+Yg5eLLv/49+Hjm4c/375+vBRc/vn034evf37+Hw=="},{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280]},"bytecode":"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","debug_symbols":"3ZjbjtowEED/Jc8IzcXj8fAr1T7QlkpIiF0tqFKF+PcmC3YM6+I2kSjhCSLNTI4nc/Wh2bx+W+7Xr9tdszg0iM3iy6HZvS233eNuv3zfNwuYNavt9/b3OGt+rDerZuH8cfZJDMXOghgwiSJCQZZYo1VypL20FS2jQ4620eml/MusQZooN9+LW8BFbvFuNLcbwc1s/izJjn0S7rA+owBQJAHKjhmkIO0sCsvFx8EPaJkitJ8itJaghWK8ioTb4GQqMVwtC27Ck/1QtO9DtN8h37JvLpo361EQ3KBksEeiIRhJg6D9CxgqPH8ZiUFiuARvmUn6QMbpIdP0kHl6yO42skerFECAiMzg6MJ+oeo4DKlJklWk65koo+mTcxisRt/6T6MrlSQv9h2MfyQYHQuD/Xdtx6AajIuzTwg9uBRDACw2KULqi7FwyW7KBwO5LYpt54qxQkIXDW1IaIWncKB5nyYO9BUPVn1id/UJQrKMaJZ7pYVh+G8wrduvYfC+MESSYHy4HS+B0/ATWPmqUDBNlpzvTG4pANpRv5Kjjvol1vlKMXIhcgj3Va49cHdK9yynVIwlTjNZLVYtpynxIV+lB00JLM/iQp9WQs1uGIouREu7JkHWDrv9cYgP/dOEoaaxCfQ62fSRTymxlZNXrJySNd0EZCOC09PdwbyYEWmswKy/qZ06/xyL/ZYCp2EkeL6+Ruj0cKBeuTGlOclzBgmnhjAvXxSwi27mbPs/f3Kel/f5mhIOUaIhSvzPSjr/w2bE0XuidBUVnZIfolTMGc+QsqyP1bauvLQPP5fv6+XXzaq7EG8f97/eTn+PvwE="},{"name":"getNumber","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"owner":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"struct","path":"value_note::value_note::ValueNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"kind":"struct","path":"aztec::note::note_header::NoteHeader","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"is_transient","type":{"kind":"boolean"}}]}}]},"visibility":"public"},"return_witnesses":[1,2,3,4,5,6,7]},"bytecode":"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","debug_symbols":"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ZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF7vNSFlPh6/5DJjv3L28K9g0WDT4NDg0uDB4GtO+j1Bo0GnwaBB2pykzUnanKTNSdqcpM0p2pyizSnanKLNKdqcos0p2pyizSnanKLNadqcps1p2pymzWnanKbNadqcps1p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Dei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7x3w3H8x3nzmDOYe5gLmEuYK5hrmBuYU52BeDfTHYF4N9MdgXg30x2BeDfTHYF4N9MdgXh31x2BeHfXHYF4d9cdgXh31x2BeHfXHYl4B9CdiXgH0J2JeAfQnYl4B9CdiXgH0J2JeEfUnYl4R9SdiXhH1J2JeEfUnYl4R9SdiXgn0p2JeCfSnYl4J9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"}],"events":[],"file_map":{"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"34":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"46":{"source":"contract BoxReact {\n    use dep::aztec::{\n        protocol_types::address::AztecAddress, state_vars::{PrivateMutable, Map},\n        note::{utils as note_utils, note_interface::NoteInterface, note_header::NoteHeader}\n    };\n\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        numbers: Map<AztecAddress, PrivateMutable<ValueNote>>,\n    }\n\n    #[aztec(private)]\n    fn constructor(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).initialize(&mut new_number, true);\n    }\n\n    #[aztec(private)]\n    fn setNumber(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).replace(&mut new_number, true);\n    }\n\n    unconstrained fn getNumber(owner: AztecAddress) -> pub ValueNote {\n        let numbers = storage.numbers;\n        numbers.at(owner).view_note()\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/boxes/react/src/contracts/src/main.nr"},"47":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/log.nr"},"51":{"source":"use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{\n    MAX_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"52":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"53":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"64":{"source":"use crate::{\n    context::inputs::PrivateContextInputs, key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn is_deployment(self) -> bool {\n        // TODO(#4738): Implement this\n        false\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"70":{"source":"use dep::std::option::Option;\nuse crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"73":{"source":"use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr"},"77":{"source":"use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"79":{"source":"#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/rand.nr"},"82":{"source":"use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr"},"90":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr"},"102":{"source":"use dep::std::option::Option;\n\nuse dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note}, note_getter::{get_note, view_notes},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::{nullifier_key::get_nullifier_secret_key, notes::check_nullifier_exists};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateMutable<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateMutable<T> {}\n\nimpl<Note> PrivateMutable<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<N>(self, new_note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note<N>(self, broadcast: bool) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr"},"104":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"110":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr"},"185":{"source":"use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/traits.nr"},"190":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/utils.nr"},"191":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/aztec_address.nr"},"192":{"source":"use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/public_keys_hash.nr"},"196":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr"},"211":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}