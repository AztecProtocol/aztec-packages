{"noir_version":"0.24.0+cbbc2eb02547deca473e1e0661ff6f9ee20e38ae","name":"BoxReact","functions":[{"name":"getNumber","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"owner":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"struct","path":"value_note::value_note::ValueNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"kind":"struct","path":"aztec::note::note_header::NoteHeader","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"is_transient","type":{"kind":"boolean"}}]}}]},"visibility":"public"},"return_witnesses":[1,2,3,4,5,6,7]},"bytecode":"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","debug_symbols":"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bhTqRqFuFOpGoW406kajbjTqRqNuNOpGo2406kajbjTqRqNuDOrGoG4M6sagbgzqxqBuDOrGoG4M6sagbizqxqJuLOrGom4s6saibizqxqJuLOrGom4c6sahbhzqxqFuHOrGoW4c6sahbhzqxpFuxOOBUoZSjlKBUolShVKNUoNSi1KoG4a6YagbhrphqBuGumGoG4a6YagbhrphqBuOuuGoG4664agbjrrhqBuOuuGoG4664agbgboRqBuBuhGoG4G6EagbgboRqBuBuoFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolcNJGLJnLRRC6ayEUTuWgiF03koolctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1ctJGLNnLRRi7ayEUbuWgjF23koo1cdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUHueggFx3kooNcdJCLDnLRQS46yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootcdJGLLnLRRS66yEUXuegiF13kootc9JCLHnLRQy56yEUPueghFz3koodc9JCLHnLRQy56yEUPueghFz3koodc9JCLHnLRQy56yEUPueghFz3koodc9JCLHnLRQy56yEUPueghFz3koodc9JCLHnLRQy56yEUPueghFz3koodc9JCLHnLRQy56yEUPueghFz3koodc9JCLHnLRQy56yEUPueghFz3koodc9JCLHnLRQy56yEUPueghFz3koodc9JCLHnLRQy56yEXvtfZk9P0Sy3zM95w96nswabBosGlwaHBp8GDwNQH9TNBo0GmQNudoc44252hzjjbnaHOONccfjwcNGg06DQYNJg0WDTYNDg0uDdLmGG2O0eYYbY7R5hhtjtHmGG2O0eYYbY7R5jhtjtPmOG2O0+Y4bY7T5jhtjtPmOG2O0+YEbU7Q5gRtTtDmBG1O0OYEbU7Q5gRtTtDmJG1O0uYkbU7S5iRtTtLmJG1O0uYkbU7S5hRtTtHmFG1O0eYUbU7R5hRtTtHmFG1O0eY0bU7T5jRtTtPmNG1O0+Y0bU7T5jRtTtPmDG3O0OYMbc7Q5gxtztDmDG3O0OYMbc7Q5ixtztLmLG3O0uYsbc7S5ixtztLmLG3O0uYcbc7R5hxtztHmHG3O0eYcbc7R5hxtDjVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzVkp4bs1JCdGrJTQ3ZqyE4N2akhOzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0Nuakh908Ysj1eBp0GgwaTBosGmwaHBpcGDwZ/wpC/CNLmNG1O0+Y0bU7T5jRtTtPmNG1O0+YMbc7Q5gxtztDmDG3O0OYMbc7Q5gxtztDmLG3O0uYsbc7S5ixtztLmLG3O0uYsbc7S5hxtztHmHG3O0eYcbc7R5hxtztHmHG3OwebM40GDRoNOg0GDSYNFg02DP9Gc+w/BP/7NRz9/J/nLBz9/uf3+sZHfz9gPnHHvP+MnEPs3n/ETMPf/O+NbcGhwafBg8DXMPd21v/3QPD/me7Dse85gzmEuYC5hrmCuYW5gbmHuWC5hXxL2JWFfEvYlYV8S9iVhXxL2JWFfEvalYF8K9qVgXwr2pWBfCvalYF8K9qVgXwr2pWFfGvalYV8a9qVhXxr2pWFfGvalYV8a9mVgXwb2ZWBfBvZlYF8G9mVgXwb2ZWBfBvZlYV8W9mVhXxb2ZWFfFvZlYV8W9mVhXxb25WBfDvblYF8O9uVgXw725WBfDvblYF+O9WUfD5gzmHOYC5hLmCuYa5gbmFuYg30x2BeDfTHYF4N9MdgXg30x2BeDfTHYF4N9cdgXh31x2BeHfXHYF4d9cdgXh31x2BeHfYG+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7+4Xvpv5PZc5r3IJcwVzDXMDcwtzx3Jf+O6PcwZzDnNf9KXmW+75R71XuYS5grmGuYG5hbljuS9898c5gzmHOdiXgX0Z2JeBfRnYl4F9GdiXhX1Z2JeFfVnYl4V9WdiXhX1Z2JeFfVnYl4N9OdiXg3052JeDfTnYl4N9OdiXg3051pd7PGDOYM5hLmAuYa5grmFuYG5hDvbFYF8M9sVgXwz2xWBfDPbFYF8M9sVgXwz2xWFfHPbFYV8c9sVhXxz2xWFfHPbFYV8c9iVgXwL2JWBfAvYlYF8C9iVgXwL2JWBfAvYlYV8S9iVhXxL2JWFfEvYlYV8S9iVhXxL2pWBfCvalYF8K9qVgXwr2pWBfCvalYF8K9qVhXxr2pWFfoO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQd4/5bjyY7z5zBnMOcwFzCXMFcw1zA3MLc7AvBvtisC8G+2KwLwb7YrAvBvtisC8G+2KwLw774rAvDvvisC8O++KwLw774rAvDvvisC8B+xKwLwH7ErAvAfsSsC8B+xKwLwH7ErAvCfuSsC8J+5KwLwn7krAvCfuSsC8J+5KwLwX7UrAvBftSsC8F+1KwLwX7UrAvBftSsC8N+9KwLw370rAvDfvSsC8N+9KwLw370rAvA/sysC8D+zKwLwP7MrAvA/sysC8D+zKwLwv7srAvC/uysC8L+7KwLwv7srAvC/uysC8H+3KwLwf7crAvB/tysC8H+3KwLwf7An3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX13oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvMd/PBfPeZM5hzmAuYS5grmGuYG5hbmIN9MdgXg30x2BeDfTHYF4N9MdgXg30x2BeDfXHYF4d9cdgXh31x2BeHfXHYF4d9cdgXh30J2JeAfQnYl4B9CdiXgH0J2JeAfQnYl4B9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"},{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[{"start":4,"end":24}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[24,25,26,27]},"bytecode":"H4sIAAAAAAAA/+2dy3LbNhSGQYrWjaJlybIk3+nGaTZdSLY8TTatumg3vUwXnSyyc2q59YwTdxylaV61b9FNl2kNhsf6eURpRAUnAWeEGY1IgAS+8xNXggR3lVKOeu8Kd781Ne0ofBj/9z7M9Q3G1ZPkdHLC6eaEs2CQU7O1lGw+9QR0Nc24lgPGYg4YSzlgLOeAsZIDxmoOGP0cMNZywBjkgHE9B4z1HDBu5ICxkQPGZg4YN3PA2MoB41YOGNs5YOwYZHSA0Yu3u3e/7bvfzt1v9+73zH3vX1YTF5piGPR/1X12Sryrkk73TVza8SZ+BeIGP+J3wY/uMRS8iQ1F4zb0Bjrekul447ECaVIGG82x9x+XQSeD7FKaRHmW8mIxjpvSWQOtKvG2wXsrfUzbiX8VSFPF14i2O2riKrBNeZq4a2qSLyszzvHYOQGEF1PsDg3bXQKWEPYpvbXYDu10/6jrJbk123q8/W5JtuePT573R/0nZxe985PLsycXp4Mz0oLSojywDn4Ufgase8BVN6/ZwId0yTlsP4TteopOBnn6Qnb2dLwbcVzLXtc0p+NogD4B0ymA8A3QriGgnQPpUty0j4wr3hUvpefHP2TV+1RHUhnXddE/zoQ3EOKdVX8Hyo60Beq8k6x18DrwbJjnOfUhjUV4MB8L1N19ITt7WO5MtwlNNX29yIYAwhugXVNAOwfSpbhpHxlXvHK8gZqUb2L1Ga8NjOSHfTzyG5rj6flqMvag+HX78hTSrZtP99QB/WkOrsxs9uCYf50J27PYrwbh2F6mXUupNn3WtWwAY53pK9luzupjoBYS+UhI4yifULkoztDYg2Mu43+ye17dVANdmqBPw7w+Ubu5KaRPi+lD/JugDx3zgunTStEH826THYd2DJW5fpeOd0tInzbTh/i3QB86Zsz0IX/UZxP0abHjpMbivkqWbe0W7Ze2hXiy9EtRH4HrHPG0M/BsAU9HiGcrA08HeLpCPJ0MPHgPeVuIp5uBZxt4doR4tjPwEINuP3gbq/+pbGCfjvJnC/woj7jgR9epAH6kFd4b7QLnUBnRoReADpgHJOrmrJpLl1khO6MxKNZN28wezBvYT5Ootx2VrJdC2EfGRXmbOeNtWcArlc+E+h6nOs4K6LrO9EW7ds2nf5K177MLPBJthZCdUT2xB3bUmT0BhGM7sCdgowPpUty0j4yL8rYt4BVK+4TKR52lt8X00OkfCKSfte97ADz75nn6QnZG5eMQ7GgzewIId8HGQwEbHUiX4qZ9ZFyUd9cCXqHrFj3XEZqP977cYTuuZtj1QCB9Xe6OVNLNK3cPgOcz8zx9ITujcncMdhwxewIIL4CNxwI2OpAuxU37yLgo76EFvELX7VTH+9B8vPfljnR9yPRFux7F26bn9D6P49L9IMpzj8CPwg9h3uBv4DoS0NtXyWut3bz64Ah4pOoDATt73I4HzJ4AwnE8GwrY6KhkHRwym1XK9jzeZs54WxbwSuUzof7I/XiWdD1g+qJdAv3jzM+Y7ANPyzxPX8jOqfFswOz52OPZfZXUl/ZnjWfn8YYW8EqPZwOW3hHTQ2huICofoUq6eeVDem5AyM6ofHRTbKK08L4/jmcl5occlbwXH6rpeYAsvPsW8Apdt4HQ/MN9uQvj+DpMX+H5mKjcYZ2j3bxyh/MxEvfSJedjNsGOfWZPAOE4nhV4fmPufAEyLsrbtYBXar5Q6Bmj+3JHujaYvmSXrybvrpCfHlf+4kzsXo0rl3fcjtW48tPxrsaVmd1qXJl0q3El+K/GlatxJXOrcSX4r8aVn35cif1b8sP+rQ6vxv74DvfTOBzbHuzvCMxt9eeVW5znI+daxrNrGY9vGU/NMp6KZTxFy3hKlvEULOMRfhYlM0/ZMp6qZTyeZTzCz4pk5lmzjMexgMdX0+MJvHfXBD+Xnavrzy/cSTj1c104h8ZLBfCjcYkHftSvWwM/6s8VU7j2wY/uF+6BH43PdsAvjLe3wY/ud3RT0sXrI/E+kcPSCmGf0qsBh/T7TYvyrFnGc2wZj2cZT9UynrJlPIeW8RQs4ylZxlO0jKdiGU/NMh7fMp5dy3hcy3iaKTwC95KjOWJc64K40IWwvSOsj5CdU3M/TWYPzqXgmFJqLmVHJfWl/VlzP/N4D3LGG1rAK5XPhOYu7+eISdd9pi/aJTAXMMBxGrl59QSuSxGa5+kL2Tn1zv0BswffCcd78VLvhHeYvrQ/6x32ebyHOeM9zhnvngW8uBboAfjV4BztcC1QfP7Dh396X78Gfi7YTX40VqLjKyq/a6y5KrnemnbvGOeHvJN2yZzmpDq9FMc9b50yugB1lVyTLVSmtOsPkInWvioznZDJAyalkv1JnG/SrgZ24Vzvx1rjjDjS1jirMm0Fnm06FbI1+v4grktWT7GTwuuxnboOaMC9Y7oeuF5wmBJObl77j88BSrTTOI6ia9tJSXsbWA2lPTWGc9T0MxEebB9SpamSz4iQzsSty0Y75TjcbrJzcN2ldordofo47Q/OHbQgf1H+kamr3uf7doo+ZdCHwnEdWdJ+qMzqg+vNDIED20K+dqQPbNguSqx356jk2uahmn5uPW19c1zvlWzk671KfNsD+xfk5tU7OL9o/Bsm8Xf2qE79bTT+6fX19dXl1ej2+9Hbn8+vbh1AJGyPYTsqaQIP185N8ROSOMoSnkrK6aXISU35UJkdLgt8uiXqwlB2peaB+EugOx3zmHVhyF+7AsSjXY3pQv8l8/pEw1yBz6xE+lSZPvwzKx4c8zXTh/xRH/zETJkdh3YMlblHFHW8vpA+NaYP8fugDx3zHdOH/FGfCoRV2XFox1CZ7W4KLBkd6bPO9OGfoMBluH9k+qyn6OODJvzTFTgcxUcbKC18ZIGXYRx2VsEPh4Hk56aki8tpkh/Vj3XwIwZsMqnOoLR0HuDNl9GKnM9bqjhBNw6j7xZpsJKaFMyqmtwnoHVI67ExGl73VXS7p/vWup+g+1TYF5z1TbcqMJAbxf/UZ/zm9vb8bXj18mL0V3jzehzeXIbPb16/vHiFJ10vc9KrZU76L96h2znn4/HoxR/jcHwTnl9chG+uxr+HN3+Obi+vb97geQV3icQqy5z05TInfbXMSd8uc9IPi56k/gf5Is/iqn8AAA==","debug_symbols":"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"},{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284]},"bytecode":"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","debug_symbols":"3ZjdiloxEIDf5VyLzG8m8VVKL2xrQRB3WaVQxHdv/ElOtMG0R3A9Xu0emBm/TOYvs+tWb9/n2+XbetPNdh1iN/uy6zbv8/Xhc7Odf2y7GUy6xfpH/LufdD+Xq0U3E7ef/CWGGs6C6DGLIkpFlljsLEwCkqUJtGYZ0RIEYtS9kP866ZBGys2P4haPiVsF7+aWO7gVnDtLKoLLwq6KAkCJBKg4ZuCKtIQkrGQFNByhdYzQbozQVoMWTPEq4m+DUzBN4RqK4CY62fdV++qTfdPb9gMm88H1KAg2KBnCM9EQ3EmDIJx/AKDB84+R6CmVH8/lEU/IOD5kGh8yjw9ZbiMrhGYdSWWKAfHCfq25+765B9+Qbmei3knPkJ3D4Fr0YibpKj1QWewPMO6ZYOxumP5ekVo35SWxeN+jKNVCAEJqUlQa1loP9JbyIYDeFkXC5D0kpYuGNiS0/Es4MOTxBAFdw4NNn4SH+iTOUz7jhFB6JcIwfBpMdPs1DD4WhkgzTDHQVONFhFyeClWuCgXTaMn5weQhBwALN3JUCHKfE9coRuJTlVPuq5zJ8ZTyKqc0TCXOClmrvaVDXgHEMagsQzikbLG+igtdfhKak9suxJDfmtENdPF+HOJD9zJhaCm2PNh1stkzn1JTMSRn2DglW8jLg2ITYKfdwbSaEXmswKK/WTh1/ilW+y15zsOId3y9Rjjo4UC9amPSXERcMfNGdxwbwrS+KGBJbubizXG+cp7W3/MtJRyiREOU+L+VbFp/GSkn76nRVVQclNwQpWrOOIacZX2sWlSKH7/mH8v5t9XisBCPn9vf76d/938A"},{"name":"setNumber","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327]},"bytecode":"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","debug_symbols":"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"}],"events":[],"file_map":{"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"34":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"46":{"source":"contract BoxReact {\n    use dep::aztec::prelude::{AztecAddress, PrivateMutable, Map, NoteInterface, NoteHeader};\n\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        numbers: Map<AztecAddress, PrivateMutable<ValueNote>>,\n    }\n\n    #[aztec(private)]\n    fn constructor(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).initialize(&mut new_number, true);\n    }\n\n    #[aztec(private)]\n    fn setNumber(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).replace(&mut new_number, true);\n    }\n\n    unconstrained fn getNumber(owner: AztecAddress) -> pub ValueNote {\n        let numbers = storage.numbers;\n        numbers.at(owner).view_note()\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/boxes/boxes/react/src/contracts/src/main.nr"},"47":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/log.nr"},"51":{"source":"use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"52":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"53":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"65":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn is_deployment(self) -> bool {\n        // TODO(#4738): Implement this\n        false\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"71":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"74":{"source":"use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr"},"77":{"source":"use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"79":{"source":"#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/rand.nr"},"83":{"source":"use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr"},"92":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr"},"105":{"source":"use dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note}, note_getter::{get_note, view_notes},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::{nullifier_key::get_nullifier_secret_key, notes::check_nullifier_exists};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateMutable<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateMutable<T> {}\n\nimpl<Note> PrivateMutable<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<N>(self, new_note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note<N>(self, broadcast: bool) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr"},"107":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"114":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr"},"193":{"source":"use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"199":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr"},"200":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"201":{"source":"use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/public_keys_hash.nr"},"205":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS,\n    GENERATOR_INDEX__CONTRACT_ADDRESS, GENERATOR_INDEX__NOTE_HASH_NONCE,\n    GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"220":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}