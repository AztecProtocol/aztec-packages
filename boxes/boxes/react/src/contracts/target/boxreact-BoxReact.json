{"noir_version":"0.24.0+cbc257eff25e8b2370e6ec25ec7ddc34f6c03ac4","name":"BoxReact","functions":[{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284]},"bytecode":"H4sIAAAAAAAA/+2dB3gcxRmG53Sn80my5Io7yabHNth3ujvrBKYYY1NsjLHp/eQ7yQJJZ05nG9F7751UQnpIIb0nhPSQQnpCGiG9k96d/J+06xvW58dJ9K/DPJ/neb7berPzzu7+U3dmXsyYmAgOiyZRXORZ2wl/PdhuDm0nQ9sTQv9vCW1PDW1PD23PCG3PCm3P8bdt5yOYg/1lNr0klyt3dZYz2Uwx3dndU8inc/meJYVMIZMv5EudhWy2XMgVurp7urvS3ZlctpzpzXdne9NjbqHlV3qcDmFLWWGeL9omWuAvF5It9/EVjpd9SOPDjpd9zdj7FzzPtgs/4+nxuYyiX2k7vIvMmI2ASzYIf+DiDdZT1nnblFnta4XDMrlBOHe4BwcrBiaKm7koAn8XGz2jGhX3Yv17lI43eCBG/TVjCRpcytrvaV07l86MvjQJ09AhcQ1erjbrvCZ/32RrXxDuVlGHv95Xrq0rDpUqgyv7ywMlm6ypAW3Y4Yrx0Plt1npwrMVE/PqYUGADv8f7iGYUwxmkb0HkwG873YfrNLvP3neaaOx91uyx97sMTBQ3MxuBvznz9Lb34M7p36O0afBARBGn6XG6wKgEYUR84MXBi5c3T3VNyhwTFJ+NJUbX0IIVfnqmXrAIjEy4wJU2dQPcZZ3fFIrTLuu8gu9fo2T56WyoGwT3f/K7p9DZkylnuvOldLFTbmQpm8vHzFONehRxMT+CuNAO4wIHwpg2btjKgokmk9Jt6ol+RPn2LjvfbmeE4OxccnCOnZuOJephS+iHrRP+Nmv7K/erzWJt9gOOdKLV4k42KKMkQ2WUlP8/7fDFLO7A72A7uB7COsVfH6rU+ntHllfLxVq5tKZSK9sPUfAHe5+dIDRZ63Hr3ERoH1yywf+D82MN/IFDZKZCYbEfrODY/634lR6fy3SbaKyUdk7Izr2MNye0n9HPCcFPz+y+oqVmCmgXx4KHf3/RUtEBor39fRFZ8ZxtxcNx18iK40WcZoUpAuudich6ZyOyuttLKXBJ3+/gOs1WXAU1aTGj+w6kLH9jZscau4S1PtXUXYu1HtznINwTTd1ot+zkP4nQf9qt48kG3J4y9wQrLJ61HVyv2dqHVDjIddjVMVE8Z3ZOJ3Dhd8uz1u1nRP19krhCih/YEakRXbu5Z6B/w6ryyLKh0tpitdZfHFhWKlXLw8ONjFE8BLCzFHtXlattFmjc2hfOGdhGx676Df5jP5SRpfrhMjIsMsrGS/3lXNGBZsey9IH+8QP85STRQaEwhlPn8aaoiqlR5iA9v0bbFMLlAmP0U2NFaxppWc+Veo4o42B/R+7VUqObO9hTb8RXb2QnmLbNX2bqbbgR5eqLdq7evgbcf1o301Y/bJqsfdsTcWvf9kTcuqZ6TjuXzqdMnUfNX7+uf7aphz2CUk0hotxm555SzVinucAxlGra/XWUalKh+sYowxa2V6lQ2FpNvd65PNhfWzG0oTqySeoWV1f67My6/cyYUNzaLHB22mlXHzY3+K8df+ECQyO3s8IMuCb6657Re1dhK1sbhMF2nrU+0QpPm354MhFxjqbP7RZHa4in3Tpuv9ftETDGrOsGftvhCF9bsWPGaDx07CIeOhqEpWM3x0NwvTZrn92mYR8Plk0hFjsPEZwfedW8dgYQxmOx0e9pdYjRz/wao1/Vr8m83BHmmCLzoY4wNykyr3CEOa7IvNIR5oQi82GOMDcrMh/uCHNSkfkIR5g1O+gd6QjzvorMqxxhXqjIvJqQ+ShC5jWEzEc7wnyIIvNawvt8DCHzOkLm9YTMxxIyH0fIfDwh8wmEzCcSMp9EyHwyIfMphMynEjKfRsh8OiHzGYTMZxIyFwmZewiZNxAylwiZy4TMvYTMfYTMGwmZ+wmZzyJkPpuQeYCQeZCQeYiQuULIvImQ+RxC5ioh8zAhc42QeTMh8xZC5q2EzOcSMo8QMp9HyHw+IfMFhMwXEjJfRMh8MSHzJYTMlxIyX0bIfDkh8xWEzFcSMl9FyHw1IfM1hMzXEjJfR8h8PSHzDYTMNxIy30TIfDMh8y2EzLcSMt9GyHw7IfMdhMx3EjLfRch8NyHzPY4wFxSZ73WEWXNaqxc5wqz5bL+YkPklhMwvJWR+GSHzywmZ7yNkfgUh8/2EzK8kZH4VIfOrCZlfQ8j8WkLm1xEyv56Q+Q2EzA8QMr+RkPlNhMxvJmR+CyHzg4TMbyVkfhsh89sJmd9ByPxOQuZ3ETK/m5D5PY4w5xWZ30t4n9/nCLPmnF3vJ7zPHyBk/iAh84cImT9MyPwQIfNHCJkfJmT+KCHzxwiZP07I/AlC5k8SMn+KkPnThMyfIWR+hJD5s4TMnyNk/jwh8xcImR8lZP4iIfOXCJm/TMj8FULmrxIyf42Q+euEzN8gZP4mIfNjhMzfImT+NiHzdwiZv0vI/D1C5scJmb9PyPwEIfMPCJl/SMj8I0LmHxMy/4SQ+aeEzD8jZP45IfMvCJl/Scj8K0LmXxMy/4aQ+UlC5t8SMv+OkPn3hMx/cIR5P0XmPxLe5z8RMv+ZkPkvhMx/JWT+GyHz3x1hTiky/8MR5hZF5n86wtyqyLzNEeY2ReZ/OcI8UZHZxNxgbldkjjnC3KHI3OQI8yRF5rgjzJMVmROOME9RZG52hHmqInPSEeZpiswTHGGersiccoR5L0XmFkeYZygytzrCPFORuc0R5lmKzBMdYZ6tyNzuCPMcReYOR5jnKjJPcoR5niLzZEeY91ZknuII8zMUmac6wvxMReZpjjB7iszTHWF+liLzXo4wP1uReYYjzM9RZJ7pCPNzFZlnOcL8PEXm2Y4wP1+ReY4jzC9QZJ7rCPMLFZnnKTKLVybu+7XQ4o/5cYBjCVGzKCnC2OloS0fbMtpa0faItji0TaGtBm0XqMtH3TbqelH3ibpA1I2hrgh1J6hLQNkaZU2UvVAWQd4ceVXk3TwR0nakdbD9sIWwDXhX8OwgLueLFljhfcxfLhcdKlohWik6THS46AjRkaJVotWio0RrREeL1oqOEa0TrRcdKzpOdLzoBNGJopNEJ4tOEZ0qOk10uugM0ZmioqhHtEFUEpVFvaI+0UZRv+gs0dmiAdGgaEhUEW0SnSOqioZFNdFm0RbRVtG5ohHReaLzRReILhRdJLpYdInoUtFlostFV4iuFF0lulp0jeha0XWi60U3iG4U3SS6WXSL6FbRbaLbRXeI7hTdJbpbdI/oXhHml8d865h/HPNxY35qzNd8nwjz+d4vwnyvmP8U84FifkzMF4n5EzGfIObXe0CE+dcwHxnm58J8VQ+KMJ8R5vfBfDeY/wXzoWB+EMyXgfkjMJ8C5hfAePsYfx7jsWN8cozX/ZAI4zk/LMJ4vxj/FuPBYnxUjBeK8TMxniTGV3xEhPH3MB4dxmfDeGWPijCeFcZ3wnhHGP8H4+FgfBiMl4LxQzCeBp4xjLeA8QfwPT6+T8f32o+L8D3vEyJ874nvH/E9IL6Pw/di+H4K3xPh+xp8b4LvL/A9Avrno7/6kyL0Z0b/XvR3Rf9P9IdE/0D0l0P/MfSnQv8i9LdB/xP0x0D/BLTX42VFey7aN9Heh/YvtAehfQTtBag/R30y6ldR34j6N9RHoX4G9RUov6M8i/IdyjvI/yM/jPwh8kvIPyA9RfoCewv7E9gMuJn+cqm/XF+rVIt9ZW94oFLz0t6Q/BYHBipby6VFnn1s2BvcPFzzhmvFas3rrVYGvcwi/H+O7888f1ms1cqDm2pereIVSyVva39to1fZUq72ip847v035/8bcjLtVH8DAQA=","debug_symbols":"3ZjbjtowEIbfJdcIeQ6e8fAqVS9ou5WQELtaUKUK8e5NADuGdeM2SCzhCiL9M3wZ5mTvm/Xr9+Vu9brZNot9A9Asvuyb7dty0z1ud8v3XbNws+Zl86P9PMyan6v1S7NgOcw+yMDbWQgBkhSAClok1rMY2XFSY/f9o2cAjRAAre2F/uusAZwoN92LmwNEbs9wMzffwO2dyVnpgSSJxZdQnMNI4jB7TcOCmi2KPWqmtSO0nyK0TBFaS9AeY756H4bB0dTHdLUsuRFO/kPRv4ToP/hh/8bRvVmPAk5GFYM9Eg26G2nAKaUfIFfh+cdMDD6mSxDLXJ6QYXrIOD1kmh4yDyML2LB3ci4ik2O88F8akhDSkESrqOuV6G+mT8EhZzV6Do7Pag6EebPvYOSRYPRWGOj/13YNqsAEjiwh9Ci+NNbQWRxSCNg3Y19aqkKqB3N+WAoIcf8C9Hgx0MakVniKAJpI2jhAKhGsxsTuGpO264WEY5ZHpYUh92kwbdivYeC+MIg+wUgYzhdmH3OAOfBVoyCcLDndmdxSAhBTpUYZXTrEslSaUdu/44ZAfZfTY80RP8tbKsQWp5lWubiuayr8iysAN6ZtkX+WEEo6EqrwcAjB0lkTXTYOj410RAzladJQY24Fp9fFpo/8lqkZoihU3pI03QRkKwLr6e5gXqyItFZANt/UTpN/DsV5i4HSMhKErq8ROjsYaVceTGlPkmznbcNxHAjz8kUBcQwzZaf/819O8/J5vmYEY4xwjBH9t5HO/3Iyohg9r3iVFZ2RjDEq1oyQS1XW56q2Ru3Dr+X7avlt/dJdiLePu99vp6+HPw=="},{"name":"setNumber","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327]},"bytecode":"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","debug_symbols":"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"},{"name":"getNumber","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"owner":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"struct","path":"value_note::value_note::ValueNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"kind":"struct","path":"aztec::note::note_header::NoteHeader","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"is_transient","type":{"kind":"boolean"}}]}}]},"visibility":"public"},"return_witnesses":[1,2,3,4,5,6,7]},"bytecode":"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","debug_symbols":"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a0mxlhRrSbGWFGtJs5Y0a0mzljRrSbOWNGtJs5Y0a0mzljRrybCWDGvJsJYMa8mwlgxrybCWDGvJsJYMa8mylixrybKWLGvJspYsa8mylixrybKWLGvJsZYca8mxlhxrybGWHGvJsZYca8mxlhxqSTweLGYs5iwWLJYsVizWLDYstizGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5aEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1XhNS5uPxSy4z9itnj/wKJg0WDTYNDg0uDR4Mvgal3xI0GnQapM052pyjzTnanKPNOdqcY83xx+NBg0aDToNBg0mDRYNNg0ODS4O0OUabY7Q5RptjtDlGm2O0OUabY7Q5RptjtDlOm+O0OU6b47Q5TpvjtDlOm+O0OU6b47Q5QZsTtDlBmxO0OUGbE7Q5QZsTtDlBmxO0OUmbk7Q5SZuTtDlJm5O0OUmbk7Q5SZuTtDlFm1O0OUWbU7Q5RZtTtDlFm1O0OUWbU7Q5TZvTtDlNm9O0OU2b07Q5TZvTtDlNm9O0OUObM7Q5Q5sztDlDmzO0OUObM7Q5Q5sztDlLm7O0OUubs7Q5S5uztDlLm7O0OUubs7Q5R5tztDlHm3O0OUebc7Q5R5tztDlHm0MN2aghGzVko4Zs1JCff0WDRYNNg0ODS4O0OdSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbl/gyGnvQw6DQYNJg0WDTYNDg0uDR4M/gZD/iZIm9O0OU2b07Q5TZvTtDlNm9O0OU2bM7Q5Q5sztDlDmzO0OUObM7Q5Q5sztDlDm7O0OUubs7Q5S5uztDlLm7O0OUubs7Q5S5tztDlHm3O0OUebc7Q5R5tztDlHm3O0OQebM48HDRoNOg0GDSYNFg02Df68OfX4D8Hf/8VHP/8k+csHP3+7/frY+PWM/cAZ9/4zfgNi/81n/AaY+/+d8SM4NLg0eDD4GuaetPgj+BS4+QqWfeUM5hzmAuYS5grmGuYG5hbmjuUS9iVhXxL2JWFfEvYlYV8S9iVhXxL2JWFfCvalYF8K9qVgXwr2pWBfCvalYF8K9qVgXxr2pWFfGvalYV8a9qVhXxr2pWFfGvalYV8G9mVgXwb2ZWBfBvZlYF8G9mVgXwb2ZWBfFvZlYV8W9mVhXxb2ZWFfFvZlYV8W9mVhXw725WBfDvblYF8O9uVgXw725WBfDvblWF/28YA5gzmHuYC5hLmCuYa5gbmFOdgXg30x2BeDfTHYF4N9MdgXg30x2BeDfTHYF4d9cdgXh31x2BeHfXHYF4d9cdgXh31x2Bfouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5+47t5X7k8e5VLmCuYa5gbmFuYO5b7xnd/njOYc5h73Zd62I/c8yp5lUuYK5hrmBuYW5g7lvvGd3+eM5hzmIN9GdiXgX0Z2JeBfRnYl4F9WdiXhX1Z2JeFfVnYl4V9WdiXhX1Z2JeFfTnYl4N9OdiXg3052JeDfTnYl4N9OdiXY325xwPmDOYc5gLmEuYK5hrmBuYW5mBfDPbFYF8M9sVgXwz2xWBfDPbFYF8M9sVgXxz2xWFfHPbFYV8c9sVhXxz2xWFfHPbFYV8C9iVgXwL2JWBfAvYlYF8C9iVgXwL2JWBfEvYlYV8S9iVhXxL2JWFfEvYlYV8S9iVhXwr2pWBfCvalYF8K9qVgXwr2pWBfCvalYF8a9qVhXxr2BfruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeY78aD+e4zZzDnMBcwlzBXMNcwNzC3MAf7YrAvBvtisC8G+2KwLwb7YrAvBvtisC8G++KwLw774rAvDvvisC8O++KwLw774rAvDvsSsC8B+xKwLwH7ErAvAfsSsC8B+xKwLwH7krAvCfuSsC8J+5KwLwn7krAvCfuSsC8J+1KwLwX7UrAvBftSsC8F+1KwLwX7UrAvBfvSsC8N+9KwLw370rAvDfvSsC8N+9KwLw37MrAvA/sysC8D+zKwLwP7MrAvA/sysC8D+7KwLwv7srAvC/uysC8L+7KwLwv7srAvC/tysC8H+3KwLwf7crAvB/tysC8H+3KwL9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LvHfDcfzHefOYM5h7mAuYS5grmGuYG5hTnYF4N9MdgXg30x2BeDfTHYF4N9MdgXg30x2BeHfXHYF4d9cdgXh31x2BeHfXHYF4d9cdiXgH0J2JeAfQnYl4B9CdiXgH0J2JeAfQnYl4R9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"},{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[{"start":4,"end":24}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[24,25,26,27]},"bytecode":"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","debug_symbols":"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"}],"events":[],"file_map":{"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"34":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"46":{"source":"contract BoxReact {\n    use dep::aztec::{\n        protocol_types::address::AztecAddress, state_vars::{PrivateMutable, Map},\n        note::{utils as note_utils, note_interface::NoteInterface, note_header::NoteHeader}\n    };\n\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        numbers: Map<AztecAddress, PrivateMutable<ValueNote>>,\n    }\n\n    #[aztec(private)]\n    fn constructor(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).initialize(&mut new_number, true);\n    }\n\n    #[aztec(private)]\n    fn setNumber(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).replace(&mut new_number, true);\n    }\n\n    unconstrained fn getNumber(owner: AztecAddress) -> pub ValueNote {\n        let numbers = storage.numbers;\n        numbers.at(owner).view_note()\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/boxes/boxes/react/src/contracts/src/main.nr"},"47":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/log.nr"},"51":{"source":"use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"52":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"53":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"65":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn is_deployment(self) -> bool {\n        // TODO(#4738): Implement this\n        false\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"71":{"source":"use dep::std::option::Option;\nuse crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"74":{"source":"use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr"},"77":{"source":"use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"79":{"source":"#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/rand.nr"},"83":{"source":"use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr"},"91":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr"},"104":{"source":"use dep::std::option::Option;\n\nuse dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note}, note_getter::{get_note, view_notes},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::{nullifier_key::get_nullifier_secret_key, notes::check_nullifier_exists};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateMutable<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateMutable<T> {}\n\nimpl<Note> PrivateMutable<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<N>(self, new_note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note<N>(self, broadcast: bool) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr"},"106":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"113":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr"},"192":{"source":"use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"198":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr"},"199":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"200":{"source":"use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/public_keys_hash.nr"},"204":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"219":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}