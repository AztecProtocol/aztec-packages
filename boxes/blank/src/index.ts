// docs:start:imports
import { BlankContractArtifact } from './artifacts/Blank.js';
import {
  AccountWallet,
  AztecAddress,
  CompleteAddress,
  Contract,
  ContractArtifact,
  DeployMethod,
  FieldsOf,
  Fr,
  FunctionArtifact,
  PXE,
  TxReceipt,
  createPXEClient,
  encodeArguments,
} from '@aztec/aztec.js';

import { getInitialTestAccountsWallets } from '@aztec/accounts/testing';

// docs:end:imports

export const contractArtifact: ContractArtifact = BlankContractArtifact;

export const PXE_URL: string = process.env.PXE_URL || 'http://localhost:8080';
export const pxe: PXE = createPXEClient(PXE_URL);

let contractAddress: string = '';

// interaction with the buttons, but conditional check so node env can also import from this file
if (typeof document !== 'undefined') {
  document.getElementById('deploy')?.addEventListener('click', async () => {
    contractAddress = await handleDeployClick();
    // eslint-disable-next-line no-console
    console.log('Deploy Succeeded, contract deployed at', contractAddress);
  });

  document.getElementById('interact')?.addEventListener('click', async () => {
    const interactionResult = await handleInteractClick(contractAddress);
    // eslint-disable-next-line no-console
    console.log('Interaction transaction succeeded', interactionResult);
  });
}
// docs:start:deploy
export async function handleDeployClick(): Promise<string> {
  // eslint-disable-next-line no-console
  console.log('Deploying Contract');
  const [wallet, ..._rest] = await getInitialTestAccountsWallets(pxe);

  const contractAztecAddress = await deployContract(
    wallet.getCompleteAddress(),
    contractArtifact,
    [],
    Fr.random(),
    pxe,
  );

  return contractAztecAddress.toString();
}
// docs:end:deploy
// docs:start:interact
export async function handleInteractClick(contractAddress: string) {
  const [wallet, ..._rest] = await getInitialTestAccountsWallets(pxe);
  const callArgs = { address: wallet.getCompleteAddress().address };
  const getPkAbi = getFunctionAbi(BlankContractArtifact, 'getPublicKey');
  const typedArgs = convertArgs(getPkAbi, callArgs);

  // eslint-disable-next-line no-console
  console.log('Interacting with Contract');

  return await callContractFunction(
    AztecAddress.fromString(contractAddress),
    contractArtifact,
    'getPublicKey',
    typedArgs,
    pxe,
    wallet.getCompleteAddress(),
  );
}
// docs:end:interact
export const getFunctionAbi = (contractAbi: any, functionName: string) => {
  const functionAbi = contractAbi.functions.find((f: FunctionArtifact) => f.name === functionName);
  if (!functionAbi) throw new Error(`Function ${functionName} not found in abi`);
  return functionAbi;
};

export async function callContractFunction(
  address: AztecAddress,
  artifact: ContractArtifact,
  functionName: string,
  typedArgs: any[], // for the exposed functions, this is an array of field elements Fr[]
  pxe: PXE,
  wallet: CompleteAddress,
): Promise<FieldsOf<TxReceipt>> {
  // selectedWallet is how we specify the "sender" of the transaction
  const selectedWallet = await getWallet(wallet, pxe);

  // Note: when you start implementing the contract with more methods, it may be useful
  // to use the typescript class for your contract generated by the `yarn compile` command,
  // which provides an object with methods corresponding to the noir contract functions
  // that are named and typed and can be called directly.
  const contract = await Contract.at(address, artifact, selectedWallet);

  return contract.methods[functionName](...typedArgs)
    .send()
    .wait();
}

/**
 * terminology is confusing, but the `account` points to a smart contract's public key information
 * while the "wallet" has the account's private key and is used to sign transactions
 * we need the "wallet" to actually submit transactions using the "account" identity
 * @param account
 * @param pxe
 * @returns
 */
export async function getWallet(account: CompleteAddress, pxe: PXE): Promise<AccountWallet> {
  const accountWallets: AccountWallet[] = await getInitialTestAccountsWallets(pxe);
  const selectedWallet: AccountWallet = accountWallets.find(w => w.getAddress().equals(account.address))!;
  if (!selectedWallet) {
    throw new Error(`Wallet for account ${account.address.toShortString()} not found in the PXE.`);
  }
  return selectedWallet;
}

export async function deployContract(
  activeWallet: CompleteAddress,
  artifact: ContractArtifact,
  typedArgs: Fr[], // encode prior to passing in
  salt: Fr,
  client: PXE,
): Promise<AztecAddress> {
  const tx = new DeployMethod(
    activeWallet.publicKey,
    client,
    artifact,
    (a, w) => Contract.at(a, artifact, w),
    typedArgs,
  ).send({
    contractAddressSalt: salt,
  });
  await tx.wait();
  const receipt = await tx.getReceipt();
  if (receipt.contractAddress) {
    return receipt.contractAddress;
  } else {
    throw new Error(`Contract not deployed (${receipt.toJSON()})`);
  }
}

export function convertArgs(functionArtifact: FunctionArtifact, args: any): Fr[] {
  const untypedArgs = functionArtifact.parameters.map(param => {
    switch (param.type.kind) {
      case 'field':
        // hack: addresses are stored as string in the form to avoid bigint compatibility issues with formik
        // convert those back to bigints before turning into Fr
        return BigInt(args[param.name]);
      default:
        // need more testing on other types
        return args[param.name];
    }
  });

  return encodeArguments(functionArtifact, untypedArgs);
}
