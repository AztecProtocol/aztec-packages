{
  "name": "Blank",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "serialized_note",
          "type": {
            "kind": "array",
            "length": 0,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+1VQQ4CIQws7C5sheg/PGHiA/b/rxK0TSYsnuwejDZpgBaGYWggEpGjl03VZ9qb5jdpy2d2c3ZY5Uie/kt4ToY83YCng7po7VI9VI/VrxJn2tcOy1zEYlnbzEMsSn+Sts1ZjXUKwM0IswT7+ywM2sygkWqzDDQPA83jQPMVMC6Qp+5OzrKGbc92x7tWc914gz7D+Y6oh5Mt5rMekjFmw8igieqn3BPkE+iVjfVysKfi6hj5/bn+NleGGL5Bml8h5rtz4DuXAaN/I0w/T5INPGze7N2np/YAao7Tjj0JAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+XdZ2+TZxSHcSfEdvdu2BD2bu3Yju1OSvemk+6Ci9Pd0kl3Kd17TzpS9l6fkHMJI/ECXnFH4tZl6S9LefHIv9h+/Ixzn3O4UCiMFY4++iL9kYHI0HF/47G891w5tUe1GNsonmC7tcpIvd5tDnerteqaynC702pU6o3OSKvaqjZajbXDrVqt26q3mu1Ou1lpV+u1bnW00a6N9jZcTPcaK+PhLsU2SuPgLp3m7nJsozwO7nJid+Ekn/dTfZ0Tx+l19id+n/oSmidlYu5PaJ6ciXlCQvOUTMwDCc1TMzEXE5qnZWIuJTRPz8RcTmiekYl5YkLzTKF5SGieJTTPFprnCM1zheZ5QvN8oXmB0LxQaF4kNC8WmpcIzUuF5mVC82VC8+VCc0VorgrNw0JzTWiuC80NoXlEaG4KzS2huS00XyE0Xyk0XyU0Xy00XyM0Xys0LxearxOaVwjN1wvNNwjNNwrNNwnNNwvNtwjNtwrNtwnNtwvNdwjNdwrNdwnNdwvNK4Xme4Tme4Xm+4Tm+4XmB4TmB4XmVULzQ0Lzw0LzI0Lzo0LzY0Lz40LzE0Lzk0LzaqF5jdDcEZqfEprXCs1doXlUaH5aaH5GaH5WaH5OaH5eaH5BaH5RaH5JaH5ZaF4nNL8iNL8qNL8mNL8uNL8hNL8pNK8Xmt8Smt8Wmt8Rmt8Vmt8Tmt8Xmj8Qmj8UmjcIzR8JzRuF5o+F5k+E5k+F5s+E5s+F5i+E5i+F5q+E5q+F5m+E5m+F5u+E5u+F5h+E5h+F5p+E5p+F5l+E5l+F5t+E5t+F5j+E5j+F5r+E5k1C899C8z9C879C839C85jQ/L/QvFlo3pKJ+YyE5q2ZmM9MaN6WifmshObtmZjPTmjekYn5nITmnZmYz01o3pWJ+byE5t2ZmM9PaN6TifmChOa9mZgvTGjel4n5ooTm/ZmYL05oPpCJ+ZKE5oOZmC9NaD6UiXkwoflwQvNgbzt9PfOEyECkGClFyhHOCTlH4pyBY2iOKTnG4piD32B+k9hHs8/iO8xnmvd48Lj/56be86TI5MiUyNTItMj0yIzIzMhQZFZkdmROZG5kXmR+ZEFkYWRRZHFkSWRpZFmEGffMfOdNZCY4M7KZGc0MZWYKM2O3GWEGKzNJmdHJzEpmODLTkBl/x2beMRNtRYSZWcyQYqYSM4aYucMMGmayMKOEmR3MsGCmAzMO6Pm/MkJPeHqk0zOcHtr0lKbH8qoIPXjpSUuPVnqW0sOTnpb0eKTn4eoIPfE6EXqm0UOMnlr0mKLnEj2I6MlDjxp6ttDDhJ4e9Lig58O6CD0BWCPPmnHWULOmmDW26yOswWRNImv0WLPGGi7WNLHGhzUvGyKsidgYoWaeGnJqqqkxpuaWGlRqMqlRpGaPGjZquqhxouaHGhhqQqiRoGaAe+jcU+YeK/ccuQfHPSnu0fCZ4Bo+17S5xss1z7EI18S4RsQ1E64hcE7NOSbnXJyDcEzOMSrHbBzD8JvObxz7fPaB7BP4jhx7HAEN+DJJTJoAAA==",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "getPublicKey",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "address",
          "type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+Xd93MTRxQH8LUqTjGQZgOGmN4M3KlYp1Sb9JDidNKxkEycOITYJoFUQnonPYEUQiop9A5/G8P7ju+GHSH4Re8Ydr438+Y8Ap/3c/1Ou++dMMbsNONTi0RCIiXRZX2GqTece81NflqWkW6w3LzXUyjUSrman/cHvFy5EhS9QrHSE/iBXwyK1VyQz9eCQlAqV8olr+wX8jV/sFjOD4YLTuu10YvDnZFlZGJwZy5wd1aWkY3BnVV2m7Ps7822s0OxnS3huuwKl9cucVKig3TeLTEl3GZYL5PC9TLlAmjXVImkOb0/2ZP2MdZudPexqI3J8OdpEp0S0yUmh5+1mvFrhT1lrJ97ldrT6JzpNTnZbY/muH5kLZup+/e20JfWbUu+1VrPxlr3psG6NNbfR1tSum3xJ5jxbYxpTW2sf31leGj1itrGvrXV/oGRsaGB4b5qdaQ2OtpoJ0k2aHzCWqGZuv+Hz6IVnrI+S1jA6LPod7LW/IwDq1dpLURnE3vvx1HdGc6nh/OJEjPq2pBUbot9ZDd7JZqhuKyr9Yze+TpLarbZbm+XOb0DJxrsCzGcwXxT93fq11+bifEAiWvjdMWw3JlGb6ePyz1Tfxud85bWa25SX6fRlFBuZ4tiO2fFtG20zQlF82xHzElF8xxHzClF81xHzGlF8zxHzBlF83xHzFlF8wJHzFMVzQsdMU9TNC9yxNypaF7siLlD0dxNaF5CaF5KaF5GaPYIzT6hOUdozhOaC4TmIqG5h9BcIjQHhOYyofkaQvO1hObrCM3XE5pvIDTfSGjuJTT3EZqXE5pvIjTfTGi+hdB8K6H5NkLz7YTmOwjNdxKaVxCa7yI0301ovofQfC+huZ/QfB+h+X5C8wOE5gcJzQ8Rmh8mND9CaF5JaH6U0PwYoflxQvMThOYnCc1PEZqfJjSvIjQPEJorhObVhOYqoblGaB4kNK8hND9DaB4iND9LaH6O0DxMaH6e0LyW0PwCoXkdoflFQvMIoXmU0DxGaF5PaH6J0PwyoXkDoXkjofkVQvOrhObXCM2vE5rfIDS/SWjeRGh+i9C8mdD8NqH5HULzu4Tm9wjN7xOaPyA0f0ho/ojQ/DGh+RNC86eE5s8IzZ8TmrcQmr8gNH9JaP6K0Pw1ofkbQvO3hObvCM3fE5p/IDRvJTRvIzT/SGj+idD8M6H5F0LzdkLzr4TmHYTm3wjNvxOa/yA0/0lo/ovQ/DeheSeh+R9C87+E5v8Izf87Yp6gaN7liLlV0bzbEfNFiuY9jpgvVjTvdcR8iaJ5nyPmSxXN+x0xtymaDzhinqhoPuiIeZKi+ZAj5smK5sOOmC9TNB9xxHy5ovmoI+YrFM3HHDFfqWg+7oj5KkXzCUVze7icltCclEhJpCUyElkJPBPiGQnPDLiHxj0l7rFwz4FrMK5JOEfjnIVjGPs0tjHM7dY63RbOZ0nMlpgjMVdinsR8iQUSCyUWSSyW6JZYIrFUYhmsEr5EDutQoiBRlOiRKEkEEqj7jjroqAuOOtmoG406ylFdYdSdXS6BuqSo04m6lajjiLqGqPOHuneoA4e6aKgThrpZqCOFukr9Eqi7gzo0qMuCOiWo24E6FqjrsFICef+RBx954ZEnHXnDkUcbeaVXSSDvcEUCeWmRpxV5S5HHE3ktkecReQ+RBxB58ZAnDnnTkEcMebXWSSDvEvIQIS8P8tQgbwvymCCvxwYJ5H1AHgTkBcA4eYwbxzhqjCveJIFxp5slMC4R4/Qwbg3juDCuCeN8MO4F40AwLgLjBNBvHv3I0a96iwT63aIfKvplop8i+u2hHxv6daGfE/r9bA23NfpJoN8AvkfH98rbJfC94w4JfC+F72nwvQXe4+O9Nt7z4r0n3gPivRjeE+G9Cd4j4Lkaz5l47sJzCO7LcZ+K+zbcx+C6jusczvs4D+K8gOMkmk4ByAfBcyOlAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "eJzVk90KwjAMRt8l10OaNG3avYp4MfwBQaa43Y29uw7sphgnOJR5tQ7OFw4fSQOH47qo98eygrwBhnzZQHUqyu6vqotzDbnJYFturt82g93+sIUc2+yJImPcDSRD0rNRhS1Jgm3gHhavwIgO+UZf3xLu8VUG7h+l/a+k2WOCHeE0adGkrU0R62RUnCX15ygOJHE3O0yb7X0qT5AfZiudCKWp0Q310QeNxGnW0m+U3JOqdfBpaohDe4ydBpqZeOBMPGgmHvZbHt01LvR7dOkS2JjnjH5n4xl9y8czL1byTUjfn9ehtr0AB5T6FQ=="
    ],
    "fileMap": {
      "1": {
        "source": "contract Blank {\n    use dep::aztec::{\n        abi,\n        oracle::{\n            get_public_key::get_public_key,\n        }\n    };\n    use dep::protocol_types::address::AztecAddress;\n\n    #[aztec(private)]\n    fn constructor() {}\n\n    #[aztec(private)]\n    fn getPublicKey(address: AztecAddress) -> [Field; 2] {\n        let pub_key = get_public_key(address);\n\n        [pub_key.x, pub_key.y]\n    }\n\n    // A function which needs to be implemented by every contract working with storage. Replace it's content with your\n    // own logic once you start working with private storage.\n    // TODO: Remove this placeholder once https://github.com/AztecProtocol/aztec-packages/issues/2918 is implemented.\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: Field,\n        nonce: Field,\n        storage_slot: Field,\n        serialized_note: [Field; 0]\n    ) -> [Field; 4] {\n        [0, 0, 0, 0]\n    }\n}\n",
        "path": "/mnt/user-data/charlie/aztec-repos/aztec-packages/boxes/blank/src/contracts/src/main.nr"
      },
      "41": {
        "source": "use crate::utils;\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn default() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n    \n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n\n    pub fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n\n    pub fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n\n    pub fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl EthAddress{\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn default() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn to_field(self) -> Field{\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n\n    pub fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n\n    pub fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n\n    pub fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\n",
        "path": "/protocol_types/address.nr"
      },
      "76": {
        "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::point::Point;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::utils::uint128::U128;\nuse crate::utils::uint256::U256;\nuse crate::utils::bounded_vec::BoundedVec;\nuse crate::constants::{\n        ARGS_HASH_CHUNK_COUNT,\n        ARGS_HASH_CHUNK_LENGTH,\n        CONTRACT_TREE_HEIGHT, \n        FUNCTION_TREE_HEIGHT, \n        NOTE_HASH_TREE_HEIGHT,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK,\n        GENERATOR_INDEX__CONSTRUCTOR,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__COMMITMENT_NONCE,\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value : Field, index : Field, sibling_path : [Field; N], root : Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf : Field, leaf_index : Field, sibling_path : [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(selector : FunctionSelector, is_internal : bool, is_private : bool, vk_hash : Field, acir_hash : Field, function_leaf_index : Field, function_leaf_sibling_path : [Field; FUNCTION_TREE_HEIGHT]) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage{\n        selector: selector,\n        is_internal : is_internal,\n        is_private : is_private,\n        vk_hash : vk_hash,\n        acir_hash : acir_hash,\n    };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root =\n        root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(function_tree_root : Field, storage_contract_address : AztecAddress, portal_contract_address : EthAddress, contract_leaf_index : Field,contract_leaf_sibling_path : [Field; CONTRACT_TREE_HEIGHT]) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address,\n                                    portal_contract_address,\n                                    function_tree_root };\n        \n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root =\n        root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n    \n    computed_contract_tree_root\n}\n\npub fn read_request_root_from_siblings(read_request : Field, leaf_index : Field, sibling_path : [Field; NOTE_HASH_TREE_HEIGHT]) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address : AztecAddress, inner_commitment : Field) -> Field {\n    pedersen_hash([\n        address.to_field(),\n        inner_commitment,\n    ], GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn silo_nullifier(address : AztecAddress, nullifier : Field) -> Field {\n    pedersen_hash([\n        address.to_field(),\n        nullifier,\n    ], GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\nfn merkle_hash(left : Field, right : Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk : VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address : AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(contract_address : AztecAddress, rollup_version_id: Field, portal_contract_address : EthAddress, chain_id : Field, content : Field) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(function_data : FunctionData, args_hash : Field, constructor_vk_hash : Field) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash([\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ], GENERATOR_INDEX__CONSTRUCTOR)\n}\n\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256 : Field = 2;\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input : [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0;64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(previous_log_hash : [Field;2], current_log_hash : [Field;2]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256([\n        U128::from_field(previous_log_hash[0]),\n        U128::from_field(previous_log_hash[1]),\n        U128::from_field(current_log_hash[0]),\n        U128::from_field(current_log_hash[1])\n    ])\n}\n\npub fn compute_partial_address(contract_address_salt : Field, function_tree_root : Field, constructor_hash : Field) -> Field {\n    pedersen_hash([\n        // TODO why the zeroes?\n        0,\n        0,\n        contract_address_salt,\n        function_tree_root,\n        constructor_hash\n    ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n}\n\npub fn compute_contract_address_from_partial(point : Point, partial_address : Field) -> AztecAddress {\n    let field = pedersen_hash([\n        point.x,\n        point.y,\n        partial_address\n    ], GENERATOR_INDEX__CONTRACT_ADDRESS);\n    AztecAddress::from_field(field)\n}\n\npub fn compute_commitment_nonce(first_nullifier : Field, commitment_index : Field) -> Field {\n    pedersen_hash([\n        first_nullifier,\n        commitment_index\n    ], GENERATOR_INDEX__COMMITMENT_NONCE)\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash([\n        nonce,\n        siloed_commitment\n    ], GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n\npub fn compute_unique_siloed_commitments<N>(first_nullifier: Field, siloed_commitments: [Field; N]) -> [Field; N] {\n    let mut unique_siloed_commitments = [0; N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = compute_unique_siloed_commitment(nonce, siloed_commitment);\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}",
        "path": "/protocol_types/hash.nr"
      },
      "91": {
        "source": "use dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n    },\n    contrakt::deployment_data::ContractDeploymentData,\n    hash::hash_args,\n};\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "92": {
        "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::GENERATOR_INDEX__CONTRACT_ADDRESS,\n    hash::pedersen_hash,\n};\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> AztecAddress {\n    AztecAddress::from_field(\n        pedersen_hash(\n            [pub_key_x, pub_key_y, partial_address],\n            GENERATOR_INDEX__CONTRACT_ADDRESS\n        )\n    )\n}\n",
        "path": "/aztec/address.nr"
      },
      "124": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\nuse dep::protocol_types::address::AztecAddress;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> Point {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key_x = result[0];\n    let pub_key_y = result[1];\n    let partial_address = result[2];\n\n    let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n    assert(calculated_address.eq(address));\n\n    Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/aztec/oracle/get_public_key.nr"
      }
    }
  }
}