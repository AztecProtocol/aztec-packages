{"noir_version":"0.24.0+78ef0134b82e76a73dadb6c7975def22290e3a1a","name":"Blank","functions":[{"name":"getNumber","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"owner":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"struct","path":"value_note::value_note::ValueNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"kind":"struct","path":"aztec::note::note_header::NoteHeader","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"is_transient","type":{"kind":"boolean"}}]}}]},"visibility":"public"},"return_witnesses":[1,2,3,4,5,6,7]},"bytecode":"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","debug_symbols":"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6LsFfbeg7xb03YK+W9B3C/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3j/muP5jvPnMGcw5zAXMJcwVzDXMDcwtzsC8G+2KwLwb7YrAvBvtisC8G+2KwLwb7YrAvDvvisC8O++KwLw774rAvDvvisC8O++KwLwH7ErAvAfsSsC8B+xKwLwH7ErAvAfsSsC8J+5KwLwn7krAvCfuSsC8J+5KwLwn7krAvBftSsC8F+1KwLwX7UrAvBftSsC8F+1KwLw370rAvDfvSsC8N+9KwLw370rAvDfvSsC8D+zKwLwP7MrAvA/sysC8D+zKwLwP7MrAvC/uysC8L+7KwLwv7srAvC/uysC8L+7KwLwf7crAvB/tysC8H+3KwLwf7crAvB/sCfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XXvtUhnrf85l+uMrd/uVa5gbmFuYO5Z77VK/Imcw5zAXMJcwB/sSsC8B+xKwLwH7krAvCfuSsC8J+5KwLwn7krAvCfuSsC8J+1KwLwX7UrAvBftSsC8F+1KwLwX7UrAvBfvSsC8N+9KwLw370rAvDfvSsC8N+9KwLw37MrAvA/sysC8D+zKwLwP7MrAvA/sysC8D+7KwLwv7srAvC/uysC8L+7KwLwv7srAvC/tysC8H+3KwLwf7crAvB/tysC8H+3KwL8f64o8HzBnMOcwFzCXMFcw1zA3MLczBvhjsi8G+GOyLwb4Y7IvBvhjsi8G+GOyLwb447IvDvjjsi8O+OOwL9F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQd/fX+G68ygXMJcwVzDXMDcwtzB3K3a/x3Zc5gzmHuYC5hLmCuYa5gbmFOdgXg30x2BeDfTHYF4N9MdgXg30x2BeDfTHYF4d9cdgXh31x2BeHfXHYF4d9cdgXh31x2JeAfQnYl4B9CdiXgH0J2JeAfQnYl4B9CdiXhH1J2JeEfUnYl4R9SdiXhH1J2Jdf4bvhf5n7/X/64O4fH9tTXx8a9nXEvf2IX6HGf/cR9vYjfoWh/ccjfuQW5o7l5gFzL/8Vtvf8+NcSll+5/CXnMBcwlzBXMNcwNzC3MHcs99rQfkUO9mVhXxb2ZWFfFvZlYV8W9mVhXxb25WBfDvbl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3Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeY7+aD+e4zZzDnMBcwlzBXMNcwNzC3MAf7YrAvBvtisC8G+2KwLwb7YrAvBvtisC8G++KwLw774rAvDvvisC8O++KwLw774rAvDvsSsC8B+xKwLwH7ErAvAfsSsC8B+xKwLwH7krAvCfuSsC8J+5KwLwn7krAvCfuSsC8J+1KwLwX7UrAvBftSsC8F+1KwLwX7UrAvBfvSsC8N+9KwLw370rAvDfvSsC8N+9KwLw37MrAvA/sysC8D+zKwLwP7MrAvA/sysC8D+7KwLwv7srAvC/uysC8L+7KwLwv7srAvC/tysC8H+3KwLwf7crAvB/tysC8H+3KwL9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3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"},{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281]},"bytecode":"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","debug_symbols":"3VjbjtowEP2XPCPkudkz/Eq1D7SlEhJiVwuqVCH+vUmDHS91kzYRlPC0G+nM4dhzPGPPqdq9flkft6/7Q7U6VQDV6tOpOryt983n4bh+P1Yrt6g2+6/13/Oi+rbdbaoV03nxGwzELkBQSFBwvoBFMrmAkQU7tEGJGZh95AYB9wH/sqgAZ6qb7qVbMIJR1Cbr5gm6iSXuIXHotHj3i1puR+1vRx1uR60lajG8hHiEfnq0kDxrmVOwdkrDbyV+TxD5Wfv5jSO9mWY+dGOche6h1MBENeACpR8gN6DnL/2iFC5AFU7QerWNYpydYpqdYp6dYhlQrDhUQzSVKIcf6Atgdi41G4B+8PAZ9BO1kyNO2sOAdg0hqlF1fFWLMTyQFp2spcsp8ECalDlJyXitlP7a0zH9wB1YSuZWja41sH4o1MTRKJjdvbB44xn2lT3D/pnGowYuqyQyqt2Ru+eW1DdVTWrM8k1ptMD/0oKA11rwrloQJWnx2m8WZUzGyh8kbY0gmqtwvq9wS9mnhq73eDKm7lafp4EyxBrPspB0i2xtJU+yyAAxlSHD+mLayafreacBNIyqV/5JNtCn11zw3L+BYC5i0eUTCB3VBSk8iwdDuv66cH3Q9IEXKTE/6AMMLJJCnOIIZvWV2znBslhPLE2Jsr4WpO33Syi2fFRK4yL1dD0yaOJgZFyxlYqPm+Czt4tvg3hZHlEQx22m7KV/yTgvy5OEoSAYE4Rjguifg3RZfsdJelNIwCtXNEF+TNAf6oJLh6zzaqDzS/3xff2+XX/ebZpJcv15/PHW/nv+CQ=="},{"name":"setNumber","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324]},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[{"start":4,"end":24}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[24,25,26,27]},"bytecode":"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","debug_symbols":"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"}],"events":[],"file_map":{"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}","path":"std/collections/bounded_vec.nr"},"31":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"contract Blank {\n    use dep::aztec::{\n        protocol_types::address::AztecAddress,\n        state_vars::{singleton::Singleton, map::Map},\n        note::{\n            utils as note_utils,\n            note_interface::NoteInterface,\n            note_header::NoteHeader,\n        },\n    };\n\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        numbers: Map<AztecAddress, Singleton<ValueNote>>,\n    }\n    \n    #[aztec(private)]\n    fn constructor(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).initialize(&mut new_number, true);\n    }\n\n    #[aztec(private)]\n    fn setNumber(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).replace(&mut new_number, true);\n    }\n\n    unconstrained fn getNumber(owner: AztecAddress) -> pub ValueNote {\n        let numbers = storage.numbers;\n        numbers.at(owner).view_note()\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/boxes/blank/src/contracts/src/main.nr"},"44":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/log.nr"},"48":{"source":"use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{\n        MAX_READ_REQUESTS_PER_CALL,\n        GET_NOTE_ORACLE_RETURN_LENGTH,\n        GET_NOTES_ORACLE_RETURN_LENGTH,\n        MAX_NOTES_PER_PAGE,\n        VIEW_NOTE_ORACLE_RETURN_LENGTH,\n    },\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption,\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u3; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"49":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"50":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_COMMITMENT,\n    GENERATOR_INDEX__SILOED_COMMITMENT\n},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"60":{"source":"use crate::{\n    context::inputs::PrivateContextInputs, key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_COMMITMENTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        // Note. The side effect counter is 2 when this is the initial call\n        if (side_effect_counter == 2) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            read_requests: BoundedVec::new(SideEffect::empty()),\n            nullifier_key_validation_requests: BoundedVec::new(NullifierKeyValidationRequest::empty()),\n            new_commitments: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(L2ToL1Message::empty()),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_commitments.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [SideEffect::empty(); MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"66":{"source":"use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    utils::arr_copy_slice,\n};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u3; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u2,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u3; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u3; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"69":{"source":"use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr"},"73":{"source":"use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"75":{"source":"#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/rand.nr"},"78":{"source":"use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr"},"85":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr"},"98":{"source":"use dep::std::option::Option;\n\nuse dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note}, note_getter::{get_note, view_notes},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::{nullifier_key::get_nullifier_secret_key, notes::check_nullifier_exists};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct Singleton<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for Singleton<T> {}\n\nimpl<Note> Singleton<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, Singleton>` type (for example), because the storage slot often also identifies an actor. e.g. \n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy. \n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<N>(self, new_note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note<N>(self, broadcast: bool) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/singleton.nr"},"100":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"106":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr"},"185":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/utils.nr"},"186":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/aztec_address.nr"},"187":{"source":"use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/public_keys_hash.nr"},"191":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_COMMITMENT,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__COMMITMENT_NONCE, GENERATOR_INDEX__UNIQUE_COMMITMENT,\n    GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr"},"206":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}