{"noir_version":"0.24.0+78ef0134b82e76a73dadb6c7975def22290e3a1a","name":"Blank","functions":[{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":36}],"number":[{"start":36,"end":37}],"owner":[{"start":37,"end":38}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"max_non_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265]},"bytecode":"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","debug_symbols":"3ZjbjhoxDED/ZZ4Rii9xbH6l6gNttxISYlcLqlQh/r3DxZmBjSbdQWKBJ4hke058i5Nts3z9Od8sXlfrZrZtAJrZt22zfpuv9sv1Zv6+aWZh0rysfrW/u0nze7F8aWZMu8kHMYh2EgSFLAohFmQRlU7CSNwZBkkly0AS3TYw2pn890kD+KDcdCtuhuTcnNLV3FzilggnJdEKO1ryD6D16ZUO9mPRvrlnUkjD9o3dvJlmUbNRm5V7gklXwkBIlD9AYRjnPzNRyZNLI3cWj8D6aMD2YMAYHg0YKsAMte6hXiQU8Mx8qfUFN4wRYFi4Wn+IV7JTIM7sqcKuwNmNkGIWlnBgoTti4atZupgCV8Kk7Nyq2Nkt5Su2IfXwtwHNwjGU7Kpv0cCGRaE17ImCEc9OsDF5FZ/Bf6bOC6HXSMoOrLpEbukSCKKZxqzvlD1L+ioWBLxk0ZuyIOYooehwsqRkLpwU6bJH2IOCU7gtuOXoE1OlPBnz6cYslTbE+fYSqdfBD2lF8CSbTMAZWfqb/CgqEZ1CRDuPHBrd5zsW4ZO4UAwdWXjYhdD1fOwPj2NdSM+ShSlPS735+1RqfMebjOKblASVTVLyJ4i2kDrDfHwjmBZnGsuvFr2TrZ0nDyf+FIqttn11cS1Uocvngr0ejNQrlmwUd4L0bi8ix8NgWr4iErubqXfNP0U8TMvXtJoSjFHCMUr0aSWelqfWmG8VMeFFVuyVZIxSeQCjkIusy9XUBrdd/Jm/L+Y/li/7l812ufn7dvy7+wc="},{"name":"getNumber","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"owner":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"struct","path":"easy_private_state::value_note::value_note::ValueNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"kind":"struct","path":"aztec::note::note_header::NoteHeader","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"is_transient","type":{"kind":"boolean"}}]}}]},"visibility":"public"},"return_witnesses":[1,2,3,4,5,6,7]},"bytecode":"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","debug_symbols":"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uw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33XouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996Dv3muXylj/JZfpj6/czVeuYW5gbmHuWO61S/2GnMGcw1zAXMIc7MvAvgzsy8C+DOzLwr4s7MvCvizsy8K+LOzLwr4s7MvCvizsy8G+HOzLwb4c7MvBvhzsy8G+HOzLwb4c6os/Hg+YM5hzmAuYS5grmGuYG5hbmIN9MdgXg30x2BeDfTHYF4N9MdgXg30x2BeDfXHYF4d9cdgXh31x2BeHfXHYF4d9cdgXh30J2JeAfQnYl4B9CdiXgH0J2JeAfQnYl4B9SdiXhH1J2JeEfUnYl4R9SdiXhH1J2JeEfSnYl4J9KdiXgn0p2JeCfSnYl4J9KdiXgn1p2JeGfWnYl4Z9adiXhn1p2JeGfWnYl4Z9GdiXgX0Z2JeBfRnYl4F9GdiXgX0Z2JeBfVnYl4V9WdiXhX1Z2JeFfVnYl4V9WdiXhX052JeDfTnYl4N9OdiXg3052JeDfTnYF+i7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6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vhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQd4/5bj6Y7z5zBnMOcwFzCXMFcw1zA3MLc7AvBvtisC8G+2KwLwb7YrAvBvtisC8G+2KwLw774rAvDvvisC8O++KwLw774rAvDvvisC8B+xKwLwH7ErAvAfsSsC8B+xKwLwH7ErAvCfuSsC8J+5KwLwn7krAvCfuSsC8J+5KwLwX7UrAvBftSsC8F+1KwLwX7UrAvBftSsC8N+9KwLw37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"},{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[{"start":4,"end":7}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[7,8,9,10]},"bytecode":"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","debug_symbols":"7d3djivHdQXgdznXRtBVtXf96FWCXCiJAxgwbMMSAgSG3j0tRDM6RgaaZMxDfjXsK0kD9unV1Tprszj8yL99+eOf/+37H//w5z/98OW7v305/qnGl+/++W9ffvjL93/6+Qc//Pj9X3/88t3xuy+//9O/n//86Xdf/uMPf/z9l++i/fS7//Ww3sovD+yRrw+d+cZDyxi/PLQev/6prfz0L7/7OUUSKTqRYhApJpFiCSnaQaQoRIpKpGhECqI7G9GdjejORnRnI7qzEd0ZRHcG0Z1BdGcQ3RlEdwbRnUF0ZxDdGUR3BtGdSXRnEt2ZRHcm0Z1JdGcS3ZlEdybRnUl0ZxLd2Ynu7ER3dqI7O9GdnejOTnRnJ7qzE93Zie7sRHcOojsH0Z2D6M5BdOcgunMQ3TmI7hxEdw6iOwfRnZPozkl05yS6cxLdOYnunER3TqI7J9Gdk+jOSXTnIrpzEd25iO5cRHcuojsX0Z2L6M5FdOciunMR3VkOojzLQbRnOYj6LAfRn+UgCrQcRIOWg6jQchAdWg6iRMthtGgxWrQYLVqMFi1GixajRYvRosVo0WK0aDFatBgtWo0WrUaLVqNFq9GiBjgqhjgqBjkqhjkqBjoqhjoqBjsqhjsqBjwqhjwqBj0qhj0qBj4qhj4qBj8qhj8qBkAqhkAqBkEqhkEqBkIqhkIqBkMqhkMqBkQqhkQqBkUqhkUqBkYqhkYqBkcqhkcqBkgqhkgqBkkqhkkqBkoqhkoqBksqhksqBkwqhkwqBk0qhk0qBk4qhk4qBk8qhk8qBlAqhlAqBlEqhlEqBlIqhlIqBlMqhlMqBlQqhlQqBlUqhlUqBlYqhlYqBlcqhlcqBlgqhlgqBlkqhlkqBloqhloqBlsqhlsqBlwqhlwqBl0qhl2qhl2qhl2qhl2qhl2qB9Gi1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBL1bBLFfmyJOTbkpCvS0K+Lwn5wiTDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLlXDLjXDLjXDLjXDLjXDLrWDaNFm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KVm2KUw7FIYdikMuxSGXYqDaNEw7FIYdikMuxSGXQrDLoVhl8KwS2HYpTDsUhh2KQy7FIZdCsMuhWGXwrBLYdilMOxSGHYpDLsUhl0Kwy6FYZfCsEth2KUw7FIYdikMuxSGXQrDLoVhl8KwS2HYpTDsUhh2KQy7FIZdCsMuhWGXwrBLYdilMOxSGHYpDLsUhl0Kwy6FYZfCsEth2KUw7FIYdikMuxSGXQrDLoVhl8KwS2HYpTDsUhh2KQy7FIZdCsMuhWGXwrBLYdilMOxSGHYpDLsUhl0Kwy6FYZfCsEth2KUw7FIYdikMuxSGXQrDLoVhl8KwS2HYpTDsUhh2KQy7FIZdCsMuhWGXwrBLYdilMOxSGHYpDLsUhl0Kwy6FYZfCsEtp2KU07FIadikNu5QH0aJp2KU07FIadikNu5SGXUrDLqVhl9KwS2nYpTTsUhp2KQ27lIZdSsMupWGX0rBLadilNOxSGnYpDbuUhl1Kwy6lYZfSsEtp2KU07FIadikNu5SGXUrDLqVhl9KwS2nYpTTsUhp2KQ27lIZdSsMupWGX0rBLadilNOxSGnYpDbuUhl1Kwy6lYZfSsEtp2KU07FIadikNu5SGXUrDLqVhl9KwS2nYpTTsUhp2KQ27lIZdSsMupWGX0rBLadilNOxSGnYpDbuUhl1Kwy6lYZfSsEtp2KU07FIadikNu5SGXUrDLqVhl9KwS2nYpTTsUhp2KQ27lIZdSsMupWGX0rBLadilNOxSGnYpDbuUhl1Kwy6lYZe6YZe6YZe6YZe6YZf6QbRoN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+xSN+zSMOzSMOzSMOzSMOzSOIgWHYZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdGoZdmoZdmoZdmoZdmoZdmgfRotOwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS9OwS8uwS8uwS8uwS8uwS+sgWnQZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdmkZdqkcBl46cxA9euYgivTMQTTpmYOo0jMH0aVnDqJMzxxEm545iDo9cyB9ajCmMwfSpwZkOnMgfWpQpjMH0qcGZjpzIH1qcKYzB9KnBmg6cyB9apCmMwfSpwZqOnMgfWqwpjMH0qcGbDpzIH1q0KYzB9KnBm46cyB9avCmMwfSpwZwOnMgfWoQpzMH0qcGcjpzIH1qMKczB9KnBnQ6cyB9alCnMwfSpwZ2OnMgfWpwpzMH0qcGeDpzIH1qkKczB9KnBno6cyB9arCnMwfSpwZ8OnMgfWrQpzMH0qcGfjpzIH1q8KczB9KnBoA6cyB9ahCoMwfSpwaCOnMgfWowqDMH0qcGhDpzIH1qUKgzB9KnBoY6cyB9anCoMwfSpwaIOnMgfWqQqDMH0qcGijpzIH1qsKgzB9KnBow6cyB9atCoMwfSpwaOOnP8Q32a/SXHOP7BHBPJsYgc5R/zUTfMUZAcFcnRkByB5EgkR0dyGH1aDqNPy4H0aUH6tCB9WpA+LUifFqRPC9KnBenTgvRpQfq0IH1akT6tSJ9WpE8r0qcV6dOK9GlF+rQifVqRPq1InzakTxvSpw3p04b0aUP6tCF92pA+bUifNqRPG9KngfRpIH0aSJ8G0qeB9GkgfRpInwbSp4H0aSB9mkifJtKnifRpIn2aSJ8m0qeJ9GkifZpInybSpx3p0470aUf6tCN92pE+7UifdqRPO9KnHenTjvTpQPp0IH06kD4dSJ8OpE8H0qcD6dOB9OlA+nQgfTqRPp1In06kTyfSpxPp04n06UT6dCJ9OpE+nUifLqRPF9KnC+nThfTpQvp0IX26kD5FfFRBfFRBfFRFfFRFfFRFfFRFfFQ9jD6tiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI+qiI9qiI9qiI9qiI9qiI9qh9GnDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRgfioQHxUID4qEB8Vh9GngfioQHxUID4qEB8ViI8KxEcF4qMC8VGB+KhAfFQgPioQHxWIjwrERwXiowLxUYH4qEB8VCA+KhAfFYiPCsRHBeKjAvFRgfioQHxUID4qEB8ViI8KxEcF4qMC8VGB+KhAfFQgPioQHxWIjwrERwXiowLxUYH4qEB8VCA+KhAfFYiPCsRHBeKjAvFRgfioQHxUID4qEB8ViI8KxEcF4qMC8VGB+KhAfFQgPioQHxWIjwrERwXiowLxUYH4qEB8VCA+KhAfFYiPCsRHBeKjAvFRgfioQHxUID4qEB8ViI8KxEcF4qMC8VGB+KhAfFQgPioQHxWIjwrERwXiowLxUYH4qEB8VCA+KhAfFYiPCsRHBeKjEvFRifioRHxUIj4qD6NPE/FRifioRHxUIj4qER+ViI9KxEcl4qMS8VGJ+KhEfFQiPioRH5WIj0rERyXioxLxUYn4qER8VCI+KhEflYiPSsRHJeKjEvFRifioRHxUIj4qER+ViI9KxEcl4qMS8VGJ+KhEfFQiPioRH5WIj0rERyXioxLxUYn4qER8VCI+KhEflYiPSsRHJeKjEvFRifioRHxUIj4qER+ViI9KxEcl4qMS8VGJ+KhEfFQiPioRH5WIj0rERyXioxLxUYn4qER8VCI+KhEflYiPSsRHJeKjEvFRifioRHxUIj4qER+ViI9KxEcl4qMS8VGJ+KhEfFQiPioRH5WIj0rERyXioxLxUYn4qER8VCI+KhEflYiPSsRHdcRHdcRHdcRHdcRH9cPo0474qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qI74qIH4qIH4qIH4qIH4qHEYfToQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQHzUQ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xKo/6d705h8oNZ90u3n7hXzSHeTtF/JJN4W3X8gn3efdfiHjWsjbLOST7sZuv5BPusG6/UI+6Z7p9gv5pNug2y/ktbO5zUKua2dzo4W8djY3WshrZ3Ojhbx2NjdayPhEC/nAj5FZn2lj88h1/Ez7mkeu42fa1jxyHT/TruaR6/iZNjWPW8fzj7vW8Sbr+Jm2NI9cx8+0o3nkOn6mDc0j1zGudbzJOl77mdus47Wfuc06XvuZ26zjtZ+5zTpe+5mbrGO5+7x+/fyWssp8Zx3X69Wu+DXFmK/pc+v0fev0Y+v0c+v0a+f09/9C8pumL1unr1unb1un33rW1q1nbd161tatZ23detbWrWdt23rWtq1nbdt61ratZ+39v4nypum3nrVt61nbtp61betZ27aetbH1rI2tZ21sPWtj61l7/6/6umn6rWdtbD1rY+tZG1vP2th61ubWsza3nrW59azNrWft/b+G5qbpt561ufWsza1nbW49a3PrWdu3nrV961nbt561fetZe/8vs7hp+q1nbd961vatZ23fetb2rWft2HrWjq1n7dh61o6tZ+39P5z7pum3nrVj61k7tp61Y+tZO7aetXPrWTu3nrVz61k7t5619/801Zum33rWzq1n7dx61s6tZ+3cetaurWft2nrWrq1n7dp61t7/8/1umn7rWbu2nrVr61m7tp61a+dZ24+dZ20/dp61/dh51vZj51nbj51nbT92nrX92HnW9mPnWduPnWdtP7aetWXrWVu2nrVl61lb7j1r13oJVMtxi++A7Hf/8KhvcAm5/yX0/S9h7H8Jc/9LWNtfwt0/WuobXELZ/xLq/pew/3S++8dNfYNL2H861/2nc91/Otf9p3Pdfzq3/adz2386t/2n8w08XevxsplvfcZvX0KW8stjsx5fBeovgW5A5G4cqGiBqhaoaYHizoEiXgJlvBko7x3o1882zzcDdS3Q0AJNLdDCAo1DC3Tvpm4vf3C2/magqgVqWqDQAqUWqGuBhhZoaoEWFmgeWiCtqafW1FNr6qk19dSaempNPbWmnlpTT62pl9bUS2vqpTX10pp6aU29tKZeWlMvramX1tQLa+pxYE09Dqypx4E19Tiwph4H1tTjwJp6HFhTj7ffYx399RcAX/1a7vUdquPt9za/e1T50FH1Q0e1Dx0VHzoqP3TUm/8r5GwvR603jxofOmp+6Kj1kaPefqPdu0eVDx1VP3TUm/9v5Hr5xXU/+ltHxYeOyg8d1T901PjQUfNDR62PHPX22zx6vh7V3zyqfOio+qGj2oeOig8dlR86qn/oqDf/3zh/gfJy1Hzrb8rb3xn07lHrI0e9/R057x5VPnRU/dBR7f931Pkf//n9X//w/b/+8fc/nAec//njf/3lf/71p/8G"},{"name":"setNumber","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":36}],"number":[{"start":36,"end":37}],"owner":[{"start":37,"end":38}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"max_non_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308]},"bytecode":"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","debug_symbols":"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"}],"events":[],"file_map":{"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}","path":"std/collections/bounded_vec.nr"},"31":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"contract Blank {\n    use dep::aztec::{\n        protocol_types::address::AztecAddress,\n        state_vars::{singleton::Singleton, map::Map},\n        context::{PrivateContext, PublicContext, Context},\n        note::{\n            utils as note_utils,\n            note_interface::NoteInterface,\n            note_header::NoteHeader,\n        },\n    };\n\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        numbers: Map<AztecAddress, Singleton<ValueNote>>,\n    }\n    \n    #[aztec(private)]\n    fn constructor(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).initialize(&mut new_number, true);\n    }\n\n    #[aztec(private)]\n    fn setNumber(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).replace(&mut new_number, true);\n    }\n\n    unconstrained fn getNumber(owner: AztecAddress) -> pub ValueNote {\n        let numbers = storage.numbers;\n        numbers.at(owner).view_note()\n    }\n\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: AztecAddress,\n        nonce: Field,\n        storage_slot: Field,\n        note_type_id: Field,\n        serialized_note: [Field; VALUE_NOTE_LEN]\n    ) -> pub [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(ValueNote::deserialize_content, note_header, serialized_note)\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/boxes/blank/src/contracts/src/main.nr"},"44":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/log.nr"},"48":{"source":"use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{\n        MAX_READ_REQUESTS_PER_CALL,\n        GET_NOTE_ORACLE_RETURN_LENGTH,\n        GET_NOTES_ORACLE_RETURN_LENGTH,\n        MAX_NOTES_PER_PAGE,\n        VIEW_NOTE_ORACLE_RETURN_LENGTH,\n    },\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption,\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u3; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"49":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"50":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_COMMITMENT,\n    GENERATOR_INDEX__SILOED_COMMITMENT\n},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"60":{"source":"use crate::{\n    context::inputs::PrivateContextInputs, key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_COMMITMENTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header, utils::reader::Reader\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    max_non_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n            max_non_revertible_side_effect_counter: 0,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            read_requests: BoundedVec::new(SideEffect::empty()),\n            nullifier_key_validation_requests: BoundedVec::new(NullifierKeyValidationRequest::empty()),\n            new_commitments: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            max_non_revertible_side_effect_counter: self.max_non_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_max_non_revertible_side_effect_counter(&mut self) {\n        assert(\n            self.max_non_revertible_side_effect_counter == 0, \"Already captured the non-revertible side effect counter\"\n        );\n        self.max_non_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_commitments.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) {\n        // docs:end:context_message_portal\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            self.this_portal_address(),\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(\n            item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n        );\n        assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [SideEffect::empty(); MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(\n            item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n        );\n        assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"66":{"source":"use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    utils::arr_copy_slice,\n};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u3; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u2,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u3; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u3; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"69":{"source":"use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr"},"73":{"source":"use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"75":{"source":"#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/rand.nr"},"78":{"source":"use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr"},"85":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/context.nr"},"97":{"source":"use dep::std::option::Option;\n\nuse dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note}, note_getter::{get_note, view_notes},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::{nullifier_key::get_nullifier_secret_key, notes::check_nullifier_exists};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct Singleton<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for Singleton<T> {}\n\nimpl<Note> Singleton<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, Singleton>` type (for example), because the storage slot often also identifies an actor. e.g. \n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy. \n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<N>(self, new_note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note<N>(self, broadcast: bool) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/state_vars/singleton.nr"},"99":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"105":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/hasher.nr"},"142":{"source":"use crate::{\n    constants::{GENERATOR_INDEX__CONTRACT_ADDRESS, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONSTRUCTOR},\n    hash::pedersen_hash, contract_class::ContractClassId, utils, grumpkin_point::GrumpkinPoint\n};\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, ToField, Serialize, Deserialize};\nuse crate::type_serialization::{ETH_ADDRESS_SERIALIZED_LEN, AZTEC_ADDRESS_SERIALIZED_LEN};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_SERIALIZED_LEN> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_SERIALIZED_LEN] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_SERIALIZED_LEN> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_SERIALIZED_LEN]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_SERIALIZED_LEN> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_SERIALIZED_LEN] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_SERIALIZED_LEN> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_SERIALIZED_LEN]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\npub fn compute_initialization_hash(selector: Field, args_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        selector,\n        args_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/src/crates/types/src/address.nr"},"166":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/src/crates/types/src/utils.nr"},"167":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::{ContractClassFunctionLeafPreimage, FunctionLeafPreimage};\nuse crate::contract_class::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_COMMITMENT,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__COMMITMENT_NONCE, GENERATOR_INDEX__UNIQUE_COMMITMENT,\n    GENERATOR_INDEX__FUNCTION_ARGS\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr"},"183":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}