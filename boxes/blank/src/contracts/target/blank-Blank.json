{"noir_version":"0.23.0+5f5843e35052b9d3599b8ab4f7633db0a225e82f","name":"Blank","functions":[{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[{"start":4,"end":7}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[7,8,9,10]},"bytecode":"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","debug_symbols":"7d3djiPJcQXgd5lrwaiMjMgfvYrhi7UtAwIE2bAEA4agd3cJ3u5dww2N3eKSXzV5tTsNVteprJkTTHZ/5J++/e5f/+mHP/72X3//h2+//tO34+8iv/367//07Q//9sPv//KFP/zxh3//47dfH7/69pvf//P53z//6tu//PZ3v/n26+x//tX/etjo7ccHjqz3h1Z98NA2548PjeOn79rbn//hV39JUUSKQaSYRIpFpNhCin4QKRqRIogUnUhBdGcnurMT3dmJ7uxEd3aiO5PoziS6M4nuTKI7k+jOJLozie5MojuT6M4kurOI7iyiO4voziK6s4juLKI7i+jOIrqziO4sojsH0Z2D6M5BdOcgunMQ3TmI7hxEdw6iOwfRnYPozkl05yS6cxLdOYnunER3TqI7J9Gdk+jOSXTnJLpzEd25iO5cRHcuojsX0Z2L6M5FdOciunMR3bmI7txEd26iOzfRnZvozk105ya6cxPduYnu3ER3bqI720GUZzuI9mwHUZ/tIPqzHUSBtoNo0HYQFdoOokPbQZRoO4wWbUaLNqNFm9GizWjRZrRoM1q0GS3ajBZtRos2o0XDaNEwWjSMFg2jRQ1w1Axx1Axy1Axz1Ax01Ax11Ax21Ax31Ax41Ax51Ax61Ax71Ax81Ax91Ax+1Ax/1AyA1AyB1AyC1AyD1AyE1AyF1AyG1AyH1AyI1AyJ1AyK1AyL1AyM1AyN1AyO1AyP1AyQ1AyR1AyS1AyT1AyU1AyV1AyW1AyX1AyY1AyZ1Aya1Ayb1Ayc1Ayd1Aye1Ayf1Ayg1Ayh1Ayi1Ayj1Ayk1Ayl1Aym1Ayn1Ayo1Ayp1Ayq1Ayr1Ays1Ayt1Ayu1Ayv1Ayw1Ayx1Ayy1Ayz1Ay01Ay11Ay21Ay31Ay41Ay51Ay61Ay7FIZdCsMuhWGXwrBLcRAtGoZdCsMuhWGXwrBLYdilMOxSGHYpDLsUhl0Kwy6FYZfCsEth2KUw7FIYdikMuxSGXQrDLoVhlwL5sCTk05KQj0tCPi8J+cAkwy6FYZfCsEth2KUw7FIYdikMuxSGXQrDLoVhl8KwS2HYpTDsUhh2KQy7FIZdCsMuhWGXwrBLYdilMOxSGHYpDLsUhl0Kwy6FYZfCsEth2KUw7FIYdikMuxSGXQrDLoVhl8KwS2HYpTDsUhh2KQy7FIZdCsMuhWGXwrBLYdilMOxSGHYpDLsUhl0Kwy6FYZfCsEth2KUw7FIYdikMuxSGXQrDLoVhl8KwS2HYpTDsUhh2KQy7FIZdCsMuhWGXwrBLYdilMOxSGHYpDLvUDbvUDbvUDbvUDbvUD6JFu2GXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGXumGX0rBLadilNOxSGnYpD6JF07BLadilNOxSGnYpDbuUhl1Kwy6lYZfSsEtp2KU07FIadikNu5SGXUrDLqVhl9KwS2nYpTTsUhp2KQ27lIZdSsMupWGX0rBLadilNOxSGnYpDbuUhl1Kwy6lYZfSsEtp2KU07FIadikNu5SGXUrDLqVhl9KwS2nYpTTsUhp2KQ27lIZdSsMupWGX0rBLadilNOxSGnYpDbuUhl1Kwy6lYZfSsEtp2KU07FIadikNu5SGXUrDLqVhl9KwS2nYpTTsUhp2KQ27lIZdSsMupWGX0rBLadilNOxSGnYpDbuUhl1Kwy6lYZfSsEtp2KU07FIadikNu5SGXUrDLqVhl9KwS2nYpTTsUhp2KQ27lIZdSsMulWGXyrBLZdilMuxSHUSLlmGXyrBLZdilMuxSGXapDLtUhl0qwy6VYZfKsEtl2KUy7FIZdqkMu1SGXSrDLpVhl8qwS2XYpTLsUhl2qQy7VIZdKsMulWGXyrBLZdilMuxSGXapDLtUhl0qwy6VYZfKsEtl2KUy7FIZdqkMu1SGXSrDLpVhl8qwS2XYpTLsUhl2qQy7VIZdKsMulWGXyrBLZdilMuxSGXapDLtUhl0qwy6VYZfKsEtl2KUy7FIZdqkMu1SGXSrDLpVhl8qwS2XYpTLsUhl2qQy7VIZdKsMulWGXyrBLZdilMuxSGXapDLtUhl0qwy6VYZfKsEtl2KUy7FIZdqkMu1SGXSrDLpVhl8qwS2XYpTLsUhl2qQy7VIZdGoZdGoZdGoZdGoZdGgfRosOwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS8OwS9OwS9OwS9OwS9OwS/MgWnQadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkadmkZdmkZdmkZdmkZdmkdRIsuwy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy4twy5twy5twy5twy5twy7tg2jRbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdilbdildhh46cxB9OiZgyjSMwfRpGcOokrPHESXnjmIMj1zEG165iDq9MyB9KnBmM4cSJ8akOnMgfSpQZnOHEifGpjpzIH0qcGZzhxInxqg6cyB9KlBms4cSJ8aqOnMgfSpwZrOHEifGrDpzIH0qUGbzhxInxq46cyB9KnBm84cSJ8awOnMgfSpQZzOHEifGsjpzIH0qcGczhxInxrQ6cyB9KlBnc4cSJ8a2OnMgfSpwZ3OHEifGuDpzIH0qUGezhxInxro6cyB9KnBns4cSJ8a8OnMgfSpQZ/OHEifGvjpzIH0qcGfzhxInxoA6syB9KlBoM4cSJ8aCOrMgfSpwaDOHEifGhDqzIH0qUGhzhxInxoY6syB9KnBoc4cSJ8aIOrMgfSpQaLOHEifGijqzIH0qcGizhxInxow6syB9KlBo84cSJ8aOOrM8Tf1aY23HPP4G3MsJMcmcrS/zUfdMEdDcgSSoyM5EslRSI6B5DD6tB1Gn7YD6dOG9GlD+rQhfdqQPm1InzakTxvSpw3p04b0aUP6NJA+DaRPA+nTQPo0kD4NpE8D6dNA+jSQPg2kTzvSpx3p0470aUf6tCN92pE+7UifdqRPO9KnHenTRPo0kT5NpE8T6dNE+jSRPk2kTxPp00T6NJE+LaRPC+nTQvq0kD4tpE8L6dNC+rSQPi2kTwvp04H06UD6dCB9OpA+HUifDqRPB9KnA+nTgfTpQPp0In06kT6dSJ9OpE8n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qIn4qIn4qIn4qIn4qIn4qIn4qIn4qIn4qIn4qIn4qIn4qIn4qIn4qIX4qIX4qIX4qIX4qHUYfboQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7UQH7URH7URH7URH7URH7UPo0834qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qM24qO24aPOrxF9en6N6NPza0Sfnl8j+vT8GtGn59eIPj2/RvTp+TWiT8+vEX16fg3pU8NHnTmQPjV81JkD6VPDR505kD41fNSZA+lTw0edOZA+NXzUmQPpU8NHnTmQPjV81JkD6VPDR505kD41fNSZA+lTw0edOZA+NXzUmQPpU8NHnTmQPjV81JkD6VPDR505kD41fNSZA+lTw0edOZA+NXzUmQPpU8NHnTmQPjV81JkD6VPDR505kD41fNSZA+lTw0edOZA+NXzUmQPpU8NHnTmQPjV81JkD6VPDR505kD41fNSZA+lTw0edOZA+NXzUmQPpU8NHnTmQPjV81JkD6VPDR505kD41fNSZA+lTw0edOZA+NXzUmQPpU8NHnTmQPjV81JkD6VPDR505kD41fNSZA+lTw0edOZA+NXzUmQPpU8NHnTmQPjV81JkD6VPDR505jD5tiI9qiI9qiI9qiI9qh9GnDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRDfFRgfioQHxUID4qEB8Vh9GngfioQHxUID4qEB8ViI8KxEcF4qMC8VGB+KhAfFQgPioQHxWIjwrERwXiowLxUYH4qEB8VCA+KhAfFYiPCsRHxcc+qmW0Hw9rOevnad6OW588bn983Kq342p/5+r7WPHjg8//7e8PnvvtJB/jolufpN3gJPmzk+TPT/LBnWx9vH/rc6H3+8Nb1nuoEEN1MVSKoUoMNcRQUwy1xFAbDJWHGEps9BQbPcVGT7HRU2z0FBs9xUZPsdFTbPQSG73ERi+x0Uts9BIbvcRGrzv3VLW3fX7FT9+3zfEeaGOBxp3/1VV/+8bVx4eBuhYotUClBRpaoF/0OdPbSdY9TnKLvoifnaT++tLuI3987I74aWnX+wuV89ACNS1QaIG6Fii1QKUFGncONNZboDU+DDS1QEsLtLFA69ACNS1QaIHu3NTtaP3tOx/nDz8/ipRepPIiDS/S9CItL9LmIu1ftLffTtLucZK4x0n6PU6S9zhJ3eMk4x4nmfc4ybrHSfYvf5J+HPc4SbvHSeIeJ+n3OEne4yR1j5OMe5xk3uMk6x4nuce/+HaPf/HtBv/i1/F+kpXtO89t/g8/kektxFBdDJViqBJDDTHUFEMtMdQNGnfN4z3U3n891Fpvv/u923ce2uL956ct6n++VPvJq43jqa62PdXVxlNdbX+qq82nutp6qqsdT3W186mudj3V1T7Vc6n+VM+l+lM9l+pP9VyqP9VzqVsgwwtd7VM9l+pP9VyqP9Vzqf5Uz6X6nZ9L7fX22Hb04wYvrOVx9QtoV7+AuPoF9KtfQF79AurqFzCufgHz6hewrn4BV5/EdfVJXFefxHX1SVxXn8S3UMs79tsF7P2dX7Wt4+0CquYt8tfF84+L558Xz78unn9fO/84Lp6/XTx/XDx/v3j+i8/fcfH5Oy4+f8fF5++4+PwdF5+/N3jniDz62++e5rHWXw/10zvVzr5vkb9dPH9cPH+/eP68eP66eP5x8fzz4vnXxfPva+dfF5+/6+Lzd118/q6Lz98bvJPJY/NffP7e4D1SsrW3XwjK9t1NyYr3n2Cs+lmkD38jKOZ++/2hWMf/WJq3/PPa+W/wviK/YP7e3z+8pffdv/Ot65jvofN7fzmjveeI+g5YfOxvnN3gXVlet+gXvkXxukX6LeqvW6TfonzdIv0W1esW6beIfkb9ukV/uUX0puF1i/5yi9brFum3aL9ukX2L8ni9usDfoterC/wter26wN+i16sL/C3K1y3Sb9Hr1QX+Fr1eXeBv0evVBf4WvV5d4G/R69UF/Ra116sL379Ftxa72V4vGDxi1V+vATxi1V/b+keser5W/QGr/tp8P2LVX/vpR6z6a4v8iFV/7XofseqvjewDVj1ee9NHrPprb/qIVX/tTR+x6q+96SNWPV+r/oBVf9q9aa23B/fvvcJ+47dmyXjarekjF/1pd6aPXPSn3Zg+ctGfdl/6wEXvT7stfeSiP+2u9JGL/rSb0kcu+tPuSR+56Pla9Psv+mtH+oBFf+1IH7Dorx3pAxb9tSN9wKK/dqT3X/R87UgfsOhfaUf6/uA2ju/kuPG7F2Z+pU3mI9fxK+0bH7mO+VrHm6zjV9rdPXIdv9KG7ZHr+JX2YI9cx6+0rXrkOn6lndID17G+0ubnkev42s/cZh1f+5nbrONrP3ObdczXOt5kHV/7mdus42s/c5t1pJ8/xj7eXpqN3b/zgSgXer+MQT/b/LKrTj83/bKrTj+T/bKrTj/v/bKrnq9Vf8Cq08+pv+yq258X91VX3f6Uu6+66vRPK77sqr/2pg9Y9fnamz5i1V9700es+mtv+ohVf+1NH7Hq+Vr1B6z6a2/6iFV/7U0fseqvvekjVv21N33Eqj/p3vTmbyi1nnS7efuFfNId5O0X8kk3hbdfyCfd591+IfO1kLdZyCfdjd1+IZ90g3X7hXzSPdPtF/JJt0G3X8jXzuY2C7lfO5sbLeRrZ3OjhXztbG60kK+dzY0WMr/QQj7wbWT2V9rYPHIdv9K+5pHr+JW2NY9cx6+0q3nkOn6lTc3j1vH8dq91vMk6fqUtzSPX8SvtaB65jl9pQ/PIdczXOt5kHV/7mdus42s/c5t1fO1nbrOOr/3MbdbxtZ+5yTq2u8/r9/dvabut76zjfr/anT+l2OM9fV06/bh0+nnp9OvS6feV09//A8lvmr5dOn1cOn2/dPpLz9q49KyNS8/auPSsjUvP2rj0rO2XnrX90rO2X3rW9kvP2vt/EuVN01961vZLz9p+6VnbLz1r+6VnbV561ualZ21eetbmpWft/T/q66bpLz1r89KzNi89a/PSszYvPWvr0rO2Lj1r69Kzti49a+//MTQ3TX/pWVuXnrV16Vlbl561delZOy49a8elZ+249Kwdl5619/8wi5umv/SsHZeetePSs3ZcetaOS8/aeelZOy89a+elZ+289Ky9/5tz3zT9pWftvPSsnZeetfPSs3ZeetauS8/adelZuy49a9elZ+393031pukvPWvXpWftuvSsXZeetevSs3ZfetbuS8/afelZuy89a+///n43TX/pWbsvPWv3pWftvvSs3VeeteO48qwdx5Vn7TiuPGvHceVZO44rz9pxXHnWjuPKs3YcV56147jyrB3HpWdtu/SsbZeete3Ss7bde9bu/RYo2nGLz4Acd3/zqF/gEur6lzCufwnz+pewrn8J+/KXcPe3lvoFLqFd/xLi+pdw/el897eb+gUu4frTOa4/neP60zmuP53j+tO5X3869+tP53796XwDT9dHvm3m+1j51y+hWvvxsRU/fd823zfzNyByNw7UtEChBepaoLxzoMy3QJUfBqp7B/rpvc3rw0BDCzS1QEsLtLFA89AC3bup+9s3rj4+DBRaoK4FSi1QaYGGFmhqgZYWaGOB1qEF0pp6aU29tKZeWlMvramX1tRLa+qlNfXSmnprTb21pt5aU2+tqbfW1Ftr6q019daaemtNvbGmngfW1PPAmnoeWFPPA2vqeWBNPQ+sqeeBNfX8+Hesc7z/AOBnP5Z7/w3V+fHvNn/3qPapo+JTR/VPHZWfOqo+ddSHfxVq9bej9odHzU8dtT511P7MUR//ot13j2qfOio+ddSHfzdqv/3gehzjo6PyU0fVp44anzpqfuqo9amj9meO+vjXPEa9HzU+PKp96qj41FH9U0flp46qTx01PnXUh383zh+gvB21PvqX8vFnBn33qP2Zoz7+jJzvHtU+dVR86qj+/zvq/MN//PDvv/3hH3/3mz+cB5x//ON//tt//++f/ws="},{"name":"setNumber","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":36}],"number":[{"start":36,"end":37}],"owner":[{"start":37,"end":38}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"max_non_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308]},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":36}],"number":[{"start":36,"end":37}],"owner":[{"start":37,"end":38}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"max_non_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265]},"bytecode":"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","debug_symbols":"3ZjdimIxDIDf5VyLND9tEl9lmQt31wVBnGGUhUV89z3+pOfoFDtzBEe90kKS8yVN0jabZvH6a7qevy5XzWTTADSTH5tm9TZd7par9fR93UzCqJktf7e/21HzZ76YNROm7eiDGEQ7CoJCFo1SEEVUOsoicWcXOJYMA6XopoHRTuRfRg3gY2LTjbAZxLFZ5GpsLmGnCEelpBV0NPEPoPXgQWlvPxbtmwdGgly2b+zmzbSzHnCQt+muaORKGghC+QMUKjyfzEUlzy+N3DN5QNbHQ7aHQ8bweMhQQWao9RH1YqGAp/ZLXTC4ZYwAFelqJSJeSU+BONNLjV6BcyhBYtfw9y0T6Z5g+GqYbl+Bazul7OSqmGWllLXY7qqnQLunnbCV7Kr7aGCXRaE17LmCEU8OtCGpFZ8igKYODKHXUMoRrMYk3TQmEJJmHLN+VHYw8m0wCHgOo7eFQcwbhUkv54uIubAo0nmjsEclp3BjcssJQEyVGmXM5xxzqjQjzi+aSF0jN9h7Cc/ipQBn5tT38qNoiugUKWkXkrZBDelbhM8Sw2TozIkvxxC61o8nd8mBMaSnyUPJ96beffxYbXzPXsbkXiaBipckPppoaynLth13PzwYF283lqcZvQPO9HD0j6HYb9tpjGuhJjqfI+z0YKBesWpj8iCk3mvGDjkaxuVXI7GHmXrP/+OWh3H53VZTgiFKOESJvqzE4/L9NeYXRhQ8y4qdUhqiVL6IUchV1uWq8falXfydvs+nPxez3byzXa7/vR3+bv8D"},{"name":"getNumber","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"owner":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"struct","path":"easy_private_state::value_note::value_note::ValueNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"kind":"struct","path":"aztec::note::note_header::NoteHeader","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"is_transient","type":{"kind":"boolean"}}]}}]},"visibility":"public"},"return_witnesses":[1,2,3,4,5,6,7]},"bytecode":"H4sIAAAAAAAA/+2deZQdR33v+87c2XTnakbL7It6Fs2iWTR3Rvt6JWuzNmsxlsC2ZO2StYyWkWTLu41tSIBAMMEEQggQCIQ1C5AEm5AFsmAwAYeEwMs577zHOyf5L+SdvJN34hP6Tn0136mpO5oeqsY/JdXnSPPrb1X371O/rq6qXqpvSRAEiWB0KSSbF2hZ9Xfg51syFvc1UGLgLKDyREtS/S1Sf4vV32jbl6pG7VLaT2iLb8nAimIC0GObIlbkiZjKKT2RHF+m3DbJ8eWLtMLkuN3ktGRyfLkjrSg5PgaRVky+oZUkx8elkliQr5T8hYG9+pGismHRYxeSnTTwvG6PZyAdTKxLpRTD0HLZi4Kplx0MadqOGUscMRbHYCwhxmIDY6kjxpIYjKVueXJ1qMTga5ajspcFUy/7LANPwnLZywy+yh2VPRVMvexgSNN2zJh2xFgegzFNf8sNjLMdMaZjMM4mxjSx4W+FI8bZMRgriBHbcTtU6YixIgZjJTFWEBv+zrHPOJgiv1NhnEM88xzxzInBM4945trnyTgq50C0j/nBxLjCV5rSuZ7Od1DGBPnFvrHOjLcTb8RTqbGmKF+lEEZocx3zpDSeaJnsvDIx8nGtcsQ4PwZjFTHOJzb8rXbEWBWDsZoYsR3HscYRY3UMxhpirCY2/K11xFgTg7GWGLEdx7HOEWNtDMY6YqwlNvytd8RYF4OxnhixHcexwRFjfQzGBmKsJzb8bXTE2BCDsZEYsR3HsckRY2MMxiZibCQ2/G12xNgUg7GZGLEdx3GBI8bmGIwLiLHZwBg6YlwQgzEkxgUGxhZHjGEMxhZiDA2MrY4YW2IwthJji4GxzRFjawzGNmJsNTC2O2Jsi8HYToxtBsaFjhjbYzAuJMZ2A2OHI8aFMRg7iHGhgbHTEWNHDMZOYuwwMHY5YuyMwdhFjJ0Gxm5HjF0xGLuJscvAuMgRY3cMxkXE2G1g7HHEuCgGYw8xLjIw9jpi7InB2EuMPcSGv32OGHtjMPYRY6+Bsd8RY18Mxn5ixHZ8rBfbZ8zdo+yPwbiYeDL2eZakyMdUeDLEM2CfJ+OonDnUwWBiXOErTelcBwYdlDFBfrFvrDOj5/W8g8TTr7GmKF+/EEZoA455UhpPtEzWbpkY+bgOOWIcjME4RIymurfEPmOuPxqKwbiEeJZZ51kykCIfU+FZRjxLrfOM9kf2yznaHy0PJsYVvtKUznVguYMyJsgv9o11Zpwqb+ltxuvj6+Pr4+vjm4/Xx9fH18fXxzcfr4+vj6+Pr49vPl4fXx9fH18f33y8Pr4+vj6+Pr75eH18fXx9fH188/H6+Pr4+vj6+Obj9fH18fXx9fHNx+vj6+Pr4+vjm4/Xx9fH18fXxzcfr49vfN6IZ0hjTVG+ISGM0JY65klpPNGS0NZDsk2MXA9XOGJcHoNxBTGazpWVjhhXxGBcSYwriA1/V9lnzM05WBmDcRXxrLHPk5sDtyoGzxriWW2fJ+OonLk5B2uDiXGFrzSlcz1d66CMCfKLfWOdGT2v511LPCs11hTlWymEEdpqxzwpjSdaJmu3TIx8XNc5Ylwbg3EdMZrq3npHjOtiMK4nxnUGxqwjxvUxGLPEuN7AuMERYzYG4wZizBoYN9pnzI09NsRg3Eg8m6zzDObmO26MwbOJeO6wzjM69rBfztGxx+ZgYlzhK03pXAc2Oyhjgvxi31hnxqnylt5mvD6+Pr4+vj6++Xh9fH18fXx9fPPx+vj6+Pr4+vjm4/Xx9fH18fXxzcfr4+vj6+P73yu+Ec8GjTVF+TYIYYR2h2OelMYTLQltPSTbxMj1cIsjxs0xGLcQo+lc2eqIcUsMxq3EuIXY8HebfcbcM6etMRi3Ec926zxDuWdO22LwbCeeO63zjD5zsl/O0WdOO4KJcYWvNKVzPd3hoIwJ8ot9Y50Z/6vylt5mvL4+uOX19cHz+vrgefPx+vrgeX198Lz5eH198Ly+PnjefLy+PnheXx88bz5eXx88r68Pnjcfr68PntfXB8+bj9fXB8/r64PnzccroT5EPFs11hTl2yqEEdqdjnlSGk+0JLT1kGwTI9fDnY4Yd8Rg3EmMpnNllyPGnTEYdxHjTgPjbkeMu2Iw7ibGXcSGv3fZZ8y9F7Y7BuNdxLPXPk/uO0h3xeDZSzx77PNkHJUz917YvmBiXOErTelcT/c5KGOC/GLfWGdGz+t59xHPbo01Rfl2C2GEtscxT0rjiZbJ2i0TIx/X/Y4Y98Vg3E+Mprp3t33GXH+0Pwbj3cRzj32eXH90dwyee4jnTfZ5Mo7KmeuPDgQT4wpfaUrnOnDAQRkT5Bf7xjozel7Pe4B49musKcq3XwgjtDc55klpPNEyWbtlYuTjetAR44EYjAeJ0VT33myfMdcfHYzB+GbiudcRz5tj8NxLPG+xz5NxVM5cf3RfMDGu8JWmdK4D9zkoY4L8Yt9YZ8bbiTfiOaixpijfQSGM0N7imCel8UTLZOeViZGP6/2OGO+LwXg/MZrq3iFHjPfHYDxEjPcbGA87YjwUg/EwMR4iNvx9wD5jrp0/HIPxAeI56ojngRg8R4nniH2ejKNy5vqdY8HEuMJXmtK5nh5zUMYE+cW+sc6MtxNvxHNYY01RvsNCGKEdccyT0niiZbLzysTIx/W4I8ZjMRiPE+MxYsPfE44Yj8dgPEGM2I7jeNIR44kYjCeJ8QSx4e8pR4wnYzCeIkZsx3E87YjxVAzG08R4itjw94wjxtMxGM8QI7bjOD7oiPFMDMYHifEMseHvWUeMD8ZgPEuM2I7jeM4R49kYjOeI8Syx4e95R4znYjCeJ0Zsx3G84IjxfAzGC8R43sA47IjxQgzGYWK8YGC86IhxOAbjRWIcNjBecsR4MQbjJWK8aGC87IjxUgzGy8R4ycB4xRHj5RiMV4gR280ixhFHjFdiMI4QI7bjOF51xDgSg/EqMY4YGK85Yrwag/EaMV41MF53xHgtBuN1YrxmYHzIEeP1GIwPEeN1A+MN+4y5+y0PxWC8QTwP2+fJOCrnQLTfR9S+XrfIG+3j0WDiMbxBxxLpj1DsHnUQuwT5xb6xzoxT5S0QwOvI9+Dsn+2jjMrP/gKN6zH1N0k6zsuoDI8ru0itI/8syos871QbVgSjscbCv+f2uP3yZiY7p+GPeTLCeLqF8dwQxtMmjOeyMJ4mYTznhPHUCOM5KYynQhjPIWE8JcJ47hHGs1MYzyZhPGuE8QwK41kkjKddGM8VYTzNwnjOC+OpFcZzShhPpTCew8J4yoTxHBDGs0sYz2ZhPGuF8QwJ4+kRxrNQGM+IMJ4FwnguCOOpE8ZzWhjPPGE8R4XxpITxHBTGs1sYzxZhPOuE8SwTxtMrjKdDGM9VYTyhMJ5hYTz1wnjOCOOZL4znmDCecmE89wrjKRTGs1cYz1ZhPOuF8SwXxtMnjKdTGM81YTwtwnguCuNpEMbzoDCeKmE8x4XxpIXx3CeMp0gYzz5hPNuF8WSF8awQxtMvjKdLGM91YTytwnguCeNpFMZzVhhPtTCeE8J4ZgvjuV8YT7Ewnv3CeHYI49kgjCchgCcVTJxrmaL0WaQ9oexC0p5UdhFpTym7mLSnlV1C2jPKLiPtrWTj77PKLiftOWWnSXte2bNJe5uyK0h7u7IrSfsFZc8j7ReVPZ+0dyi7irR3KruatHcpu4a0X1J2LWnvVnYdae9Rdj1pv6zsBtLeq+xG0l5QdhNp71N2M2m/ouwFpL1f2SFpLyq7hbQPKLuVtF9VdhtpH1R2O2kfUvZC0n5N2R2kfVjZnaT9urK7SPuIsrtJ+w1lLyLto8ruIe1jyu4l7ePK7iPtN5XdT9onlJ0h7ZPKHiTtt5Q9RNqnlL2MtE8rezlpv63sFaR9RtkrSfussteQ9jllryXt88peR9oXlL2etC8qO0va7yh7A2m/q+xNpP2esjeT9vvK3kLal5S9lbQvK3s7aV9R9g7S/kDZO0n7Q2XvIu2PlL2btK8qey9pLyl7H2kvK3s/aV9T9j2k/bGyD5D2dWUfJO1PlH0vaX+q7PtI+zNl30/anyv7EGnfUPZh0r6p7KOk/YWyj5H2l8o+TtpfKfsEaX+t7JOkfUvZp0h7RdmnSfu2ss+Q9h1lP0jaq8o+S9p3lX2OtL9R9nnSvqfsC6R9X9nDpL2m7Iuk/a2yL5H2A2VfJu3vlH2FtL9X9ghpP1T2VdL+QdnXSPuRsq+T9mNl3yAN8965n0a/+wRpmAP+JGnoi58iDX3x06ShL36GNMw9534Y/fOzpGFc8Bxp6LOfJw199ttIQ5/9dtLQZ/8Caeizf5E09NnvIG2Ost9J2lxlv4s09O2/RBr69neThr79PaShb/9l0tC3v5c09O0vkIa+/X2koW//FdLQt7+fNPTtL5KGvv0DpKFv/1XS0Ld/kLRQ2R8iDX37r5GGvv3DpKFv/3XS0Ld/hDT07b9BGvr2j5KGvv1jpKFv/zhp6Nt/kzT07Z8grUfZnyQNfftvkYa+/VOkoW//NGmLlf3bpA0o+zOkYQzwWdIwBvgcaRgDfJ60Jcr+AmlLlf1F0jBW+B3SMFb4XdIwVvg90jBW+H3SVin7S6StVvaXScOY4iukYUzxB6RhTPGHpGFM8UekZZX9VdIwpniJtI3Kfpm0O5T9NdIw9vhj0jD2+DppGHv8CWkYe/wpaduU/Wek4Xfy/pw0jFG+QdoOZX+TNIxR/oI0jFH+kjSMUf6KNPzW0F+Tht/2+RZpGMu8QhrGMt8mDWOZ75CG3494lTT8XsN3ScOY529Iw5jne6RhzPN90vDN9ddIwzfO/5Y0jI1+QBrGRn9HGsZGf08axkY/JA1jo38g7QFl/4i0I8pGPxz1i58tGUsHYwFtg7LwtTDKnCQNseHrY8SQr4+/S76h4ZiUkgZGjhvKwvFFmfk4IDZ8vBBDPq6INR9/HJNXDXx8HwPbhIHd+xjsK6R1+CsnjleF8GwQxrNDGM9+YTzFwnjuF8YzWxjPCWE81cJ4zgrjaRTGc0kYT6swnuvCeLqE8fQL41khjCcrjGe7MJ59wniKhPHcJ4wnLYznuDCeKmE8DwrjaRDGc1EYT4swnmvCeDqF8fQJ41kujGe9MJ6twnj2CuMpFMZzrzCecmE8x4TxzBfGc0YYT70wnmFhPKEwnqvCeDqE8fQK41kmjGedMJ4twnh2C+M5KIwnJYznqDCeecJ4TgvjqRPGc0EYzwJhPCPCeBYK4+kRxjMkjGetMJ7Nwnh2CeM5IIynTBjPYWE8lcJ4TgnjqRXGc14YT7MwnivCeNqF8SwSxjMojGeNMJ5Nwnh2CuO5RxhPiTCeQ8J4KoTxnBTGUyOM55wwniZhPJeF8bQJ47khjKdbGE9GGM9KjYfnsf2YNMwt4zl3mIPGc/MwV43n8GFOG8/1w9w3nhOIOY08d7BAY440vOPB890wX4/nxeFdWJ4/h/lBPM8OfTjPx8N8PTCVKQ3va4aBtWN1LPKH5xJYEtp6SDZ/Y/WYfZ6Mo3IORPs9QeWztd9oHycpPke1OKUpnb/PdtJB7BLkF/vG+kmD79LAbhxO3SIOpwwsp2Y4DqcMvl8P7Mbh9C3icNrAcnqG43Da4LswsBuHM7eIwxkDy5kZjgMzTpX3xG3Ge/I24z11m/H6+uuW19dft7wS6m/k+0H7vlemNN/RMtn49kHHsXBUzlx/e5bKcVwrT5rS+fw/66CMCfKLfWOdGafKe1IAL/suCOwet3O3iMM5A8u5GY4DM06V98RtxnvyNuP19cEtr68P8Xkd9W8ZR2XK3RfCew4W2/UMf6e7gGJzwdFxCbTjggX+8v2OnQSelcJ4hoTx9Anj6RTG0yKM55AwngZhPAeF8VQJ49knjKdCGM9OYTxlwni2COMpFMaTFcazShjPEmE8/cJ4uoTxtArjOSyMp1EYz5uF8VQL49kvjKdSGM8uYTyzhPFsFcaTFMazQRjPamE8S4XxLBbG0y2Mp00YzwPCeJqE8bxFGE+NMJ67hfHMEcazWxhPShjPNmE8RcJ4NgrjWSOMZ5kwngFhPIuE8bQL4zkijKdZGM+9wnhqhfG8SRjPXGE8dwnjKRfGc6cwnmJhPHcI41krjGe5MJ6MMJ4eYTwLhfEsEMZznzCeOmE89wjjmSeMZ48wnrQwnu3CeEqE8WwSxrNOGM8KYTyDwnh6hfF0COMJhfHcL4ynXhjPAWE884Xx7BXGM1sYzw5hPKXCeDYL40kI4EkFE+e9pyj9CGn4XaOjpF1U9jHSLin7FGn4Rt0J0vCd3JOkjRi2xe8FnSYNv6F4nDT8rvQZ0h4y7O9hA8sNA8sjyj5L2qPKfpC0x5R9jrTHlX2eNMz349jjHfhh0vBe2EXS8Kz0Emm4f3iZNIzxr5CG83CENMxNuEoa3te7RhqeYV8nDfd1HyIN9fph0tA+3iANc0YeIQ3vUT5KGt4teIw03G9HbKOyvjJrLB3bF9A28FNI2uMGf48ZuGDzeYptwsDuecq+QlqHv3LieEQIz2ZhPKXCeHYI45ktjGevMJ75wngOCOOpF8ZzvzCeUBhPhzCeXmE8g8J4VgjjWSeMZ5MwnhJhPNuF8aSF8ewRxjNPGM89wnjqhPHcJ4xngTCehcJ4eoTxZITxLBfGs1YYzx3CeIqF8dwpjKdcGM9dwnjmCuN5kzCeWmE89wrjaRbGc0QYT7swnkXCeAaE8SwTxrNGGM9GYTxFwni2CeNJCePZLYxnjjCeu4Xx1AjjeYswniZhPA8I42kTxtMtjGexMJ6lwnhWC+PZIIwnKYxnqzCeWcJ4dgnjqRTGs18YT7UwnjcL42kUxnNYGE+rMJ4uYTz9wniWCONZJYwnK4ynUBjPFmE8ZcJ4dgrjqRDGs08YT5UwnoPCeBqE8RwSxtMijKdTGE+fMJ4hYTwrhfGsF8ZTYODB3LqsPZ7cbx8+bL2cSweismHOYLHaN/jhL0l5nlc3dNBvQ48WzOG7QfF5VMvH5cgG9o5XtN/rjuJzTYsP+K9TfJDnXVp8oHN8Hqb4PKTl43JkA2vxGYz2e9VRfEa0+ID/KsUHed6nxQc6x+c6xeealo/LkQ2sxWco2u8VR/G5rMUH/FcoPsjzIS0+0Dk+Vyk+I1o+Lkc2sBafJdF+LzmKz0UtPuC/RPFBno9p8YHO8blC8bms5eNyZANr8Vka7XfYUXwuaPEB/zDFB3k+rcUHOsfnEsXnopaPy5ENrMVnWbTfJxzF50ktPuB/guKDPF/U4gOd4zNM8bmg5eNyZANr8Vke7fcpR/F5WosP+J+i+CDPV7T4QOf4PEHxeVLLx+VIBHbHY/BRpPb96CTleJnKkSKdv4/wjLL52wpvVTZ/l+FZZfM3HZ5TNn8P4nll87ck3qbsJ0nDmPFp0nAf7RnS8GzxraThfatnScM76M+Rhnlwz5OGufhgKlMa5jyFgd3jBX7sG+v8zURXvlOa75TmO99vfrviCTSeYBKeucJ4KoTxlAvjKRXGUySMZ44wntnCeGYJ40kJ4ykRxlMojCcpjKdSGE9aGE+ZMJ5iYTwJATz5vsGHdP52Gb5RlCQNz+2KSMO7TMWk4f3uEtL4N16gYd59GWn49s8s0hrIxt9GZZeThvem06RhLtls0jCfvYI0jJc5VojHfNIQjyrSEI9q0hCPGtIQj1rSEI860hCPetIQD44F4tFIGuLRRBri0Uwa4oFYRGzfrRxLR5kLaBtTPQmVzfWkRdlcT/DOEteTNvINjX9LChrm+3M9wTeHuJ50ko2/XcrmeoIy83FFbPj4I4YhaYh1C2k4Jq2k4di1kYZj3E4a6sJC0lBnOkhD3eIyog52kQab25tOKkdW2QM/35Jrb9hXSOvwx98S7BLCUyyMp0wYT1oYT6UwnqQwnkJhPCXCeFLCeGYJ45ktjGeOMJ4iYTylwnjKhfFUCOOZK4ynYAZ5MH7Gvps0Hpe+GzTfDTPou07zXTeDvms03zUz6LtK8101g759XfN1baZ8+7rm65rue6F130sH+J4WloS2HpLNv0PaYZ1n9H1U++UcfQ+4ncpna7/RPtooPp1anNKUzvcd2xzELkF+sW+stxl8vx7YjUPrLeLQamBpneE4MKPn9byeVx5vu+d1yuvrr+f1vJ43H69vf93y+vrreT2v583H69tft7y+/npez+t58/H69tctr6+/ntfzet58vL79dcvr66/n9byeNx+vb3/d8vr663k9r+fNx+vbX7e8vv56Xs/refPx+vbXLa+vv57X83refLy+/XXL6+uv5/W8njcfr4T2LPLdYt338SUpzXe0JLT1kOwWx7FwU87R+XhcjoVaedKUzvUzdFDGBPnFvrnMgcH2vJ7X83reUNM9r+cNPK/nDQLP63k9r+f1vJ7X83pez+t5Pa/n9bye1/MGgef1vJ7X83pez+t5Pa/n9bye1/N6Xs/reYPA83pez+t5Pa/n9bye1/N6Xs/reT2v5/W8QeB5Pa/n9bye1/N6Xs/reT2v5/W8ntfzet4g8Lye1/N6Xs/reT2v5/W8ntfzel7P63k9bxB4Xs/reT2v5/W8ntfzel7P63k9r+f1vJ43CDyv5/W8ntfzel7P63k9r+f1vJ7X83pezxsEntfzel7P63k9r+f1vJ7X83pez+t5Pa/nDQLP63k9r+f1vJ7X83pez+t5Pa/n9bye1/MGwW3NG/meZ9/3UErzHS0JbT0ke57jWDgq50C0j/lUjhatPGlK5+M930EZE+QX+8Y6M3ped7xpSi8gHgd1LzOV84l5FgjjqRfGUyeMZ64wnkZhPA3CeKqF8VQJ45kjjKdZGE+TMJ5aYTw1wngqhfEkBPCkgonj/EjrVnYBaYuUvYC0HmU3k9ar7CbS+pTdSFq/shtIW6zsetIGlF1HWkbZtaQNKruGtCFlV5O2RNlVpC1VdiVpy5Q9h7Tlyp5L2gpld5K2UtkdpK1S9kLSViu7lbQ1ym4hba2yQ9JwbLpJK1T2ItKSyu4hrUjZvaQVK7uPtBJl95NWquzFpJUpe4C0WcrOkJZS9iBp5coeIg3nyRLSZit7KWkVyl5GGo7hctJwDFeQhmO4kjScF6tIw7XCatJQd9aQhjqGYxXF7v/PHUvH9nxOwU8haWsN/tYYuGBzO4JtwsBuO8K+QlqHv3LiWCWEp1IYT40wnlphPE3CeJqF8cwRxlMljKdaGE+DMJ5GYTxzhfHUCeOpF8azQBhPgcbDY6y1pGF8x2O1Am1/PHZG/jJVxrkOyshj0oDKyktINt9bZDtrh2cgTTy8fwf35Qd5nD2Vss8nnmr7PEM8xp8KD983rLLPk3FUztylWU0wMa7wlaZ0rgM1DsqYIL/YN9aZ0fO644149OdhfB07TwgjtCq3PIMpjSdaJmsH+P5mnX2eXLtUE4OHn4fV2ufJOCrnQLRfjHVeD+y2dw3BxOOFMqQpnZ9tNjiIXYL8Yt9YZ0bP646X2xK+R4x81UIYodW65RlMaTzRMln7ws9vm+zz5Nq7hhg8/Pyt0T5PxlE5c+0d7i0VBnbbuwXBxOOFMqQpnZ+lLnAQuwT5xb6xzoye1x0vtyX8jA356oQwQuNng3iug34jel61UF2gRvtF2xg9s3qC8ifpL/J0zh3bR9ecsTK7GkPCL5apjiEdXGvHHkPytbara1sH5RxwdV8k2kd9MPF48fuDSGf/9Q5ilwjG36cIaZ0ZPa873oinVmPl+0e1QhihVbnlGYx774yvAxyM2XLtXX0MHn5H0sWY31E5B3hsWhDYbe+ag4nHC2VIUzqPv5sdxC5BfrFvrDOj53XHy20Jv5OFfPOFMELja1RoNu8p8ftF2H80rjxMY1P0Cxib8jtl0ZKkPO+dM7aPo8rmd0XwTIaft/O7e/Wa5vLeBberIa03ECP66HrSYPM7eI2a5uhae9L600SMKEMjabD5vcNmTXN57dSscWN9ATGiDM2kweZ3I0NNi7hbHHGHGjfWW4iRYwYNNj+LaNW0iLvNEXerxo31NmJEGVoNjDwexDb8jmm7svndUbwLym0r3hnla3a8W8rXyF3K5vds8S4ov4872Xu7IWl4F7SFtAJlc3nxnLyNNFx3t5OGd0z5fVe8Y8rvxeIdU35/Fu+YdpGGd0z5fVe8Y8rvu6Kd5fdd8Y4pyohn+66ea4EL+8Y6X+87uL4ejHu9DwZ+NllGcasycLt4HyJBvrBvrM8lRmizHPOkNJ5bxdHEmCJGF9eC/A7zVBj5+hDblROji3FD3Osxfg7CvGB0cZ8/7nMHHqtju9nEiPY4G9gbd+rjmGi/GFfydaB+LzUbjB+j2GZq1phQ5xcQk35PPMrH44Ripen3hiNu9DuJwG5bgz6uSGOBvyTl+YoahFeo8kCvDMbHuD2wHuOhiK2NYpkl/+0UJ/SnoT3fKyPfnXSMQmLpoDghz9coTgHp0YI+hcdSC7V8XI5sYPd4M0vWUI7Id7ejGC7SYgiWbooh8nxTi+GiYGIMOymGXVo+Lkc2sDeuSGgsWYphN/nudRTDPi2GYOmlGCLPd7QY9gUTY7iIYtij5Yv2hbr5Pbo+b5s7tg2252usTk1zdF5OqM8hrXdQuXBckFZAdr62KwzctF163Ye/JOX5MR03R9d5Q47Kmpvixn1Ht6GcSP+fVKf+l7L5ug91K0r/qSEdy2RjFMffqsn1/eincWxDg+9mYrXkO8O+E+qffm8kSfa/0IvWPF5ZRHGJFr6+z3e/tkPbhu/XthjKHVoud0gsIa3DX1Rn/g/Vr5/S8+6FDpi43ByfTooP0rtIq9Xy830Ubj9dnKuT3etpJ0ZoiFt5MPF+FN/r4XtUru6ttWncWOd7ayiD4zZgyNQGdJKfaOHzMKn6T7TvDu6bDjkqa66eN1OZ2g3lRHoZvW+Sovm/OB6oQ1F6vSEdy2TtO18juXi+GPnGtS2ObaPBdz2xWvKdYd9o3/VnDUmy6+gmCN9rQJz5nn6TIR/bbdo2fB+iyVDu0HK58z2r4PegZlP9Qv1x1eZwuTk+3L4jvYc0/Rtf/OyE28nQURzzPTsJiVHvt3mMz/dnLT4/zMWT789iHM73DKHVENdh6sddvNsfxawwGB8zrHN/LOmdOR5HFFD8agzcLt5lSwTjj2VI66b76oWOeWzc+08So4tv8sW9r87vgWG7ImJ0de8/zjtNfO8f2xUTo9R7/yXEKPXefyn95XvaWTuM48Y52DfuG8FfQTDx/ZJsMP46zzZTk8aE87KZmPT3hKJ8+pg8G0x8X4bHCrbHbaHaV5HGAn9JyrOHrgcKSK8Ixse4jdYtsS7ha0DcV4d/vm5ycM18LPLdQccoDCZeayYpzwGKUxCMvw+Efg/b8/Vfh6Ec2cDu8WaWrKEcke8uRzHs1mIIli6KIfIc1mLYHUyMId871e/Rczmygd376t15YthFvnscxbBXiyFYeiiGyHNKi2FvMDGG3RRD/R49lyMb2L0P0Zsnhj3ku99RDBdrMQRLP8UQeYa1GC4OJsawl2LYp+Xjew9X6Drw3+jZBLbn9wS7Nc3ReZnR63NI611ULhwXri+w51A8urR82WBmn1fAv+l5xePa/azb+XlFj6GcSH+G6tmzdL8K7SXqW5T+giEdy2RjP/+8Ysx+Lw3s+T4GP1uNlv8qzyveRvXrBbr/MpPPK/jZBNL5Htc8LT8/r+A2VerzCn73uk3TpD2vKCeb+4IWLV82cFZ3h/gaDO2Ffq4lKc8ntb7Axfx4V+dptI9GKlO7oZxI/wydq5+jtj5U6fxs4yVDOpbJ+gLH99lzfQHPHw4D8z3+GmK15DvDvtEX6Pcree7yV6kv4Ht7iDPPs2gw5NPvT/I2fN+vwVDu0HK5880f4fvcX6T69RL1BS7mWHC5se9oaaH4IH0RadVa/nzzWSTMh+K5Iqb5LKZvAbiaP5TvWwA8f0i/p8XP7Lgv0L+9kA2c1d1cX4B7z2gv9HMtSXle1foCB/f6h1ydp9E+5lOZmg3lRPprdK7+gNp6fU5jlP4TQzqWyfoCnr/s4Pp9wHT93m/wPUCslnxn2Df6Avjh633Y/5v6goEx82acwc3z8Dgf2/XaNmlKn2sod2i53P3EEtI6/EV15odUv35CfYGL559cbo4PP5NAeh9pdVp+fnbEbaqrPjXftwD4Gan+bYJy0vg3Xri+Zy0y8hiEnyuyP8TW2rP2zOi5jXoVndtlwcTvLyYpz/+ldpu/h8rjk3+jelhjm1nVQ34WXqEx8LdxaolrIb0f4Oo7D3G+FcZjTGzHv6OB9JkYd9xq3vJMf2OkSOMp0mLm0neJ5rtkBn2Xab7LZtB3SvOdmkHfac13egZ9T+VbMVgKZoAn0HiCSXjmCeOZL4ynQhjPLGE8ruffxuVJCuMpEsZTJ4xnjjCemRibxOGZLYynVBhPmTCeQmE8NcJ4ZuLbfXF4HH+7LzZPtTCeSmE85cJ40sJ4XL8THZenRBhPQgBPKjD/HizSeZ4F7p/wb1fyc2RoeEZTRBqeKxSThmdVJaSFwVhMoLUom79ThOehs0jjuUf4i2fb5aThfYk0aXjPYzZpeB+kgrQuZfM3/vR37fgbXDxvFLHk2COW/O0vxJK//YVY8re/EEv+9hdiyd/+QixD0hDLFtIQy1bSEEuOLWLJ3/5CLPnbX4glv0OjfyuE5z91kYaxOH/7C+NhxDYq68erxtKxPddZ+OE6u8jgr9vABZvPU1fvULKvkNb5HcqExvhG85QI4ykWxpMWxlMujKdSGE+1MJ4qYTy1wnhqhPEUCuMpE8ZTKoxntjCeucJ45gjjqRPGUySMJymMJyWMZ5YwngphPPOF8cwTxlMwgzy3mlMX+Xbw7czc74zYn4dzPDf/GvcL9Pm7PAcaeV5TBx/nCPRowfU7z9/t0vK5KcfoO2bt2rHp0spRQDbPD4qYcG8la48p95szLdbLOnrMQrUvfd46/PH8/n/Ujhn0aMExw/Y85wf5Ssm2V47R84nf9QyD8d8R0X3b/v2QGs1X7v3WeWN+O+37PRKVGfUSv0uiXy8lKc+/zhtj+6d5Y8dIf2+P7/ny83tJv+XBjHyvVZ9/wPdkedtCzQd+O6DTfhkH+Dhh3/pxKggm9kdRvmhb/bsSyGf6rsS/0zE+p24uOKp/S5m1IDBfq7fb9zsYBOPnIbdrcYtY0AZx/+mm7RltQ/V5yK3kJwjGzwUuVIMwtKH8+6OmNrRFy+eoHcvoLPo84yiu+hznbDD+Oz5hYDeu+vcK4Z+fSd2ca6TFtcEQV/5NHb2t4HIkArvnP7Mkgonf9C8IJn6PKKH+8rvOOCY8BupRdhjMzPiUv7/Ra9/3IP+WDccs0Hiw8LdIHMwnGuLf0ZkKTz/x9NnnyTgqZ+66APOSbI6PcvsIJh4v0zylxRS7N2qekud1yxvx9GisKcrXI4QRWh8x1mpxjMZZA/PHeB2Ms4ZM43z9OQ2P8y9WjbEtUWx8/cy/odWhaTxmCwO7MecxWxhM7Mv4G138nbM36vcW3mjfDn57ZoDvT1gs05DpPgL44Y/vI2zUxmrQo0W/z1MeTByLurzP4uIb5lF8mrX4gJ+/F4Q8d2rxaTbEh68RQi0flyMb2BubOboPMGQa64O/ieKDPHsmGesjPvydhGYtn6v7Gakg3u+Ouf7+ON8TmQoPz19zMLaP/f1YHtu7GEvHHdv3EY+DMXiOpy8GD19rLHbE0x+Dx/X4MhWM/77irXh4PIfzsoO0Jm0bnjfM315BHWkjDcephTTEqoA08PJvFoCL77kOaloUwyHiyyp74OdbcuMP+MK+sT5EjBllD1KZYONeX1ZxLqF1S5wrEsRToPYL/0soRkuVbfGeTW4csMJ67Jfm7gWtVPtCP4cywl+S8jxC/Vwp6TaZ3JR19H7iKipTxlBOpD+pyhldszyt7OicWAaWYCz9PYZ0LJO1BYhdVN419subO7Zr1b5wbNcYfK8jVku+M+w7of7BD/Qk2e+mSeTrxsybcQZ31A6sNuRje5m2TZrSVxvKHVou9xpiCWkd/nLfOKX69R66Xl/ugInLzfEZovggnduuVbRNlvK3UgxXW+cdbZMQM9RbsMBfkvJ8QGuT7J9Lo22S/bKOHhs+H5Ybyon0D1Od+Qi1OWi/cFyj9M8b0rFM1iYhdlF519sv7wC3MTi26w2+NxCrJd8Z3hfaJPiBniT7c9QmbRgzb8YZ3FGbtM6Qj+0V2jZpSl9nKHdoudzriSWkdfiL6szHqH59ntok+338aL1fZ4jPKooP0jE+5j4lUCzIz22S/XZ9tE1CzFBvwQJ/ScrzZa1Nsn8ujbZJLvqwIBh/Pqw0lBPpX6U68zK1OWi/cFyj9FcM6Vgma5MQu6i8G+2XN3ds71D7wrHdaPC9iVgt+c6wb7RJ8AM9Sfa3qE3aNGbejDO4ozZpgyEf26u1bdKUvsFQ7tByuTcSS0jr8BfVma9T/XqF2iQH4+UMl5vjs5biw+1ztHBdCJSN/Nwm2W/XR9skxKxY2zf8JSnPa1qbZP9cGm2TXPRh0T74fFhjKCfSf0h15kfU5ujXAFH6PxvSsUzWJiF2UXk32y9v7thuUfvCsd1s8L2VWC35zrBvtEnwAz1J9j9Rm7R1zLwZZ3BHbdImQz6212nbpCl9k6HcoeVybyaWkNbhL6oz/0j165+pTXIwXs5wuTk+WYoP0vl3Je6gbbKUn9sk++36aJuEmKHeggX+kpTnp1qbZP9cGm2TXPRh0T74fFhvKCfS/x/VmX+nNke/BojSy6ompmOZrE1C7KLybrNf3tyxvVPtC8d2m8H3dmK15DvDvtEmwQ/0JNml9AOQ28fMm3EGd9QmbTXkY3uDtk2a0rcayh1aLvc2YglpHf6iOvMfVL/K6D1bB+PlDJeb43MHxQfpeD7BfUqgWJCf2yT77fpom4SYod6CBf6SlGeOih/aJPvn0mib5KIPi/bB58NGQzmRXk3v5dRSm6NfA0TpnYZ0LJO1SYhdVN4d9subO7Y71b5wbHcYfO8iVku+M+wbbRL8QE+S3UFt0q4x82acwR21SdsN+djepG2TpvTthnKHlsu9g1hCWoe/qM40UP3qpDbJwXg5w+Xm+Gyh+CC9Rf3lPiVQLMjPbZL9dn20TULMUG/BAn9JyrNYa5Psn0ujbZKLPizaB58Pmw3lRPoSqjPLqM3RrwGi9M2GdCyTtUmIXVTe3fbLmzu2d6l94djuNvjeQ6yWfGfYN9ok+IGeJHsTtUl7xsybcQZ31CbtMuRje6u2TZrSdxnKHVou925iCWkd/qI6s5Lq12ZqkxyMlzNcbo7PnRQfpOP9DO5TAsWC/Nwm2W/XR9skxAz1Fizwl6Q8u7Q2yf65NNomuejDon3w+bDNUE6k76M6cze1Ofo1QJR+zJCOZbI2CbGLyrvXfnlzx3af2heO7V6D7/3Easl3hn2jTYIf6Emyj1KbtH/MvBlncEdt0h5DPra3a9ukKX2Podyh5XLvJZaQ1uEvqjMHqH4dozbJwXg5w+Xm+Oyk+CC9kbQ6LX9Uv3F+8PthrsabdwXj44j1XcQIbQfF1vGc01w8u4hNn3PKc7G7iOsnNN/5dpwHoduY/8Hf8NR/Iz4bzOycV45XtPCc10eo7woC85xXLr/+bnwB2bVa+SS8j/601jc7+N2bIUdlzZ1TvVSmTkM5kf48tZ1vp743VOl8zr1oSMcyWd/M7+jP9O/DsW8Jvw/3fuqbeY4f4sy/D9dnyMd2qG3D8wL7DOUOLZd7Kr8P9w6qXy9SX+LqN3L7NKZoWUDxQXoraT1afp5DwP2Hq+9l9GrMWG8iRmjNBh7b/THz1GosPGeSf1Oe50zOcxSnfN+D4d8gcuU73++BzYTvEs13yQz6zvd7YDPhO6X5Ts2g77TmOz2Dvt+Yen58SbTfagf75d/bxDLZeIF/w8LB7/JmZgVj3zU9dWJk9/DIiSsJ4gLr9zXWRDCeG+nlpBWQXUjbJQ1asUErNWizDFq5pkXLbLIryK4kex7tY84k5UAeLm/hDOnBLTjAG9Ur1BX+Zj+uF6tIw3GpJg3+kL8smFgvrZ7YXHB9KaG0ApU3qjRRR1Os0jsN279D1Sy80LV/ZPjykVMnwivnhkfCgfDCz/4/cu7c8PUTx/tDTrsSnr96ZSS8MnLk8kh48vLw+TDTz/t9TtU63JzYcPnykYfDMxeOn3goHL46Eg6fDI8OX71w/Apv9M7pbPTCdDb64HQ2+uh0NvrUdDb6wnQ2+vJ0Nnp5zjQ2+sZ0Nvr2dDb60XQ2Kpw7jY3umc5Gh6az0cnpbHRhOhs9Np2NPjGdjb4znY3+VW2EG51HRkZOnL84Eo4Mh0eOHw+vnxk5HQ5fO3H55M/an3EN+LxpOPsf09moYP40NkpNZ6MN09lo23Q2ums6G92YzkYvTmejL01no+9PZ6N/mc5GlVXT2Kh/OhvtnM5GN6az0VNT3Sj4T86sZShnrQMA","debug_symbols":"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Qw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIYc1JCDGnJQQw5qyEENOaghBzXkoIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkoobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCbGnJTQ25qyE0NuakhNzXkpobc1JCb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0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u4x380H891nzmDOYS5gLmGuYK5hbmBuYQ72xWBfDPbFYF8M9sVgXwz2xWBfDPbFYF8M9sVhXxz2xWFfHPbFYV8c9sVhXxz2xWFfHPYlYF8C9iVgXwL2JWBfAvYlYF8C9iVgXwL2JWFfEvYlYV8S9iVhXxL2JWFfEvYlYV8S9qVgXwr2pWBfCvalYF8K9qVgXwr2pWBfCvalYV8a9qVh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"}],"events":[],"file_map":{"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}","path":"std/collections/bounded_vec.nr"},"31":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"contract Blank {\n    use dep::aztec::{\n        protocol_types::address::AztecAddress,\n        state_vars::{singleton::Singleton, map::Map},\n        context::{PrivateContext, PublicContext, Context},\n        note::{\n            utils as note_utils,\n            note_interface::NoteInterface,\n            note_header::NoteHeader,\n        },\n    };\n\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        numbers: Map<AztecAddress, Singleton<ValueNote>>,\n    }\n    \n    #[aztec(private)]\n    fn constructor(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).initialize(&mut new_number, true);\n    }\n\n    #[aztec(private)]\n    fn setNumber(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).replace(&mut new_number, true);\n    }\n\n    unconstrained fn getNumber(owner: AztecAddress) -> pub ValueNote {\n        let numbers = storage.numbers;\n        numbers.at(owner).view_note()\n    }\n\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: AztecAddress,\n        nonce: Field,\n        storage_slot: Field,\n        note_type_id: Field,\n        serialized_note: [Field; VALUE_NOTE_LEN]\n    ) -> pub [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(ValueNote::deserialize_content, note_header, serialized_note)\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/boxes/blank/src/contracts/src/main.nr"},"53":{"source":"use crate::{\n    context::inputs::PrivateContextInputs, key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_COMMITMENTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header, utils::reader::Reader\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    max_non_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n            max_non_revertible_side_effect_counter: 0,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            read_requests: BoundedVec::new(SideEffect::empty()),\n            nullifier_key_validation_requests: BoundedVec::new(NullifierKeyValidationRequest::empty()),\n            new_commitments: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            max_non_revertible_side_effect_counter: self.max_non_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_max_non_revertible_side_effect_counter(&mut self) {\n        assert(\n            self.max_non_revertible_side_effect_counter == 0, \"Already captured the non-revertible side effect counter\"\n        );\n        self.max_non_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_commitments.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) {\n        // docs:end:context_message_portal\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            self.this_portal_address(),\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(\n            item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n        );\n        assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [SideEffect::empty(); MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(\n            item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n        );\n        assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"55":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/context.nr"},"57":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/hasher.nr"},"68":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/log.nr"},"72":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"73":{"source":"use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{\n        MAX_READ_REQUESTS_PER_CALL,\n        GET_NOTE_ORACLE_RETURN_LENGTH,\n        GET_NOTES_ORACLE_RETURN_LENGTH,\n        MAX_NOTES_PER_PAGE,\n        VIEW_NOTE_ORACLE_RETURN_LENGTH,\n    },\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption,\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u3; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"79":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_COMMITMENT,\n    GENERATOR_INDEX__SILOED_COMMITMENT\n},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"91":{"source":"use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr"},"94":{"source":"use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"95":{"source":"use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    utils::arr_copy_slice,\n};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u3; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u2,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u3; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u3; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"96":{"source":"use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr"},"98":{"source":"#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/oracle/rand.nr"},"102":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"105":{"source":"use dep::std::option::Option;\n\nuse dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note}, note_getter::{get_note, view_notes},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::{nullifier_key::get_nullifier_secret_key, notes::check_nullifier_exists};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct Singleton<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for Singleton<T> {}\n\nimpl<Note> Singleton<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, Singleton>` type (for example), because the storage slot often also identifies an actor. e.g. \n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy. \n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<N>(self, new_note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note<N>(self, broadcast: bool) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/aztec/src/state_vars/singleton.nr"},"136":{"source":"use crate::{\n    constants::{GENERATOR_INDEX__CONTRACT_ADDRESS, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONSTRUCTOR},\n    hash::pedersen_hash, contract_class::ContractClassId, utils, grumpkin_point::GrumpkinPoint\n};\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, ToField, Serialize, Deserialize};\nuse crate::type_serialization::{ETH_ADDRESS_SERIALIZED_LEN, AZTEC_ADDRESS_SERIALIZED_LEN};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_SERIALIZED_LEN> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_SERIALIZED_LEN] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_SERIALIZED_LEN> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_SERIALIZED_LEN]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_SERIALIZED_LEN> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_SERIALIZED_LEN] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_SERIALIZED_LEN> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_SERIALIZED_LEN]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\npub fn compute_initialization_hash(selector: Field, args_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        selector,\n        args_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/noir-protocol-circuits/src/crates/types/src/address.nr"},"145":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::{ContractClassFunctionLeafPreimage, FunctionLeafPreimage};\nuse crate::contract_class::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_COMMITMENT,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__COMMITMENT_NONCE, GENERATOR_INDEX__UNIQUE_COMMITMENT,\n    GENERATOR_INDEX__FUNCTION_ARGS\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr"},"176":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/noir-protocol-circuits/src/crates/types/src/utils.nr"},"183":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n","path":"/Users/zpedro/nargo/github.com/AztecProtocol/aztec-packagesmaster/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}