// AUTOGENERATED FILE
#pragma once

#include <mutex>
#include <vector>

#include "barretenberg/common/constexpr_utils.hpp"
#include "barretenberg/common/thread.hpp"
#include "barretenberg/common/throw_or_abort.hpp"
#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include "barretenberg/stdlib_circuit_builders/circuit_builder_base.hpp"
#include "barretenberg/relations/generic_permutation/generic_permutation_relation.hpp"
#include "barretenberg/relations/generic_lookup/generic_lookup_relation.hpp"
#include "barretenberg/honk/proof_system/logderivative_library.hpp"

#include "barretenberg/vm/generated/{{snakeCase name}}_full_row.hpp"
#include "barretenberg/vm/generated/{{snakeCase name}}_flavor.hpp"

namespace bb {

class {{name}}CircuitBuilder {
    public:
        using Flavor = bb::{{name}}Flavor;
        using FF = Flavor::FF;
        using Row = {{name}}FullRow<FF>;

        // TODO: template
        using Polynomial = Flavor::Polynomial;
        using ProverPolynomials = Flavor::ProverPolynomials;

        static constexpr size_t num_fixed_columns = {{len all_cols}};
        static constexpr size_t num_polys = {{len all_cols}} + {{len to_be_shifted}};
        std::vector<Row> rows;

        void set_trace(std::vector<Row>&& trace) { rows = std::move(trace); }

        ProverPolynomials compute_polynomials() {
            const auto num_rows = get_circuit_subgroup_size();
            ProverPolynomials polys;

            // Allocate mem for each column
            for (auto& poly : polys.get_all()) {
                poly = Polynomial(num_rows);
            }

            for (size_t i = 0; i < rows.size(); i++) {
              {{#each all_cols_without_inverses as |poly|}}
              polys.{{poly}}[i] = rows[i].{{poly}};
              {{/each}}
            }

            for (auto [shifted, to_be_shifted] : zip_view(polys.get_shifted(), polys.get_to_be_shifted())) {
                shifted = to_be_shifted.shifted();
            }

            return polys;
        }

        [[maybe_unused]] bool check_circuit()
        {
            const FF gamma = FF::random_element();
            const FF beta = FF::random_element();
            bb::RelationParameters<typename Flavor::FF> params{
                .eta = 0,
                .beta = beta,
                .gamma = gamma,
                .public_input_delta = 0,
                .lookup_grand_product_delta = 0,
                .beta_sqr = 0,
                .beta_cube = 0,
                .eccvm_set_permutation_delta = 0,
            };

            auto polys = compute_polynomials();
            const size_t num_rows = polys.get_polynomial_size();

            // Checks that we will run.
            using SignalErrorFn = const std::function<void(const std::string&)>&;
            std::vector<std::function<void(SignalErrorFn)>> checks;

            // Add relation checks.
            bb::constexpr_for<0, std::tuple_size_v<{{name}}Flavor::MainRelations>, 1>([&]<size_t i>() {
                using Relation = std::tuple_element_t<i, {{name}}Flavor::MainRelations>;
                checks.push_back([&](SignalErrorFn signal_error) {
                    typename Relation::SumcheckArrayOfValuesOverSubrelations result;
                    for (auto& r : result) {
                        r = 0;
                    }
                    constexpr size_t NUM_SUBRELATIONS = result.size();

                    for (size_t r = 0; r < num_rows; ++r) {
                        Relation::accumulate(result, polys.get_row(r), {}, 1);
                        for (size_t j = 0; j < NUM_SUBRELATIONS; ++j) {
                            if (result[j] != 0) {
                                signal_error(format("Relation ",
                                                    Relation::NAME,
                                                    ", subrelation ",
                                                    Relation::get_subrelation_label(j),
                                                    " failed at row ",
                                                    r));
                            }
                        }
                    }
                });
            });

            // Add calculation of logderivatives and lookup/permutation checks.
            bb::constexpr_for<0, std::tuple_size_v<{{name}}Flavor::LookupRelations>, 1>([&]<size_t i>() {
                using Relation = std::tuple_element_t<i, {{name}}Flavor::LookupRelations>;
                checks.push_back([&, num_rows](SignalErrorFn signal_error) {
                    // Check the logderivative relation
                    bb::compute_logderivative_inverse<Flavor, Relation>(polys, params, num_rows);

                    typename Relation::SumcheckArrayOfValuesOverSubrelations lookup_result;

                    for (auto& r : lookup_result) {
                        r = 0;
                    }
                    for (size_t r = 0; r < num_rows; ++r) {
                        Relation::accumulate(lookup_result, polys.get_row(r), params, 1);
                    }
                    for (auto r : lookup_result) {
                        if (r != 0) {
                            signal_error(format("Lookup ", Relation::NAME, " failed."));
                        }
                    }
                });
            });

            std::string errors;
            auto signal_error = [&](const std::string& error) {
                // Thread safety first!
                static std::mutex m;
                std::lock_guard<std::mutex> lock(m);
                errors += error + "\n";
            };
            bb::parallel_for(checks.size(), [&](size_t i) { checks[i](signal_error); });
            if (!errors.empty()) {
                throw_or_abort(errors);
            }

            return errors.empty();
        }
    
        [[nodiscard]] size_t get_num_gates() const { return rows.size(); }

        [[nodiscard]] size_t get_circuit_subgroup_size() const
        {
            const size_t num_rows = get_num_gates();
            const auto num_rows_log2 = static_cast<size_t>(numeric::get_msb64(num_rows));
            size_t num_rows_pow2 = 1UL << (num_rows_log2 + (1UL << num_rows_log2 == num_rows ? 0 : 1));
            return num_rows_pow2;
        }
};

}  // namespace bb