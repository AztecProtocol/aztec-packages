// AUTOGENERATED FILE
#pragma once

#include <vector>
#ifndef __wasm__
#include <future>
#endif

#include "barretenberg/common/constexpr_utils.hpp"
#include "barretenberg/common/throw_or_abort.hpp"
#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include "barretenberg/stdlib_circuit_builders/circuit_builder_base.hpp"
#include "barretenberg/relations/generic_permutation/generic_permutation_relation.hpp"
#include "barretenberg/relations/generic_lookup/generic_lookup_relation.hpp"
#include "barretenberg/honk/proof_system/logderivative_library.hpp"

#include "barretenberg/vm/generated/{{snakeCase name}}_full_row.hpp"
#include "barretenberg/vm/generated/{{snakeCase name}}_flavor.hpp"

namespace bb {

class {{name}}CircuitBuilder {
    public:
        using Flavor = bb::{{name}}Flavor;
        using FF = Flavor::FF;
        using Row = {{name}}FullRow<FF>;

        // TODO: template
        using Polynomial = Flavor::Polynomial;
        using ProverPolynomials = Flavor::ProverPolynomials;

        static constexpr size_t num_fixed_columns = {{len all_cols}};
        static constexpr size_t num_polys = {{len all_cols}} + {{len to_be_shifted}};
        std::vector<Row> rows;

        void set_trace(std::vector<Row>&& trace) { rows = std::move(trace); }

        ProverPolynomials compute_polynomials() {
            const auto num_rows = get_circuit_subgroup_size();
            ProverPolynomials polys;

            // Allocate mem for each column
            for (auto& poly : polys.get_all()) {
                poly = Polynomial(num_rows);
            }

            for (size_t i = 0; i < rows.size(); i++) {
              {{#each all_cols_without_inverses as |poly|}}
              polys.{{poly}}[i] = rows[i].{{poly}};
              {{/each}}
            }

            for (auto [shifted, to_be_shifted] : zip_view(polys.get_shifted(), polys.get_to_be_shifted())) {
                shifted = to_be_shifted.shifted();
            }

            return polys;
        }

        [[maybe_unused]] bool check_circuit()
        {
            const FF gamma = FF::random_element();
            const FF beta = FF::random_element();
            bb::RelationParameters<typename Flavor::FF> params{
                .eta = 0,
                .beta = beta,
                .gamma = gamma,
                .public_input_delta = 0,
                .lookup_grand_product_delta = 0,
                .beta_sqr = 0,
                .beta_cube = 0,
                .eccvm_set_permutation_delta = 0,
            };

            auto polys = compute_polynomials();
            const size_t num_rows = polys.get_polynomial_size();
    
            const auto evaluate_relation = [&]<typename Relation>(const std::string& relation_name,
                                                                    std::string (*debug_label)(int)) {
                typename Relation::SumcheckArrayOfValuesOverSubrelations result;
                for (auto& r : result) {
                    r = 0;
                }
                constexpr size_t NUM_SUBRELATIONS = result.size();
    
                for (size_t i = 0; i < num_rows; ++i) {
                    Relation::accumulate(result, polys.get_row(i), {}, 1);
    
                    bool x = true;
                    for (size_t j = 0; j < NUM_SUBRELATIONS; ++j) {
                        if (result[j] != 0) {
                            std::string row_name = debug_label(static_cast<int>(j));
                            throw_or_abort(
                                format("Relation ", relation_name, ", subrelation index ", row_name, " failed at row ", i));
                            x = false;
                        }
                    }
                    if (!x) {
                        return false;
                    }
                }
                return true;
            };

            const auto evaluate_logderivative = [&]<typename LogDerivativeSettings>(const std::string& lookup_name) {
                // Check the logderivative relation
                bb::compute_logderivative_inverse<
                    Flavor,
                    LogDerivativeSettings>(
                    polys, params, num_rows);
        
                typename LogDerivativeSettings::SumcheckArrayOfValuesOverSubrelations
                    lookup_result;

                for (auto& r : lookup_result) {
                    r = 0;
                }
                for (size_t i = 0; i < num_rows; ++i) {
                    LogDerivativeSettings::accumulate(lookup_result, polys.get_row(i), params, 1);
                }
                for (auto r : lookup_result) {
                    if (r != 0) {
                        throw_or_abort(format("Lookup ", lookup_name, " failed."));
                        return false;
                    }
                }
                return true;
            };

            // Check relations
            {{#each relations as |rel|}}
            auto {{rel}} = [=]() {
              return evaluate_relation.template operator()<{{../name}}_vm::{{rel}}<FF>>("{{rel}}", {{../name}}_vm::get_relation_label_{{rel}});
            };
            {{/each}}

            // Check lookups
            {{#each permutations as |l|}}
            auto {{l}} = [=]() {
              return evaluate_logderivative.template operator()<{{l}}_relation<FF>>("{{shoutySnakeCase l}}");
            };
            {{/each}}

            // Evaluate check circuit closures as futures
            std::vector<std::future<bool>> relation_futures;

            {{#each relations as |rel|}}
            relation_futures.emplace_back(std::async(std::launch::async, {{rel}}));
            {{/each}}
            {{#each permutations as |l|}}
            relation_futures.emplace_back(std::async(std::launch::async, {{l}}));
            {{/each}}

            // Wait for lookup evaluations to complete
            for (auto& future : relation_futures) {
                if (!future.get()) {
                    return false;
                }
            }

            return true;
        }
    

        [[nodiscard]] size_t get_num_gates() const { return rows.size(); }

        [[nodiscard]] size_t get_circuit_subgroup_size() const
        {
            const size_t num_rows = get_num_gates();
            const auto num_rows_log2 = static_cast<size_t>(numeric::get_msb64(num_rows));
            size_t num_rows_pow2 = 1UL << (num_rows_log2 + (1UL << num_rows_log2 == num_rows ? 0 : 1));
            return num_rows_pow2;
        }
};

}  // namespace bb