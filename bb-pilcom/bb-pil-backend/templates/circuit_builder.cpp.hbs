// AUTOGENERATED FILE
#include "barretenberg/vm/{{snakeCase name}}/generated/circuit_builder.hpp"

#include <mutex>

#include "barretenberg/common/constexpr_utils.hpp"
#include "barretenberg/common/thread.hpp"
#include "barretenberg/common/throw_or_abort.hpp"
#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include "barretenberg/relations/generic_permutation/generic_permutation_relation.hpp"
#include "barretenberg/relations/generic_lookup/generic_lookup_relation.hpp"
#include "barretenberg/honk/proof_system/logderivative_library.hpp"

namespace bb {

{{name}}CircuitBuilder::ProverPolynomials {{name}}CircuitBuilder::compute_polynomials() const {
    const auto num_rows = get_circuit_subgroup_size();
    ProverPolynomials polys;

    // Allocate mem for each column
    for (auto& poly : polys.get_all()) {
        poly = Polynomial(num_rows);
    }

    for (size_t i = 0; i < rows.size(); i++) {
        {{#each all_cols_without_inverses as |poly|}}
        polys.{{poly}}[i] = rows[i].{{poly}};
        {{/each}}
    }

    for (auto [shifted, to_be_shifted] : zip_view(polys.get_shifted(), polys.get_to_be_shifted())) {
        shifted = to_be_shifted.shifted();
    }

    return polys;
}

bool {{name}}CircuitBuilder::check_circuit() const {
    const FF gamma = FF::random_element();
    const FF beta = FF::random_element();
    bb::RelationParameters<typename Flavor::FF> params{
        .eta = 0,
        .beta = beta,
        .gamma = gamma,
        .public_input_delta = 0,
        .lookup_grand_product_delta = 0,
        .beta_sqr = 0,
        .beta_cube = 0,
        .eccvm_set_permutation_delta = 0,
    };

    auto polys = compute_polynomials();
    const size_t num_rows = polys.get_polynomial_size();

    // Checks that we will run.
    using SignalErrorFn = const std::function<void(const std::string&)>&;
    std::vector<std::function<void(SignalErrorFn)>> checks;

    // Add relation checks.
    bb::constexpr_for<0, std::tuple_size_v<{{name}}Flavor::MainRelations>, 1>([&]<size_t i>() {
        using Relation = std::tuple_element_t<i, {{name}}Flavor::MainRelations>;
        checks.push_back([&](SignalErrorFn signal_error) {
            typename Relation::SumcheckArrayOfValuesOverSubrelations result;
            for (auto& r : result) {
                r = 0;
            }

            std::array<bool, result.size()> subrelation_failed = { false };
            for (size_t r = 0; r < num_rows; ++r) {
                Relation::accumulate(result, polys.get_row(r), {}, 1);
                for (size_t j = 0; j < result.size(); ++j) {
                    if (!subrelation_failed[j] && result[j] != 0) {
                        signal_error(format("Relation ",
                                            Relation::NAME,
                                            ", subrelation ",
                                            Relation::get_subrelation_label(j),
                                            " failed at row ",
                                            r));
                        // We will not check this subrelation for any other rows.
                        // Since the accumulation will keep being != 0.
                        subrelation_failed[j] = true;
                    }
                }
            }
        });
    });

    // Add calculation of logderivatives and lookup/permutation checks.
    bb::constexpr_for<0, std::tuple_size_v<{{name}}Flavor::LookupRelations>, 1>([&]<size_t i>() {
        using Relation = std::tuple_element_t<i, {{name}}Flavor::LookupRelations>;
        checks.push_back([&, num_rows](SignalErrorFn signal_error) {
            // Check the logderivative relation
            bb::compute_logderivative_inverse<Flavor, Relation>(polys, params, num_rows);

            typename Relation::SumcheckArrayOfValuesOverSubrelations lookup_result;

            for (auto& r : lookup_result) {
                r = 0;
            }
            for (size_t r = 0; r < num_rows; ++r) {
                Relation::accumulate(lookup_result, polys.get_row(r), params, 1);
            }
            for (auto r : lookup_result) {
                if (r != 0) {
                    signal_error(format("Lookup ", Relation::NAME, " failed."));
                }
            }
        });
    });

    std::string errors;
    std::mutex m;
    auto signal_error = [&](const std::string& error) {
        std::lock_guard<std::mutex> lock(m);
        errors += error + "\n";
    };
    bb::parallel_for(checks.size(), [&](size_t i) { checks[i](signal_error); });
    if (!errors.empty()) {
        throw_or_abort(errors);
    }

    return errors.empty();
}
    
}  // namespace bb