// AUTOGENERATED FILE
#pragma once

#include "barretenberg/commitment_schemes/kzg/kzg.hpp"
#include "barretenberg/ecc/curves/bn254/g1.hpp"
#include "barretenberg/flavor/relation_definitions.hpp"
#include "barretenberg/polynomials/barycentric.hpp"
#include "barretenberg/polynomials/univariate.hpp"

#include "barretenberg/flavor/flavor_macros.hpp"
#include "barretenberg/transcript/transcript.hpp"
#include "barretenberg/polynomials/evaluation_domain.hpp"
#include "barretenberg/flavor/flavor.hpp"

#include "barretenberg/vm/{{snakeCase name}}/generated/flavor_settings.hpp"

// Relations
{{#each relation_file_names as |r|}}
#include "barretenberg/vm/{{snakeCase ../name}}/generated/relations/{{r}}.hpp"
{{/each}}

// Lookup and permutation relations
{{#each lookups as |r|}}
#include "barretenberg/vm/{{snakeCase ../name}}/generated/relations/{{r}}.hpp"
{{/each}}

// Metaprogramming to concatenate tuple types.
template <typename... input_t> using tuple_cat_t = decltype(std::tuple_cat(std::declval<input_t>()...));

// The entities that will be used in the flavor.
// clang-format off
#define PRECOMPUTED_ENTITIES {{#each fixed as |item|}}{{#if @index}}, {{/if}}{{item}}{{/each}}
#define WIRE_ENTITIES {{#each witness_without_inverses as |item|}}{{#if @index}}, {{/if}}{{item}}{{/each}}
#define DERIVED_WITNESS_ENTITIES {{#each inverses as |item|}}{{#if @index}}, {{/if}}{{item}}{{/each}}
#define SHIFTED_ENTITIES {{#each shifted as |item|}}{{#if @index}}, {{/if}}{{item}}{{/each}}
#define TO_BE_SHIFTED(e) {{#each to_be_shifted as |item|}}{{#if @index}}, {{/if}}e.{{item}}{{/each}}
#define ALL_ENTITIES {{#if (len fixed)}}PRECOMPUTED_ENTITIES{{/if}}{{#if (len witness_without_inverses)}}, WIRE_ENTITIES{{/if}}{{#if (len lookups)}}, DERIVED_WITNESS_ENTITIES{{/if}}{{#if (len shifted)}}, SHIFTED_ENTITIES{{/if}}
// clang-format on

namespace bb {

class {{name}}Flavor {
  public:
    using Curve = {{name}}FlavorSettings::Curve;
    using G1 = {{name}}FlavorSettings::G1;
    using PCS = {{name}}FlavorSettings::PCS;

    using FF = {{name}}FlavorSettings::FF;
    using Polynomial = {{name}}FlavorSettings::Polynomial;
    using PolynomialHandle = {{name}}FlavorSettings::PolynomialHandle;
    using GroupElement = {{name}}FlavorSettings::GroupElement;
    using Commitment = {{name}}FlavorSettings::Commitment;
    using CommitmentHandle = {{name}}FlavorSettings::CommitmentHandle;
    using CommitmentKey = {{name}}FlavorSettings::CommitmentKey;
    using VerifierCommitmentKey = {{name}}FlavorSettings::VerifierCommitmentKey;
    using RelationSeparator = {{name}}FlavorSettings::RelationSeparator;

    // This flavor would not be used with ZK Sumcheck
    static constexpr bool HasZK = false;

    static constexpr size_t NUM_PRECOMPUTED_ENTITIES = {{len fixed}};
    static constexpr size_t NUM_WITNESS_ENTITIES = {{len witness}};
    static constexpr size_t NUM_SHIFTED_ENTITIES = {{len shifted}};
    static constexpr size_t NUM_WIRES = NUM_WITNESS_ENTITIES + NUM_PRECOMPUTED_ENTITIES;
    // We have two copies of the witness entities, so we subtract the number of fixed ones (they have no shift), one for the unshifted and one for the shifted
    static constexpr size_t NUM_ALL_ENTITIES = {{len all_cols_and_shifts}};
    // The total number of witnesses including shifts and derived entities.
    static constexpr size_t NUM_ALL_WITNESS_ENTITIES = NUM_WITNESS_ENTITIES + NUM_SHIFTED_ENTITIES;

    // Need to be templated for recursive verifier
    template <typename FF>
    using MainRelations_ = std::tuple<
      // Relations
      {{#each relation_file_names as |item|}}{{#if @index}},{{/if}}{{../name}}_vm::{{item}}<FF>{{/each}}
    >;

    using MainRelations = MainRelations_<FF>;

    // Need to be templated for recursive verifier
    template <typename FF>
    using LookupRelations_ = std::tuple<
      // Lookups
      {{#each lookups as |item|}}{{#if @index}},{{/if}}{{item}}_relation<FF>{{/each}}
    >;

    using LookupRelations = LookupRelations_<FF>;

    // Need to be templated for recursive verifier
    template <typename FF> using Relations_ = tuple_cat_t<MainRelations_<FF>, LookupRelations_<FF>>;
    using Relations = Relations_<FF>;

    static constexpr size_t MAX_PARTIAL_RELATION_LENGTH = compute_max_partial_relation_length<Relations>();

    // BATCHED_RELATION_PARTIAL_LENGTH = algebraic degree of sumcheck relation *after* multiplying by the `pow_zeta`
    // random polynomial e.g. For \sum(x) [A(x) * B(x) + C(x)] * PowZeta(X), relation length = 2 and random relation
    // length = 3
    static constexpr size_t BATCHED_RELATION_PARTIAL_LENGTH = MAX_PARTIAL_RELATION_LENGTH + 1;
    static constexpr size_t NUM_RELATIONS = std::tuple_size_v<Relations>;

    using SumcheckTupleOfTuplesOfUnivariates = decltype(create_sumcheck_tuple_of_tuples_of_univariates<Relations>());
    using TupleOfArraysOfValues = decltype(create_tuple_of_arrays_of_values<Relations>());

    static constexpr bool has_zero_row = true;

    template <typename DataType_> class PrecomputedEntities : public PrecomputedEntitiesBase {
      public:
        using DataType = DataType_;

        DEFINE_FLAVOR_MEMBERS(DataType, PRECOMPUTED_ENTITIES)

        RefVector<DataType> get_selectors() { return get_all(); }
        RefVector<DataType> get_sigma_polynomials() { return {}; }
        RefVector<DataType> get_id_polynomials() { return {}; }
        RefVector<DataType> get_table_polynomials() { return {}; }
    };

    template <typename DataType>
    class WireEntities {
      public:
        DEFINE_FLAVOR_MEMBERS(DataType, WIRE_ENTITIES)
    };

    template <typename DataType>
    class DerivedWitnessEntities {
      public:
        DEFINE_FLAVOR_MEMBERS(DataType, DERIVED_WITNESS_ENTITIES)
    };

    template <typename DataType>
    class ShiftedEntities {
      public:
        DEFINE_FLAVOR_MEMBERS(DataType, SHIFTED_ENTITIES)
    };

    template <typename DataType, typename PrecomputedAndWitnessEntitiesSuperset>
    static auto get_to_be_shifted([[maybe_unused]] PrecomputedAndWitnessEntitiesSuperset& entities) {
        return RefArray<DataType, NUM_SHIFTED_ENTITIES>{ TO_BE_SHIFTED(entities) };
    }

    template <typename DataType>
      class WitnessEntities: public WireEntities<DataType>, public DerivedWitnessEntities<DataType> {
          public:
              DEFINE_COMPOUND_GET_ALL(WireEntities<DataType>, DerivedWitnessEntities<DataType>)
              auto get_wires() { return WireEntities<DataType>::get_all(); }
              auto get_derived() { return DerivedWitnessEntities<DataType>::get_all(); }
    };

    template <typename DataType>
    class AllEntities : public PrecomputedEntities<DataType>
                  , public WitnessEntities<DataType>
                  , public ShiftedEntities<DataType> {
      public:
        DEFINE_COMPOUND_GET_ALL(PrecomputedEntities<DataType>, WitnessEntities<DataType>, ShiftedEntities<DataType>)

        auto get_unshifted() {
          return concatenate(PrecomputedEntities<DataType>::get_all(), WitnessEntities<DataType>::get_all());
        }
        auto get_to_be_shifted() { return {{name}}Flavor::get_to_be_shifted<DataType>(*this); }
        auto get_shifted() { return ShiftedEntities<DataType>::get_all(); }
        auto get_precomputed() { return PrecomputedEntities<DataType>::get_all(); }
    };

    class ProvingKey : public ProvingKeyAvm_<PrecomputedEntities<Polynomial>, WitnessEntities<Polynomial>, CommitmentKey> {
      public:
        // Expose constructors on the base class
        using Base = ProvingKeyAvm_<PrecomputedEntities<Polynomial>, WitnessEntities<Polynomial>, CommitmentKey>;
        using Base::Base;
       auto get_to_be_shifted() {
          return {{name}}Flavor::get_to_be_shifted<DataType>(*this);
         }
    };

    class VerificationKey : public VerificationKey_<PrecomputedEntities<Commitment>, VerifierCommitmentKey> {
      public:
       VerificationKey() = default;

        VerificationKey(const std::shared_ptr<ProvingKey>& proving_key)
            : VerificationKey_(proving_key->circuit_size, proving_key->num_public_inputs)
        {
            for (auto [polynomial, commitment] :
                zip_view(proving_key->get_precomputed_polynomials(), this->get_all())) {
                    commitment = proving_key->commitment_key->commit(polynomial);
            }
            pcs_verification_key = std::make_shared<VerifierCommitmentKey>();
        }

        VerificationKey(const size_t circuit_size,
                        const size_t num_public_inputs,
                        std::array<Commitment, NUM_PRECOMPUTED_ENTITIES> const& precomputed_cmts)
            : VerificationKey_(circuit_size, num_public_inputs)
        {
            for (auto [vk_cmt, cmt] : zip_view(this->get_all(), precomputed_cmts)) {
                vk_cmt = cmt;
            }
            pcs_verification_key = std::make_shared<VerifierCommitmentKey>();
        }
    };

    {{!-- Used by sumcheck --}}
    class AllValues : public AllEntities<FF> {
      public:
        using Base = AllEntities<FF>;
        using Base::Base;
    };

    {{!-- Used by get_row, logderivs, etc --}}
    class AllConstRefValues {
      public:
        using BaseDataType = const FF;
        using DataType = BaseDataType&;

        {{!--
        We define the flavor members here again to avoid having to make this class inherit from AllEntities.
        If we did inherit from AllEntities, we have to define a special constructor for AllEntities, and all
        the classes that AllEntities inherits from, in cascade.
        --}}
        DEFINE_FLAVOR_MEMBERS(DataType, ALL_ENTITIES)

        AllConstRefValues(const RefArray<BaseDataType, NUM_ALL_ENTITIES>& il);
    };

    /**
    * @brief A container for the prover polynomials handles.
    */
    class ProverPolynomials : public AllEntities<Polynomial> {
      public:
        // Define all operations as default, except copy construction/assignment
        ProverPolynomials() = default;
        ProverPolynomials& operator=(const ProverPolynomials&) = delete;
        ProverPolynomials(const ProverPolynomials& o) = delete;
        ProverPolynomials(ProverPolynomials&& o) noexcept = default;
        ProverPolynomials& operator=(ProverPolynomials&& o) noexcept = default;
        ~ProverPolynomials() = default;

        ProverPolynomials(ProvingKey& proving_key);

        [[nodiscard]] size_t get_polynomial_size() const { return {{witness.0}}.size(); }
        /**
        * @brief Returns the evaluations of all prover polynomials at one point on the boolean hypercube, which
        * represents one row in the execution trace.
        */
        [[nodiscard]] AllConstRefValues get_row(size_t row_idx) const;
    };

    class PartiallyEvaluatedMultivariates : public AllEntities<Polynomial> {
      public:
        PartiallyEvaluatedMultivariates() = default;
        PartiallyEvaluatedMultivariates(const size_t circuit_size);
    };

    /**
    * @brief A container for univariates used during Protogalaxy folding and sumcheck.
    * @details During folding and sumcheck, the prover evaluates the relations on these univariates.
    */
    template <size_t LENGTH>
    using ProverUnivariates = AllEntities<bb::Univariate<FF, LENGTH>>;

    /**
    * @brief A container for univariates used during Protogalaxy folding and sumcheck with some of the computation
    * optimistically ignored
    * @details During folding and sumcheck, the prover evaluates the relations on these univariates.
    */
    template <size_t LENGTH, size_t SKIP_COUNT>
    using OptimisedProverUnivariates = AllEntities<bb::Univariate<FF, LENGTH, 0, SKIP_COUNT>>;

    /**
    * @brief A container for univariates produced during the hot loop in sumcheck.
    */
    using ExtendedEdges = ProverUnivariates<MAX_PARTIAL_RELATION_LENGTH>;

    /**
    * @brief A container for the witness commitments.
    *
    */
    using WitnessCommitments = WitnessEntities<Commitment>;

    class CommitmentLabels: public AllEntities<std::string> {
      private:
        using Base = AllEntities<std::string>;

      public:
        CommitmentLabels();
    };

    // Templated for use in recursive verifier
    template <typename Commitment, typename VerificationKey>
    class VerifierCommitments_ : public AllEntities<Commitment> {
    private:
      using Base = AllEntities<Commitment>;

    public:
      VerifierCommitments_(const std::shared_ptr<VerificationKey>& verification_key) {
            {{#each fixed as |item|}}
            this->{{item}} = verification_key->{{item}};
            {{/each}}
        }
    };

    // Native version of the verifier commitments
    using VerifierCommitments = VerifierCommitments_<Commitment, VerificationKey>;

    class Transcript : public NativeTranscript {
    public:
      uint32_t circuit_size;

      std::array<Commitment, NUM_WITNESS_ENTITIES> commitments;

      std::vector<bb::Univariate<FF, BATCHED_RELATION_PARTIAL_LENGTH>> sumcheck_univariates;
      std::array<FF, NUM_ALL_ENTITIES> sumcheck_evaluations;
      std::vector<Commitment> zm_cq_comms;
      Commitment zm_cq_comm;
      Commitment zm_pi_comm;

      Transcript() = default;

      Transcript(const std::vector<FF>& proof)
          : NativeTranscript(proof)
      {}

      void deserialize_full_transcript();
      void serialize_full_transcript();
    };
};

} // namespace bb
