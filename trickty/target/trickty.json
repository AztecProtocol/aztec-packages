{"noir_version":"0.30.0+f6d65afe6820d0d6e55ecae3bf8693b5ad9a9c48","hash":13623433748087479528,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"x":[{"start":0,"end":1}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"H4sIAAAAAAAA/7XU1W5bQRRA0YaZmZnJ9jVch5mZGRw7//8FVRM1lXaj/VCp7ZaOZqQljc7T5H37WfZ93j7vee9T9nn+6jvsq+fB88Xz4QXiBfBC8UJ4kXgRvFi8GF4iXgIvFS+Fl4mXwcvFy+EV4hXwSvFKeJV4FbxavBpeI14DrxWvhdeJ18HrxevhDeIN8EbxRniTeBO8WbwZ3iLeAm8Vb4W3ibfB28Xb4R3iHfBO8U54l3gXvFu8G94j3gPvFe+F94n3wfvF++ED4gPwQfFB+JD4EHxYfBg+Ij4CHxUfhY+Jj8HHxcfhE+IT8EnxSfiU+BR8WnwaPiM+A4+IR+BR8Sg8Jh6DB+IBPC4ehyfEE/CkeBKeEk/BQ/EQnhZPw2fFZ+Fz4nPwefF5+IL4AnxRfBG+JL4EXxZfhq+Ir8BXxVfha+Jr8HXxdfiG+AZ8U3wTviW+Bd8W34bviO/Ad8V34Xvie/B98X34gfgB/FD8EH4kfgQ/Fj+Gn4ifwE/FT+Fn4mfwc/Fz+IX4BfxS/BJ+JX4Fvxa/ht+I38BvxW/hd+J38Hvxe/iD+AP8UfwR/iT+BH8Wf4a/iL/AM+IZ+Kv4Kzz77ff4B30U+btiWbwVRJLxeC4Vy0WD6Eskls6EiUg8kUmG0TCaCBPZWBgEuTAeptKZdCqSjsaDXPQtkQ5ybx/lEv9xz+Df7ZlNfexW+GXPP+oHWpQ5Cx0OAAA=","debug_symbols":"tdrPasJAEMfxd9lzDp3ZnZ3dvEopJWosAYmisVDEd29isVLq9XucZOZ3+5A/O5ew6Vfnj/dh3O5PoX29hN1+3U3DfpyrS3i5XTodunGpTlN3nELr3oR+3IRWJF6bsB12fWiTX5t/nSKPXhX7bdZ6fWuCkOFKhkcyPJHhRoZnMtzJ8EKGVxQRSxQ1KihSQZUKylRQp4JCFVSqoFQFtaqoVWWfp6hVRa0qalVRq4paVdSqolYVtRpRqxG1GtmXX9RqRK1G1GpErUbUakStRtRqQq0m1GpCrSb2SxW1mlCrCbWaUKsJtZpQq4ZaNdSqoVYNtWqoVUOtGmrVUKuGWjXUakatZtRqRq1m1GpGrWb2HzBqNaNWM2o1o1YdteqoVUetOmrVUauOWnX2wAa16qhVR60W1GpBrRbUakGtFtRqQa0W1GphT1dRqwW1WlGrFbVaUasVtVpRqxW1WlGrFbVa2VUIeBfiKVZRu88soY/828hTgWLxPuL2Z2QuPrvj0K12/bIhtdw7j+v7wtRcTl+Hnztz7zc=","file_map":{"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"47":{"source":"fn main(x: Field) {\n    let mut acc = x;\n    for i in 0..100 {\n        acc = dep::std::hash::pedersen_hash([acc]);\n    }\n    assert_eq(acc * 2, 28);\n    assert_eq(acc * 3, 42);\n}\n\n","path":"/mnt/user-data/mike/packages/trickty/src/main.nr"}},"names":["main"]}